
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$4() { }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$4;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty$3() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children$1(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
        select.selectedIndex = -1; // no option should be selected
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            while (flushidx < dirty_components.length) {
                const component = dirty_components[flushidx];
                flushidx++;
                set_current_component(component);
                update$1(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update$1($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function bind$1(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init$2(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$4,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$1(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$4;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.45.0' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    /*! UIkit 3.10.1 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */

    var uikit = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    })(commonjsGlobal, (function () {
        var objPrototype = Object.prototype;
        var hasOwnProperty = objPrototype.hasOwnProperty;

        function hasOwn(obj, key) {
            return hasOwnProperty.call(obj, key);
        }

        var hyphenateRe = /\B([A-Z])/g;

        var hyphenate = memoize(function (str) { return str
            .replace(hyphenateRe, '-$1')
            .toLowerCase(); }
        );

        var camelizeRe = /-(\w)/g;

        var camelize = memoize(function (str) { return str.replace(camelizeRe, toUpper); }
        );

        var ucfirst = memoize(function (str) { return str.length ? toUpper(null, str.charAt(0)) + str.slice(1) : ''; }
        );

        function toUpper(_, c) {
            return c ? c.toUpperCase() : '';
        }

        var strPrototype = String.prototype;
        var startsWithFn = strPrototype.startsWith || function (search) { return this.lastIndexOf(search, 0) === 0; };

        function startsWith(str, search) {
            return startsWithFn.call(str, search);
        }

        var endsWithFn = strPrototype.endsWith || function (search) { return this.substr(-search.length) === search; };

        function endsWith(str, search) {
            return endsWithFn.call(str, search);
        }

        var arrPrototype = Array.prototype;

        var includesFn = function (search, i) { return !!~this.indexOf(search, i); };
        var includesStr = strPrototype.includes || includesFn;
        var includesArray = arrPrototype.includes || includesFn;

        function includes(obj, search) {
            return obj && (isString(obj) ? includesStr : includesArray).call(obj, search);
        }

        var findIndexFn = arrPrototype.findIndex || function (predicate) {
            var arguments$1 = arguments;

            for (var i = 0; i < this.length; i++) {
                if (predicate.call(arguments$1[1], this[i], i, this)) {
                    return i;
                }
            }
            return -1;
        };

        function findIndex(array, predicate) {
            return findIndexFn.call(array, predicate);
        }

        var isArray = Array.isArray;

        function isFunction(obj) {
            return typeof obj === 'function';
        }

        function isObject(obj) {
            return obj !== null && typeof obj === 'object';
        }

        var toString = objPrototype.toString;
        function isPlainObject(obj) {
            return toString.call(obj) === '[object Object]';
        }

        function isWindow(obj) {
            return isObject(obj) && obj === obj.window;
        }

        function isDocument(obj) {
            return nodeType(obj) === 9;
        }

        function isNode(obj) {
            return nodeType(obj) >= 1;
        }

        function isElement(obj) {
            return nodeType(obj) === 1;
        }

        function nodeType(obj) {
            return !isWindow(obj) && isObject(obj) && obj.nodeType;
        }

        function isBoolean(value) {
            return typeof value === 'boolean';
        }

        function isString(value) {
            return typeof value === 'string';
        }

        function isNumber(value) {
            return typeof value === 'number';
        }

        function isNumeric(value) {
            return isNumber(value) || isString(value) && !isNaN(value - parseFloat(value));
        }

        function isEmpty(obj) {
            return !(isArray(obj)
                ? obj.length
                : isObject(obj)
                    ? Object.keys(obj).length
                    : false
            );
        }

        function isUndefined(value) {
            return value === void 0;
        }

        function toBoolean(value) {
            return isBoolean(value)
                ? value
                : value === 'true' || value === '1' || value === ''
                    ? true
                    : value === 'false' || value === '0'
                        ? false
                        : value;
        }

        function toNumber(value) {
            var number = Number(value);
            return isNaN(number) ? false : number;
        }

        function toFloat(value) {
            return parseFloat(value) || 0;
        }

        var toArray = Array.from || (function (value) { return arrPrototype.slice.call(value); });

        function toNode(element) {
            return toNodes(element)[0];
        }

        function toNodes(element) {
            return element && (isNode(element) ? [element] : toArray(element).filter(isNode)) || [];
        }

        function toWindow(element) {
            if (isWindow(element)) {
                return element;
            }

            element = toNode(element);

            return element
                ? (isDocument(element)
                    ? element
                    : element.ownerDocument
                ).defaultView
                : window;
        }

        function toMs(time) {
            return !time
                ? 0
                : endsWith(time, 'ms')
                    ? toFloat(time)
                    : toFloat(time) * 1000;
        }

        function isEqual(value, other) {
            return value === other
                || isObject(value)
                && isObject(other)
                && Object.keys(value).length === Object.keys(other).length
                && each(value, function (val, key) { return val === other[key]; });
        }

        function swap(value, a, b) {
            return value.replace(
                new RegExp((a + "|" + b), 'g'),
                function (match) { return match === a ? b : a; }
            );
        }

        var assign = Object.assign || function (target) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            target = Object(target);
            for (var i = 0; i < args.length; i++) {
                var source = args[i];
                if (source !== null) {
                    for (var key in source) {
                        if (hasOwn(source, key)) {
                            target[key] = source[key];
                        }
                    }
                }
            }
            return target;
        };

        function last(array) {
            return array[array.length - 1];
        }

        function each(obj, cb) {
            for (var key in obj) {
                if (false === cb(obj[key], key)) {
                    return false;
                }
            }
            return true;
        }

        function sortBy$1(array, prop) {
            return array.slice().sort(function (ref, ref$1) {
                    var propA = ref[prop]; if ( propA === void 0 ) propA = 0;
                    var propB = ref$1[prop]; if ( propB === void 0 ) propB = 0;

                    return propA > propB
                    ? 1
                    : propB > propA
                        ? -1
                        : 0;
            }
            );
        }

        function uniqueBy(array, prop) {
            var seen = new Set();
            return array.filter(function (ref) {
                var check = ref[prop];

                return seen.has(check)
                ? false
                : seen.add(check) || true;
            } // IE 11 does not return the Set object
            );
        }

        function clamp(number, min, max) {
            if ( min === void 0 ) min = 0;
            if ( max === void 0 ) max = 1;

            return Math.min(Math.max(toNumber(number) || 0, min), max);
        }

        function noop() {}

        function intersectRect() {
            var rects = [], len = arguments.length;
            while ( len-- ) rects[ len ] = arguments[ len ];

            return [['bottom', 'top'], ['right', 'left']].every(function (ref) {
                    var minProp = ref[0];
                    var maxProp = ref[1];

                    return Math.min.apply(Math, rects.map(function (ref) {
                    var min = ref[minProp];

                    return min;
                    })) - Math.max.apply(Math, rects.map(function (ref) {
                    var max = ref[maxProp];

                    return max;
                    })) > 0;
            }
            );
        }

        function pointInRect(point, rect) {
            return point.x <= rect.right &&
                point.x >= rect.left &&
                point.y <= rect.bottom &&
                point.y >= rect.top;
        }

        var Dimensions = {

            ratio: function(dimensions, prop, value) {
                var obj;


                var aProp = prop === 'width' ? 'height' : 'width';

                return ( obj = {}, obj[aProp] = dimensions[prop] ? Math.round(value * dimensions[aProp] / dimensions[prop]) : dimensions[aProp], obj[prop] = value, obj );
            },

            contain: function(dimensions, maxDimensions) {
                var this$1$1 = this;

                dimensions = assign({}, dimensions);

                each(dimensions, function (_, prop) { return dimensions = dimensions[prop] > maxDimensions[prop]
                    ? this$1$1.ratio(dimensions, prop, maxDimensions[prop])
                    : dimensions; }
                );

                return dimensions;
            },

            cover: function(dimensions, maxDimensions) {
                var this$1$1 = this;

                dimensions = this.contain(dimensions, maxDimensions);

                each(dimensions, function (_, prop) { return dimensions = dimensions[prop] < maxDimensions[prop]
                    ? this$1$1.ratio(dimensions, prop, maxDimensions[prop])
                    : dimensions; }
                );

                return dimensions;
            }

        };

        function getIndex(i, elements, current, finite) {
            if ( current === void 0 ) current = 0;
            if ( finite === void 0 ) finite = false;


            elements = toNodes(elements);

            var length = elements.length;

            i = isNumeric(i)
                ? toNumber(i)
                : i === 'next'
                    ? current + 1
                    : i === 'previous'
                        ? current - 1
                        : elements.indexOf(toNode(i));

            if (finite) {
                return clamp(i, 0, length - 1);
            }

            i %= length;

            return i < 0 ? i + length : i;
        }

        function memoize(fn) {
            var cache = Object.create(null);
            return function (key) { return cache[key] || (cache[key] = fn(key)); };
        }

        function attr(element, name, value) {

            if (isObject(name)) {
                for (var key in name) {
                    attr(element, key, name[key]);
                }
                return;
            }

            if (isUndefined(value)) {
                element = toNode(element);
                return element && element.getAttribute(name);
            } else {
                toNodes(element).forEach(function (element) {

                    if (isFunction(value)) {
                        value = value.call(element, attr(element, name));
                    }

                    if (value === null) {
                        removeAttr(element, name);
                    } else {
                        element.setAttribute(name, value);
                    }
                });
            }

        }

        function hasAttr(element, name) {
            return toNodes(element).some(function (element) { return element.hasAttribute(name); });
        }

        function removeAttr(element, name) {
            element = toNodes(element);
            name.split(' ').forEach(function (name) { return element.forEach(function (element) { return element.hasAttribute(name) && element.removeAttribute(name); }
                ); }
            );
        }

        function data(element, attribute) {
            for (var i = 0, attrs = [attribute, ("data-" + attribute)]; i < attrs.length; i++) {
                if (hasAttr(element, attrs[i])) {
                    return attr(element, attrs[i]);
                }
            }
        }

        /* global DocumentTouch */

        var inBrowser = typeof window !== 'undefined';
        var isIE = inBrowser && /msie|trident/i.test(window.navigator.userAgent);
        var isRtl = inBrowser && attr(document.documentElement, 'dir') === 'rtl';

        var hasTouchEvents = inBrowser && 'ontouchstart' in window;
        var hasPointerEvents = inBrowser && window.PointerEvent;
        var hasTouch = inBrowser && (hasTouchEvents
            || window.DocumentTouch && document instanceof DocumentTouch
            || navigator.maxTouchPoints); // IE >=11

        var pointerDown = hasPointerEvents ? 'pointerdown' : hasTouchEvents ? 'touchstart' : 'mousedown';
        var pointerMove = hasPointerEvents ? 'pointermove' : hasTouchEvents ? 'touchmove' : 'mousemove';
        var pointerUp = hasPointerEvents ? 'pointerup' : hasTouchEvents ? 'touchend' : 'mouseup';
        var pointerEnter = hasPointerEvents ? 'pointerenter' : hasTouchEvents ? '' : 'mouseenter';
        var pointerLeave = hasPointerEvents ? 'pointerleave' : hasTouchEvents ? '' : 'mouseleave';
        var pointerCancel = hasPointerEvents ? 'pointercancel' : 'touchcancel';

        var voidElements = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            menuitem: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
        };
        function isVoidElement(element) {
            return toNodes(element).some(function (element) { return voidElements[element.tagName.toLowerCase()]; });
        }

        function isVisible(element) {
            return toNodes(element).some(function (element) { return element.offsetWidth || element.offsetHeight || element.getClientRects().length; });
        }

        var selInput = 'input,select,textarea,button';
        function isInput(element) {
            return toNodes(element).some(function (element) { return matches(element, selInput); });
        }

        var selFocusable = selInput + ",a[href],[tabindex]";
        function isFocusable(element) {
            return matches(element, selFocusable);
        }

        function parent(element) {
            element = toNode(element);
            return element && isElement(element.parentNode) && element.parentNode;
        }

        function filter$1(element, selector) {
            return toNodes(element).filter(function (element) { return matches(element, selector); });
        }

        var elProto = inBrowser ? Element.prototype : {};
        var matchesFn = elProto.matches || elProto.webkitMatchesSelector || elProto.msMatchesSelector || noop;

        function matches(element, selector) {
            return toNodes(element).some(function (element) { return matchesFn.call(element, selector); });
        }

        var closestFn = elProto.closest || function (selector) {
            var ancestor = this;

            do {

                if (matches(ancestor, selector)) {
                    return ancestor;
                }

            } while ((ancestor = parent(ancestor)));
        };

        function closest(element, selector) {

            if (startsWith(selector, '>')) {
                selector = selector.slice(1);
            }

            return isElement(element)
                ? closestFn.call(element, selector)
                : toNodes(element).map(function (element) { return closest(element, selector); }).filter(Boolean);
        }

        function within(element, selector) {
            return !isString(selector)
                ? element === selector || (isDocument(selector)
                    ? selector.documentElement
                    : toNode(selector)).contains(toNode(element)) // IE 11 document does not implement contains
                : matches(element, selector) || !!closest(element, selector);
        }

        function parents(element, selector) {
            var elements = [];

            while ((element = parent(element))) {
                if (!selector || matches(element, selector)) {
                    elements.push(element);
                }
            }

            return elements;
        }

        function children(element, selector) {
            element = toNode(element);
            var children = element ? toNodes(element.children) : [];
            return selector ? filter$1(children, selector) : children;
        }

        function index(element, ref) {
            return ref
                ? toNodes(element).indexOf(toNode(ref))
                : children(parent(element)).indexOf(element);
        }

        function query(selector, context) {
            return find(selector, getContext(selector, context));
        }

        function queryAll(selector, context) {
            return findAll(selector, getContext(selector, context));
        }

        function getContext(selector, context) {
            if ( context === void 0 ) context = document;

            return isString(selector) && isContextSelector(selector) || isDocument(context)
                ? context
                : context.ownerDocument;
        }

        function find(selector, context) {
            return toNode(_query(selector, context, 'querySelector'));
        }

        function findAll(selector, context) {
            return toNodes(_query(selector, context, 'querySelectorAll'));
        }

        function _query(selector, context, queryFn) {
            if ( context === void 0 ) context = document;


            if (!selector || !isString(selector)) {
                return selector;
            }

            selector = selector.replace(contextSanitizeRe, '$1 *');

            if (isContextSelector(selector)) {

                selector = splitSelector(selector).map(function (selector) {

                    var ctx = context;

                    if (selector[0] === '!') {

                        var selectors = selector.substr(1).trim().split(' ');
                        ctx = closest(parent(context), selectors[0]);
                        selector = selectors.slice(1).join(' ').trim();

                    }

                    if (selector[0] === '-') {

                        var selectors$1 = selector.substr(1).trim().split(' ');
                        var prev = (ctx || context).previousElementSibling;
                        ctx = matches(prev, selector.substr(1)) ? prev : null;
                        selector = selectors$1.slice(1).join(' ');

                    }

                    if (!ctx) {
                        return null;
                    }

                    return ((domPath(ctx)) + " " + selector);

                }).filter(Boolean).join(',');

                context = document;

            }

            try {

                return context[queryFn](selector);

            } catch (e) {

                return null;

            }

        }

        var contextSelectorRe = /(^|[^\\],)\s*[!>+~-]/;
        var contextSanitizeRe = /([!>+~-])(?=\s+[!>+~-]|\s*$)/g;

        var isContextSelector = memoize(function (selector) { return selector.match(contextSelectorRe); });

        var selectorRe = /.*?[^\\](?:,|$)/g;

        var splitSelector = memoize(function (selector) { return selector.match(selectorRe).map(function (selector) { return selector.replace(/,$/, '').trim(); }
            ); }
        );

        function domPath(element) {
            var names = [];
            while (element.parentNode) {
                var id = attr(element, 'id');
                if (id) {
                    names.unshift(("#" + (escape(id))));
                    break;
                } else {
                    var tagName = element.tagName;
                    if (tagName !== 'HTML') {
                        tagName += ":nth-child(" + (index(element) + 1) + ")";
                    }
                    names.unshift(tagName);
                    element = element.parentNode;
                }
            }
            return names.join(' > ');
        }

        var escapeFn = inBrowser && window.CSS && CSS.escape || function (css) { return css.replace(/([^\x7f-\uFFFF\w-])/g, function (match) { return ("\\" + match); }); };
        function escape(css) {
            return isString(css) ? escapeFn.call(null, css) : '';
        }

        function on() {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];


            var ref = getArgs(args);
            var targets = ref[0];
            var type = ref[1];
            var selector = ref[2];
            var listener = ref[3];
            var useCapture = ref[4];

            targets = toEventTargets(targets);

            if (listener.length > 1) {
                listener = detail(listener);
            }

            if (useCapture && useCapture.self) {
                listener = selfFilter(listener);
            }

            if (selector) {
                listener = delegate(selector, listener);
            }

            useCapture = useCaptureFilter(useCapture);

            type.split(' ').forEach(function (type) { return targets.forEach(function (target) { return target.addEventListener(type, listener, useCapture); }
                ); }
            );
            return function () { return off(targets, type, listener, useCapture); };
        }

        function off(targets, type, listener, useCapture) {
            if ( useCapture === void 0 ) useCapture = false;

            useCapture = useCaptureFilter(useCapture);
            targets = toEventTargets(targets);
            type.split(' ').forEach(function (type) { return targets.forEach(function (target) { return target.removeEventListener(type, listener, useCapture); }
                ); }
            );
        }

        function once() {
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];


            var ref = getArgs(args);
            var element = ref[0];
            var type = ref[1];
            var selector = ref[2];
            var listener = ref[3];
            var useCapture = ref[4];
            var condition = ref[5];
            var off = on(element, type, selector, function (e) {
                var result = !condition || condition(e);
                if (result) {
                    off();
                    listener(e, result);
                }
            }, useCapture);

            return off;
        }

        function trigger(targets, event, detail) {
            return toEventTargets(targets).reduce(function (notCanceled, target) { return notCanceled && target.dispatchEvent(createEvent(event, true, true, detail)); }
                , true);
        }

        function createEvent(e, bubbles, cancelable, detail) {
            if ( bubbles === void 0 ) bubbles = true;
            if ( cancelable === void 0 ) cancelable = false;

            if (isString(e)) {
                var event = document.createEvent('CustomEvent'); // IE 11
                event.initCustomEvent(e, bubbles, cancelable, detail);
                e = event;
            }

            return e;
        }

        function getArgs(args) {
            if (isFunction(args[2])) {
                args.splice(2, 0, false);
            }
            return args;
        }

        function delegate(selector, listener) {
            var this$1$1 = this;

            return function (e) {

                var current = selector[0] === '>'
                    ? findAll(selector, e.currentTarget).reverse().filter(function (element) { return within(e.target, element); })[0]
                    : closest(e.target, selector);

                if (current) {
                    e.current = current;
                    listener.call(this$1$1, e);
                }

            };
        }

        function detail(listener) {
            return function (e) { return isArray(e.detail) ? listener.apply(void 0, [ e ].concat( e.detail )) : listener(e); };
        }

        function selfFilter(listener) {
            return function (e) {
                if (e.target === e.currentTarget || e.target === e.current) {
                    return listener.call(null, e);
                }
            };
        }

        function useCaptureFilter(options) {
            return options && isIE && !isBoolean(options)
                ? !!options.capture
                : options;
        }

        function isEventTarget(target) {
            return target && 'addEventListener' in target;
        }

        function toEventTarget(target) {
            return isEventTarget(target) ? target : toNode(target);
        }

        function toEventTargets(target) {
            return isArray(target)
                ? target.map(toEventTarget).filter(Boolean)
                : isString(target)
                    ? findAll(target)
                    : isEventTarget(target)
                        ? [target]
                        : toNodes(target);
        }

        function isTouch(e) {
            return e.pointerType === 'touch' || !!e.touches;
        }

        function getEventPos(e) {
            var touches = e.touches;
            var changedTouches = e.changedTouches;
            var ref = touches && touches[0] || changedTouches && changedTouches[0] || e;
            var x = ref.clientX;
            var y = ref.clientY;

            return {x: x, y: y};
        }

        /* global setImmediate */

        var Promise$1 = inBrowser && window.Promise || PromiseFn;

        var Deferred = function() {
            var this$1$1 = this;

            this.promise = new Promise$1(function (resolve, reject) {
                this$1$1.reject = reject;
                this$1$1.resolve = resolve;
            });
        };

        /**
         * Promises/A+ polyfill v1.1.4 (https://github.com/bramstein/promis)
         */

        var RESOLVED = 0;
        var REJECTED = 1;
        var PENDING = 2;

        var async = inBrowser && window.setImmediate || setTimeout;

        function PromiseFn(executor) {

            this.state = PENDING;
            this.value = undefined;
            this.deferred = [];

            var promise = this;

            try {
                executor(
                    function (x) {
                        promise.resolve(x);
                    },
                    function (r) {
                        promise.reject(r);
                    }
                );
            } catch (e) {
                promise.reject(e);
            }
        }

        PromiseFn.reject = function (r) {
            return new PromiseFn(function (resolve, reject) {
                reject(r);
            });
        };

        PromiseFn.resolve = function (x) {
            return new PromiseFn(function (resolve, reject) {
                resolve(x);
            });
        };

        PromiseFn.all = function all(iterable) {
            return new PromiseFn(function (resolve, reject) {
                var result = [];
                var count = 0;

                if (iterable.length === 0) {
                    resolve(result);
                }

                function resolver(i) {
                    return function (x) {
                        result[i] = x;
                        count += 1;

                        if (count === iterable.length) {
                            resolve(result);
                        }
                    };
                }

                for (var i = 0; i < iterable.length; i += 1) {
                    PromiseFn.resolve(iterable[i]).then(resolver(i), reject);
                }
            });
        };

        PromiseFn.race = function race(iterable) {
            return new PromiseFn(function (resolve, reject) {
                for (var i = 0; i < iterable.length; i += 1) {
                    PromiseFn.resolve(iterable[i]).then(resolve, reject);
                }
            });
        };

        var p = PromiseFn.prototype;

        p.resolve = function resolve(x) {
            var promise = this;

            if (promise.state === PENDING) {
                if (x === promise) {
                    throw new TypeError('Promise settled with itself.');
                }

                var called = false;

                try {
                    var then = x && x.then;

                    if (x !== null && isObject(x) && isFunction(then)) {
                        then.call(
                            x,
                            function (x) {
                                if (!called) {
                                    promise.resolve(x);
                                }
                                called = true;
                            },
                            function (r) {
                                if (!called) {
                                    promise.reject(r);
                                }
                                called = true;
                            }
                        );
                        return;
                    }
                } catch (e) {
                    if (!called) {
                        promise.reject(e);
                    }
                    return;
                }

                promise.state = RESOLVED;
                promise.value = x;
                promise.notify();
            }
        };

        p.reject = function reject(reason) {
            var promise = this;

            if (promise.state === PENDING) {
                if (reason === promise) {
                    throw new TypeError('Promise settled with itself.');
                }

                promise.state = REJECTED;
                promise.value = reason;
                promise.notify();
            }
        };

        p.notify = function notify() {
            var this$1$1 = this;

            async(function () {
                if (this$1$1.state !== PENDING) {
                    while (this$1$1.deferred.length) {
                        var ref = this$1$1.deferred.shift();
                        var onResolved = ref[0];
                        var onRejected = ref[1];
                        var resolve = ref[2];
                        var reject = ref[3];

                        try {
                            if (this$1$1.state === RESOLVED) {
                                if (isFunction(onResolved)) {
                                    resolve(onResolved.call(undefined, this$1$1.value));
                                } else {
                                    resolve(this$1$1.value);
                                }
                            } else if (this$1$1.state === REJECTED) {
                                if (isFunction(onRejected)) {
                                    resolve(onRejected.call(undefined, this$1$1.value));
                                } else {
                                    reject(this$1$1.value);
                                }
                            }
                        } catch (e) {
                            reject(e);
                        }
                    }
                }
            });
        };

        p.then = function then(onResolved, onRejected) {
            var this$1$1 = this;

            return new PromiseFn(function (resolve, reject) {
                this$1$1.deferred.push([onResolved, onRejected, resolve, reject]);
                this$1$1.notify();
            });
        };

        p.catch = function (onRejected) {
            return this.then(undefined, onRejected);
        };

        function ajax(url, options) {

            var env = assign({
                data: null,
                method: 'GET',
                headers: {},
                xhr: new XMLHttpRequest(),
                beforeSend: noop,
                responseType: ''
            }, options);

            return Promise$1.resolve()
                .then(function () { return env.beforeSend(env); })
                .then(function () { return send(url, env); });
        }

        function send(url, env) {
            return new Promise$1(function (resolve, reject) {
                var xhr = env.xhr;

                for (var prop in env) {
                    if (prop in xhr) {
                        try {

                            xhr[prop] = env[prop];

                        } catch (e) {}
                    }
                }

                xhr.open(env.method.toUpperCase(), url);

                for (var header in env.headers) {
                    xhr.setRequestHeader(header, env.headers[header]);
                }

                on(xhr, 'load', function () {

                    if (xhr.status === 0 || xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {

                        // IE 11 does not support responseType 'json'
                        if (env.responseType === 'json' && isString(xhr.response)) {
                            xhr = assign(copyXhr(xhr), {response: JSON.parse(xhr.response)});
                        }

                        resolve(xhr);

                    } else {
                        reject(assign(Error(xhr.statusText), {
                            xhr: xhr,
                            status: xhr.status
                        }));
                    }

                });

                on(xhr, 'error', function () { return reject(assign(Error('Network Error'), {xhr: xhr})); });
                on(xhr, 'timeout', function () { return reject(assign(Error('Network Timeout'), {xhr: xhr})); });

                xhr.send(env.data);
            });
        }

        function getImage(src, srcset, sizes) {

            return new Promise$1(function (resolve, reject) {
                var img = new Image();

                img.onerror = function (e) { return reject(e); };
                img.onload = function () { return resolve(img); };

                sizes && (img.sizes = sizes);
                srcset && (img.srcset = srcset);
                img.src = src;
            });

        }

        function copyXhr(source) {
            var target = {};
            for (var key in source) {
                target[key] = source[key];
            }
            return target;
        }

        function ready(fn) {

            if (document.readyState !== 'loading') {
                fn();
                return;
            }

            once(document, 'DOMContentLoaded', fn);
        }

        function empty(element) {
            element = $(element);
            element.innerHTML = '';
            return element;
        }

        function html(parent, html) {
            parent = $(parent);
            return isUndefined(html)
                ? parent.innerHTML
                : append(parent.hasChildNodes() ? empty(parent) : parent, html);
        }

        function prepend(parent, element) {

            parent = $(parent);

            if (parent.hasChildNodes()) {
                return insertNodes(element, function (element) { return parent.insertBefore(element, parent.firstChild); });
            } else {
                return append(parent, element);
            }
        }

        function append(parent, element) {
            parent = $(parent);
            return insertNodes(element, function (element) { return parent.appendChild(element); });
        }

        function before(ref, element) {
            ref = $(ref);
            return insertNodes(element, function (element) { return ref.parentNode.insertBefore(element, ref); });
        }

        function after(ref, element) {
            ref = $(ref);
            return insertNodes(element, function (element) { return ref.nextSibling
                ? before(ref.nextSibling, element)
                : append(ref.parentNode, element); }
            );
        }

        function insertNodes(element, fn) {
            element = isString(element) ? fragment(element) : element;
            return element
                ? 'length' in element
                    ? toNodes(element).map(fn)
                    : fn(element)
                : null;
        }

        function remove$1(element) {
            toNodes(element).forEach(function (element) { return element.parentNode && element.parentNode.removeChild(element); });
        }

        function wrapAll(element, structure) {

            structure = toNode(before(element, structure));

            while (structure.firstChild) {
                structure = structure.firstChild;
            }

            append(structure, element);

            return structure;
        }

        function wrapInner(element, structure) {
            return toNodes(toNodes(element).map(function (element) { return element.hasChildNodes ? wrapAll(toNodes(element.childNodes), structure) : append(element, structure); }
            ));
        }

        function unwrap(element) {
            toNodes(element)
                .map(parent)
                .filter(function (value, index, self) { return self.indexOf(value) === index; })
                .forEach(function (parent) {
                    before(parent, parent.childNodes);
                    remove$1(parent);
                });
        }

        var fragmentRe = /^\s*<(\w+|!)[^>]*>/;
        var singleTagRe = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;

        function fragment(html) {

            var matches = singleTagRe.exec(html);
            if (matches) {
                return document.createElement(matches[1]);
            }

            var container = document.createElement('div');
            if (fragmentRe.test(html)) {
                container.insertAdjacentHTML('beforeend', html.trim());
            } else {
                container.textContent = html;
            }

            return container.childNodes.length > 1 ? toNodes(container.childNodes) : container.firstChild;

        }

        function apply$1(node, fn) {

            if (!isElement(node)) {
                return;
            }

            fn(node);
            node = node.firstElementChild;
            while (node) {
                var next = node.nextElementSibling;
                apply$1(node, fn);
                node = next;
            }
        }

        function $(selector, context) {
            return isHtml(selector)
                ? toNode(fragment(selector))
                : find(selector, context);
        }

        function $$(selector, context) {
            return isHtml(selector)
                ? toNodes(fragment(selector))
                : findAll(selector, context);
        }

        function isHtml(str) {
            return isString(str) && (str[0] === '<' || str.match(/^\s*</));
        }

        function addClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            apply(element, args, 'add');
        }

        function removeClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            apply(element, args, 'remove');
        }

        function removeClasses(element, cls) {
            attr(element, 'class', function (value) { return (value || '').replace(new RegExp(("\\b" + cls + "\\b"), 'g'), ''); });
        }

        function replaceClass(element) {
            var args = [], len = arguments.length - 1;
            while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];

            args[0] && removeClass(element, args[0]);
            args[1] && addClass(element, args[1]);
        }

        function hasClass(element, cls) {
            var assign;

            (assign = getClasses(cls), cls = assign[0]);
            var nodes = toNodes(element);
            for (var n = 0; n < nodes.length; n++) {
                if (cls && nodes[n].classList.contains(cls)) {
                    return true;
                }
            }
            return false;
        }

        function toggleClass(element, cls, force) {

            cls = getClasses(cls);

            var nodes = toNodes(element);
            for (var n = 0; n < nodes.length; n++) {
                var list = nodes[n].classList;
                for (var i = 0; i < cls.length; i++) {
                    if (isUndefined(force)) {
                        list.toggle(cls[i]);
                    } else if (supports.Force) {
                        list.toggle(cls[i], !!force);
                    } else {
                        list[force ? 'add' : 'remove'](cls[i]);
                    }
                }
            }
        }

        function apply(element, args, fn) {
            var ref;


            args = args.reduce(function (args, arg) { return args.concat(getClasses(arg)); }, []);

            var nodes = toNodes(element);
            var loop = function ( n ) {
                if (supports.Multiple) {
                    (ref = nodes[n].classList)[fn].apply(ref, args);
                } else {
                    args.forEach(function (cls) { return nodes[n].classList[fn](cls); });
                }
            };

            for (var n = 0; n < nodes.length; n++) loop( n );
        }

        function getClasses(str) {
            return String(str).split(/\s|,/).filter(Boolean);
        }

        // IE 11
        var supports = {

            get Multiple() {
                return this.get('Multiple');
            },

            get Force() {
                return this.get('Force');
            },

            get: function(key) {

                var ref = document.createElement('_');
                var classList = ref.classList;
                classList.add('a', 'b');
                classList.toggle('c', false);
                supports = {
                    Multiple: classList.contains('b'),
                    Force: !classList.contains('c')
                };

                return supports[key];
            }

        };

        var cssNumber = {
            'animation-iteration-count': true,
            'column-count': true,
            'fill-opacity': true,
            'flex-grow': true,
            'flex-shrink': true,
            'font-weight': true,
            'line-height': true,
            'opacity': true,
            'order': true,
            'orphans': true,
            'stroke-dasharray': true,
            'stroke-dashoffset': true,
            'widows': true,
            'z-index': true,
            'zoom': true
        };

        function css(element, property, value, priority) {
            if ( priority === void 0 ) priority = '';


            return toNodes(element).map(function (element) {

                if (isString(property)) {

                    property = propName(property);

                    if (isUndefined(value)) {
                        return getStyle(element, property);
                    } else if (!value && !isNumber(value)) {
                        element.style.removeProperty(property);
                    } else {
                        element.style.setProperty(property, isNumeric(value) && !cssNumber[property] ? (value + "px") : value, priority);
                    }

                } else if (isArray(property)) {

                    var styles = getStyles(element);

                    return property.reduce(function (props, property) {
                        props[property] = styles[propName(property)];
                        return props;
                    }, {});

                } else if (isObject(property)) {
                    priority = value;
                    each(property, function (value, property) { return css(element, property, value, priority); });
                }

                return element;

            })[0];

        }

        function getStyles(element, pseudoElt) {
            return toWindow(element).getComputedStyle(element, pseudoElt);
        }

        function getStyle(element, property, pseudoElt) {
            return getStyles(element, pseudoElt)[property];
        }

        var parseCssVar = memoize(function (name) {
            /* usage in css: .uk-name:before { content:"xyz" } */

            var element = append(document.documentElement, fragment('<div>'));

            addClass(element, ("uk-" + name));

            var value = getStyle(element, 'content', ':before');

            remove$1(element);

            return value;
        });

        var propertyRe = /^\s*(["'])?(.*?)\1\s*$/;
        function getCssVar(name) {
            return (isIE
                ? parseCssVar(name)
                : getStyles(document.documentElement).getPropertyValue(("--uk-" + name))
            ).replace(propertyRe, '$2');
        }

        // https://drafts.csswg.org/cssom/#dom-cssstyledeclaration-setproperty
        var propName = memoize(function (name) { return vendorPropName(name); });

        var cssPrefixes = ['webkit', 'moz', 'ms'];

        function vendorPropName(name) {

            name = hyphenate(name);

            var ref = document.documentElement;
            var style = ref.style;

            if (name in style) {
                return name;
            }

            var i = cssPrefixes.length, prefixedName;

            while (i--) {
                prefixedName = "-" + (cssPrefixes[i]) + "-" + name;
                if (prefixedName in style) {
                    return prefixedName;
                }
            }
        }

        function transition(element, props, duration, timing) {
            if ( duration === void 0 ) duration = 400;
            if ( timing === void 0 ) timing = 'linear';


            return Promise$1.all(toNodes(element).map(function (element) { return new Promise$1(function (resolve, reject) {

                    for (var name in props) {
                        var value = css(element, name);
                        if (value === '') {
                            css(element, name, value);
                        }
                    }

                    var timer = setTimeout(function () { return trigger(element, 'transitionend'); }, duration);

                    once(element, 'transitionend transitioncanceled', function (ref) {
                        var type = ref.type;

                        clearTimeout(timer);
                        removeClass(element, 'uk-transition');
                        css(element, {
                            transitionProperty: '',
                            transitionDuration: '',
                            transitionTimingFunction: ''
                        });
                        type === 'transitioncanceled' ? reject() : resolve(element);
                    }, {self: true});

                    addClass(element, 'uk-transition');
                    css(element, assign({
                        transitionProperty: Object.keys(props).map(propName).join(','),
                        transitionDuration: (duration + "ms"),
                        transitionTimingFunction: timing
                    }, props));

                }); }
            ));

        }

        var Transition = {

            start: transition,

            stop: function(element) {
                trigger(element, 'transitionend');
                return Promise$1.resolve();
            },

            cancel: function(element) {
                trigger(element, 'transitioncanceled');
            },

            inProgress: function(element) {
                return hasClass(element, 'uk-transition');
            }

        };

        var animationPrefix = 'uk-animation-';

        function animate$1(element, animation, duration, origin, out) {
            if ( duration === void 0 ) duration = 200;


            return Promise$1.all(toNodes(element).map(function (element) { return new Promise$1(function (resolve, reject) {

                    trigger(element, 'animationcanceled');
                    var timer = setTimeout(function () { return trigger(element, 'animationend'); }, duration);

                    once(element, 'animationend animationcanceled', function (ref) {
                        var type = ref.type;


                        clearTimeout(timer);

                        type === 'animationcanceled' ? reject() : resolve(element);

                        css(element, 'animationDuration', '');
                        removeClasses(element, (animationPrefix + "\\S*"));

                    }, {self: true});

                    css(element, 'animationDuration', (duration + "ms"));
                    addClass(element, animation, animationPrefix + (out ? 'leave' : 'enter'));

                    if (startsWith(animation, animationPrefix)) {
                        origin && addClass(element, ("uk-transform-origin-" + origin));
                        out && addClass(element, (animationPrefix + "reverse"));
                    }

                }); }
            ));

        }

        var inProgress = new RegExp((animationPrefix + "(enter|leave)"));
        var Animation = {

            in: animate$1,

            out: function(element, animation, duration, origin) {
                return animate$1(element, animation, duration, origin, true);
            },

            inProgress: function(element) {
                return inProgress.test(attr(element, 'class'));
            },

            cancel: function(element) {
                trigger(element, 'animationcanceled');
            }

        };

        var dirs$1 = {
            width: ['left', 'right'],
            height: ['top', 'bottom']
        };

        function dimensions(element) {

            var rect = isElement(element)
                ? toNode(element).getBoundingClientRect()
                : {height: height(element), width: width(element), top: 0, left: 0};

            return {
                height: rect.height,
                width: rect.width,
                top: rect.top,
                left: rect.left,
                bottom: rect.top + rect.height,
                right: rect.left + rect.width
            };
        }

        function offset(element, coordinates) {

            var currentOffset = dimensions(element);

            if (element) {
                var ref = toWindow(element);
                var pageYOffset = ref.pageYOffset;
                var pageXOffset = ref.pageXOffset;
                var offsetBy = {height: pageYOffset, width: pageXOffset};

                for (var dir in dirs$1) {
                    for (var i in dirs$1[dir]) {
                        currentOffset[dirs$1[dir][i]] += offsetBy[dir];
                    }
                }
            }

            if (!coordinates) {
                return currentOffset;
            }

            var pos = css(element, 'position');

            each(css(element, ['left', 'top']), function (value, prop) { return css(element, prop, coordinates[prop]
                    - currentOffset[prop]
                    + toFloat(pos === 'absolute' && value === 'auto'
                        ? position(element)[prop]
                        : value)
                ); }
            );
        }

        function position(element) {

            var ref = offset(element);
            var top = ref.top;
            var left = ref.left;

            var ref$1 = toNode(element);
            var ref$1_ownerDocument = ref$1.ownerDocument;
            var body = ref$1_ownerDocument.body;
            var documentElement = ref$1_ownerDocument.documentElement;
            var offsetParent = ref$1.offsetParent;
            var parent = offsetParent || documentElement;

            while (parent && (parent === body || parent === documentElement) && css(parent, 'position') === 'static') {
                parent = parent.parentNode;
            }

            if (isElement(parent)) {
                var parentOffset = offset(parent);
                top -= parentOffset.top + toFloat(css(parent, 'borderTopWidth'));
                left -= parentOffset.left + toFloat(css(parent, 'borderLeftWidth'));
            }

            return {
                top: top - toFloat(css(element, 'marginTop')),
                left: left - toFloat(css(element, 'marginLeft'))
            };
        }

        function offsetPosition(element) {
            var offset = [0, 0];

            element = toNode(element);

            do {

                offset[0] += element.offsetTop;
                offset[1] += element.offsetLeft;

                if (css(element, 'position') === 'fixed') {
                    var win = toWindow(element);
                    offset[0] += win.pageYOffset;
                    offset[1] += win.pageXOffset;
                    return offset;
                }

            } while ((element = element.offsetParent));

            return offset;
        }

        var height = dimension('height');
        var width = dimension('width');

        function dimension(prop) {
            var propName = ucfirst(prop);
            return function (element, value) {

                if (isUndefined(value)) {

                    if (isWindow(element)) {
                        return element[("inner" + propName)];
                    }

                    if (isDocument(element)) {
                        var doc = element.documentElement;
                        return Math.max(doc[("offset" + propName)], doc[("scroll" + propName)]);
                    }

                    element = toNode(element);

                    value = css(element, prop);
                    value = value === 'auto' ? element[("offset" + propName)] : toFloat(value) || 0;

                    return value - boxModelAdjust(element, prop);

                } else {

                    return css(element, prop, !value && value !== 0
                        ? ''
                        : +value + boxModelAdjust(element, prop) + 'px'
                    );

                }

            };
        }

        function boxModelAdjust(element, prop, sizing) {
            if ( sizing === void 0 ) sizing = 'border-box';

            return css(element, 'boxSizing') === sizing
                ? dirs$1[prop].map(ucfirst).reduce(function (value, prop) { return value
                    + toFloat(css(element, ("padding" + prop)))
                    + toFloat(css(element, ("border" + prop + "Width"))); }
                    , 0)
                : 0;
        }

        function flipPosition(pos) {
            for (var dir in dirs$1) {
                for (var i in dirs$1[dir]) {
                    if (dirs$1[dir][i] === pos) {
                        return dirs$1[dir][1 - i];
                    }
                }
            }
            return pos;
        }

        function toPx(value, property, element) {
            if ( property === void 0 ) property = 'width';
            if ( element === void 0 ) element = window;

            return isNumeric(value)
                ? +value
                : endsWith(value, 'vh')
                    ? percent(height(toWindow(element)), value)
                    : endsWith(value, 'vw')
                        ? percent(width(toWindow(element)), value)
                        : endsWith(value, '%')
                            ? percent(dimensions(element)[property], value)
                            : toFloat(value);
        }

        function percent(base, value) {
            return base * toFloat(value) / 100;
        }

        /*
            Based on:
            Copyright (c) 2016 Wilson Page wilsonpage@me.com
            https://github.com/wilsonpage/fastdom
        */

        var fastdom = {

            reads: [],
            writes: [],

            read: function(task) {
                this.reads.push(task);
                scheduleFlush();
                return task;
            },

            write: function(task) {
                this.writes.push(task);
                scheduleFlush();
                return task;
            },

            clear: function(task) {
                remove(this.reads, task);
                remove(this.writes, task);
            },

            flush: flush

        };

        function flush(recursion) {
            if ( recursion === void 0 ) recursion = 1;

            runTasks(fastdom.reads);
            runTasks(fastdom.writes.splice(0));

            fastdom.scheduled = false;

            if (fastdom.reads.length || fastdom.writes.length) {
                scheduleFlush(recursion + 1);
            }
        }

        var RECURSION_LIMIT = 4;
        function scheduleFlush(recursion) {

            if (fastdom.scheduled) {
                return;
            }

            fastdom.scheduled = true;
            if (recursion && recursion < RECURSION_LIMIT) {
                Promise$1.resolve().then(function () { return flush(recursion); });
            } else {
                requestAnimationFrame(function () { return flush(); });
            }

        }

        function runTasks(tasks) {
            var task;
            while ((task = tasks.shift())) {
                try {
                    task();
                } catch (e) {
                    console.error(e);
                }
            }
        }

        function remove(array, item) {
            var index = array.indexOf(item);
            return ~index && array.splice(index, 1);
        }

        function MouseTracker() {}

        MouseTracker.prototype = {

            positions: [],

            init: function() {
                var this$1$1 = this;


                this.positions = [];

                var position;
                this.unbind = on(document, 'mousemove', function (e) { return position = getEventPos(e); });
                this.interval = setInterval(function () {

                    if (!position) {
                        return;
                    }

                    this$1$1.positions.push(position);

                    if (this$1$1.positions.length > 5) {
                        this$1$1.positions.shift();
                    }
                }, 50);

            },

            cancel: function() {
                this.unbind && this.unbind();
                this.interval && clearInterval(this.interval);
            },

            movesTo: function(target) {

                if (this.positions.length < 2) {
                    return false;
                }

                var p = target.getBoundingClientRect();
                var left = p.left;
                var right = p.right;
                var top = p.top;
                var bottom = p.bottom;

                var ref = this.positions;
                var prevPosition = ref[0];
                var position = last(this.positions);
                var path = [prevPosition, position];

                if (pointInRect(position, p)) {
                    return false;
                }

                var diagonals = [[{x: left, y: top}, {x: right, y: bottom}], [{x: left, y: bottom}, {x: right, y: top}]];

                return diagonals.some(function (diagonal) {
                    var intersection = intersect(path, diagonal);
                    return intersection && pointInRect(intersection, p);
                });
            }

        };

        // Inspired by http://paulbourke.net/geometry/pointlineplane/
        function intersect(ref, ref$1) {
            var ref_0 = ref[0];
            var x1 = ref_0.x;
            var y1 = ref_0.y;
            var ref_1 = ref[1];
            var x2 = ref_1.x;
            var y2 = ref_1.y;
            var ref$1_0 = ref$1[0];
            var x3 = ref$1_0.x;
            var y3 = ref$1_0.y;
            var ref$1_1 = ref$1[1];
            var x4 = ref$1_1.x;
            var y4 = ref$1_1.y;


            var denominator = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

            // Lines are parallel
            if (denominator === 0) {
                return false;
            }

            var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;

            if (ua < 0) {
                return false;
            }

            // Return an object with the x and y coordinates of the intersection
            return {x: x1 + ua * (x2 - x1), y: y1 + ua * (y2 - y1)};
        }

        var strats = {};

        strats.events =
        strats.created =
        strats.beforeConnect =
        strats.connected =
        strats.beforeDisconnect =
        strats.disconnected =
        strats.destroy = concatStrat;

        // args strategy
        strats.args = function (parentVal, childVal) {
            return childVal !== false && concatStrat(childVal || parentVal);
        };

        // update strategy
        strats.update = function (parentVal, childVal) {
            return sortBy$1(concatStrat(parentVal, isFunction(childVal) ? {read: childVal} : childVal), 'order');
        };

        // property strategy
        strats.props = function (parentVal, childVal) {

            if (isArray(childVal)) {
                childVal = childVal.reduce(function (value, key) {
                    value[key] = String;
                    return value;
                }, {});
            }

            return strats.methods(parentVal, childVal);
        };

        // extend strategy
        strats.computed =
        strats.methods = function (parentVal, childVal) {
            return childVal
                ? parentVal
                    ? assign({}, parentVal, childVal)
                    : childVal
                : parentVal;
        };

        // data strategy
        strats.data = function (parentVal, childVal, vm) {

            if (!vm) {

                if (!childVal) {
                    return parentVal;
                }

                if (!parentVal) {
                    return childVal;
                }

                return function (vm) {
                    return mergeFnData(parentVal, childVal, vm);
                };

            }

            return mergeFnData(parentVal, childVal, vm);
        };

        function mergeFnData(parentVal, childVal, vm) {
            return strats.computed(
                isFunction(parentVal)
                    ? parentVal.call(vm, vm)
                    : parentVal,
                isFunction(childVal)
                    ? childVal.call(vm, vm)
                    : childVal
            );
        }

        // concat strategy
        function concatStrat(parentVal, childVal) {

            parentVal = parentVal && !isArray(parentVal) ? [parentVal] : parentVal;

            return childVal
                ? parentVal
                    ? parentVal.concat(childVal)
                    : isArray(childVal)
                        ? childVal
                        : [childVal]
                : parentVal;
        }

        // default strategy
        function defaultStrat(parentVal, childVal) {
            return isUndefined(childVal) ? parentVal : childVal;
        }

        function mergeOptions(parent, child, vm) {

            var options = {};

            if (isFunction(child)) {
                child = child.options;
            }

            if (child.extends) {
                parent = mergeOptions(parent, child.extends, vm);
            }

            if (child.mixins) {
                for (var i = 0, l = child.mixins.length; i < l; i++) {
                    parent = mergeOptions(parent, child.mixins[i], vm);
                }
            }

            for (var key in parent) {
                mergeKey(key);
            }

            for (var key$1 in child) {
                if (!hasOwn(parent, key$1)) {
                    mergeKey(key$1);
                }
            }

            function mergeKey(key) {
                options[key] = (strats[key] || defaultStrat)(parent[key], child[key], vm);
            }

            return options;
        }

        function parseOptions(options, args) {
            var obj;

            if ( args === void 0 ) args = [];

            try {

                return !options
                    ? {}
                    : startsWith(options, '{')
                        ? JSON.parse(options)
                        : args.length && !includes(options, ':')
                            ? (( obj = {}, obj[args[0]] = options, obj ))
                            : options.split(';').reduce(function (options, option) {
                                var ref = option.split(/:(.*)/);
                                var key = ref[0];
                                var value = ref[1];
                                if (key && !isUndefined(value)) {
                                    options[key.trim()] = value.trim();
                                }
                                return options;
                            }, {});

            } catch (e) {
                return {};
            }

        }

        function play(el) {

            if (isIFrame(el)) {
                call(el, {func: 'playVideo', method: 'play'});
            }

            if (isHTML5(el)) {
                try {
                    el.play().catch(noop);
                } catch (e) {}
            }

        }

        function pause(el) {

            if (isIFrame(el)) {
                call(el, {func: 'pauseVideo', method: 'pause'});
            }

            if (isHTML5(el)) {
                el.pause();
            }

        }

        function mute(el) {

            if (isIFrame(el)) {
                call(el, {func: 'mute', method: 'setVolume', value: 0});
            }

            if (isHTML5(el)) {
                el.muted = true;
            }

        }

        function isVideo(el) {
            return isHTML5(el) || isIFrame(el);
        }

        function isHTML5(el) {
            return el && el.tagName === 'VIDEO';
        }

        function isIFrame(el) {
            return el && el.tagName === 'IFRAME' && (isYoutube(el) || isVimeo(el));
        }

        function isYoutube(el) {
            return !!el.src.match(/\/\/.*?youtube(-nocookie)?\.[a-z]+\/(watch\?v=[^&\s]+|embed)|youtu\.be\/.*/);
        }

        function isVimeo(el) {
            return !!el.src.match(/vimeo\.com\/video\/.*/);
        }

        function call(el, cmd) {
            enableApi(el).then(function () { return post(el, cmd); });
        }

        function post(el, cmd) {
            try {
                el.contentWindow.postMessage(JSON.stringify(assign({event: 'command'}, cmd)), '*');
            } catch (e) {}
        }

        var stateKey$1 = '_ukPlayer';
        var counter = 0;
        function enableApi(el) {

            if (el[stateKey$1]) {
                return el[stateKey$1];
            }

            var youtube = isYoutube(el);
            var vimeo = isVimeo(el);

            var id = ++counter;
            var poller;

            return el[stateKey$1] = new Promise$1(function (resolve) {

                youtube && once(el, 'load', function () {
                    var listener = function () { return post(el, {event: 'listening', id: id}); };
                    poller = setInterval(listener, 100);
                    listener();
                });

                once(window, 'message', resolve, false, function (ref) {
                    var data = ref.data;


                    try {
                        data = JSON.parse(data);
                        return data && (youtube && data.id === id && data.event === 'onReady' || vimeo && Number(data.player_id) === id);
                    } catch (e) {}

                });

                el.src = "" + (el.src) + (includes(el.src, '?') ? '&' : '?') + (youtube ? 'enablejsapi=1' : ("api=1&player_id=" + id));

            }).then(function () { return clearInterval(poller); });
        }

        function isInView(element, offsetTop, offsetLeft) {
            if ( offsetTop === void 0 ) offsetTop = 0;
            if ( offsetLeft === void 0 ) offsetLeft = 0;


            if (!isVisible(element)) {
                return false;
            }

            return intersectRect.apply(void 0, scrollParents(element).map(function (parent) {

                var ref = offset(getViewport$1(parent));
                var top = ref.top;
                var left = ref.left;
                var bottom = ref.bottom;
                var right = ref.right;

                return {
                    top: top - offsetTop,
                    left: left - offsetLeft,
                    bottom: bottom + offsetTop,
                    right: right + offsetLeft
                };
            }).concat(offset(element)));
        }

        function scrollTop(element, top) {

            if (isWindow(element) || isDocument(element)) {
                element = getScrollingElement(element);
            } else {
                element = toNode(element);
            }

            element.scrollTop = top;
        }

        function scrollIntoView(element, ref) {
            if ( ref === void 0 ) ref = {};
            var offsetBy = ref.offset; if ( offsetBy === void 0 ) offsetBy = 0;


            var parents = isVisible(element) ? scrollParents(element) : [];
            return parents.reduce(function (fn, scrollElement, i) {

                var scrollTop = scrollElement.scrollTop;
                var scrollHeight = scrollElement.scrollHeight;
                var offsetHeight = scrollElement.offsetHeight;
                var maxScroll = scrollHeight - getViewportClientHeight(scrollElement);
                var ref = offset(parents[i - 1] || element);
                var elHeight = ref.height;
                var elTop = ref.top;

                var top = Math.ceil(
                    elTop
                    - offset(getViewport$1(scrollElement)).top
                    - offsetBy
                    + scrollTop
                );

                if (offsetBy > 0 && offsetHeight < elHeight + offsetBy) {
                    top += offsetBy;
                } else {
                    offsetBy = 0;
                }

                if (top > maxScroll) {
                    offsetBy -= top - maxScroll;
                    top = maxScroll;
                } else if (top < 0) {
                    offsetBy -= top;
                    top = 0;
                }

                return function () { return scrollTo(scrollElement, top - scrollTop).then(fn); };

            }, function () { return Promise$1.resolve(); })();

            function scrollTo(element, top) {
                return new Promise$1(function (resolve) {

                    var scroll = element.scrollTop;
                    var duration = getDuration(Math.abs(top));
                    var start = Date.now();

                    (function step() {

                        var percent = ease(clamp((Date.now() - start) / duration));

                        scrollTop(element, scroll + top * percent);

                        // scroll more if we have not reached our destination
                        if (percent === 1) {
                            resolve();
                        } else {
                            requestAnimationFrame(step);
                        }

                    })();
                });
            }

            function getDuration(dist) {
                return 40 * Math.pow(dist, .375);
            }

            function ease(k) {
                return 0.5 * (1 - Math.cos(Math.PI * k));
            }

        }

        function scrolledOver(element, heightOffset) {
            if ( heightOffset === void 0 ) heightOffset = 0;


            if (!isVisible(element)) {
                return 0;
            }

            var ref = scrollParents(element, /auto|scroll/, true);
            var scrollElement = ref[0];
            var scrollHeight = scrollElement.scrollHeight;
            var scrollTop = scrollElement.scrollTop;
            var clientHeight = getViewportClientHeight(scrollElement);
            var viewportTop = offsetPosition(element)[0] - scrollTop - offsetPosition(scrollElement)[0];
            var viewportDist = Math.min(clientHeight, viewportTop + scrollTop);

            var top = viewportTop - viewportDist;
            var dist = Math.min(
                element.offsetHeight + heightOffset + viewportDist,
                scrollHeight - (viewportTop + scrollTop),
                scrollHeight - clientHeight
            );

            return clamp(-1 * top / dist);
        }

        function scrollParents(element, overflowRe, scrollable) {
            if ( overflowRe === void 0 ) overflowRe = /auto|scroll|hidden/;
            if ( scrollable === void 0 ) scrollable = false;

            var scrollEl = getScrollingElement(element);

            var ancestors = parents(element).reverse();
            ancestors = ancestors.slice(ancestors.indexOf(scrollEl) + 1);

            var fixedIndex = findIndex(ancestors, function (el) { return css(el, 'position') === 'fixed'; });
            if (~fixedIndex) {
                ancestors = ancestors.slice(fixedIndex);
            }

            return [scrollEl].concat(ancestors.filter(function (parent) { return overflowRe.test(css(parent, 'overflow')) && (!scrollable || parent.scrollHeight > getViewportClientHeight(parent)); })
            ).reverse();
        }

        function getViewport$1(scrollElement) {
            return scrollElement === getScrollingElement(scrollElement) ? window : scrollElement;
        }

        // iOS 12 returns <body> as scrollingElement
        function getViewportClientHeight(scrollElement) {
            return (scrollElement === getScrollingElement(scrollElement) ? document.documentElement : scrollElement).clientHeight;
        }

        function getScrollingElement(element) {
            var ref = toWindow(element);
            var document = ref.document;
            return document.scrollingElement || document.documentElement;
        }

        var dirs = {
            width: ['x', 'left', 'right'],
            height: ['y', 'top', 'bottom']
        };

        function positionAt(element, target, elAttach, targetAttach, elOffset, targetOffset, flip, boundary) {

            elAttach = getPos(elAttach);
            targetAttach = getPos(targetAttach);

            var flipped = {element: elAttach, target: targetAttach};

            if (!element || !target) {
                return flipped;
            }

            var dim = offset(element);
            var targetDim = offset(target);
            var position = targetDim;

            moveTo(position, elAttach, dim, -1);
            moveTo(position, targetAttach, targetDim, 1);

            elOffset = getOffsets(elOffset, dim.width, dim.height);
            targetOffset = getOffsets(targetOffset, targetDim.width, targetDim.height);

            elOffset['x'] += targetOffset['x'];
            elOffset['y'] += targetOffset['y'];

            position.left += elOffset['x'];
            position.top += elOffset['y'];

            if (flip) {

                var boundaries = scrollParents(element).map(getViewport$1);

                if (boundary && !includes(boundaries, boundary)) {
                    boundaries.unshift(boundary);
                }

                boundaries = boundaries.map(function (el) { return offset(el); });

                each(dirs, function (ref, prop) {
                    var dir = ref[0];
                    var align = ref[1];
                    var alignFlip = ref[2];


                    if (!(flip === true || includes(flip, dir))) {
                        return;
                    }

                    boundaries.some(function (boundary) {

                        var elemOffset = elAttach[dir] === align
                            ? -dim[prop]
                            : elAttach[dir] === alignFlip
                                ? dim[prop]
                                : 0;

                        var targetOffset = targetAttach[dir] === align
                            ? targetDim[prop]
                            : targetAttach[dir] === alignFlip
                                ? -targetDim[prop]
                                : 0;

                        if (position[align] < boundary[align] || position[align] + dim[prop] > boundary[alignFlip]) {

                            var centerOffset = dim[prop] / 2;
                            var centerTargetOffset = targetAttach[dir] === 'center' ? -targetDim[prop] / 2 : 0;

                            return elAttach[dir] === 'center' && (
                                apply(centerOffset, centerTargetOffset)
                                || apply(-centerOffset, -centerTargetOffset)
                            ) || apply(elemOffset, targetOffset);

                        }

                        function apply(elemOffset, targetOffset) {

                            var newVal = toFloat((position[align] + elemOffset + targetOffset - elOffset[dir] * 2).toFixed(4));

                            if (newVal >= boundary[align] && newVal + dim[prop] <= boundary[alignFlip]) {
                                position[align] = newVal;

                                ['element', 'target'].forEach(function (el) {
                                    flipped[el][dir] = !elemOffset
                                        ? flipped[el][dir]
                                        : flipped[el][dir] === dirs[prop][1]
                                            ? dirs[prop][2]
                                            : dirs[prop][1];
                                });

                                return true;
                            }

                        }

                    });

                });
            }

            offset(element, position);

            return flipped;
        }

        function moveTo(position, attach, dim, factor) {
            each(dirs, function (ref, prop) {
                var dir = ref[0];
                var align = ref[1];
                var alignFlip = ref[2];

                if (attach[dir] === alignFlip) {
                    position[align] += dim[prop] * factor;
                } else if (attach[dir] === 'center') {
                    position[align] += dim[prop] * factor / 2;
                }
            });
        }

        function getPos(pos) {

            var x = /left|center|right/;
            var y = /top|center|bottom/;

            pos = (pos || '').split(' ');

            if (pos.length === 1) {
                pos = x.test(pos[0])
                    ? pos.concat('center')
                    : y.test(pos[0])
                        ? ['center'].concat(pos)
                        : ['center', 'center'];
            }

            return {
                x: x.test(pos[0]) ? pos[0] : 'center',
                y: y.test(pos[1]) ? pos[1] : 'center'
            };
        }

        function getOffsets(offsets, width, height) {

            var ref = (offsets || '').split(' ');
            var x = ref[0];
            var y = ref[1];

            return {
                x: x ? toFloat(x) * (endsWith(x, '%') ? width / 100 : 1) : 0,
                y: y ? toFloat(y) * (endsWith(y, '%') ? height / 100 : 1) : 0
            };
        }

        var util = /*#__PURE__*/Object.freeze({
            __proto__: null,
            ajax: ajax,
            getImage: getImage,
            transition: transition,
            Transition: Transition,
            animate: animate$1,
            Animation: Animation,
            attr: attr,
            hasAttr: hasAttr,
            removeAttr: removeAttr,
            data: data,
            addClass: addClass,
            removeClass: removeClass,
            removeClasses: removeClasses,
            replaceClass: replaceClass,
            hasClass: hasClass,
            toggleClass: toggleClass,
            dimensions: dimensions,
            offset: offset,
            position: position,
            offsetPosition: offsetPosition,
            height: height,
            width: width,
            boxModelAdjust: boxModelAdjust,
            flipPosition: flipPosition,
            toPx: toPx,
            ready: ready,
            empty: empty,
            html: html,
            prepend: prepend,
            append: append,
            before: before,
            after: after,
            remove: remove$1,
            wrapAll: wrapAll,
            wrapInner: wrapInner,
            unwrap: unwrap,
            fragment: fragment,
            apply: apply$1,
            $: $,
            $$: $$,
            inBrowser: inBrowser,
            isIE: isIE,
            isRtl: isRtl,
            hasTouch: hasTouch,
            pointerDown: pointerDown,
            pointerMove: pointerMove,
            pointerUp: pointerUp,
            pointerEnter: pointerEnter,
            pointerLeave: pointerLeave,
            pointerCancel: pointerCancel,
            on: on,
            off: off,
            once: once,
            trigger: trigger,
            createEvent: createEvent,
            toEventTargets: toEventTargets,
            isTouch: isTouch,
            getEventPos: getEventPos,
            fastdom: fastdom,
            isVoidElement: isVoidElement,
            isVisible: isVisible,
            selInput: selInput,
            isInput: isInput,
            selFocusable: selFocusable,
            isFocusable: isFocusable,
            parent: parent,
            filter: filter$1,
            matches: matches,
            closest: closest,
            within: within,
            parents: parents,
            children: children,
            index: index,
            hasOwn: hasOwn,
            hyphenate: hyphenate,
            camelize: camelize,
            ucfirst: ucfirst,
            startsWith: startsWith,
            endsWith: endsWith,
            includes: includes,
            findIndex: findIndex,
            isArray: isArray,
            isFunction: isFunction,
            isObject: isObject,
            isPlainObject: isPlainObject,
            isWindow: isWindow,
            isDocument: isDocument,
            isNode: isNode,
            isElement: isElement,
            isBoolean: isBoolean,
            isString: isString,
            isNumber: isNumber,
            isNumeric: isNumeric,
            isEmpty: isEmpty,
            isUndefined: isUndefined,
            toBoolean: toBoolean,
            toNumber: toNumber,
            toFloat: toFloat,
            toArray: toArray,
            toNode: toNode,
            toNodes: toNodes,
            toWindow: toWindow,
            toMs: toMs,
            isEqual: isEqual,
            swap: swap,
            assign: assign,
            last: last,
            each: each,
            sortBy: sortBy$1,
            uniqueBy: uniqueBy,
            clamp: clamp,
            noop: noop,
            intersectRect: intersectRect,
            pointInRect: pointInRect,
            Dimensions: Dimensions,
            getIndex: getIndex,
            memoize: memoize,
            MouseTracker: MouseTracker,
            mergeOptions: mergeOptions,
            parseOptions: parseOptions,
            play: play,
            pause: pause,
            mute: mute,
            isVideo: isVideo,
            positionAt: positionAt,
            Promise: Promise$1,
            Deferred: Deferred,
            query: query,
            queryAll: queryAll,
            find: find,
            findAll: findAll,
            escape: escape,
            css: css,
            getCssVar: getCssVar,
            propName: propName,
            isInView: isInView,
            scrollTop: scrollTop,
            scrollIntoView: scrollIntoView,
            scrolledOver: scrolledOver,
            scrollParents: scrollParents,
            getViewport: getViewport$1,
            getViewportClientHeight: getViewportClientHeight
        });

        function globalAPI (UIkit) {

            var DATA = UIkit.data;

            UIkit.use = function (plugin) {

                if (plugin.installed) {
                    return;
                }

                plugin.call(null, this);
                plugin.installed = true;

                return this;
            };

            UIkit.mixin = function (mixin, component) {
                component = (isString(component) ? UIkit.component(component) : component) || this;
                component.options = mergeOptions(component.options, mixin);
            };

            UIkit.extend = function (options) {

                options = options || {};

                var Super = this;
                var Sub = function UIkitComponent(options) {
                    this._init(options);
                };

                Sub.prototype = Object.create(Super.prototype);
                Sub.prototype.constructor = Sub;
                Sub.options = mergeOptions(Super.options, options);

                Sub.super = Super;
                Sub.extend = Super.extend;

                return Sub;
            };

            UIkit.update = function (element, e) {

                element = element ? toNode(element) : document.body;

                parents(element).reverse().forEach(function (element) { return update(element[DATA], e); });
                apply$1(element, function (element) { return update(element[DATA], e); });

            };

            var container;
            Object.defineProperty(UIkit, 'container', {

                get: function() {
                    return container || document.body;
                },

                set: function(element) {
                    container = $(element);
                }

            });

            function update(data, e) {

                if (!data) {
                    return;
                }

                for (var name in data) {
                    if (data[name]._connected) {
                        data[name]._callUpdate(e);
                    }
                }

            }
        }

        function hooksAPI (UIkit) {

            UIkit.prototype._callHook = function (hook) {
                var this$1$1 = this;


                var handlers = this.$options[hook];

                if (handlers) {
                    handlers.forEach(function (handler) { return handler.call(this$1$1); });
                }
            };

            UIkit.prototype._callConnected = function () {

                if (this._connected) {
                    return;
                }

                this._data = {};
                this._computeds = {};

                this._initProps();

                this._callHook('beforeConnect');
                this._connected = true;

                this._initEvents();
                this._initObservers();

                this._callHook('connected');
                this._callUpdate();
            };

            UIkit.prototype._callDisconnected = function () {

                if (!this._connected) {
                    return;
                }

                this._callHook('beforeDisconnect');
                this._disconnectObservers();
                this._unbindEvents();
                this._callHook('disconnected');

                this._connected = false;
                delete this._watch;

            };

            UIkit.prototype._callUpdate = function (e) {
                var this$1$1 = this;
                if ( e === void 0 ) e = 'update';


                if (!this._connected) {
                    return;
                }

                if (e === 'update' || e === 'resize') {
                    this._callWatches();
                }

                if (!this.$options.update) {
                    return;
                }

                if (!this._updates) {
                    this._updates = new Set();
                    fastdom.read(function () {
                        if (this$1$1._connected) {
                            runUpdates.call(this$1$1, this$1$1._updates);
                        }
                        delete this$1$1._updates;
                    });
                }

                this._updates.add(e.type || e);
            };

            UIkit.prototype._callWatches = function () {
                var this$1$1 = this;


                if (this._watch) {
                    return;
                }

                var initial = !hasOwn(this, '_watch');

                this._watch = fastdom.read(function () {
                    if (this$1$1._connected) {
                        runWatches.call(this$1$1, initial);
                    }
                    this$1$1._watch = null;

                });

            };

            function runUpdates(types) {
                var this$1$1 = this;


                var updates = this.$options.update;

                var loop = function ( i ) {
                    var ref = updates[i];
                    var read = ref.read;
                    var write = ref.write;
                    var events = ref.events;

                    if (!types.has('update') && (!events || !events.some(function (type) { return types.has(type); }))) {
                        return;
                    }

                    var result = (void 0);
                    if (read) {

                        result = read.call(this$1$1, this$1$1._data, types);

                        if (result && isPlainObject(result)) {
                            assign(this$1$1._data, result);
                        }
                    }

                    if (write && result !== false) {
                        fastdom.write(function () { return write.call(this$1$1, this$1$1._data, types); });
                    }

                };

                for (var i = 0; i < updates.length; i++) loop( i );
            }

            function runWatches(initial) {

                var ref = this;
                var computed = ref.$options.computed;
                var _computeds = ref._computeds;

                for (var key in computed) {

                    var hasPrev = hasOwn(_computeds, key);
                    var prev = _computeds[key];

                    delete _computeds[key];

                    var ref$1 = computed[key];
                    var watch = ref$1.watch;
                    var immediate = ref$1.immediate;
                    if (watch && (
                        initial && immediate
                        || hasPrev && !isEqual(prev, this[key])
                    )) {
                        watch.call(this, this[key], prev);
                    }

                }
            }
        }

        function stateAPI (UIkit) {

            var uid = 0;

            UIkit.prototype._init = function (options) {

                options = options || {};
                options.data = normalizeData(options, this.constructor.options);

                this.$options = mergeOptions(this.constructor.options, options, this);
                this.$el = null;
                this.$props = {};

                this._uid = uid++;
                this._initData();
                this._initMethods();
                this._initComputeds();
                this._callHook('created');

                if (options.el) {
                    this.$mount(options.el);
                }
            };

            UIkit.prototype._initData = function () {

                var ref = this.$options;
                var data = ref.data; if ( data === void 0 ) data = {};

                for (var key in data) {
                    this.$props[key] = this[key] = data[key];
                }
            };

            UIkit.prototype._initMethods = function () {

                var ref = this.$options;
                var methods = ref.methods;

                if (methods) {
                    for (var key in methods) {
                        this[key] = methods[key].bind(this);
                    }
                }
            };

            UIkit.prototype._initComputeds = function () {

                var ref = this.$options;
                var computed = ref.computed;

                this._computeds = {};

                if (computed) {
                    for (var key in computed) {
                        registerComputed(this, key, computed[key]);
                    }
                }
            };

            UIkit.prototype._initProps = function (props) {

                var key;

                props = props || getProps(this.$options, this.$name);

                for (key in props) {
                    if (!isUndefined(props[key])) {
                        this.$props[key] = props[key];
                    }
                }

                var exclude = [this.$options.computed, this.$options.methods];
                for (key in this.$props) {
                    if (key in props && notIn(exclude, key)) {
                        this[key] = this.$props[key];
                    }
                }
            };

            UIkit.prototype._initEvents = function () {
                var this$1$1 = this;


                this._events = [];

                var ref = this.$options;
                var events = ref.events;

                if (events) {

                    events.forEach(function (event) {

                        if (hasOwn(event, 'handler')) {
                            registerEvent(this$1$1, event);
                        } else {
                            for (var key in event) {
                                registerEvent(this$1$1, event[key], key);
                            }
                        }

                    });
                }
            };

            UIkit.prototype._unbindEvents = function () {
                this._events.forEach(function (unbind) { return unbind(); });
                delete this._events;
            };

            UIkit.prototype._initObservers = function () {
                this._observers = [
                    initChildListObserver(this),
                    initPropsObserver(this)
                ];
            };

            UIkit.prototype._disconnectObservers = function () {
                this._observers.forEach(function (observer) { return observer && observer.disconnect(); }
                );
            };

            function getProps(opts, name) {

                var data$1 = {};
                var args = opts.args; if ( args === void 0 ) args = [];
                var props = opts.props; if ( props === void 0 ) props = {};
                var el = opts.el;

                if (!props) {
                    return data$1;
                }

                for (var key in props) {
                    var prop = hyphenate(key);
                    var value = data(el, prop);

                    if (isUndefined(value)) {
                        continue;
                    }

                    value = props[key] === Boolean && value === ''
                        ? true
                        : coerce(props[key], value);

                    if (prop === 'target' && (!value || startsWith(value, '_'))) {
                        continue;
                    }

                    data$1[key] = value;
                }

                var options = parseOptions(data(el, name), args);

                for (var key$1 in options) {
                    var prop$1 = camelize(key$1);
                    if (props[prop$1] !== undefined) {
                        data$1[prop$1] = coerce(props[prop$1], options[key$1]);
                    }
                }

                return data$1;
            }

            function registerComputed(component, key, cb) {
                Object.defineProperty(component, key, {

                    enumerable: true,

                    get: function() {

                        var _computeds = component._computeds;
                        var $props = component.$props;
                        var $el = component.$el;

                        if (!hasOwn(_computeds, key)) {
                            _computeds[key] = (cb.get || cb).call(component, $props, $el);
                        }

                        return _computeds[key];
                    },

                    set: function(value) {

                        var _computeds = component._computeds;

                        _computeds[key] = cb.set ? cb.set.call(component, value) : value;

                        if (isUndefined(_computeds[key])) {
                            delete _computeds[key];
                        }
                    }

                });
            }

            function registerEvent(component, event, key) {

                if (!isPlainObject(event)) {
                    event = ({name: key, handler: event});
                }

                var name = event.name;
                var el = event.el;
                var handler = event.handler;
                var capture = event.capture;
                var passive = event.passive;
                var delegate = event.delegate;
                var filter = event.filter;
                var self = event.self;
                el = isFunction(el)
                    ? el.call(component)
                    : el || component.$el;

                if (isArray(el)) {
                    el.forEach(function (el) { return registerEvent(component, assign({}, event, {el: el}), key); });
                    return;
                }

                if (!el || filter && !filter.call(component)) {
                    return;
                }

                component._events.push(
                    on(
                        el,
                        name,
                        !delegate
                            ? null
                            : isString(delegate)
                                ? delegate
                                : delegate.call(component),
                        isString(handler) ? component[handler] : handler.bind(component),
                        {passive: passive, capture: capture, self: self}
                    )
                );

            }

            function notIn(options, key) {
                return options.every(function (arr) { return !arr || !hasOwn(arr, key); });
            }

            function coerce(type, value) {

                if (type === Boolean) {
                    return toBoolean(value);
                } else if (type === Number) {
                    return toNumber(value);
                } else if (type === 'list') {
                    return toList(value);
                }

                return type ? type(value) : value;
            }

            function toList(value) {
                return isArray(value)
                    ? value
                    : isString(value)
                        ? value.split(/,(?![^(]*\))/).map(function (value) { return isNumeric(value)
                            ? toNumber(value)
                            : toBoolean(value.trim()); })
                        : [value];
            }

            function normalizeData(ref, ref$1) {
                var data = ref.data;
                var args = ref$1.args;
                var props = ref$1.props; if ( props === void 0 ) props = {};

                data = isArray(data)
                    ? !isEmpty(args)
                        ? data.slice(0, args.length).reduce(function (data, value, index) {
                            if (isPlainObject(value)) {
                                assign(data, value);
                            } else {
                                data[args[index]] = value;
                            }
                            return data;
                        }, {})
                        : undefined
                    : data;

                if (data) {
                    for (var key in data) {
                        if (isUndefined(data[key])) {
                            delete data[key];
                        } else {
                            data[key] = props[key] ? coerce(props[key], data[key]) : data[key];
                        }
                    }
                }

                return data;
            }

            function initChildListObserver(component) {
                var ref = component.$options;
                var el = ref.el;

                var observer = new MutationObserver(function () { return component.$emit(); });
                observer.observe(el, {
                    childList: true,
                    subtree: true
                });

                return observer;
            }

            function initPropsObserver(component) {

                var $name = component.$name;
                var $options = component.$options;
                var $props = component.$props;
                var attrs = $options.attrs;
                var props = $options.props;
                var el = $options.el;

                if (!props || attrs === false) {
                    return;
                }

                var attributes = isArray(attrs) ? attrs : Object.keys(props);
                var filter = attributes.map(function (key) { return hyphenate(key); }).concat($name);

                var observer = new MutationObserver(function (records) {
                    var data = getProps($options, $name);
                    if (records.some(function (ref) {
                        var attributeName = ref.attributeName;

                        var prop = attributeName.replace('data-', '');
                        return (prop === $name ? attributes : [camelize(prop), camelize(attributeName)]).some(function (prop) { return !isUndefined(data[prop]) && data[prop] !== $props[prop]; }
                        );
                    })) {
                        component.$reset();
                    }
                });

                observer.observe(el, {
                    attributes: true,
                    attributeFilter: filter.concat(filter.map(function (key) { return ("data-" + key); }))
                });

                return observer;
            }
        }

        function instanceAPI (UIkit) {

            var DATA = UIkit.data;

            UIkit.prototype.$create = function (component, element, data) {
                return UIkit[component](element, data);
            };

            UIkit.prototype.$mount = function (el) {

                var ref = this.$options;
                var name = ref.name;

                if (!el[DATA]) {
                    el[DATA] = {};
                }

                if (el[DATA][name]) {
                    return;
                }

                el[DATA][name] = this;

                this.$el = this.$options.el = this.$options.el || el;

                if (within(el, document)) {
                    this._callConnected();
                }
            };

            UIkit.prototype.$reset = function () {
                this._callDisconnected();
                this._callConnected();
            };

            UIkit.prototype.$destroy = function (removeEl) {
                if ( removeEl === void 0 ) removeEl = false;


                var ref = this.$options;
                var el = ref.el;
                var name = ref.name;

                if (el) {
                    this._callDisconnected();
                }

                this._callHook('destroy');

                if (!el || !el[DATA]) {
                    return;
                }

                delete el[DATA][name];

                if (!isEmpty(el[DATA])) {
                    delete el[DATA];
                }

                if (removeEl) {
                    remove$1(this.$el);
                }
            };

            UIkit.prototype.$emit = function (e) {
                this._callUpdate(e);
            };

            UIkit.prototype.$update = function (element, e) {
                if ( element === void 0 ) element = this.$el;

                UIkit.update(element, e);
            };

            UIkit.prototype.$getComponent = UIkit.getComponent;

            var componentName = memoize(function (name) { return UIkit.prefix + hyphenate(name); });
            Object.defineProperties(UIkit.prototype, {

                $container: Object.getOwnPropertyDescriptor(UIkit, 'container'),

                $name: {

                    get: function() {
                        return componentName(this.$options.name);
                    }

                }

            });

        }

        function componentAPI (UIkit) {

            var DATA = UIkit.data;

            var components = {};

            UIkit.component = function (name, options) {

                var id = hyphenate(name);

                name = camelize(id);

                if (!options) {

                    if (isPlainObject(components[name])) {
                        components[name] = UIkit.extend(components[name]);
                    }

                    return components[name];

                }

                UIkit[name] = function (element, data) {
                    var i = arguments.length, argsArray = Array(i);
                    while ( i-- ) argsArray[i] = arguments[i];


                    var component = UIkit.component(name);

                    return component.options.functional
                        ? new component({data: isPlainObject(element) ? element : [].concat( argsArray )})
                        : !element ? init(element) : $$(element).map(init)[0];

                    function init(element) {

                        var instance = UIkit.getComponent(element, name);

                        if (instance) {
                            if (data) {
                                instance.$destroy();
                            } else {
                                return instance;
                            }
                        }

                        return new component({el: element, data: data});

                    }

                };

                var opt = isPlainObject(options) ? assign({}, options) : options.options;

                opt.name = name;

                if (opt.install) {
                    opt.install(UIkit, opt, name);
                }

                if (UIkit._initialized && !opt.functional) {
                    fastdom.read(function () { return UIkit[name](("[uk-" + id + "],[data-uk-" + id + "]")); });
                }

                return components[name] = isPlainObject(options) ? opt : options;
            };

            UIkit.getComponents = function (element) { return element && element[DATA] || {}; };
            UIkit.getComponent = function (element, name) { return UIkit.getComponents(element)[name]; };

            UIkit.connect = function (node) {

                if (node[DATA]) {
                    for (var name in node[DATA]) {
                        node[DATA][name]._callConnected();
                    }
                }

                for (var i = 0; i < node.attributes.length; i++) {

                    var name$1 = getComponentName(node.attributes[i].name);

                    if (name$1 && name$1 in components) {
                        UIkit[name$1](node);
                    }

                }

            };

            UIkit.disconnect = function (node) {
                for (var name in node[DATA]) {
                    node[DATA][name]._callDisconnected();
                }
            };

        }

        var getComponentName = memoize(function (attribute) {
            return startsWith(attribute, 'uk-') || startsWith(attribute, 'data-uk-')
                ? camelize(attribute.replace('data-uk-', '').replace('uk-', ''))
                : false;
        });

        var UIkit = function (options) {
            this._init(options);
        };

        UIkit.util = util;
        UIkit.data = '__uikit__';
        UIkit.prefix = 'uk-';
        UIkit.options = {};
        UIkit.version = '3.10.1';

        globalAPI(UIkit);
        hooksAPI(UIkit);
        stateAPI(UIkit);
        componentAPI(UIkit);
        instanceAPI(UIkit);

        function Core (UIkit) {

            if (!inBrowser) {
                return;
            }

            // throttle 'resize'
            var pendingResize;
            var handleResize = function () {
                if (pendingResize) {
                    return;
                }
                pendingResize = true;
                fastdom.write(function () { return pendingResize = false; });
                UIkit.update(null, 'resize');
            };

            on(window, 'load resize', handleResize);
            on(document, 'loadedmetadata load', handleResize, true);

            if ('ResizeObserver' in window) {
                (new ResizeObserver(handleResize)).observe(document.documentElement);
            }

            // throttle `scroll` event (Safari triggers multiple `scroll` events per frame)
            var pending;
            on(window, 'scroll', function (e) {

                if (pending) {
                    return;
                }
                pending = true;
                fastdom.write(function () { return pending = false; });

                UIkit.update(null, e.type);

            }, {passive: true, capture: true});

            var started = 0;
            on(document, 'animationstart', function (ref) {
                var target = ref.target;

                if ((css(target, 'animationName') || '').match(/^uk-.*(left|right)/)) {

                    started++;
                    css(document.documentElement, 'overflowX', 'hidden');
                    setTimeout(function () {
                        if (!--started) {
                            css(document.documentElement, 'overflowX', '');
                        }
                    }, toMs(css(target, 'animationDuration')) + 100);
                }
            }, true);

            on(document, pointerDown, function (e) {

                if (!isTouch(e)) {
                    return;
                }

                // Handle Swipe Gesture
                var pos = getEventPos(e);
                var target = 'tagName' in e.target ? e.target : parent(e.target);
                once(document, (pointerUp + " " + pointerCancel + " scroll"), function (e) {

                    var ref = getEventPos(e);
                    var x = ref.x;
                    var y = ref.y;

                    // swipe
                    if (e.type !== 'scroll' && target && x && Math.abs(pos.x - x) > 100 || y && Math.abs(pos.y - y) > 100) {

                        setTimeout(function () {
                            trigger(target, 'swipe');
                            trigger(target, ("swipe" + (swipeDirection(pos.x, pos.y, x, y))));
                        });

                    }

                });

            }, {passive: true});

        }

        function swipeDirection(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) >= Math.abs(y1 - y2)
                ? x1 - x2 > 0
                    ? 'Left'
                    : 'Right'
                : y1 - y2 > 0
                    ? 'Up'
                    : 'Down';
        }

        function boot (UIkit) {

            var connect = UIkit.connect;
            var disconnect = UIkit.disconnect;

            if (!inBrowser || !window.MutationObserver) {
                return;
            }

            fastdom.read(function () {

                if (document.body) {
                    apply$1(document.body, connect);
                }

                new MutationObserver(function (records) { return records.forEach(applyChildListMutation); }
                ).observe(document, {
                    childList: true,
                    subtree: true
                });

                new MutationObserver(function (records) { return records.forEach(applyAttributeMutation); }
                ).observe(document, {
                    attributes: true,
                    subtree: true
                });

                UIkit._initialized = true;
            });

            function applyChildListMutation(ref) {
                var addedNodes = ref.addedNodes;
                var removedNodes = ref.removedNodes;

                for (var i = 0; i < addedNodes.length; i++) {
                    apply$1(addedNodes[i], connect);
                }

                for (var i$1 = 0; i$1 < removedNodes.length; i$1++) {
                    apply$1(removedNodes[i$1], disconnect);
                }
            }

            function applyAttributeMutation(ref) {
                var target = ref.target;
                var attributeName = ref.attributeName;


                var name = getComponentName(attributeName);

                if (!name || !(name in UIkit)) {
                    return;
                }

                if (hasAttr(target, attributeName)) {
                    UIkit[name](target);
                    return;
                }

                var component = UIkit.getComponent(target, name);

                if (component) {
                    component.$destroy();
                }

            }

        }

        var Class = {

            connected: function() {
                !hasClass(this.$el, this.$name) && addClass(this.$el, this.$name);
            }

        };

        var Togglable = {

            props: {
                cls: Boolean,
                animation: 'list',
                duration: Number,
                origin: String,
                transition: String
            },

            data: {
                cls: false,
                animation: [false],
                duration: 200,
                origin: false,
                transition: 'linear',
                clsEnter: 'uk-togglabe-enter',
                clsLeave: 'uk-togglabe-leave',

                initProps: {
                    overflow: '',
                    height: '',
                    paddingTop: '',
                    paddingBottom: '',
                    marginTop: '',
                    marginBottom: ''
                },

                hideProps: {
                    overflow: 'hidden',
                    height: 0,
                    paddingTop: 0,
                    paddingBottom: 0,
                    marginTop: 0,
                    marginBottom: 0
                }

            },

            computed: {

                hasAnimation: function(ref) {
                    var animation = ref.animation;

                    return !!animation[0];
                },

                hasTransition: function(ref) {
                    var animation = ref.animation;

                    return this.hasAnimation && animation[0] === true;
                }

            },

            methods: {

                toggleElement: function(targets, toggle, animate) {
                    var this$1$1 = this;

                    return new Promise$1(function (resolve) { return Promise$1.all(toNodes(targets).map(function (el) {

                            var show = isBoolean(toggle) ? toggle : !this$1$1.isToggled(el);

                            if (!trigger(el, ("before" + (show ? 'show' : 'hide')), [this$1$1])) {
                                return Promise$1.reject();
                            }

                            var promise = (
                                isFunction(animate)
                                    ? animate
                                    : animate === false || !this$1$1.hasAnimation
                                    ? this$1$1._toggle
                                    : this$1$1.hasTransition
                                        ? toggleHeight(this$1$1)
                                        : toggleAnimation(this$1$1)
                            )(el, show);

                            var cls = show ? this$1$1.clsEnter : this$1$1.clsLeave;

                            addClass(el, cls);

                            trigger(el, show ? 'show' : 'hide', [this$1$1]);

                            var done = function () {
                                removeClass(el, cls);
                                trigger(el, show ? 'shown' : 'hidden', [this$1$1]);
                                this$1$1.$update(el);
                            };

                            return promise ? promise.then(done, function () {
                                removeClass(el, cls);
                                return Promise$1.reject();
                            }) : done();

                        })).then(resolve, noop); }
                    );
                },

                isToggled: function(el) {
                    var assign;

                    if ( el === void 0 ) el = this.$el;
                    (assign = toNodes(el), el = assign[0]);
                    return hasClass(el, this.clsEnter)
                        ? true
                        : hasClass(el, this.clsLeave)
                            ? false
                            : this.cls
                                ? hasClass(el, this.cls.split(' ')[0])
                                : isVisible(el);
                },

                _toggle: function(el, toggled) {

                    if (!el) {
                        return;
                    }

                    toggled = Boolean(toggled);

                    var changed;
                    if (this.cls) {
                        changed = includes(this.cls, ' ') || toggled !== hasClass(el, this.cls);
                        changed && toggleClass(el, this.cls, includes(this.cls, ' ') ? undefined : toggled);
                    } else {
                        changed = toggled === el.hidden;
                        changed && (el.hidden = !toggled);
                    }

                    $$('[autofocus]', el).some(function (el) { return isVisible(el) ? el.focus() || true : el.blur(); });

                    if (changed) {
                        trigger(el, 'toggled', [toggled, this]);
                        this.$update(el);
                    }
                }

            }

        };

        function toggleHeight(ref) {
            var isToggled = ref.isToggled;
            var duration = ref.duration;
            var initProps = ref.initProps;
            var hideProps = ref.hideProps;
            var transition = ref.transition;
            var _toggle = ref._toggle;

            return function (el, show) {

                var inProgress = Transition.inProgress(el);
                var inner = el.hasChildNodes ? toFloat(css(el.firstElementChild, 'marginTop')) + toFloat(css(el.lastElementChild, 'marginBottom')) : 0;
                var currentHeight = isVisible(el) ? height(el) + (inProgress ? 0 : inner) : 0;

                Transition.cancel(el);

                if (!isToggled(el)) {
                    _toggle(el, true);
                }

                height(el, '');

                // Update child components first
                fastdom.flush();

                var endHeight = height(el) + (inProgress ? 0 : inner);
                height(el, currentHeight);

                return (show
                    ? Transition.start(el, assign({}, initProps, {overflow: 'hidden', height: endHeight}), Math.round(duration * (1 - currentHeight / endHeight)), transition)
                    : Transition.start(el, hideProps, Math.round(duration * (currentHeight / endHeight)), transition).then(function () { return _toggle(el, false); })
                ).then(function () { return css(el, initProps); });

            };
        }

        function toggleAnimation(cmp) {
            return function (el, show) {

                Animation.cancel(el);

                var animation = cmp.animation;
                var duration = cmp.duration;
                var _toggle = cmp._toggle;

                if (show) {
                    _toggle(el, true);
                    return Animation.in(el, animation[0], duration, cmp.origin);
                }

                return Animation.out(el, animation[1] || animation[0], duration, cmp.origin).then(function () { return _toggle(el, false); });
            };
        }

        var Accordion = {

            mixins: [Class, Togglable],

            props: {
                targets: String,
                active: null,
                collapsible: Boolean,
                multiple: Boolean,
                toggle: String,
                content: String,
                transition: String,
                offset: Number
            },

            data: {
                targets: '> *',
                active: false,
                animation: [true],
                collapsible: true,
                multiple: false,
                clsOpen: 'uk-open',
                toggle: '> .uk-accordion-title',
                content: '> .uk-accordion-content',
                transition: 'ease',
                offset: 0
            },

            computed: {

                items: {

                    get: function(ref, $el) {
                        var targets = ref.targets;

                        return $$(targets, $el);
                    },

                    watch: function(items, prev) {
                        var this$1$1 = this;


                        items.forEach(function (el) { return hide($(this$1$1.content, el), !hasClass(el, this$1$1.clsOpen)); });

                        if (prev || hasClass(items, this.clsOpen)) {
                            return;
                        }

                        var active = this.active !== false && items[Number(this.active)]
                            || !this.collapsible && items[0];

                        if (active) {
                            this.toggle(active, false);
                        }

                    },

                    immediate: true

                },

                toggles: function(ref) {
                    var toggle = ref.toggle;

                    return this.items.map(function (item) { return $(toggle, item); });
                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ((this.targets) + " " + (this.$props.toggle));
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.toggle(index(this.toggles, e.current));
                    }

                }

            ],

            methods: {

                toggle: function(item, animate) {
                    var this$1$1 = this;


                    var items = [this.items[getIndex(item, this.items)]];
                    var activeItems = filter$1(this.items, ("." + (this.clsOpen)));

                    if (!this.multiple && !includes(activeItems, items[0])) {
                        items = items.concat(activeItems);
                    }

                    if (!this.collapsible && activeItems.length < 2 && !filter$1(items, (":not(." + (this.clsOpen) + ")")).length) {
                        return;
                    }

                    items.forEach(function (el) { return this$1$1.toggleElement(el, !hasClass(el, this$1$1.clsOpen), function (el, show) {

                        toggleClass(el, this$1$1.clsOpen, show);
                        attr($(this$1$1.$props.toggle, el), 'aria-expanded', show);

                        var content = $(("" + (el._wrapper ? '> * ' : '') + (this$1$1.content)), el);

                        if (animate === false || !this$1$1.hasTransition) {
                            hide(content, !show);
                            return;
                        }

                        if (!el._wrapper) {
                            el._wrapper = wrapAll(content, ("<div" + (show ? ' hidden' : '') + ">"));
                        }

                        hide(content, false);
                        return toggleHeight(this$1$1)(el._wrapper, show).then(function () {
                            hide(content, !show);
                            delete el._wrapper;
                            unwrap(content);

                            if (show) {
                                var toggle = $(this$1$1.$props.toggle, el);
                                if (!isInView(toggle)) {
                                    scrollIntoView(toggle, {offset: this$1$1.offset});
                                }
                            }
                        });
                    }); });
                }

            }

        };

        function hide(el, hide) {
            el && (el.hidden = hide);
        }

        var alert = {

            mixins: [Class, Togglable],

            args: 'animation',

            props: {
                close: String
            },

            data: {
                animation: [true],
                selClose: '.uk-alert-close',
                duration: 150,
                hideProps: assign({opacity: 0}, Togglable.data.hideProps)
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.selClose;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.close();
                    }

                }

            ],

            methods: {

                close: function() {
                    var this$1$1 = this;

                    this.toggleElement(this.$el).then(function () { return this$1$1.$destroy(true); });
                }

            }

        };

        var Video = {

            args: 'autoplay',

            props: {
                automute: Boolean,
                autoplay: Boolean
            },

            data: {
                automute: false,
                autoplay: true
            },

            computed: {

                inView: function(ref) {
                    var autoplay = ref.autoplay;

                    return autoplay === 'inview';
                }

            },

            connected: function() {

                if (this.inView && !hasAttr(this.$el, 'preload')) {
                    this.$el.preload = 'none';
                }

                if (this.automute) {
                    mute(this.$el);
                }

            },

            update: {

                read: function() {

                    if (!isVideo(this.$el)) {
                        return false;
                    }

                    return {
                        visible: isVisible(this.$el) && css(this.$el, 'visibility') !== 'hidden',
                        inView: this.inView && isInView(this.$el)
                    };
                },

                write: function(ref) {
                    var visible = ref.visible;
                    var inView = ref.inView;


                    if (!visible || this.inView && !inView) {
                        pause(this.$el);
                    } else if (this.autoplay === true || this.inView && inView) {
                        play(this.$el);
                    }

                },

                events: ['resize', 'scroll']

            }

        };

        var cover = {

            mixins: [Video],

            props: {
                width: Number,
                height: Number
            },

            data: {
                automute: true
            },

            update: {

                read: function() {

                    var el = this.$el;
                    var ref = getPositionedParent(el) || parent(el);
                    var height = ref.offsetHeight;
                    var width = ref.offsetWidth;
                    var dim = Dimensions.cover(
                        {
                            width: this.width || el.naturalWidth || el.videoWidth || el.clientWidth,
                            height: this.height || el.naturalHeight || el.videoHeight || el.clientHeight
                        },
                        {
                            width: width + (width % 2 ? 1 : 0),
                            height: height + (height % 2 ? 1 : 0)
                        }
                    );

                    if (!dim.width || !dim.height) {
                        return false;
                    }

                    return dim;
                },

                write: function(ref) {
                    var height = ref.height;
                    var width = ref.width;

                    css(this.$el, {height: height, width: width});
                },

                events: ['resize']

            }

        };

        function getPositionedParent(el) {
            while ((el = parent(el))) {
                if (css(el, 'position') !== 'static') {
                    return el;
                }
            }
        }

        var Container = {

            props: {
                container: Boolean
            },

            data: {
                container: true
            },

            computed: {

                container: function(ref) {
                    var container = ref.container;

                    return container === true && this.$container || container && $(container);
                }

            }

        };

        var Position = {

            props: {
                pos: String,
                offset: null,
                flip: Boolean,
                clsPos: String
            },

            data: {
                pos: ("bottom-" + (isRtl ? 'right' : 'left')),
                flip: true,
                offset: false,
                clsPos: ''
            },

            computed: {

                pos: function(ref) {
                    var pos = ref.pos;

                    return pos.split('-').concat('center').slice(0, 2);
                },

                dir: function() {
                    return this.pos[0];
                },

                align: function() {
                    return this.pos[1];
                }

            },

            methods: {

                positionAt: function(element, target, boundary) {

                    removeClasses(element, ((this.clsPos) + "-(top|bottom|left|right)(-[a-z]+)?"));

                    var ref = this;
                    var offset$1 = ref.offset;
                    var axis = this.getAxis();

                    if (!isNumeric(offset$1)) {
                        var node = $(offset$1);
                        offset$1 = node
                            ? offset(node)[axis === 'x' ? 'left' : 'top'] - offset(target)[axis === 'x' ? 'right' : 'bottom']
                            : 0;
                    }

                    var ref$1 = positionAt(
                        element,
                        target,
                        axis === 'x' ? ((flipPosition(this.dir)) + " " + (this.align)) : ((this.align) + " " + (flipPosition(this.dir))),
                        axis === 'x' ? ((this.dir) + " " + (this.align)) : ((this.align) + " " + (this.dir)),
                        axis === 'x' ? ("" + (this.dir === 'left' ? -offset$1 : offset$1)) : (" " + (this.dir === 'top' ? -offset$1 : offset$1)),
                        null,
                        this.flip,
                        boundary
                    ).target;
                    var x = ref$1.x;
                    var y = ref$1.y;

                    this.dir = axis === 'x' ? x : y;
                    this.align = axis === 'x' ? y : x;

                    toggleClass(element, ((this.clsPos) + "-" + (this.dir) + "-" + (this.align)), this.offset === false);

                },

                getAxis: function() {
                    return this.dir === 'top' || this.dir === 'bottom' ? 'y' : 'x';
                }

            }

        };

        var active$1;

        var drop = {

            mixins: [Container, Position, Togglable],

            args: 'pos',

            props: {
                mode: 'list',
                toggle: Boolean,
                boundary: Boolean,
                boundaryAlign: Boolean,
                delayShow: Number,
                delayHide: Number,
                clsDrop: String
            },

            data: {
                mode: ['click', 'hover'],
                toggle: '- *',
                boundary: true,
                boundaryAlign: false,
                delayShow: 0,
                delayHide: 800,
                clsDrop: false,
                animation: ['uk-animation-fade'],
                cls: 'uk-open',
                container: false
            },

            computed: {

                boundary: function(ref, $el) {
                    var boundary = ref.boundary;

                    return boundary === true ? window : query(boundary, $el);
                },

                clsDrop: function(ref) {
                    var clsDrop = ref.clsDrop;

                    return clsDrop || ("uk-" + (this.$options.name));
                },

                clsPos: function() {
                    return this.clsDrop;
                }

            },

            created: function() {
                this.tracker = new MouseTracker();
            },

            connected: function() {

                addClass(this.$el, this.clsDrop);

                if (this.toggle && !this.target) {
                    this.target = this.$create('toggle', query(this.toggle, this.$el), {
                        target: this.$el,
                        mode: this.mode
                    }).$el;
                    attr(this.target, 'aria-haspopup', true);
                }

            },

            disconnected: function() {
                if (this.isActive()) {
                    active$1 = null;
                }
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ("." + (this.clsDrop) + "-close");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.hide(false);
                    }

                },

                {

                    name: 'click',

                    delegate: function() {
                        return 'a[href^="#"]';
                    },

                    handler: function(ref) {
                        var defaultPrevented = ref.defaultPrevented;
                        var hash = ref.current.hash;

                        if (!defaultPrevented && hash && !within(hash, this.$el)) {
                            this.hide(false);
                        }
                    }

                },

                {

                    name: 'beforescroll',

                    handler: function() {
                        this.hide(false);
                    }

                },

                {

                    name: 'toggle',

                    self: true,

                    handler: function(e, toggle) {

                        e.preventDefault();

                        if (this.isToggled()) {
                            this.hide(false);
                        } else {
                            this.show(toggle.$el, false);
                        }
                    }

                },

                {

                    name: 'toggleshow',

                    self: true,

                    handler: function(e, toggle) {
                        e.preventDefault();
                        this.show(toggle.$el);
                    }

                },

                {

                    name: 'togglehide',

                    self: true,

                    handler: function(e) {
                        e.preventDefault();
                        if (!matches(this.$el, ':focus,:hover')) {
                            this.hide();
                        }
                    }

                },

                {

                    name: (pointerEnter + " focusin"),

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {
                        if (!isTouch(e)) {
                            this.clearTimers();
                        }
                    }

                },

                {

                    name: (pointerLeave + " focusout"),

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {
                        if (!isTouch(e) && e.relatedTarget) {
                            this.hide();
                        }
                    }

                },

                {

                    name: 'toggled',

                    self: true,

                    handler: function(e, toggled) {

                        if (!toggled) {
                            return;
                        }

                        this.clearTimers();
                        this.position();
                    }

                },

                {

                    name: 'show',

                    self: true,

                    handler: function() {
                        var this$1$1 = this;


                        active$1 = this;

                        this.tracker.init();

                        once(this.$el, 'hide', on(document, pointerDown, function (ref) {
                                var target = ref.target;

                                return !within(target, this$1$1.$el) && once(document, (pointerUp + " " + pointerCancel + " scroll"), function (ref) {
                                var defaultPrevented = ref.defaultPrevented;
                                var type = ref.type;
                                var newTarget = ref.target;

                                if (!defaultPrevented && type === pointerUp && target === newTarget && !(this$1$1.target && within(target, this$1$1.target))) {
                                    this$1$1.hide(false);
                                }
                            }, true);
                        }
                        ), {self: true});

                        once(this.$el, 'hide', on(document, 'keydown', function (e) {
                            if (e.keyCode === 27) {
                                this$1$1.hide(false);
                            }
                        }), {self: true});

                    }

                },

                {

                    name: 'beforehide',

                    self: true,

                    handler: function() {
                        this.clearTimers();
                    }

                },

                {

                    name: 'hide',

                    handler: function(ref) {
                        var target = ref.target;


                        if (this.$el !== target) {
                            active$1 = active$1 === null && within(target, this.$el) && this.isToggled() ? this : active$1;
                            return;
                        }

                        active$1 = this.isActive() ? null : active$1;
                        this.tracker.cancel();
                    }

                }

            ],

            update: {

                write: function() {

                    if (this.isToggled() && !hasClass(this.$el, this.clsEnter)) {
                        this.position();
                    }

                },

                events: ['resize']

            },

            methods: {

                show: function(target, delay) {
                    var this$1$1 = this;
                    if ( target === void 0 ) target = this.target;
                    if ( delay === void 0 ) delay = true;


                    if (this.isToggled() && target && this.target && target !== this.target) {
                        this.hide(false);
                    }

                    this.target = target;

                    this.clearTimers();

                    if (this.isActive()) {
                        return;
                    }

                    if (active$1) {

                        if (delay && active$1.isDelaying) {
                            this.showTimer = setTimeout(this.show, 10);
                            return;
                        }

                        var prev;
                        while (active$1 && prev !== active$1 && !within(this.$el, active$1.$el)) {
                            prev = active$1;
                            active$1.hide(false);
                        }

                    }

                    if (this.container && parent(this.$el) !== this.container) {
                        append(this.container, this.$el);
                    }

                    this.showTimer = setTimeout(function () { return this$1$1.toggleElement(this$1$1.$el, true); }, delay && this.delayShow || 0);

                },

                hide: function(delay) {
                    var this$1$1 = this;
                    if ( delay === void 0 ) delay = true;


                    var hide = function () { return this$1$1.toggleElement(this$1$1.$el, false, false); };

                    this.clearTimers();

                    this.isDelaying = getPositionedElements(this.$el).some(function (el) { return this$1$1.tracker.movesTo(el); });

                    if (delay && this.isDelaying) {
                        this.hideTimer = setTimeout(this.hide, 50);
                    } else if (delay && this.delayHide) {
                        this.hideTimer = setTimeout(hide, this.delayHide);
                    } else {
                        hide();
                    }
                },

                clearTimers: function() {
                    clearTimeout(this.showTimer);
                    clearTimeout(this.hideTimer);
                    this.showTimer = null;
                    this.hideTimer = null;
                    this.isDelaying = false;
                },

                isActive: function() {
                    return active$1 === this;
                },

                position: function() {

                    removeClass(this.$el, ((this.clsDrop) + "-stack"));
                    toggleClass(this.$el, ((this.clsDrop) + "-boundary"), this.boundaryAlign);

                    var boundary = offset(this.boundary);
                    var alignTo = this.boundaryAlign ? boundary : offset(this.target);

                    if (this.align === 'justify') {
                        var prop = this.getAxis() === 'y' ? 'width' : 'height';
                        css(this.$el, prop, alignTo[prop]);
                    } else if (this.boundary && this.$el.offsetWidth > Math.max(boundary.right - alignTo.left, alignTo.right - boundary.left)) {
                        addClass(this.$el, ((this.clsDrop) + "-stack"));
                    }

                    this.positionAt(this.$el, this.boundaryAlign ? this.boundary : this.target, this.boundary);

                }

            }

        };

        function getPositionedElements(el) {
            var result = [];
            apply$1(el, function (el) { return css(el, 'position') !== 'static' && result.push(el); });
            return result;
        }

        var formCustom = {

            mixins: [Class],

            args: 'target',

            props: {
                target: Boolean
            },

            data: {
                target: false
            },

            computed: {

                input: function(_, $el) {
                    return $(selInput, $el);
                },

                state: function() {
                    return this.input.nextElementSibling;
                },

                target: function(ref, $el) {
                    var target = ref.target;

                    return target && (target === true
                        && parent(this.input) === $el
                        && this.input.nextElementSibling
                        || query(target, $el));
                }

            },

            update: function() {

                var ref = this;
                var target = ref.target;
                var input = ref.input;

                if (!target) {
                    return;
                }

                var option;
                var prop = isInput(target) ? 'value' : 'textContent';
                var prev = target[prop];
                var value = input.files && input.files[0]
                    ? input.files[0].name
                    : matches(input, 'select') && (option = $$('option', input).filter(function (el) { return el.selected; })[0]) // eslint-disable-line prefer-destructuring
                        ? option.textContent
                        : input.value;

                if (prev !== value) {
                    target[prop] = value;
                }

            },

            events: [

                {
                    name: 'change',

                    handler: function() {
                        this.$update();
                    }
                },

                {
                    name: 'reset',

                    el: function() {
                        return closest(this.$el, 'form');
                    },

                    handler: function() {
                        this.$update();
                    }
                }

            ]

        };

        // Deprecated
        var gif = {

            update: {

                read: function(data) {

                    var inview = isInView(this.$el);

                    if (!inview || data.isInView === inview) {
                        return false;
                    }

                    data.isInView = inview;
                },

                write: function() {
                    this.$el.src = '' + this.$el.src; // force self-assign
                },

                events: ['scroll', 'resize']
            }

        };

        var Margin = {

            props: {
                margin: String,
                firstColumn: Boolean
            },

            data: {
                margin: 'uk-margin-small-top',
                firstColumn: 'uk-first-column'
            },

            update: {

                read: function() {

                    var rows = getRows(this.$el.children);

                    return {
                        rows: rows,
                        columns: getColumns(rows)
                    };
                },

                write: function(ref) {
                    var columns = ref.columns;
                    var rows = ref.rows;

                    for (var i = 0; i < rows.length; i++) {
                        for (var j = 0; j < rows[i].length; j++) {
                            toggleClass(rows[i][j], this.margin, i !== 0);
                            toggleClass(rows[i][j], this.firstColumn, !!~columns[0].indexOf(rows[i][j]));
                        }
                    }
                },

                events: ['resize']

            }

        };

        function getRows(items) {
            return sortBy(items, 'top', 'bottom');
        }

        function getColumns(rows) {

            var columns = [];

            for (var i = 0; i < rows.length; i++) {
                var sorted = sortBy(rows[i], 'left', 'right');
                for (var j = 0; j < sorted.length; j++) {
                    columns[j] = !columns[j] ? sorted[j] : columns[j].concat(sorted[j]);
                }
            }

            return isRtl
                ? columns.reverse()
                : columns;
        }

        function sortBy(items, startProp, endProp) {

            var sorted = [[]];

            for (var i = 0; i < items.length; i++) {

                var el = items[i];

                if (!isVisible(el)) {
                    continue;
                }

                var dim = getOffset(el);

                for (var j = sorted.length - 1; j >= 0; j--) {

                    var current = sorted[j];

                    if (!current[0]) {
                        current.push(el);
                        break;
                    }

                    var startDim = (void 0);
                    if (current[0].offsetParent === el.offsetParent) {
                        startDim = getOffset(current[0]);
                    } else {
                        dim = getOffset(el, true);
                        startDim = getOffset(current[0], true);
                    }

                    if (dim[startProp] >= startDim[endProp] - 1 && dim[startProp] !== startDim[startProp]) {
                        sorted.push([el]);
                        break;
                    }

                    if (dim[endProp] - 1 > startDim[startProp] || dim[startProp] === startDim[startProp]) {
                        current.push(el);
                        break;
                    }

                    if (j === 0) {
                        sorted.unshift([el]);
                        break;
                    }

                }

            }

            return sorted;
        }

        function getOffset(element, offset) {
            var assign;

            if ( offset === void 0 ) offset = false;

            var offsetTop = element.offsetTop;
            var offsetLeft = element.offsetLeft;
            var offsetHeight = element.offsetHeight;
            var offsetWidth = element.offsetWidth;

            if (offset) {
                (assign = offsetPosition(element), offsetTop = assign[0], offsetLeft = assign[1]);
            }

            return {
                top: offsetTop,
                left: offsetLeft,
                bottom: offsetTop + offsetHeight,
                right: offsetLeft + offsetWidth
            };
        }

        var grid = {

            extends: Margin,

            mixins: [Class],

            name: 'grid',

            props: {
                masonry: Boolean,
                parallax: Number
            },

            data: {
                margin: 'uk-grid-margin',
                clsStack: 'uk-grid-stack',
                masonry: false,
                parallax: 0
            },

            connected: function() {
                this.masonry && addClass(this.$el, 'uk-flex-top uk-flex-wrap-top');
            },

            update: [

                {

                    write: function(ref) {
                        var columns = ref.columns;

                        toggleClass(this.$el, this.clsStack, columns.length < 2);
                    },

                    events: ['resize']

                },

                {

                    read: function(data) {

                        var columns = data.columns;
                        var rows = data.rows;

                        // Filter component makes elements positioned absolute
                        if (!columns.length || !this.masonry && !this.parallax || positionedAbsolute(this.$el)) {
                            data.translates = false;
                            return false;
                        }

                        var translates = false;

                        var nodes = children(this.$el);
                        var columnHeights = getColumnHeights(columns);
                        var margin = getMarginTop(nodes, this.margin) * (rows.length - 1);
                        var elHeight = Math.max.apply(Math, columnHeights) + margin;

                        if (this.masonry) {
                            columns = columns.map(function (column) { return sortBy$1(column, 'offsetTop'); });
                            translates = getTranslates(rows, columns);
                        }

                        var padding = Math.abs(this.parallax);
                        if (padding) {
                            padding = columnHeights.reduce(function (newPadding, hgt, i) { return Math.max(newPadding, hgt + margin + (i % 2 ? padding : padding / 8) - elHeight); }
                                , 0);
                        }

                        return {padding: padding, columns: columns, translates: translates, height: translates ? elHeight : ''};

                    },

                    write: function(ref) {
                        var height = ref.height;
                        var padding = ref.padding;


                        css(this.$el, 'paddingBottom', padding || '');
                        height !== false && css(this.$el, 'height', height);

                    },

                    events: ['resize']

                },

                {

                    read: function(ref) {
                        var height$1 = ref.height;


                        if (positionedAbsolute(this.$el)) {
                            return false;
                        }

                        return {
                            scrolled: this.parallax
                                ? scrolledOver(this.$el, height$1 ? height$1 - height(this.$el) : 0) * Math.abs(this.parallax)
                                : false
                        };
                    },

                    write: function(ref) {
                        var columns = ref.columns;
                        var scrolled = ref.scrolled;
                        var translates = ref.translates;


                        if (scrolled === false && !translates) {
                            return;
                        }

                        columns.forEach(function (column, i) { return column.forEach(function (el, j) { return css(el, 'transform', !scrolled && !translates ? '' : ("translateY(" + ((translates && -translates[i][j]) + (scrolled ? i % 2 ? scrolled : scrolled / 8 : 0)) + "px)")); }
                            ); }
                        );

                    },

                    events: ['scroll', 'resize']

                }

            ]

        };

        function positionedAbsolute(el) {
            return children(el).some(function (el) { return css(el, 'position') === 'absolute'; });
        }

        function getTranslates(rows, columns) {

            var rowHeights = rows.map(function (row) { return Math.max.apply(Math, row.map(function (el) { return el.offsetHeight; })); }
            );

            return columns.map(function (elements) {
                var prev = 0;
                return elements.map(function (element, row) { return prev += row
                        ? rowHeights[row - 1] - elements[row - 1].offsetHeight
                        : 0; }
                );
            });
        }

        function getMarginTop(nodes, cls) {

            var ref = nodes.filter(function (el) { return hasClass(el, cls); });
            var node = ref[0];

            return toFloat(node
                ? css(node, 'marginTop')
                : css(nodes[0], 'paddingLeft'));
        }

        function getColumnHeights(columns) {
            return columns.map(function (column) { return column.reduce(function (sum, el) { return sum + el.offsetHeight; }, 0); }
            );
        }

        // IE 11 fix (min-height on a flex container won't apply to its flex items)
        var FlexBug = isIE ? {

            props: {
                selMinHeight: String
            },

            data: {
                selMinHeight: false,
                forceHeight: false
            },

            computed: {

                elements: function(ref, $el) {
                    var selMinHeight = ref.selMinHeight;

                    return selMinHeight ? $$(selMinHeight, $el) : [$el];
                }

            },

            update: [

                {

                    read: function() {
                        css(this.elements, 'height', '');
                    },

                    order: -5,

                    events: ['resize']

                },

                {

                    write: function() {
                        var this$1$1 = this;

                        this.elements.forEach(function (el) {
                            var height = toFloat(css(el, 'minHeight'));
                            if (height && (this$1$1.forceHeight || Math.round(height + boxModelAdjust(el, 'height', 'content-box')) >= el.offsetHeight)) {
                                css(el, 'height', height);
                            }
                        });
                    },

                    order: 5,

                    events: ['resize']

                }

            ]

        } : {};

        var heightMatch = {

            mixins: [FlexBug],

            args: 'target',

            props: {
                target: String,
                row: Boolean
            },

            data: {
                target: '> *',
                row: true,
                forceHeight: true
            },

            computed: {

                elements: function(ref, $el) {
                    var target = ref.target;

                    return $$(target, $el);
                }

            },

            update: {

                read: function() {
                    return {
                        rows: (this.row ? getRows(this.elements) : [this.elements]).map(match$1)
                    };
                },

                write: function(ref) {
                    var rows = ref.rows;

                    rows.forEach(function (ref) {
                            var heights = ref.heights;
                            var elements = ref.elements;

                            return elements.forEach(function (el, i) { return css(el, 'minHeight', heights[i]); }
                        );
                    }
                    );
                },

                events: ['resize']

            }

        };

        function match$1(elements) {

            if (elements.length < 2) {
                return {heights: [''], elements: elements};
            }

            var heights = elements.map(getHeight);
            var max = Math.max.apply(Math, heights);
            var hasMinHeight = elements.some(function (el) { return el.style.minHeight; });
            var hasShrunk = elements.some(function (el, i) { return !el.style.minHeight && heights[i] < max; });

            if (hasMinHeight && hasShrunk) {
                css(elements, 'minHeight', '');
                heights = elements.map(getHeight);
                max = Math.max.apply(Math, heights);
            }

            heights = elements.map(function (el, i) { return heights[i] === max && toFloat(el.style.minHeight).toFixed(2) !== max.toFixed(2) ? '' : max; }
            );

            return {heights: heights, elements: elements};
        }

        function getHeight(element) {

            var style = false;
            if (!isVisible(element)) {
                style = element.style.display;
                css(element, 'display', 'block', 'important');
            }

            var height = dimensions(element).height - boxModelAdjust(element, 'height', 'content-box');

            if (style !== false) {
                css(element, 'display', style);
            }

            return height;
        }

        var heightViewport = {

            mixins: [FlexBug],

            props: {
                expand: Boolean,
                offsetTop: Boolean,
                offsetBottom: Boolean,
                minHeight: Number
            },

            data: {
                expand: false,
                offsetTop: false,
                offsetBottom: false,
                minHeight: 0
            },

            update: {

                read: function(ref) {
                    var prev = ref.minHeight;


                    if (!isVisible(this.$el)) {
                        return false;
                    }

                    var minHeight = '';
                    var box = boxModelAdjust(this.$el, 'height', 'content-box');

                    if (this.expand) {

                        minHeight = height(window) - (dimensions(document.documentElement).height - dimensions(this.$el).height) - box || '';

                    } else {

                        // on mobile devices (iOS and Android) window.innerHeight !== 100vh
                        minHeight = 'calc(100vh';

                        if (this.offsetTop) {

                            var ref$1 = offset(this.$el);
                            var top = ref$1.top;
                            minHeight += top > 0 && top < height(window) / 2 ? (" - " + top + "px") : '';

                        }

                        if (this.offsetBottom === true) {

                            minHeight += " - " + (dimensions(this.$el.nextElementSibling).height) + "px";

                        } else if (isNumeric(this.offsetBottom)) {

                            minHeight += " - " + (this.offsetBottom) + "vh";

                        } else if (this.offsetBottom && endsWith(this.offsetBottom, 'px')) {

                            minHeight += " - " + (toFloat(this.offsetBottom)) + "px";

                        } else if (isString(this.offsetBottom)) {

                            minHeight += " - " + (dimensions(query(this.offsetBottom, this.$el)).height) + "px";

                        }

                        minHeight += (box ? (" - " + box + "px") : '') + ")";

                    }

                    return {minHeight: minHeight, prev: prev};
                },

                write: function(ref) {
                    var minHeight = ref.minHeight;
                    var prev = ref.prev;


                    css(this.$el, {minHeight: minHeight});

                    if (minHeight !== prev) {
                        this.$update(this.$el, 'resize');
                    }

                    if (this.minHeight && toFloat(css(this.$el, 'minHeight')) < this.minHeight) {
                        css(this.$el, 'minHeight', this.minHeight);
                    }

                },

                events: ['resize']

            }

        };

        var SVG = {

            args: 'src',

            props: {
                id: Boolean,
                icon: String,
                src: String,
                style: String,
                width: Number,
                height: Number,
                ratio: Number,
                class: String,
                strokeAnimation: Boolean,
                focusable: Boolean, // IE 11
                attributes: 'list'
            },

            data: {
                ratio: 1,
                include: ['style', 'class', 'focusable'],
                class: '',
                strokeAnimation: false
            },

            beforeConnect: function() {
                this.class += ' uk-svg';
            },

            connected: function() {
                var this$1$1 = this;
                var assign;


                if (!this.icon && includes(this.src, '#')) {
                    (assign = this.src.split('#'), this.src = assign[0], this.icon = assign[1]);
                }

                this.svg = this.getSvg().then(function (el) {

                    if (this$1$1._connected) {

                        var svg = insertSVG(el, this$1$1.$el);

                        if (this$1$1.svgEl && svg !== this$1$1.svgEl) {
                            remove$1(this$1$1.svgEl);
                        }

                        this$1$1.applyAttributes(svg, el);
                        this$1$1.$emit();
                        return this$1$1.svgEl = svg;
                    }

                }, noop);

            },

            disconnected: function() {
                var this$1$1 = this;


                this.svg.then(function (svg) {
                    if (!this$1$1._connected) {

                        if (isVoidElement(this$1$1.$el)) {
                            this$1$1.$el.hidden = false;
                        }

                        remove$1(svg);
                        this$1$1.svgEl = null;
                    }
                });

                this.svg = null;

            },

            update: {

                read: function() {
                    return !!(this.strokeAnimation && this.svgEl && isVisible(this.svgEl));
                },

                write: function() {
                    applyAnimation(this.svgEl);
                },

                type: ['resize']

            },

            methods: {

                getSvg: function() {
                    var this$1$1 = this;

                    return loadSVG(this.src).then(function (svg) { return parseSVG(svg, this$1$1.icon) || Promise$1.reject('SVG not found.'); }
                    );
                },

                applyAttributes: function(el, ref) {
                    var this$1$1 = this;


                    for (var prop in this.$options.props) {
                        if (includes(this.include, prop) && (prop in this)) {
                            attr(el, prop, this[prop]);
                        }
                    }

                    for (var attribute in this.attributes) {
                        var ref$1 = this.attributes[attribute].split(':', 2);
                        var prop$1 = ref$1[0];
                        var value = ref$1[1];
                        attr(el, prop$1, value);
                    }

                    if (!this.id) {
                        removeAttr(el, 'id');
                    }

                    var props = ['width', 'height'];
                    var dimensions = props.map(function (prop) { return this$1$1[prop]; });

                    if (!dimensions.some(function (val) { return val; })) {
                        dimensions = props.map(function (prop) { return attr(ref, prop); });
                    }

                    var viewBox = attr(ref, 'viewBox');
                    if (viewBox && !dimensions.some(function (val) { return val; })) {
                        dimensions = viewBox.split(' ').slice(2);
                    }

                    dimensions.forEach(function (val, i) { return attr(el, props[i], toFloat(val) * this$1$1.ratio || null); }
                    );

                }

            }

        };

        var loadSVG = memoize(function (src) { return new Promise$1(function (resolve, reject) {

                if (!src) {
                    reject();
                    return;
                }

                if (startsWith(src, 'data:')) {
                    resolve(decodeURIComponent(src.split(',')[1]));
                } else {

                    ajax(src).then(
                        function (xhr) { return resolve(xhr.response); },
                        function () { return reject('SVG not found.'); }
                    );

                }
            }); }
        );

        function parseSVG(svg, icon) {

            if (icon && includes(svg, '<symbol')) {
                svg = parseSymbols(svg, icon) || svg;
            }

            svg = $(svg.substr(svg.indexOf('<svg')));
            return svg && svg.hasChildNodes() && svg;
        }

        var symbolRe = /<symbol([^]*?id=(['"])(.+?)\2[^]*?<\/)symbol>/g;
        var symbols = {};

        function parseSymbols(svg, icon) {

            if (!symbols[svg]) {

                symbols[svg] = {};

                symbolRe.lastIndex = 0;

                var match;
                while ((match = symbolRe.exec(svg))) {
                    symbols[svg][match[3]] = "<svg xmlns=\"http://www.w3.org/2000/svg\"" + (match[1]) + "svg>";
                }

            }

            return symbols[svg][icon];
        }

        function applyAnimation(el) {

            var length = getMaxPathLength(el);

            if (length) {
                el.style.setProperty('--uk-animation-stroke', length);
            }

        }

        function getMaxPathLength(el) {
            return Math.ceil(Math.max.apply(Math, [ 0 ].concat( $$('[stroke]', el).map(function (stroke) {
                try {
                    return stroke.getTotalLength();
                } catch (e) {
                    return 0;
                }
            }) )));
        }

        function insertSVG(el, root) {

            if (isVoidElement(root) || root.tagName === 'CANVAS') {

                root.hidden = true;

                var next = root.nextElementSibling;
                return equals(el, next)
                    ? next
                    : after(root, el);

            }

            var last = root.lastElementChild;
            return equals(el, last)
                ? last
                : append(root, el);
        }

        function equals(el, other) {
            return isSVG(el) && isSVG(other) && innerHTML(el) === innerHTML(other);
        }

        function isSVG(el) {
            return el && el.tagName === 'svg';
        }

        function innerHTML(el) {
            return (el.innerHTML || (new XMLSerializer()).serializeToString(el).replace(/<svg.*?>(.*?)<\/svg>/g, '$1')).replace(/\s/g, '');
        }

        var closeIcon = "<svg width=\"14\" height=\"14\" viewBox=\"0 0 14 14\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"1\" y1=\"1\" x2=\"13\" y2=\"13\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13\" y1=\"1\" x2=\"1\" y2=\"13\"/></svg>";

        var closeLarge = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"1\" y1=\"1\" x2=\"19\" y2=\"19\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" x1=\"19\" y1=\"1\" x2=\"1\" y2=\"19\"/></svg>";

        var marker = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"4\" width=\"1\" height=\"11\"/><rect x=\"4\" y=\"9\" width=\"11\" height=\"1\"/></svg>";

        var navbarToggleIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"9\" width=\"20\" height=\"2\"/><rect y=\"3\" width=\"20\" height=\"2\"/><rect y=\"15\" width=\"20\" height=\"2\"/></svg>";

        var overlayIcon = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"19\" y=\"0\" width=\"1\" height=\"40\"/><rect x=\"0\" y=\"19\" width=\"40\" height=\"1\"/></svg>";

        var paginationNext = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 1 6 6 1 11\"/></svg>";

        var paginationPrevious = "<svg width=\"7\" height=\"12\" viewBox=\"0 0 7 12\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"6 1 1 6 6 11\"/></svg>";

        var searchIcon = "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>";

        var searchLarge = "<svg width=\"40\" height=\"40\" viewBox=\"0 0 40 40\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" cx=\"17.5\" cy=\"17.5\" r=\"16.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.8\" x1=\"38\" y1=\"39\" x2=\"29\" y2=\"30\"/></svg>";

        var searchNavbar = "<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10.5\" cy=\"10.5\" r=\"9.5\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"23\" y1=\"23\" x2=\"17\" y2=\"17\"/></svg>";

        var slidenavNext = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"1.225,23 12.775,12 1.225,1 \"/></svg>";

        var slidenavNextLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"4.002,38.547 22.527,20.024 4,1.5 \"/></svg>";

        var slidenavPrevious = "<svg width=\"14\" height=\"24\" viewBox=\"0 0 14 24\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" points=\"12.775,1 1.225,12 12.775,23 \"/></svg>";

        var slidenavPreviousLarge = "<svg width=\"25\" height=\"40\" viewBox=\"0 0 25 40\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"2\" points=\"20.527,1.5 2,20.024 20.525,38.547 \"/></svg>";

        var spinner = "<svg width=\"30\" height=\"30\" viewBox=\"0 0 30 30\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"15\" cy=\"15\" r=\"14\"/></svg>";

        var totop = "<svg width=\"18\" height=\"10\" viewBox=\"0 0 18 10\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" points=\"1 9 9 1 17 9 \"/></svg>";

        var icons = {
            spinner: spinner,
            totop: totop,
            marker: marker,
            'close-icon': closeIcon,
            'close-large': closeLarge,
            'navbar-toggle-icon': navbarToggleIcon,
            'overlay-icon': overlayIcon,
            'pagination-next': paginationNext,
            'pagination-previous': paginationPrevious,
            'search-icon': searchIcon,
            'search-large': searchLarge,
            'search-navbar': searchNavbar,
            'slidenav-next': slidenavNext,
            'slidenav-next-large': slidenavNextLarge,
            'slidenav-previous': slidenavPrevious,
            'slidenav-previous-large': slidenavPreviousLarge
        };

        var Icon = {

            install: install$3,

            extends: SVG,

            args: 'icon',

            props: ['icon'],

            data: {
                include: ['focusable']
            },

            isIcon: true,

            beforeConnect: function() {
                addClass(this.$el, 'uk-icon');
            },

            methods: {

                getSvg: function() {

                    var icon = getIcon(this.icon);

                    if (!icon) {
                        return Promise$1.reject('Icon not found.');
                    }

                    return Promise$1.resolve(icon);
                }

            }

        };

        var IconComponent = {

            args: false,

            extends: Icon,

            data: function (vm) { return ({
                icon: hyphenate(vm.constructor.options.name)
            }); },

            beforeConnect: function() {
                addClass(this.$el, this.$name);
            }

        };

        var Slidenav = {

            extends: IconComponent,

            beforeConnect: function() {
                addClass(this.$el, 'uk-slidenav');
            },

            computed: {

                icon: function(ref, $el) {
                    var icon = ref.icon;

                    return hasClass($el, 'uk-slidenav-large')
                        ? (icon + "-large")
                        : icon;
                }

            }

        };

        var Search = {

            extends: IconComponent,

            computed: {

                icon: function(ref, $el) {
                    var icon = ref.icon;

                    return hasClass($el, 'uk-search-icon') && parents($el, '.uk-search-large').length
                        ? 'search-large'
                        : parents($el, '.uk-search-navbar').length
                            ? 'search-navbar'
                            : icon;
                }

            }

        };

        var Close = {

            extends: IconComponent,

            computed: {

                icon: function() {
                    return ("close-" + (hasClass(this.$el, 'uk-close-large') ? 'large' : 'icon'));
                }

            }

        };

        var Spinner = {

            extends: IconComponent,

            connected: function() {
                var this$1$1 = this;

                this.svg.then(function (svg) { return svg && this$1$1.ratio !== 1 && css($('circle', svg), 'strokeWidth', 1 / this$1$1.ratio); });
            }

        };

        var parsed = {};
        function install$3(UIkit) {
            UIkit.icon.add = function (name, svg) {
                var obj;


                var added = isString(name) ? (( obj = {}, obj[name] = svg, obj )) : name;
                each(added, function (svg, name) {
                    icons[name] = svg;
                    delete parsed[name];
                });

                if (UIkit._initialized) {
                    apply$1(document.body, function (el) { return each(UIkit.getComponents(el), function (cmp) {
                            cmp.$options.isIcon && cmp.icon in added && cmp.$reset();
                        }); }
                    );
                }
            };
        }

        function getIcon(icon) {

            if (!icons[icon]) {
                return null;
            }

            if (!parsed[icon]) {
                parsed[icon] = $((icons[applyRtl(icon)] || icons[icon]).trim());
            }

            return parsed[icon].cloneNode(true);
        }

        function applyRtl(icon) {
            return isRtl ? swap(swap(icon, 'left', 'right'), 'previous', 'next') : icon;
        }

        var img = {

            args: 'dataSrc',

            props: {
                dataSrc: String,
                dataSrcset: Boolean,
                sizes: String,
                width: Number,
                height: Number,
                offsetTop: String,
                offsetLeft: String,
                target: String
            },

            data: {
                dataSrc: '',
                dataSrcset: false,
                sizes: false,
                width: false,
                height: false,
                offsetTop: '50vh',
                offsetLeft: '50vw',
                target: false
            },

            computed: {

                cacheKey: function(ref) {
                    var dataSrc = ref.dataSrc;

                    return ((this.$name) + "." + dataSrc);
                },

                width: function(ref) {
                    var width = ref.width;
                    var dataWidth = ref.dataWidth;

                    return width || dataWidth;
                },

                height: function(ref) {
                    var height = ref.height;
                    var dataHeight = ref.dataHeight;

                    return height || dataHeight;
                },

                sizes: function(ref) {
                    var sizes = ref.sizes;
                    var dataSizes = ref.dataSizes;

                    return sizes || dataSizes;
                },

                isImg: function(_, $el) {
                    return isImg($el);
                },

                target: {

                    get: function(ref) {
                        var target = ref.target;

                        return [this.$el ].concat( queryAll(target, this.$el));
                    },

                    watch: function() {
                        this.observe();
                    }

                },

                offsetTop: function(ref) {
                    var offsetTop = ref.offsetTop;

                    return toPx(offsetTop, 'height');
                },

                offsetLeft: function(ref) {
                    var offsetLeft = ref.offsetLeft;

                    return toPx(offsetLeft, 'width');
                }

            },

            connected: function() {

                if (!window.IntersectionObserver) {
                    setSrcAttrs(this.$el, this.dataSrc, this.dataSrcset, this.sizes);
                    return;
                }

                if (storage[this.cacheKey]) {
                    setSrcAttrs(this.$el, storage[this.cacheKey], this.dataSrcset, this.sizes);
                } else if (this.isImg && this.width && this.height) {
                    setSrcAttrs(this.$el, getPlaceholderImage(this.width, this.height, this.sizes));
                }

                this.observer = new IntersectionObserver(this.load, {
                    rootMargin: ((this.offsetTop) + "px " + (this.offsetLeft) + "px")
                });

                requestAnimationFrame(this.observe);

            },

            disconnected: function() {
                this.observer && this.observer.disconnect();
            },

            update: {

                read: function(ref) {
                    var this$1$1 = this;
                    var image = ref.image;


                    if (!this.observer) {
                        return false;
                    }

                    if (!image && document.readyState === 'complete') {
                        this.load(this.observer.takeRecords());
                    }

                    if (this.isImg) {
                        return false;
                    }

                    image && image.then(function (img) { return img && img.currentSrc !== '' && setSrcAttrs(this$1$1.$el, currentSrc(img)); });

                },

                write: function(data) {

                    if (this.dataSrcset && window.devicePixelRatio !== 1) {

                        var bgSize = css(this.$el, 'backgroundSize');
                        if (bgSize.match(/^(auto\s?)+$/) || toFloat(bgSize) === data.bgSize) {
                            data.bgSize = getSourceSize(this.dataSrcset, this.sizes);
                            css(this.$el, 'backgroundSize', ((data.bgSize) + "px"));
                        }

                    }

                },

                events: ['resize']

            },

            methods: {

                load: function(entries) {
                    var this$1$1 = this;


                    // Old chromium based browsers (UC Browser) did not implement `isIntersecting`
                    if (!entries.some(function (entry) { return isUndefined(entry.isIntersecting) || entry.isIntersecting; })) {
                        return;
                    }

                    this._data.image = getImage(this.dataSrc, this.dataSrcset, this.sizes).then(function (img) {

                        setSrcAttrs(this$1$1.$el, currentSrc(img), img.srcset, img.sizes);
                        storage[this$1$1.cacheKey] = currentSrc(img);
                        return img;

                    }, function (e) { return trigger(this$1$1.$el, new e.constructor(e.type, e)); });

                    this.observer.disconnect();
                },

                observe: function() {
                    var this$1$1 = this;

                    if (this._connected && !this._data.image) {
                        this.target.forEach(function (el) { return this$1$1.observer.observe(el); });
                    }
                }

            }

        };

        function setSrcAttrs(el, src, srcset, sizes) {

            if (isImg(el)) {
                var set = function (prop, val) { return val && val !== el[prop] && (el[prop] = val); };
                set('sizes', sizes);
                set('srcset', srcset);
                set('src', src);
            } else if (src) {

                var change = !includes(el.style.backgroundImage, src);
                if (change) {
                    css(el, 'backgroundImage', ("url(" + (escape(src)) + ")"));
                    trigger(el, createEvent('load', false));
                }

            }

        }

        function getPlaceholderImage(width, height, sizes) {
            var assign;


            if (sizes) {
                ((assign = Dimensions.ratio({width: width, height: height}, 'width', toPx(sizesToPixel(sizes))), width = assign.width, height = assign.height));
            }

            return ("data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"" + width + "\" height=\"" + height + "\"></svg>");
        }

        var sizesRe = /\s*(.*?)\s*(\w+|calc\(.*?\))\s*(?:,|$)/g;
        function sizesToPixel(sizes) {
            var matches;

            sizesRe.lastIndex = 0;

            while ((matches = sizesRe.exec(sizes))) {
                if (!matches[1] || window.matchMedia(matches[1]).matches) {
                    matches = evaluateSize(matches[2]);
                    break;
                }
            }

            return matches || '100vw';
        }

        var sizeRe = /\d+(?:\w+|%)/g;
        var additionRe = /[+-]?(\d+)/g;
        function evaluateSize(size) {
            return startsWith(size, 'calc')
                ? size
                    .slice(5, -1)
                    .replace(sizeRe, function (size) { return toPx(size); })
                    .replace(/ /g, '')
                    .match(additionRe)
                    .reduce(function (a, b) { return a + +b; }, 0)
                : size;
        }

        var srcSetRe = /\s+\d+w\s*(?:,|$)/g;
        function getSourceSize(srcset, sizes) {
            var srcSize = toPx(sizesToPixel(sizes));
            var descriptors = (srcset.match(srcSetRe) || []).map(toFloat).sort(function (a, b) { return a - b; });

            return descriptors.filter(function (size) { return size >= srcSize; })[0] || descriptors.pop() || '';
        }

        function isImg(el) {
            return el.tagName === 'IMG';
        }

        function currentSrc(el) {
            return el.currentSrc || el.src;
        }

        var key = '__test__';
        var storage;

        // workaround for Safari's private browsing mode and accessing sessionStorage in Blink
        try {
            storage = window.sessionStorage || {};
            storage[key] = 1;
            delete storage[key];
        } catch (e) {
            storage = {};
        }

        var Media = {

            props: {
                media: Boolean
            },

            data: {
                media: false
            },

            computed: {

                matchMedia: function() {
                    var media = toMedia(this.media);
                    return !media || window.matchMedia(media).matches;
                }

            }

        };

        function toMedia(value) {

            if (isString(value)) {
                if (value[0] === '@') {
                    var name = "breakpoint-" + (value.substr(1));
                    value = toFloat(getCssVar(name));
                } else if (isNaN(value)) {
                    return value;
                }
            }

            return value && !isNaN(value) ? ("(min-width: " + value + "px)") : false;
        }

        var leader = {

            mixins: [Class, Media],

            props: {
                fill: String
            },

            data: {
                fill: '',
                clsWrapper: 'uk-leader-fill',
                clsHide: 'uk-leader-hide',
                attrFill: 'data-fill'
            },

            computed: {

                fill: function(ref) {
                    var fill = ref.fill;

                    return fill || getCssVar('leader-fill-content');
                }

            },

            connected: function() {
                var assign;

                (assign = wrapInner(this.$el, ("<span class=\"" + (this.clsWrapper) + "\">")), this.wrapper = assign[0]);
            },

            disconnected: function() {
                unwrap(this.wrapper.childNodes);
            },

            update: {

                read: function(ref) {
                    var changed = ref.changed;
                    var width = ref.width;


                    var prev = width;

                    width = Math.floor(this.$el.offsetWidth / 2);

                    return {
                        width: width,
                        fill: this.fill,
                        changed: changed || prev !== width,
                        hide: !this.matchMedia
                    };
                },

                write: function(data) {

                    toggleClass(this.wrapper, this.clsHide, data.hide);

                    if (data.changed) {
                        data.changed = false;
                        attr(this.wrapper, this.attrFill, new Array(data.width).join(data.fill));
                    }

                },

                events: ['resize']

            }

        };

        var active = [];

        var Modal = {

            mixins: [Class, Container, Togglable],

            props: {
                selPanel: String,
                selClose: String,
                escClose: Boolean,
                bgClose: Boolean,
                stack: Boolean
            },

            data: {
                cls: 'uk-open',
                escClose: true,
                bgClose: true,
                overlay: true,
                stack: false
            },

            computed: {

                panel: function(ref, $el) {
                    var selPanel = ref.selPanel;

                    return $(selPanel, $el);
                },

                transitionElement: function() {
                    return this.panel;
                },

                bgClose: function(ref) {
                    var bgClose = ref.bgClose;

                    return bgClose && this.panel;
                }

            },

            beforeDisconnect: function() {
                if (includes(active, this)) {
                    this.toggleElement(this.$el, false, false);
                }
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.selClose;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.hide();
                    }

                },

                {

                    name: 'toggle',

                    self: true,

                    handler: function(e, toggle) {

                        if (e.defaultPrevented) {
                            return;
                        }

                        e.preventDefault();

                        if (this.isToggled() === includes(active, this)) {
                            this.toggle();
                        }
                    }

                },

                {
                    name: 'beforeshow',

                    self: true,

                    handler: function(e) {

                        if (includes(active, this)) {
                            return false;
                        }

                        if (!this.stack && active.length) {
                            Promise$1.all(active.map(function (modal) { return modal.hide(); })).then(this.show);
                            e.preventDefault();
                        } else {
                            active.push(this);
                        }
                    }

                },

                {

                    name: 'show',

                    self: true,

                    handler: function() {
                        var this$1$1 = this;


                        var docEl = document.documentElement;

                        if (width(window) > docEl.clientWidth && this.overlay) {
                            css(document.body, 'overflowY', 'scroll');
                        }

                        if (this.stack) {
                            css(this.$el, 'zIndex', toFloat(css(this.$el, 'zIndex')) + active.length);
                        }

                        addClass(docEl, this.clsPage);

                        if (this.bgClose) {
                            once(this.$el, 'hide', on(document, pointerDown, function (ref) {
                                var target = ref.target;


                                if (last(active) !== this$1$1 || this$1$1.overlay && !within(target, this$1$1.$el) || within(target, this$1$1.panel)) {
                                    return;
                                }

                                once(document, (pointerUp + " " + pointerCancel + " scroll"), function (ref) {
                                    var defaultPrevented = ref.defaultPrevented;
                                    var type = ref.type;
                                    var newTarget = ref.target;

                                    if (!defaultPrevented && type === pointerUp && target === newTarget) {
                                        this$1$1.hide();
                                    }
                                }, true);

                            }), {self: true});
                        }

                        if (this.escClose) {
                            once(this.$el, 'hide', on(document, 'keydown', function (e) {
                                if (e.keyCode === 27 && last(active) === this$1$1) {
                                    this$1$1.hide();
                                }
                            }), {self: true});
                        }
                    }

                },

                {
                    name: 'shown',

                    self: true,

                    handler: function() {
                        if (!isFocusable(this.$el)) {
                            attr(this.$el, 'tabindex', '-1');
                        }

                        if (!$(':focus', this.$el)) {
                            this.$el.focus();
                        }
                    }
                },

                {

                    name: 'hidden',

                    self: true,

                    handler: function() {
                        var this$1$1 = this;


                        if (includes(active, this)) {
                            active.splice(active.indexOf(this), 1);
                        }

                        if (!active.length) {
                            css(document.body, 'overflowY', '');
                        }

                        css(this.$el, 'zIndex', '');

                        if (!active.some(function (modal) { return modal.clsPage === this$1$1.clsPage; })) {
                            removeClass(document.documentElement, this.clsPage);
                        }

                    }

                }

            ],

            methods: {

                toggle: function() {
                    return this.isToggled() ? this.hide() : this.show();
                },

                show: function() {
                    var this$1$1 = this;

                    if (this.container && parent(this.$el) !== this.container) {
                        append(this.container, this.$el);
                        return new Promise$1(function (resolve) { return requestAnimationFrame(function () { return this$1$1.show().then(resolve); }
                            ); }
                        );
                    }

                    return this.toggleElement(this.$el, true, animate(this));
                },

                hide: function() {
                    return this.toggleElement(this.$el, false, animate(this));
                }

            }

        };

        function animate(ref) {
            var transitionElement = ref.transitionElement;
            var _toggle = ref._toggle;

            return function (el, show) { return new Promise$1(function (resolve, reject) { return once(el, 'show hide', function () {
                        el._reject && el._reject();
                        el._reject = reject;

                        _toggle(el, show);

                        var off = once(transitionElement, 'transitionstart', function () {
                            once(transitionElement, 'transitionend transitioncancel', resolve, {self: true});
                            clearTimeout(timer);
                        }, {self: true});

                        var timer = setTimeout(function () {
                            off();
                            resolve();
                        }, toMs(css(transitionElement, 'transitionDuration')));

                    }); }
                ).then(function () { return delete el._reject; }); };
        }

        var modal = {

            install: install$2,

            mixins: [Modal],

            data: {
                clsPage: 'uk-modal-page',
                selPanel: '.uk-modal-dialog',
                selClose: '.uk-modal-close, .uk-modal-close-default, .uk-modal-close-outside, .uk-modal-close-full'
            },

            events: [

                {
                    name: 'show',

                    self: true,

                    handler: function() {

                        if (hasClass(this.panel, 'uk-margin-auto-vertical')) {
                            addClass(this.$el, 'uk-flex');
                        } else {
                            css(this.$el, 'display', 'block');
                        }

                        height(this.$el); // force reflow
                    }
                },

                {
                    name: 'hidden',

                    self: true,

                    handler: function() {

                        css(this.$el, 'display', '');
                        removeClass(this.$el, 'uk-flex');

                    }
                }

            ]

        };

        function install$2(ref) {
            var modal = ref.modal;


            modal.dialog = function (content, options) {

                var dialog = modal(
                    ("<div class=\"uk-modal\"> <div class=\"uk-modal-dialog\">" + content + "</div> </div>"),
                    options
                );

                dialog.show();

                on(dialog.$el, 'hidden', function () { return Promise$1.resolve().then(function () { return dialog.$destroy(true); }
                    ); }, {self: true}
                );

                return dialog;
            };

            modal.alert = function (message, options) {
                return openDialog(
                    function (ref) {
                        var labels = ref.labels;

                        return ("<div class=\"uk-modal-body\">" + (isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-primary uk-modal-close\" autofocus>" + (labels.ok) + "</button> </div>");
                },
                    options,
                    function (deferred) { return deferred.resolve(); }
                );
            };

            modal.confirm = function (message, options) {
                return openDialog(
                    function (ref) {
                        var labels = ref.labels;

                        return ("<form> <div class=\"uk-modal-body\">" + (isString(message) ? message : html(message)) + "</div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" + (labels.cancel) + "</button> <button class=\"uk-button uk-button-primary\" autofocus>" + (labels.ok) + "</button> </div> </form>");
                },
                    options,
                    function (deferred) { return deferred.reject(); }
                );
            };

            modal.prompt = function (message, value, options) {
                return openDialog(
                    function (ref) {
                        var labels = ref.labels;

                        return ("<form class=\"uk-form-stacked\"> <div class=\"uk-modal-body\"> <label>" + (isString(message) ? message : html(message)) + "</label> <input class=\"uk-input\" value=\"" + (value || '') + "\" autofocus> </div> <div class=\"uk-modal-footer uk-text-right\"> <button class=\"uk-button uk-button-default uk-modal-close\" type=\"button\">" + (labels.cancel) + "</button> <button class=\"uk-button uk-button-primary\">" + (labels.ok) + "</button> </div> </form>");
                },
                    options,
                    function (deferred) { return deferred.resolve(null); },
                    function (dialog) { return $('input', dialog.$el).value; }
                );
            };

            modal.labels = {
                ok: 'Ok',
                cancel: 'Cancel'
            };

            function openDialog(tmpl, options, hideFn, submitFn) {

                options = assign({bgClose: false, escClose: true, labels: modal.labels}, options);

                var dialog = modal.dialog(tmpl(options), options);
                var deferred = new Deferred();

                var resolved = false;

                on(dialog.$el, 'submit', 'form', function (e) {
                    e.preventDefault();
                    deferred.resolve(submitFn && submitFn(dialog));
                    resolved = true;
                    dialog.hide();
                });

                on(dialog.$el, 'hide', function () { return !resolved && hideFn(deferred); });

                deferred.promise.dialog = dialog;

                return deferred.promise;
            }

        }

        var nav = {

            extends: Accordion,

            data: {
                targets: '> .uk-parent',
                toggle: '> a',
                content: '> ul'
            }

        };

        var navItem = '.uk-navbar-nav > li > a, .uk-navbar-item, .uk-navbar-toggle';

        var navbar = {

            mixins: [Class, Container, FlexBug],

            props: {
                dropdown: String,
                mode: 'list',
                align: String,
                offset: Number,
                boundary: Boolean,
                boundaryAlign: Boolean,
                clsDrop: String,
                delayShow: Number,
                delayHide: Number,
                dropbar: Boolean,
                dropbarMode: String,
                dropbarAnchor: Boolean,
                duration: Number
            },

            data: {
                dropdown: navItem,
                align: isRtl ? 'right' : 'left',
                clsDrop: 'uk-navbar-dropdown',
                mode: undefined,
                offset: undefined,
                delayShow: undefined,
                delayHide: undefined,
                boundaryAlign: undefined,
                flip: 'x',
                boundary: true,
                dropbar: false,
                dropbarMode: 'slide',
                dropbarAnchor: false,
                duration: 200,
                forceHeight: true,
                selMinHeight: navItem,
                container: false
            },

            computed: {

                boundary: function(ref, $el) {
                    var boundary = ref.boundary;
                    var boundaryAlign = ref.boundaryAlign;

                    return boundary === true || boundaryAlign ? $el : boundary;
                },

                dropbarAnchor: function(ref, $el) {
                    var dropbarAnchor = ref.dropbarAnchor;

                    return query(dropbarAnchor, $el);
                },

                pos: function(ref) {
                    var align = ref.align;

                    return ("bottom-" + align);
                },

                dropbar: {

                    get: function(ref) {
                        var dropbar = ref.dropbar;


                        if (!dropbar) {
                            return null;
                        }

                        dropbar = this._dropbar || query(dropbar, this.$el) || $('+ .uk-navbar-dropbar', this.$el);

                        return dropbar ? dropbar : (this._dropbar = $('<div></div>'));

                    },

                    watch: function(dropbar) {
                        addClass(dropbar, 'uk-navbar-dropbar');
                    },

                    immediate: true

                },

                dropContainer: function(_, $el) {
                    return this.container || $el;
                },

                dropdowns: {

                    get: function(ref, $el) {
                        var this$1$1 = this;
                        var clsDrop = ref.clsDrop;

                        var dropdowns = $$(("." + clsDrop), $el);

                        if (this.dropContainer !== $el) {
                            $$(("." + clsDrop), this.dropContainer).forEach(function (el) {
                                var dropdown = this$1$1.getDropdown(el);
                                if (!includes(dropdowns, el) && dropdown && dropdown.target && within(dropdown.target, this$1$1.$el)) {
                                    dropdowns.push(el);
                                }
                            });
                        }

                        return dropdowns;
                    },

                    watch: function(dropdowns) {
                        var this$1$1 = this;

                        this.$create(
                            'drop',
                            dropdowns.filter(function (el) { return !this$1$1.getDropdown(el); }),
                            assign({}, this.$props, {boundary: this.boundary, pos: this.pos, offset: this.dropbar || this.offset})
                        );
                    },

                    immediate: true

                },

                toggles: function(ref, $el) {
                    var dropdown = ref.dropdown;

                    return $$(dropdown, $el);
                }

            },

            disconnected: function() {
                this.dropbar && remove$1(this.dropbar);
                delete this._dropbar;
            },

            events: [

                {
                    name: 'mouseover focusin',

                    delegate: function() {
                        return this.dropdown;
                    },

                    handler: function(ref) {
                        var current = ref.current;

                        var active = this.getActive();
                        if (active && includes(active.mode, 'hover') && active.target && !within(active.target, current) && !active.tracker.movesTo(active.$el)) {
                            active.hide(false);
                        }
                    }

                },

                {
                    name: 'keydown',

                    delegate: function() {
                        return this.dropdown;
                    },

                    handler: function(e) {

                        var current = e.current;
                        var keyCode = e.keyCode;
                        var active = this.getActive();

                        if (keyCode === keyMap.DOWN && hasAttr(current, 'aria-expanded')) {

                            e.preventDefault();

                            if (!active || active.target !== current) {
                                current.click();
                                once(this.dropContainer, 'show', function (ref) {
                                    var target = ref.target;

                                    return focusFirstFocusableElement(target);
                                });
                            } else {
                                focusFirstFocusableElement(active.$el);
                            }

                        }

                        handleNavItemNavigation(e, this.toggles, active);
                    }
                },

                {
                    name: 'keydown',

                    el: function() {
                        return this.dropContainer;
                    },

                    delegate: function() {
                        return ("." + (this.clsDrop));
                    },

                    handler: function(e) {

                        var current = e.current;
                        var keyCode = e.keyCode;

                        if (!includes(this.dropdowns, current)) {
                            return;
                        }

                        var active = this.getActive();
                        var elements = $$(selFocusable, current);
                        var i = findIndex(elements, function (el) { return matches(el, ':focus'); });

                        if (keyCode === keyMap.UP) {
                            e.preventDefault();
                            if (i > 0) {
                                elements[i - 1].focus();
                            }
                        }

                        if (keyCode === keyMap.DOWN) {
                            e.preventDefault();
                            if (i < elements.length - 1) {
                                elements[i + 1].focus();
                            }
                        }

                        if (keyCode === keyMap.ESC) {
                            active && active.target && active.target.focus();
                        }

                        handleNavItemNavigation(e, this.toggles, active);
                    }
                },

                {
                    name: 'mouseleave',

                    el: function() {
                        return this.dropbar;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function() {
                        var active = this.getActive();

                        if (active && includes(active.mode, 'hover') && !this.dropdowns.some(function (el) { return matches(el, ':hover'); })) {
                            active.hide();
                        }
                    }
                },

                {
                    name: 'beforeshow',

                    el: function() {
                        return this.dropContainer;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function() {

                        if (!parent(this.dropbar)) {
                            after(this.dropbarAnchor || this.$el, this.dropbar);
                        }

                    }
                },

                {
                    name: 'show',

                    el: function() {
                        return this.dropContainer;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function(_, ref) {
                        var $el = ref.$el;
                        var dir = ref.dir;

                        if (!hasClass($el, this.clsDrop)) {
                            return;
                        }

                        if (this.dropbarMode === 'slide') {
                            addClass(this.dropbar, 'uk-navbar-dropbar-slide');
                        }

                        this.clsDrop && addClass($el, ((this.clsDrop) + "-dropbar"));

                        if (dir === 'bottom') {
                            this.transitionTo($el.offsetHeight + toFloat(css($el, 'marginTop')) + toFloat(css($el, 'marginBottom')), $el);
                        }
                    }
                },

                {
                    name: 'beforehide',

                    el: function() {
                        return this.dropContainer;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function(e, ref) {
                        var $el = ref.$el;


                        var active = this.getActive();

                        if (matches(this.dropbar, ':hover') && active && active.$el === $el) {
                            e.preventDefault();
                        }
                    }
                },

                {
                    name: 'hide',

                    el: function() {
                        return this.dropContainer;
                    },

                    filter: function() {
                        return this.dropbar;
                    },

                    handler: function(_, ref) {
                        var $el = ref.$el;

                        if (!hasClass($el, this.clsDrop)) {
                            return;
                        }

                        var active = this.getActive();

                        if (!active || active && active.$el === $el) {
                            this.transitionTo(0);
                        }
                    }
                }

            ],

            methods: {

                getActive: function() {
                    return active$1 && within(active$1.target, this.$el) && active$1;
                },

                transitionTo: function(newHeight, el) {
                    var this$1$1 = this;


                    var ref = this;
                    var dropbar = ref.dropbar;
                    var oldHeight = isVisible(dropbar) ? height(dropbar) : 0;

                    el = oldHeight < newHeight && el;

                    css(el, 'clip', ("rect(0," + (el.offsetWidth) + "px," + oldHeight + "px,0)"));

                    height(dropbar, oldHeight);

                    Transition.cancel([el, dropbar]);
                    return Promise$1.all([
                        Transition.start(dropbar, {height: newHeight}, this.duration),
                        Transition.start(el, {clip: ("rect(0," + (el.offsetWidth) + "px," + newHeight + "px,0)")}, this.duration)
                    ])
                        .catch(noop)
                        .then(function () {
                            css(el, {clip: ''});
                            this$1$1.$update(dropbar);
                        });
                },

                getDropdown: function(el) {
                    return this.$getComponent(el, 'drop') || this.$getComponent(el, 'dropdown');
                }

            }

        };

        function handleNavItemNavigation(e, toggles, active) {

            var current = e.current;
            var keyCode = e.keyCode;
            var target = active && active.target || current;
            var i = toggles.indexOf(target);

            // Left
            if (keyCode === keyMap.LEFT && i > 0) {
                active && active.hide(false);
                toggles[i - 1].focus();
            }

            // Right
            if (keyCode === keyMap.RIGHT && i < toggles.length - 1) {
                active && active.hide(false);
                toggles[i + 1].focus();
            }

            if (keyCode === keyMap.TAB) {
                target.focus();
                active && active.hide(false);
            }
        }

        function focusFirstFocusableElement(el) {
            if (!$(':focus', el)) {
                var focusEl = $(selFocusable, el);
                if (focusEl) {
                    focusEl.focus();
                }
            }
        }

        var keyMap = {
            TAB: 9,
            ESC: 27,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40
        };

        var offcanvas = {

            mixins: [Modal],

            args: 'mode',

            props: {
                mode: String,
                flip: Boolean,
                overlay: Boolean
            },

            data: {
                mode: 'slide',
                flip: false,
                overlay: false,
                clsPage: 'uk-offcanvas-page',
                clsContainer: 'uk-offcanvas-container',
                selPanel: '.uk-offcanvas-bar',
                clsFlip: 'uk-offcanvas-flip',
                clsContainerAnimation: 'uk-offcanvas-container-animation',
                clsSidebarAnimation: 'uk-offcanvas-bar-animation',
                clsMode: 'uk-offcanvas',
                clsOverlay: 'uk-offcanvas-overlay',
                selClose: '.uk-offcanvas-close',
                container: false
            },

            computed: {

                clsFlip: function(ref) {
                    var flip = ref.flip;
                    var clsFlip = ref.clsFlip;

                    return flip ? clsFlip : '';
                },

                clsOverlay: function(ref) {
                    var overlay = ref.overlay;
                    var clsOverlay = ref.clsOverlay;

                    return overlay ? clsOverlay : '';
                },

                clsMode: function(ref) {
                    var mode = ref.mode;
                    var clsMode = ref.clsMode;

                    return (clsMode + "-" + mode);
                },

                clsSidebarAnimation: function(ref) {
                    var mode = ref.mode;
                    var clsSidebarAnimation = ref.clsSidebarAnimation;

                    return mode === 'none' || mode === 'reveal' ? '' : clsSidebarAnimation;
                },

                clsContainerAnimation: function(ref) {
                    var mode = ref.mode;
                    var clsContainerAnimation = ref.clsContainerAnimation;

                    return mode !== 'push' && mode !== 'reveal' ? '' : clsContainerAnimation;
                },

                transitionElement: function(ref) {
                    var mode = ref.mode;

                    return mode === 'reveal' ? parent(this.panel) : this.panel;
                }

            },

            update: {

                read: function() {
                    if (this.isToggled() && !isVisible(this.$el)) {
                        this.hide();
                    }
                },

                events: ['resize']

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return 'a[href^="#"]';
                    },

                    handler: function(ref) {
                        var hash = ref.current.hash;
                        var defaultPrevented = ref.defaultPrevented;

                        if (!defaultPrevented && hash && $(hash, document.body)) {
                            this.hide();
                        }
                    }

                },

                {
                    name: 'touchstart',

                    passive: true,

                    el: function() {
                        return this.panel;
                    },

                    handler: function(ref) {
                        var targetTouches = ref.targetTouches;


                        if (targetTouches.length === 1) {
                            this.clientY = targetTouches[0].clientY;
                        }

                    }

                },

                {
                    name: 'touchmove',

                    self: true,
                    passive: false,

                    filter: function() {
                        return this.overlay;
                    },

                    handler: function(e) {
                        e.cancelable && e.preventDefault();
                    }

                },

                {
                    name: 'touchmove',

                    passive: false,

                    el: function() {
                        return this.panel;
                    },

                    handler: function(e) {

                        if (e.targetTouches.length !== 1) {
                            return;
                        }

                        var clientY = e.targetTouches[0].clientY - this.clientY;
                        var ref = this.panel;
                        var scrollTop = ref.scrollTop;
                        var scrollHeight = ref.scrollHeight;
                        var clientHeight = ref.clientHeight;

                        if (clientHeight >= scrollHeight
                            || scrollTop === 0 && clientY > 0
                            || scrollHeight - scrollTop <= clientHeight && clientY < 0
                        ) {
                            e.cancelable && e.preventDefault();
                        }

                    }

                },

                {
                    name: 'show',

                    self: true,

                    handler: function() {

                        if (this.mode === 'reveal' && !hasClass(parent(this.panel), this.clsMode)) {
                            wrapAll(this.panel, '<div>');
                            addClass(parent(this.panel), this.clsMode);
                        }

                        css(document.documentElement, 'overflowY', this.overlay ? 'hidden' : '');
                        addClass(document.body, this.clsContainer, this.clsFlip);
                        css(document.body, 'touch-action', 'pan-y pinch-zoom');
                        css(this.$el, 'display', 'block');
                        addClass(this.$el, this.clsOverlay);
                        addClass(this.panel, this.clsSidebarAnimation, this.mode !== 'reveal' ? this.clsMode : '');

                        height(document.body); // force reflow
                        addClass(document.body, this.clsContainerAnimation);

                        this.clsContainerAnimation && suppressUserScale();


                    }
                },

                {
                    name: 'hide',

                    self: true,

                    handler: function() {
                        removeClass(document.body, this.clsContainerAnimation);
                        css(document.body, 'touch-action', '');
                    }
                },

                {
                    name: 'hidden',

                    self: true,

                    handler: function() {

                        this.clsContainerAnimation && resumeUserScale();

                        if (this.mode === 'reveal') {
                            unwrap(this.panel);
                        }

                        removeClass(this.panel, this.clsSidebarAnimation, this.clsMode);
                        removeClass(this.$el, this.clsOverlay);
                        css(this.$el, 'display', '');
                        removeClass(document.body, this.clsContainer, this.clsFlip);

                        css(document.documentElement, 'overflowY', '');

                    }
                },

                {
                    name: 'swipeLeft swipeRight',

                    handler: function(e) {

                        if (this.isToggled() && endsWith(e.type, 'Left') ^ this.flip) {
                            this.hide();
                        }

                    }
                }

            ]

        };

        // Chrome in responsive mode zooms page upon opening offcanvas
        function suppressUserScale() {
            getViewport().content += ',user-scalable=0';
        }

        function resumeUserScale() {
            var viewport = getViewport();
            viewport.content = viewport.content.replace(/,user-scalable=0$/, '');
        }

        function getViewport() {
            return $('meta[name="viewport"]', document.head) || append(document.head, '<meta name="viewport">');
        }

        var overflowAuto = {

            mixins: [Class],

            props: {
                selContainer: String,
                selContent: String,
                minHeight: Number
            },

            data: {
                selContainer: '.uk-modal',
                selContent: '.uk-modal-dialog',
                minHeight: 150
            },

            computed: {

                container: function(ref, $el) {
                    var selContainer = ref.selContainer;

                    return closest($el, selContainer);
                },

                content: function(ref, $el) {
                    var selContent = ref.selContent;

                    return closest($el, selContent);
                }

            },

            connected: function() {
                css(this.$el, 'minHeight', this.minHeight);
            },

            update: {

                read: function() {

                    if (!this.content || !this.container || !isVisible(this.$el)) {
                        return false;
                    }

                    return {
                        current: toFloat(css(this.$el, 'maxHeight')),
                        max: Math.max(this.minHeight, height(this.container) - (dimensions(this.content).height - height(this.$el)))
                    };
                },

                write: function(ref) {
                    var current = ref.current;
                    var max = ref.max;

                    css(this.$el, 'maxHeight', max);
                    if (Math.round(current) !== Math.round(max)) {
                        trigger(this.$el, 'resize');
                    }
                },

                events: ['resize']

            }

        };

        var responsive = {

            props: ['width', 'height'],

            connected: function() {
                addClass(this.$el, 'uk-responsive-width');
            },

            update: {

                read: function() {
                    return isVisible(this.$el) && this.width && this.height
                        ? {width: width(parent(this.$el)), height: this.height}
                        : false;
                },

                write: function(dim) {
                    height(this.$el, Dimensions.contain({
                        height: this.height,
                        width: this.width
                    }, dim).height);
                },

                events: ['resize']

            }

        };

        var scroll = {

            props: {
                offset: Number
            },

            data: {
                offset: 0
            },

            methods: {

                scrollTo: function(el) {
                    var this$1$1 = this;


                    el = el && $(el) || document.body;

                    if (trigger(this.$el, 'beforescroll', [this, el])) {
                        scrollIntoView(el, {offset: this.offset}).then(function () { return trigger(this$1$1.$el, 'scrolled', [this$1$1, el]); }
                        );
                    }

                }

            },

            events: {

                click: function(e) {

                    if (e.defaultPrevented) {
                        return;
                    }

                    e.preventDefault();
                    this.scrollTo(("#" + (escape(decodeURIComponent((this.$el.hash || '').substr(1))))));
                }

            }

        };

        var stateKey = '_ukScrollspy';
        var scrollspy = {

            args: 'cls',

            props: {
                cls: String,
                target: String,
                hidden: Boolean,
                offsetTop: Number,
                offsetLeft: Number,
                repeat: Boolean,
                delay: Number
            },

            data: function () { return ({
                cls: false,
                target: false,
                hidden: true,
                offsetTop: 0,
                offsetLeft: 0,
                repeat: false,
                delay: 0,
                inViewClass: 'uk-scrollspy-inview'
            }); },

            computed: {

                elements: {

                    get: function(ref, $el) {
                        var target = ref.target;

                        return target ? $$(target, $el) : [$el];
                    },

                    watch: function(elements) {
                        if (this.hidden) {
                            css(filter$1(elements, (":not(." + (this.inViewClass) + ")")), 'visibility', 'hidden');
                        }
                    },

                    immediate: true

                }

            },

            disconnected: function() {
                var this$1$1 = this;

                this.elements.forEach(function (el) {
                    removeClass(el, this$1$1.inViewClass, el[stateKey] ? el[stateKey].cls : '');
                    delete el[stateKey];
                });
            },

            update: [

                {

                    read: function(data$1) {
                        var this$1$1 = this;


                        // Let child components be applied at least once first
                        if (!data$1.update) {
                            Promise$1.resolve().then(function () {
                                this$1$1.$emit();
                                data$1.update = true;
                            });
                            return false;
                        }

                        this.elements.forEach(function (el) {

                            if (!el[stateKey]) {
                                el[stateKey] = {cls: data(el, 'uk-scrollspy-class') || this$1$1.cls};
                            }

                            el[stateKey].show = isInView(el, this$1$1.offsetTop, this$1$1.offsetLeft);

                        });

                    },

                    write: function(data) {
                        var this$1$1 = this;


                        this.elements.forEach(function (el) {

                            var state = el[stateKey];

                            if (state.show && !state.inview && !state.queued) {

                                state.queued = true;

                                data.promise = (data.promise || Promise$1.resolve()).then(function () { return new Promise$1(function (resolve) { return setTimeout(resolve, this$1$1.delay); }
                                    ); }
                                ).then(function () {
                                    this$1$1.toggle(el, true);
                                    setTimeout(function () {
                                        state.queued = false;
                                        this$1$1.$emit();
                                    }, 300);
                                });

                            } else if (!state.show && state.inview && !state.queued && this$1$1.repeat) {

                                this$1$1.toggle(el, false);

                            }

                        });

                    },

                    events: ['scroll', 'resize']

                }

            ],

            methods: {

                toggle: function(el, inview) {

                    var state = el[stateKey];

                    state.off && state.off();

                    css(el, 'visibility', !inview && this.hidden ? 'hidden' : '');

                    toggleClass(el, this.inViewClass, inview);
                    toggleClass(el, state.cls);

                    if (/\buk-animation-/.test(state.cls)) {
                        state.off = once(el, 'animationcancel animationend', function () { return removeClasses(el, 'uk-animation-[\\w-]+'); }
                        );
                    }

                    trigger(el, inview ? 'inview' : 'outview');

                    state.inview = inview;

                    this.$update(el);
                }

            }

        };

        var scrollspyNav = {

            props: {
                cls: String,
                closest: String,
                scroll: Boolean,
                overflow: Boolean,
                offset: Number
            },

            data: {
                cls: 'uk-active',
                closest: false,
                scroll: false,
                overflow: true,
                offset: 0
            },

            computed: {

                links: {

                    get: function(_, $el) {
                        return $$('a[href^="#"]', $el).filter(function (el) { return el.hash; });
                    },

                    watch: function(links) {
                        if (this.scroll) {
                            this.$create('scroll', links, {offset: this.offset || 0});
                        }
                    },

                    immediate: true

                },

                targets: function() {
                    return $$(this.links.map(function (el) { return escape(el.hash).substr(1); }).join(','));
                },

                elements: function(ref) {
                    var selector = ref.closest;

                    return closest(this.links, selector || '*');
                }

            },

            update: [

                {

                    read: function() {
                        var this$1$1 = this;


                        var ref = this.targets;
                        var length = ref.length;

                        if (!length || !isVisible(this.$el)) {
                            return false;
                        }

                        var ref$1 = scrollParents(this.targets, /auto|scroll/, true);
                        var scrollElement = ref$1[0];
                        var scrollTop = scrollElement.scrollTop;
                        var scrollHeight = scrollElement.scrollHeight;
                        var max = scrollHeight - getViewportClientHeight(scrollElement);
                        var active = false;

                        if (scrollTop === max) {
                            active = length - 1;
                        } else {

                            this.targets.every(function (el, i) {
                                if (offset(el).top - offset(getViewport$1(scrollElement)).top - this$1$1.offset <= 0) {
                                    active = i;
                                    return true;
                                }
                            });

                            if (active === false && this.overflow) {
                                active = 0;
                            }
                        }

                        return {active: active};
                    },

                    write: function(ref) {
                        var active = ref.active;


                        var changed = active !== false && !hasClass(this.elements[active], this.cls);

                        this.links.forEach(function (el) { return el.blur(); });
                        removeClass(this.elements, this.cls);
                        addClass(this.elements[active], this.cls);

                        if (changed) {
                            trigger(this.$el, 'active', [active, this.elements[active]]);
                        }
                    },

                    events: ['scroll', 'resize']

                }

            ]

        };

        var sticky = {

            mixins: [Class, Media],

            props: {
                top: null,
                bottom: Boolean,
                offset: String,
                animation: String,
                clsActive: String,
                clsInactive: String,
                clsFixed: String,
                clsBelow: String,
                selTarget: String,
                widthElement: Boolean,
                showOnUp: Boolean,
                targetOffset: Number
            },

            data: {
                top: 0,
                bottom: false,
                offset: 0,
                animation: '',
                clsActive: 'uk-active',
                clsInactive: '',
                clsFixed: 'uk-sticky-fixed',
                clsBelow: 'uk-sticky-below',
                selTarget: '',
                widthElement: false,
                showOnUp: false,
                targetOffset: false
            },

            computed: {

                offset: function(ref) {
                    var offset = ref.offset;

                    return toPx(offset);
                },

                selTarget: function(ref, $el) {
                    var selTarget = ref.selTarget;

                    return selTarget && $(selTarget, $el) || $el;
                },

                widthElement: function(ref, $el) {
                    var widthElement = ref.widthElement;

                    return query(widthElement, $el) || this.placeholder;
                },

                isActive: {

                    get: function() {
                        return hasClass(this.selTarget, this.clsActive);
                    },

                    set: function(value) {
                        if (value && !this.isActive) {
                            replaceClass(this.selTarget, this.clsInactive, this.clsActive);
                            trigger(this.$el, 'active');
                        } else if (!value && !hasClass(this.selTarget, this.clsInactive)) {
                            replaceClass(this.selTarget, this.clsActive, this.clsInactive);
                            trigger(this.$el, 'inactive');
                        }
                    }

                }

            },

            connected: function() {
                this.placeholder = $('+ .uk-sticky-placeholder', this.$el) || $('<div class="uk-sticky-placeholder"></div>');
                this.isFixed = false;
                this.isActive = false;
            },

            disconnected: function() {

                if (this.isFixed) {
                    this.hide();
                    removeClass(this.selTarget, this.clsInactive);
                }

                remove$1(this.placeholder);
                this.placeholder = null;
                this.widthElement = null;
            },

            events: [

                {

                    name: 'load hashchange popstate',

                    el: function() {
                        return window;
                    },

                    handler: function() {
                        var this$1$1 = this;


                        if (!(this.targetOffset !== false && location.hash && window.pageYOffset > 0)) {
                            return;
                        }

                        var target = $(location.hash);

                        if (target) {
                            fastdom.read(function () {

                                var ref = offset(target);
                                var top = ref.top;
                                var elTop = offset(this$1$1.$el).top;
                                var elHeight = this$1$1.$el.offsetHeight;

                                if (this$1$1.isFixed && elTop + elHeight >= top && elTop <= top + target.offsetHeight) {
                                    scrollTop(window, top - elHeight - (isNumeric(this$1$1.targetOffset) ? this$1$1.targetOffset : 0) - this$1$1.offset);
                                }

                            });
                        }

                    }

                }

            ],

            update: [

                {

                    read: function(ref, types) {
                        var height$1 = ref.height;


                        this.inactive = !this.matchMedia || !isVisible(this.$el);

                        if (this.inactive) {
                            return false;
                        }

                        if (this.isActive && types.has('resize')) {
                            this.hide();
                            height$1 = this.$el.offsetHeight;
                            this.show();
                        }

                        height$1 = this.isActive ? height$1 : this.$el.offsetHeight;

                        if (height$1 + this.offset > height(window)) {
                            this.inactive = true;
                            return false;
                        }

                        var referenceElement = this.isFixed ? this.placeholder : this.$el;
                        this.topOffset = offset(referenceElement).top;
                        this.bottomOffset = this.topOffset + height$1;
                        this.offsetParentTop = offset(referenceElement.offsetParent).top;

                        var bottom = parseProp('bottom', this);

                        this.top = Math.max(toFloat(parseProp('top', this)), this.topOffset) - this.offset;
                        this.bottom = bottom && bottom - this.$el.offsetHeight;
                        this.width = dimensions(isVisible(this.widthElement) ? this.widthElement : this.$el).width;

                        return {
                            height: height$1,
                            top: offsetPosition(this.placeholder)[0],
                            margins: css(this.$el, ['marginTop', 'marginBottom', 'marginLeft', 'marginRight'])
                        };
                    },

                    write: function(ref) {
                        var height = ref.height;
                        var margins = ref.margins;


                        var ref$1 = this;
                        var placeholder = ref$1.placeholder;

                        css(placeholder, assign({height: height}, margins));

                        if (!within(placeholder, document)) {
                            after(this.$el, placeholder);
                            placeholder.hidden = true;
                        }

                        this.isActive = !!this.isActive; // force self-assign

                    },

                    events: ['resize']

                },

                {

                    read: function(ref) {
                        var scroll = ref.scroll; if ( scroll === void 0 ) scroll = 0;


                        this.scroll = window.pageYOffset;

                        return {
                            dir: scroll <= this.scroll ? 'down' : 'up',
                            scroll: this.scroll
                        };
                    },

                    write: function(data, types) {
                        var this$1$1 = this;


                        var now = Date.now();
                        var isScrollUpdate = types.has('scroll');
                        var initTimestamp = data.initTimestamp; if ( initTimestamp === void 0 ) initTimestamp = 0;
                        var dir = data.dir;
                        var lastDir = data.lastDir;
                        var lastScroll = data.lastScroll;
                        var scroll = data.scroll;
                        var top = data.top;

                        data.lastScroll = scroll;

                        if (scroll < 0 || scroll === lastScroll && isScrollUpdate || this.showOnUp && !isScrollUpdate && !this.isFixed) {
                            return;
                        }

                        if (now - initTimestamp > 300 || dir !== lastDir) {
                            data.initScroll = scroll;
                            data.initTimestamp = now;
                        }

                        data.lastDir = dir;

                        if (this.showOnUp && !this.isFixed && Math.abs(data.initScroll - scroll) <= 30 && Math.abs(lastScroll - scroll) <= 10) {
                            return;
                        }

                        if (this.inactive
                            || scroll < this.top
                            || this.showOnUp && (scroll <= this.top || dir === 'down' && isScrollUpdate || dir === 'up' && !this.isFixed && scroll <= this.bottomOffset)
                        ) {

                            if (!this.isFixed) {

                                if (Animation.inProgress(this.$el) && top > scroll) {
                                    Animation.cancel(this.$el);
                                    this.hide();
                                }

                                return;
                            }

                            this.isFixed = false;

                            if (this.animation && scroll > this.topOffset) {
                                Animation.cancel(this.$el);
                                Animation.out(this.$el, this.animation).then(function () { return this$1$1.hide(); }, noop);
                            } else {
                                this.hide();
                            }

                        } else if (this.isFixed) {

                            this.update();

                        } else if (this.animation) {

                            Animation.cancel(this.$el);
                            this.show();
                            Animation.in(this.$el, this.animation).catch(noop);

                        } else {
                            this.show();
                        }

                    },

                    events: ['resize', 'scroll']

                }

            ],

            methods: {

                show: function() {

                    this.isFixed = true;
                    this.update();
                    this.placeholder.hidden = false;

                },

                hide: function() {

                    this.isActive = false;
                    removeClass(this.$el, this.clsFixed, this.clsBelow);
                    css(this.$el, {position: '', top: '', width: ''});
                    this.placeholder.hidden = true;

                },

                update: function() {

                    var active = this.top !== 0 || this.scroll > this.top;
                    var top = Math.max(0, this.offset);
                    var position = 'fixed';

                    if (isNumeric(this.bottom) && this.scroll > this.bottom - this.offset) {
                        top = this.bottom - this.offsetParentTop;
                        position = 'absolute';
                    }

                    css(this.$el, {
                        position: position,
                        top: (top + "px"),
                        width: this.width
                    });

                    this.isActive = active;
                    toggleClass(this.$el, this.clsBelow, this.scroll > this.bottomOffset);
                    addClass(this.$el, this.clsFixed);

                }

            }

        };

        function parseProp(prop, ref) {
            var $props = ref.$props;
            var $el = ref.$el;
            var propOffset = ref[(prop + "Offset")];


            var value = $props[prop];

            if (!value) {
                return;
            }

            if (isString(value) && value.match(/^-?\d/)) {

                return propOffset + toPx(value);

            } else {

                return offset(value === true ? parent($el) : query(value, $el)).bottom;

            }
        }

        var Switcher = {

            mixins: [Togglable],

            args: 'connect',

            props: {
                connect: String,
                toggle: String,
                itemNav: String,
                active: Number,
                swiping: Boolean
            },

            data: {
                connect: '~.uk-switcher',
                toggle: '> * > :first-child',
                itemNav: false,
                active: 0,
                swiping: true,
                cls: 'uk-active',
                attrItem: 'uk-switcher-item'
            },

            computed: {

                connects: {

                    get: function(ref, $el) {
                        var connect = ref.connect;

                        return queryAll(connect, $el);
                    },

                    watch: function(connects) {
                        var this$1$1 = this;


                        if (this.swiping) {
                            css(connects, 'touch-action', 'pan-y pinch-zoom');
                        }

                        var index = this.index();
                        this.connects.forEach(function (el) { return children(el).forEach(function (child, i) { return toggleClass(child, this$1$1.cls, i === index); }
                            ); }
                        );

                    },

                    immediate: true

                },

                toggles: {

                    get: function(ref, $el) {
                        var toggle = ref.toggle;

                        return $$(toggle, $el).filter(function (el) { return !matches(el, '.uk-disabled *, .uk-disabled, [disabled]'); });
                    },

                    watch: function(toggles) {
                        var active = this.index();
                        this.show(~active ? active : toggles[this.active] || toggles[0]);
                    },

                    immediate: true

                },

                children: function() {
                    var this$1$1 = this;

                    return children(this.$el).filter(function (child) { return this$1$1.toggles.some(function (toggle) { return within(toggle, child); }); });
                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.toggle;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(e.current);
                    }

                },

                {
                    name: 'click',

                    el: function() {
                        return this.connects.concat(this.itemNav ? queryAll(this.itemNav, this.$el) : []);
                    },

                    delegate: function() {
                        return ("[" + (this.attrItem) + "],[data-" + (this.attrItem) + "]");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(data(e.current, this.attrItem));
                    }
                },

                {
                    name: 'swipeRight swipeLeft',

                    filter: function() {
                        return this.swiping;
                    },

                    el: function() {
                        return this.connects;
                    },

                    handler: function(ref) {
                        var type = ref.type;

                        this.show(endsWith(type, 'Left') ? 'next' : 'previous');
                    }
                }

            ],

            methods: {

                index: function() {
                    var this$1$1 = this;

                    return findIndex(this.children, function (el) { return hasClass(el, this$1$1.cls); });
                },

                show: function(item) {
                    var this$1$1 = this;


                    var prev = this.index();
                    var next = getIndex(
                        this.children[getIndex(item, this.toggles, prev)],
                        children(this.$el)
                    );

                    if (prev === next) {
                        return;
                    }

                    this.children.forEach(function (child, i) {
                        toggleClass(child, this$1$1.cls, next === i);
                        attr(this$1$1.toggles[i], 'aria-expanded', next === i);
                    });

                    this.connects.forEach(function (ref) {
                            var children = ref.children;

                            return this$1$1.toggleElement(toNodes(children).filter(function (child) { return hasClass(child, this$1$1.cls); }
                        ), false, prev >= 0).then(function () { return this$1$1.toggleElement(children[next], true, prev >= 0); }
                        );
                    }
                    );
                }

            }

        };

        var tab = {

            mixins: [Class],

            extends: Switcher,

            props: {
                media: Boolean
            },

            data: {
                media: 960,
                attrItem: 'uk-tab-item'
            },

            connected: function() {

                var cls = hasClass(this.$el, 'uk-tab-left')
                    ? 'uk-tab-left'
                    : hasClass(this.$el, 'uk-tab-right')
                        ? 'uk-tab-right'
                        : false;

                if (cls) {
                    this.$create('toggle', this.$el, {cls: cls, mode: 'media', media: this.media});
                }
            }

        };

        var KEY_SPACE = 32;

        var toggle = {

            mixins: [Media, Togglable],

            args: 'target',

            props: {
                href: String,
                target: null,
                mode: 'list',
                queued: Boolean
            },

            data: {
                href: false,
                target: false,
                mode: 'click',
                queued: true
            },

            connected: function() {
                if (!includes(this.mode, 'media') && !isFocusable(this.$el)) {
                    attr(this.$el, 'tabindex', '0');
                }
            },

            computed: {

                target: {

                    get: function(ref, $el) {
                        var href = ref.href;
                        var target = ref.target;

                        target = queryAll(target || href, $el);
                        return target.length && target || [$el];
                    },

                    watch: function() {
                        this.updateAria();
                    },

                    immediate: true

                }

            },

            events: [

                {
                    name: pointerDown,

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {
                        var this$1$1 = this;


                        if (!isTouch(e) || this._showState) {
                            return;
                        }

                        // Clicking a button does not give it focus on all browsers and platforms
                        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#clicking_and_focus
                        trigger(this.$el, 'focus');
                        once(document, pointerDown, function () { return trigger(this$1$1.$el, 'blur'); }, true, function (e) { return !within(e.target, this$1$1.$el); });

                        // Prevent initial click to prevent double toggle through focus + click
                        if (includes(this.mode, 'click')) {
                            this._preventClick = true;
                        }
                    }
                },

                {

                    name: (pointerEnter + " " + pointerLeave + " focus blur"),

                    filter: function() {
                        return includes(this.mode, 'hover');
                    },

                    handler: function(e) {
                        if (isTouch(e)) {
                            return;
                        }

                        var show = includes([pointerEnter, 'focus'], e.type);
                        var expanded = attr(this.$el, 'aria-expanded');

                        // Skip hide if still hovered or focused
                        if (!show && (
                            e.type === pointerLeave && matches(this.$el, ':focus')
                            || e.type === 'blur' && matches(this.$el, ':hover')
                        )) {
                            return;
                        }

                        // Skip if state does not change e.g. hover + focus received
                        if (this._showState && show === (expanded !== this._showState)) {

                            // Ensure reset if state has changed through click
                            if (!show) {
                                this._showState = null;
                            }
                            return;
                        }

                        this._showState = show ? expanded : null;

                        this.toggle(("toggle" + (show ? 'show' : 'hide')));
                    }

                },

                {
                    name: 'keydown',

                    filter: function() {
                        return includes(this.mode, 'click') && this.$el.tagName !== 'INPUT';
                    },

                    handler: function(e) {
                        if (e.keyCode === KEY_SPACE) {
                            e.preventDefault();
                            this.$el.click();
                        }
                    }
                },

                {

                    name: 'click',

                    filter: function() {
                        return includes(this.mode, 'click');
                    },

                    handler: function(e) {

                        if (this._preventClick) {
                            return this._preventClick = null;
                        }

                        var link;
                        if (closest(e.target, 'a[href="#"], a[href=""]')
                            || (link = closest(e.target, 'a[href]')) && (
                                attr(this.$el, 'aria-expanded') !== 'true'
                                || link.hash && matches(this.target, link.hash)
                            )
                        ) {
                            e.preventDefault();
                        }

                        this.toggle();
                    }

                },

                {

                    name: 'toggled',

                    self: true,

                    el: function() {
                        return this.target;
                    },

                    handler: function(e, toggled) {
                        if (e.target === this.target[0]) {
                            this.updateAria(toggled);
                        }
                    }
                }

            ],

            update: {

                read: function() {
                    return includes(this.mode, 'media') && this.media
                        ? {match: this.matchMedia}
                        : false;
                },

                write: function(ref) {
                    var match = ref.match;


                    var toggled = this.isToggled(this.target);
                    if (match ? !toggled : toggled) {
                        this.toggle();
                    }

                },

                events: ['resize']

            },

            methods: {

                toggle: function(type) {
                    var this$1$1 = this;


                    if (!trigger(this.target, type || 'toggle', [this])) {
                        return;
                    }

                    if (!this.queued) {
                        return this.toggleElement(this.target);
                    }

                    var leaving = this.target.filter(function (el) { return hasClass(el, this$1$1.clsLeave); });

                    if (leaving.length) {
                        this.target.forEach(function (el) {
                            var isLeaving = includes(leaving, el);
                            this$1$1.toggleElement(el, isLeaving, isLeaving);
                        });
                        return;
                    }

                    var toggled = this.target.filter(this.isToggled);
                    this.toggleElement(toggled, false).then(function () { return this$1$1.toggleElement(this$1$1.target.filter(function (el) { return !includes(toggled, el); }
                        ), true); }
                    );

                },

                updateAria: function(toggled) {
                    if (includes(this.mode, 'media')) {
                        return;
                    }

                    attr(this.$el, 'aria-expanded', isBoolean(toggled)
                        ? toggled
                        : this.isToggled(this.target)
                    );
                }

            }

        };

        var components$1 = /*#__PURE__*/Object.freeze({
            __proto__: null,
            Accordion: Accordion,
            Alert: alert,
            Cover: cover,
            Drop: drop,
            Dropdown: drop,
            FormCustom: formCustom,
            Gif: gif,
            Grid: grid,
            HeightMatch: heightMatch,
            HeightViewport: heightViewport,
            Icon: Icon,
            Img: img,
            Leader: leader,
            Margin: Margin,
            Modal: modal,
            Nav: nav,
            Navbar: navbar,
            Offcanvas: offcanvas,
            OverflowAuto: overflowAuto,
            Responsive: responsive,
            Scroll: scroll,
            Scrollspy: scrollspy,
            ScrollspyNav: scrollspyNav,
            Sticky: sticky,
            Svg: SVG,
            Switcher: Switcher,
            Tab: tab,
            Toggle: toggle,
            Video: Video,
            Close: Close,
            Spinner: Spinner,
            SlidenavNext: Slidenav,
            SlidenavPrevious: Slidenav,
            SearchIcon: Search,
            Marker: IconComponent,
            NavbarToggleIcon: IconComponent,
            OverlayIcon: IconComponent,
            PaginationNext: IconComponent,
            PaginationPrevious: IconComponent,
            Totop: IconComponent
        });

        // register components
        each(components$1, function (component, name) { return UIkit.component(name, component); }
        );

        // core functionality
        UIkit.use(Core);

        boot(UIkit);

        var countdown = {

            mixins: [Class],

            props: {
                date: String,
                clsWrapper: String
            },

            data: {
                date: '',
                clsWrapper: '.uk-countdown-%unit%'
            },

            computed: {

                date: function(ref) {
                    var date = ref.date;

                    return Date.parse(date);
                },

                days: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'days'), $el);
                },

                hours: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'hours'), $el);
                },

                minutes: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'minutes'), $el);
                },

                seconds: function(ref, $el) {
                    var clsWrapper = ref.clsWrapper;

                    return $(clsWrapper.replace('%unit%', 'seconds'), $el);
                },

                units: function() {
                    var this$1$1 = this;

                    return ['days', 'hours', 'minutes', 'seconds'].filter(function (unit) { return this$1$1[unit]; });
                }

            },

            connected: function() {
                this.start();
            },

            disconnected: function() {
                var this$1$1 = this;

                this.stop();
                this.units.forEach(function (unit) { return empty(this$1$1[unit]); });
            },

            events: [

                {

                    name: 'visibilitychange',

                    el: function() {
                        return document;
                    },

                    handler: function() {
                        if (document.hidden) {
                            this.stop();
                        } else {
                            this.start();
                        }
                    }

                }

            ],

            update: {

                write: function() {
                    var this$1$1 = this;


                    var timespan = getTimeSpan(this.date);

                    if (timespan.total <= 0) {

                        this.stop();

                        timespan.days
                            = timespan.hours
                            = timespan.minutes
                            = timespan.seconds
                            = 0;
                    }

                    this.units.forEach(function (unit) {

                        var digits = String(Math.floor(timespan[unit]));

                        digits = digits.length < 2 ? ("0" + digits) : digits;

                        var el = this$1$1[unit];
                        if (el.textContent !== digits) {
                            digits = digits.split('');

                            if (digits.length !== el.children.length) {
                                html(el, digits.map(function () { return '<span></span>'; }).join(''));
                            }

                            digits.forEach(function (digit, i) { return el.children[i].textContent = digit; });
                        }

                    });

                }

            },

            methods: {

                start: function() {

                    this.stop();

                    if (this.date && this.units.length) {
                        this.$update();
                        this.timer = setInterval(this.$update, 1000);
                    }

                },

                stop: function() {

                    if (this.timer) {
                        clearInterval(this.timer);
                        this.timer = null;
                    }

                }

            }

        };

        function getTimeSpan(date) {

            var total = date - Date.now();

            return {
                total: total,
                seconds: total / 1000 % 60,
                minutes: total / 1000 / 60 % 60,
                hours: total / 1000 / 60 / 60 % 24,
                days: total / 1000 / 60 / 60 / 24
            };
        }

        var clsLeave = 'uk-transition-leave';
        var clsEnter = 'uk-transition-enter';

        function fade(action, target, duration, stagger) {
            if ( stagger === void 0 ) stagger = 0;


            var index = transitionIndex(target, true);
            var propsIn = {opacity: 1};
            var propsOut = {opacity: 0};

            var wrapIndexFn = function (fn) { return function () { return index === transitionIndex(target) ? fn() : Promise$1.reject(); }; };

            var leaveFn = wrapIndexFn(function () {

                addClass(target, clsLeave);

                return Promise$1.all(getTransitionNodes(target).map(function (child, i) { return new Promise$1(function (resolve) { return setTimeout(function () { return Transition.start(child, propsOut, duration / 2, 'ease').then(resolve); }, i * stagger); }
                    ); }
                )).then(function () { return removeClass(target, clsLeave); });

            });

            var enterFn = wrapIndexFn(function () {

                var oldHeight = height(target);

                addClass(target, clsEnter);
                action();

                css(children(target), {opacity: 0});

                // Ensure UIkit updates have propagated
                return new Promise$1(function (resolve) { return requestAnimationFrame(function () {

                        var nodes = children(target);
                        var newHeight = height(target);

                        // Ensure Grid cells do not stretch when height is applied
                        css(target, 'alignContent', 'flex-start');
                        height(target, oldHeight);

                        var transitionNodes = getTransitionNodes(target);
                        css(nodes, propsOut);

                        var transitions = transitionNodes.map(function (child, i) { return new Promise$1(function (resolve) { return setTimeout(function () { return Transition.start(child, propsIn, duration / 2, 'ease').then(resolve); }, i * stagger); }
                            ); }
                        );

                        if (oldHeight !== newHeight) {
                            transitions.push(Transition.start(target, {height: newHeight}, duration / 2 + transitionNodes.length * stagger, 'ease'));
                        }

                        Promise$1.all(transitions).then(function () {
                            removeClass(target, clsEnter);
                            if (index === transitionIndex(target)) {
                                css(target, {height: '', alignContent: ''});
                                css(nodes, {opacity: ''});
                                delete target.dataset.transition;
                            }
                            resolve();
                        });
                    }); }
                );
            });

            return hasClass(target, clsLeave)
                ? waitTransitionend(target).then(enterFn)
                : hasClass(target, clsEnter)
                    ? waitTransitionend(target).then(leaveFn).then(enterFn)
                    : leaveFn().then(enterFn);
        }

        function transitionIndex(target, next) {
            if (next) {
                target.dataset.transition = 1 + transitionIndex(target);
            }

            return toNumber(target.dataset.transition) || 0;
        }

        function waitTransitionend(target) {
            return Promise$1.all(children(target).filter(Transition.inProgress).map(function (el) { return new Promise$1(function (resolve) { return once(el, 'transitionend transitioncanceled', resolve); }); }
            ));
        }

        function getTransitionNodes(target) {
            return getRows(children(target)).reduce(function (nodes, row) { return nodes.concat(sortBy$1(row.filter(function (el) { return isInView(el); }), 'offsetLeft')); }, []);
        }

        function slide (action, target, duration) {

            return new Promise$1(function (resolve) { return requestAnimationFrame(function () {

                    var nodes = children(target);

                    // Get current state
                    var currentProps = nodes.map(function (el) { return getProps(el, true); });
                    var targetProps = css(target, ['height', 'padding']);

                    // Cancel previous animations
                    Transition.cancel(target);
                    nodes.forEach(Transition.cancel);
                    reset(target);

                    // Adding, sorting, removing nodes
                    action();

                    // Find new nodes
                    nodes = nodes.concat(children(target).filter(function (el) { return !includes(nodes, el); }));

                    // Wait for update to propagate
                    Promise$1.resolve().then(function () {

                        // Force update
                        fastdom.flush();

                        // Get new state
                        var targetPropsTo = css(target, ['height', 'padding']);
                        var ref = getTransitionProps(target, nodes, currentProps);
                        var propsTo = ref[0];
                        var propsFrom = ref[1];

                        // Reset to previous state
                        nodes.forEach(function (el, i) { return propsFrom[i] && css(el, propsFrom[i]); });
                        css(target, assign({display: 'block'}, targetProps));

                        // Start transitions on next frame
                        requestAnimationFrame(function () {

                            var transitions = nodes.map(function (el, i) { return parent(el) === target && Transition.start(el, propsTo[i], duration, 'ease'); }
                                ).concat(Transition.start(target, targetPropsTo, duration, 'ease'));

                            Promise$1.all(transitions).then(function () {
                                nodes.forEach(function (el, i) { return parent(el) === target && css(el, 'display', propsTo[i].opacity === 0 ? 'none' : ''); });
                                reset(target);
                            }, noop).then(resolve);

                        });
                    });
                }); });
        }

        function getProps(el, opacity) {

            var zIndex = css(el, 'zIndex');

            return isVisible(el)
                ? assign({
                    display: '',
                    opacity: opacity ? css(el, 'opacity') : '0',
                    pointerEvents: 'none',
                    position: 'absolute',
                    zIndex: zIndex === 'auto' ? index(el) : zIndex
                }, getPositionWithMargin(el))
                : false;
        }

        function getTransitionProps(target, nodes, currentProps) {

            var propsTo = nodes.map(function (el, i) { return parent(el) && i in currentProps
                    ? currentProps[i]
                    ? isVisible(el)
                        ? getPositionWithMargin(el)
                        : {opacity: 0}
                    : {opacity: isVisible(el) ? 1 : 0}
                    : false; });

            var propsFrom = propsTo.map(function (props, i) {

                var from = parent(nodes[i]) === target && (currentProps[i] || getProps(nodes[i]));

                if (!from) {
                    return false;
                }

                if (!props) {
                    delete from.opacity;
                } else if (!('opacity' in props)) {
                    var opacity = from.opacity;

                    if (opacity % 1) {
                        props.opacity = 1;
                    } else {
                        delete from.opacity;
                    }
                }

                return from;
            });

            return [propsTo, propsFrom];
        }

        function reset(el) {
            css(el.children, {
                height: '',
                left: '',
                opacity: '',
                pointerEvents: '',
                position: '',
                top: '',
                marginTop: '',
                marginLeft: '',
                transform: '',
                width: '',
                zIndex: ''
            });
            css(el, {height: '', display: '', padding: ''});
        }

        function getPositionWithMargin(el) {
            var ref = offset(el);
            var height = ref.height;
            var width = ref.width;
            var ref$1 = position(el);
            var top = ref$1.top;
            var left = ref$1.left;
            var ref$2 = css(el, ['marginTop', 'marginLeft']);
            var marginLeft = ref$2.marginLeft;
            var marginTop = ref$2.marginTop;

            return {top: top, left: left, height: height, width: width, marginLeft: marginLeft, marginTop: marginTop, transform: ''};
        }

        var Animate = {

            props: {
                duration: Number,
                animation: Boolean
            },

            data: {
                duration: 150,
                animation: 'slide'
            },

            methods: {

                animate: function(action, target) {
                    var this$1$1 = this;
                    if ( target === void 0 ) target = this.$el;


                    var name = this.animation;
                    var animationFn = name === 'fade'
                        ? fade
                        : name === 'delayed-fade'
                            ? function () {
                                var args = [], len = arguments.length;
                                while ( len-- ) args[ len ] = arguments[ len ];

                                return fade.apply(void 0, args.concat( [40] ));
                    }
                            : name
                                ? slide
                                : function () {
                                    action();
                                    return Promise$1.resolve();
                                };

                    return animationFn(action, target, this.duration)
                        .then(function () { return this$1$1.$update(target, 'resize'); }, noop);
                }

            }
        };

        var filter = {

            mixins: [Animate],

            args: 'target',

            props: {
                target: Boolean,
                selActive: Boolean
            },

            data: {
                target: null,
                selActive: false,
                attrItem: 'uk-filter-control',
                cls: 'uk-active',
                duration: 250
            },

            computed: {

                toggles: {

                    get: function(ref, $el) {
                        var attrItem = ref.attrItem;

                        return $$(("[" + attrItem + "],[data-" + attrItem + "]"), $el);
                    },

                    watch: function() {
                        var this$1$1 = this;


                        this.updateState();

                        if (this.selActive !== false) {
                            var actives = $$(this.selActive, this.$el);
                            this.toggles.forEach(function (el) { return toggleClass(el, this$1$1.cls, includes(actives, el)); });
                        }

                    },

                    immediate: true

                },

                children: {

                    get: function(ref, $el) {
                        var target = ref.target;

                        return $$((target + " > *"), $el);
                    },

                    watch: function(list, old) {
                        if (old && !isEqualList(list, old)) {
                            this.updateState();
                        }
                    },

                    immediate: true

                }

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ("[" + (this.attrItem) + "],[data-" + (this.attrItem) + "]");
                    },

                    handler: function(e) {

                        e.preventDefault();
                        this.apply(e.current);

                    }

                }

            ],

            methods: {

                apply: function(el) {
                    var prevState = this.getState();
                    var newState = mergeState(el, this.attrItem, this.getState());

                    if (!isEqualState(prevState, newState)) {
                        this.setState(newState);
                    }
                },

                getState: function() {
                    var this$1$1 = this;

                    return this.toggles
                        .filter(function (item) { return hasClass(item, this$1$1.cls); })
                        .reduce(function (state, el) { return mergeState(el, this$1$1.attrItem, state); }, {filter: {'': ''}, sort: []});
                },

                setState: function(state, animate) {
                    var this$1$1 = this;
                    if ( animate === void 0 ) animate = true;


                    state = assign({filter: {'': ''}, sort: []}, state);

                    trigger(this.$el, 'beforeFilter', [this, state]);

                    this.toggles.forEach(function (el) { return toggleClass(el, this$1$1.cls, !!matchFilter(el, this$1$1.attrItem, state)); });

                    Promise$1.all($$(this.target, this.$el).map(function (target) {
                        var filterFn = function () {
                            applyState(state, target, children(target));
                            this$1$1.$update(this$1$1.$el);
                        };
                        return animate ? this$1$1.animate(filterFn, target) : filterFn();
                    })).then(function () { return trigger(this$1$1.$el, 'afterFilter', [this$1$1]); });

                },

                updateState: function() {
                    var this$1$1 = this;

                    fastdom.write(function () { return this$1$1.setState(this$1$1.getState(), false); });
                }

            }

        };

        function getFilter(el, attr) {
            return parseOptions(data(el, attr), ['filter']);
        }

        function isEqualState(stateA, stateB) {
            return ['filter', 'sort'].every(function (prop) { return isEqual(stateA[prop], stateB[prop]); });
        }

        function applyState(state, target, children) {
            var selector = getSelector(state);

            children.forEach(function (el) { return css(el, 'display', selector && !matches(el, selector) ? 'none' : ''); });

            var ref = state.sort;
            var sort = ref[0];
            var order = ref[1];

            if (sort) {
                var sorted = sortItems(children, sort, order);
                if (!isEqual(sorted, children)) {
                    append(target, sorted);
                }
            }
        }

        function mergeState(el, attr, state) {

            var filterBy = getFilter(el, attr);
            var filter = filterBy.filter;
            var group = filterBy.group;
            var sort = filterBy.sort;
            var order = filterBy.order; if ( order === void 0 ) order = 'asc';

            if (filter || isUndefined(sort)) {

                if (group) {

                    if (filter) {
                        delete state.filter[''];
                        state.filter[group] = filter;
                    } else {
                        delete state.filter[group];

                        if (isEmpty(state.filter) || '' in state.filter) {
                            state.filter = {'': filter || ''};
                        }

                    }

                } else {
                    state.filter = {'': filter || ''};
                }

            }

            if (!isUndefined(sort)) {
                state.sort = [sort, order];
            }

            return state;
        }

        function matchFilter(el, attr, ref) {
            var stateFilter = ref.filter; if ( stateFilter === void 0 ) stateFilter = {'': ''};
            var ref_sort = ref.sort;
            var stateSort = ref_sort[0];
            var stateOrder = ref_sort[1];


            var ref$1 = getFilter(el, attr);
            var filter = ref$1.filter; if ( filter === void 0 ) filter = '';
            var group = ref$1.group; if ( group === void 0 ) group = '';
            var sort = ref$1.sort;
            var order = ref$1.order; if ( order === void 0 ) order = 'asc';

            return isUndefined(sort)
                ? group in stateFilter && filter === stateFilter[group]
                    || !filter && group && !(group in stateFilter) && !stateFilter['']
                : stateSort === sort && stateOrder === order;
        }

        function isEqualList(listA, listB) {
            return listA.length === listB.length
                && listA.every(function (el) { return ~listB.indexOf(el); });
        }

        function getSelector(ref) {
            var filter = ref.filter;

            var selector = '';
            each(filter, function (value) { return selector += value || ''; });
            return selector;
        }

        function sortItems(nodes, sort, order) {
            return assign([], nodes).sort(function (a, b) { return data(a, sort).localeCompare(data(b, sort), undefined, {numeric: true}) * (order === 'asc' || -1); });
        }

        var Animations$2 = {

            slide: {

                show: function(dir) {
                    return [
                        {transform: translate(dir * -100)},
                        {transform: translate()}
                    ];
                },

                percent: function(current) {
                    return translated(current);
                },

                translate: function(percent, dir) {
                    return [
                        {transform: translate(dir * -100 * percent)},
                        {transform: translate(dir * 100 * (1 - percent))}
                    ];
                }

            }

        };

        function translated(el) {
            return Math.abs(css(el, 'transform').split(',')[4] / el.offsetWidth) || 0;
        }

        function translate(value, unit) {
            if ( value === void 0 ) value = 0;
            if ( unit === void 0 ) unit = '%';

            value += value ? unit : '';
            return isIE ? ("translateX(" + value + ")") : ("translate3d(" + value + ", 0, 0)"); // currently, not translate3d in IE, translate3d within translate3d does not work while transitioning
        }

        function scale3d(value) {
            return ("scale3d(" + value + ", " + value + ", 1)");
        }

        var Animations$1 = assign({}, Animations$2, {

            fade: {

                show: function() {
                    return [
                        {opacity: 0},
                        {opacity: 1}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent},
                        {opacity: percent}
                    ];
                }

            },

            scale: {

                show: function() {
                    return [
                        {opacity: 0, transform: scale3d(1 - .2)},
                        {opacity: 1, transform: scale3d(1)}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent, transform: scale3d(1 - .2 * percent)},
                        {opacity: percent, transform: scale3d(1 - .2 + .2 * percent)}
                    ];
                }

            }

        });

        function Transitioner$1(prev, next, dir, ref) {
            var animation = ref.animation;
            var easing = ref.easing;


            var percent = animation.percent;
            var translate = animation.translate;
            var show = animation.show; if ( show === void 0 ) show = noop;
            var props = show(dir);
            var deferred = new Deferred();

            return {

                dir: dir,

                show: function(duration, percent, linear) {
                    var this$1$1 = this;
                    if ( percent === void 0 ) percent = 0;


                    var timing = linear ? 'linear' : easing;
                    duration -= Math.round(duration * clamp(percent, -1, 1));

                    this.translate(percent);

                    triggerUpdate$1(next, 'itemin', {percent: percent, duration: duration, timing: timing, dir: dir});
                    triggerUpdate$1(prev, 'itemout', {percent: 1 - percent, duration: duration, timing: timing, dir: dir});

                    Promise$1.all([
                        Transition.start(next, props[1], duration, timing),
                        Transition.start(prev, props[0], duration, timing)
                    ]).then(function () {
                        this$1$1.reset();
                        deferred.resolve();
                    }, noop);

                    return deferred.promise;
                },

                cancel: function() {
                    Transition.cancel([next, prev]);
                },

                reset: function() {
                    for (var prop in props[0]) {
                        css([next, prev], prop, '');
                    }
                },

                forward: function(duration, percent) {
                    if ( percent === void 0 ) percent = this.percent();

                    Transition.cancel([next, prev]);
                    return this.show(duration, percent, true);
                },

                translate: function(percent) {

                    this.reset();

                    var props = translate(percent, dir);
                    css(next, props[1]);
                    css(prev, props[0]);
                    triggerUpdate$1(next, 'itemtranslatein', {percent: percent, dir: dir});
                    triggerUpdate$1(prev, 'itemtranslateout', {percent: 1 - percent, dir: dir});

                },

                percent: function() {
                    return percent(prev || next, next, dir);
                },

                getDistance: function() {
                    return prev && prev.offsetWidth;
                }

            };

        }

        function triggerUpdate$1(el, type, data) {
            trigger(el, createEvent(type, false, false, data));
        }

        var SliderAutoplay = {

            props: {
                autoplay: Boolean,
                autoplayInterval: Number,
                pauseOnHover: Boolean
            },

            data: {
                autoplay: false,
                autoplayInterval: 7000,
                pauseOnHover: true
            },

            connected: function() {
                this.autoplay && this.startAutoplay();
            },

            disconnected: function() {
                this.stopAutoplay();
            },

            update: function() {
                attr(this.slides, 'tabindex', '-1');
            },

            events: [

                {

                    name: 'visibilitychange',

                    el: function() {
                        return document;
                    },

                    filter: function() {
                        return this.autoplay;
                    },

                    handler: function() {
                        if (document.hidden) {
                            this.stopAutoplay();
                        } else {
                            this.startAutoplay();
                        }
                    }

                }

            ],

            methods: {

                startAutoplay: function() {
                    var this$1$1 = this;


                    this.stopAutoplay();

                    this.interval = setInterval(
                        function () { return (!this$1$1.draggable || !$(':focus', this$1$1.$el))
                            && (!this$1$1.pauseOnHover || !matches(this$1$1.$el, ':hover'))
                            && !this$1$1.stack.length
                            && this$1$1.show('next'); },
                        this.autoplayInterval
                    );

                },

                stopAutoplay: function() {
                    this.interval && clearInterval(this.interval);
                }

            }

        };

        var SliderDrag = {

            props: {
                draggable: Boolean
            },

            data: {
                draggable: true,
                threshold: 10
            },

            created: function() {
                var this$1$1 = this;


                ['start', 'move', 'end'].forEach(function (key) {

                    var fn = this$1$1[key];
                    this$1$1[key] = function (e) {

                        var pos = getEventPos(e).x * (isRtl ? -1 : 1);

                        this$1$1.prevPos = pos !== this$1$1.pos ? this$1$1.pos : this$1$1.prevPos;
                        this$1$1.pos = pos;

                        fn(e);
                    };

                });

            },

            events: [

                {

                    name: pointerDown,

                    delegate: function() {
                        return this.selSlides;
                    },

                    handler: function(e) {

                        if (!this.draggable
                            || !isTouch(e) && hasTextNodesOnly(e.target)
                            || closest(e.target, selInput)
                            || e.button > 0
                            || this.length < 2
                        ) {
                            return;
                        }

                        this.start(e);
                    }

                },

                {
                    name: 'dragstart',

                    handler: function(e) {
                        e.preventDefault();
                    }
                }

            ],

            methods: {

                start: function() {

                    this.drag = this.pos;

                    if (this._transitioner) {

                        this.percent = this._transitioner.percent();
                        this.drag += this._transitioner.getDistance() * this.percent * this.dir;

                        this._transitioner.cancel();
                        this._transitioner.translate(this.percent);

                        this.dragging = true;

                        this.stack = [];

                    } else {
                        this.prevIndex = this.index;
                    }

                    on(document, pointerMove, this.move, {passive: false});

                    // 'input' event is triggered by video controls
                    on(document, (pointerUp + " " + pointerCancel + " input"), this.end, true);

                    css(this.list, 'userSelect', 'none');

                },

                move: function(e) {
                    var this$1$1 = this;


                    var distance = this.pos - this.drag;

                    if (distance === 0 || this.prevPos === this.pos || !this.dragging && Math.abs(distance) < this.threshold) {
                        return;
                    }

                    // prevent click event
                    css(this.list, 'pointerEvents', 'none');

                    e.cancelable && e.preventDefault();

                    this.dragging = true;
                    this.dir = (distance < 0 ? 1 : -1);

                    var ref = this;
                    var slides = ref.slides;
                    var ref$1 = this;
                    var prevIndex = ref$1.prevIndex;
                    var dis = Math.abs(distance);
                    var nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
                    var width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;

                    while (nextIndex !== prevIndex && dis > width) {

                        this.drag -= width * this.dir;

                        prevIndex = nextIndex;
                        dis -= width;
                        nextIndex = this.getIndex(prevIndex + this.dir, prevIndex);
                        width = this._getDistance(prevIndex, nextIndex) || slides[prevIndex].offsetWidth;

                    }

                    this.percent = dis / width;

                    var prev = slides[prevIndex];
                    var next = slides[nextIndex];
                    var changed = this.index !== nextIndex;
                    var edge = prevIndex === nextIndex;

                    var itemShown;

                    [this.index, this.prevIndex].filter(function (i) { return !includes([nextIndex, prevIndex], i); }).forEach(function (i) {
                        trigger(slides[i], 'itemhidden', [this$1$1]);

                        if (edge) {
                            itemShown = true;
                            this$1$1.prevIndex = prevIndex;
                        }

                    });

                    if (this.index === prevIndex && this.prevIndex !== prevIndex || itemShown) {
                        trigger(slides[this.index], 'itemshown', [this]);
                    }

                    if (changed) {
                        this.prevIndex = prevIndex;
                        this.index = nextIndex;

                        !edge && trigger(prev, 'beforeitemhide', [this]);
                        trigger(next, 'beforeitemshow', [this]);
                    }

                    this._transitioner = this._translate(Math.abs(this.percent), prev, !edge && next);

                    if (changed) {
                        !edge && trigger(prev, 'itemhide', [this]);
                        trigger(next, 'itemshow', [this]);
                    }

                },

                end: function() {

                    off(document, pointerMove, this.move, {passive: false});
                    off(document, (pointerUp + " " + pointerCancel + " input"), this.end, true);

                    if (this.dragging) {

                        this.dragging = null;

                        if (this.index === this.prevIndex) {
                            this.percent = 1 - this.percent;
                            this.dir *= -1;
                            this._show(false, this.index, true);
                            this._transitioner = null;
                        } else {

                            var dirChange = (isRtl ? this.dir * (isRtl ? 1 : -1) : this.dir) < 0 === this.prevPos > this.pos;
                            this.index = dirChange ? this.index : this.prevIndex;

                            if (dirChange) {
                                this.percent = 1 - this.percent;
                            }

                            this.show(this.dir > 0 && !dirChange || this.dir < 0 && dirChange ? 'next' : 'previous', true);
                        }

                    }

                    css(this.list, {userSelect: '', pointerEvents: ''});

                    this.drag
                        = this.percent
                        = null;

                }

            }

        };

        function hasTextNodesOnly(el) {
            return !el.children.length && el.childNodes.length;
        }

        var SliderNav = {

            data: {
                selNav: false
            },

            computed: {

                nav: function(ref, $el) {
                    var selNav = ref.selNav;

                    return $(selNav, $el);
                },

                selNavItem: function(ref) {
                    var attrItem = ref.attrItem;

                    return ("[" + attrItem + "],[data-" + attrItem + "]");
                },

                navItems: function(_, $el) {
                    return $$(this.selNavItem, $el);
                }

            },

            update: {

                write: function() {
                    var this$1$1 = this;


                    if (this.nav && this.length !== this.nav.children.length) {
                        html(this.nav, this.slides.map(function (_, i) { return ("<li " + (this$1$1.attrItem) + "=\"" + i + "\"><a href></a></li>"); }).join(''));
                    }

                    this.navItems.concat(this.nav).forEach(function (el) { return el && (el.hidden = !this$1$1.maxIndex); });

                    this.updateNav();

                },

                events: ['resize']

            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return this.selNavItem;
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(data(e.current, this.attrItem));
                    }

                },

                {

                    name: 'itemshow',
                    handler: 'updateNav'

                }

            ],

            methods: {

                updateNav: function() {
                    var this$1$1 = this;


                    var i = this.getValidIndex();
                    this.navItems.forEach(function (el) {

                        var cmd = data(el, this$1$1.attrItem);

                        toggleClass(el, this$1$1.clsActive, toNumber(cmd) === i);
                        toggleClass(el, 'uk-invisible', this$1$1.finite && (cmd === 'previous' && i === 0 || cmd === 'next' && i >= this$1$1.maxIndex));
                    });

                }

            }

        };

        var Slider = {

            mixins: [SliderAutoplay, SliderDrag, SliderNav],

            props: {
                clsActivated: Boolean,
                easing: String,
                index: Number,
                finite: Boolean,
                velocity: Number,
                selSlides: String
            },

            data: function () { return ({
                easing: 'ease',
                finite: false,
                velocity: 1,
                index: 0,
                prevIndex: -1,
                stack: [],
                percent: 0,
                clsActive: 'uk-active',
                clsActivated: false,
                Transitioner: false,
                transitionOptions: {}
            }); },

            connected: function() {
                this.prevIndex = -1;
                this.index = this.getValidIndex(this.$props.index);
                this.stack = [];
            },

            disconnected: function() {
                removeClass(this.slides, this.clsActive);
            },

            computed: {

                duration: function(ref, $el) {
                    var velocity = ref.velocity;

                    return speedUp($el.offsetWidth / velocity);
                },

                list: function(ref, $el) {
                    var selList = ref.selList;

                    return $(selList, $el);
                },

                maxIndex: function() {
                    return this.length - 1;
                },

                selSlides: function(ref) {
                    var selList = ref.selList;
                    var selSlides = ref.selSlides;

                    return (selList + " " + (selSlides || '> *'));
                },

                slides: {

                    get: function() {
                        return $$(this.selSlides, this.$el);
                    },

                    watch: function() {
                        this.$reset();
                    }

                },

                length: function() {
                    return this.slides.length;
                }

            },

            events: {

                itemshown: function() {
                    this.$update(this.list);
                }

            },

            methods: {

                show: function(index, force) {
                    var this$1$1 = this;
                    if ( force === void 0 ) force = false;


                    if (this.dragging || !this.length) {
                        return;
                    }

                    var ref = this;
                    var stack = ref.stack;
                    var queueIndex = force ? 0 : stack.length;
                    var reset = function () {
                        stack.splice(queueIndex, 1);

                        if (stack.length) {
                            this$1$1.show(stack.shift(), true);
                        }
                    };

                    stack[force ? 'unshift' : 'push'](index);

                    if (!force && stack.length > 1) {

                        if (stack.length === 2) {
                            this._transitioner.forward(Math.min(this.duration, 200));
                        }

                        return;
                    }

                    var prevIndex = this.getIndex(this.index);
                    var prev = hasClass(this.slides, this.clsActive) && this.slides[prevIndex];
                    var nextIndex = this.getIndex(index, this.index);
                    var next = this.slides[nextIndex];

                    if (prev === next) {
                        reset();
                        return;
                    }

                    this.dir = getDirection(index, prevIndex);
                    this.prevIndex = prevIndex;
                    this.index = nextIndex;

                    if (prev && !trigger(prev, 'beforeitemhide', [this])
                        || !trigger(next, 'beforeitemshow', [this, prev])
                    ) {
                        this.index = this.prevIndex;
                        reset();
                        return;
                    }

                    var promise = this._show(prev, next, force).then(function () {

                        prev && trigger(prev, 'itemhidden', [this$1$1]);
                        trigger(next, 'itemshown', [this$1$1]);

                        return new Promise$1(function (resolve) {
                            fastdom.write(function () {
                                stack.shift();
                                if (stack.length) {
                                    this$1$1.show(stack.shift(), true);
                                } else {
                                    this$1$1._transitioner = null;
                                }
                                resolve();
                            });
                        });

                    });

                    prev && trigger(prev, 'itemhide', [this]);
                    trigger(next, 'itemshow', [this]);

                    return promise;

                },

                getIndex: function(index, prev) {
                    if ( index === void 0 ) index = this.index;
                    if ( prev === void 0 ) prev = this.index;

                    return clamp(getIndex(index, this.slides, prev, this.finite), 0, this.maxIndex);
                },

                getValidIndex: function(index, prevIndex) {
                    if ( index === void 0 ) index = this.index;
                    if ( prevIndex === void 0 ) prevIndex = this.prevIndex;

                    return this.getIndex(index, prevIndex);
                },

                _show: function(prev, next, force) {

                    this._transitioner = this._getTransitioner(
                        prev,
                        next,
                        this.dir,
                        assign({
                            easing: force
                                ? next.offsetWidth < 600
                                    ? 'cubic-bezier(0.25, 0.46, 0.45, 0.94)' /* easeOutQuad */
                                    : 'cubic-bezier(0.165, 0.84, 0.44, 1)' /* easeOutQuart */
                                : this.easing
                        }, this.transitionOptions)
                    );

                    if (!force && !prev) {
                        this._translate(1);
                        return Promise$1.resolve();
                    }

                    var ref = this.stack;
                    var length = ref.length;
                    return this._transitioner[length > 1 ? 'forward' : 'show'](length > 1 ? Math.min(this.duration, 75 + 75 / (length - 1)) : this.duration, this.percent);

                },

                _getDistance: function(prev, next) {
                    return this._getTransitioner(prev, prev !== next && next).getDistance();
                },

                _translate: function(percent, prev, next) {
                    if ( prev === void 0 ) prev = this.prevIndex;
                    if ( next === void 0 ) next = this.index;

                    var transitioner = this._getTransitioner(prev !== next ? prev : false, next);
                    transitioner.translate(percent);
                    return transitioner;
                },

                _getTransitioner: function(prev, next, dir, options) {
                    if ( prev === void 0 ) prev = this.prevIndex;
                    if ( next === void 0 ) next = this.index;
                    if ( dir === void 0 ) dir = this.dir || 1;
                    if ( options === void 0 ) options = this.transitionOptions;

                    return new this.Transitioner(
                        isNumber(prev) ? this.slides[prev] : prev,
                        isNumber(next) ? this.slides[next] : next,
                        dir * (isRtl ? -1 : 1),
                        options
                    );
                }

            }

        };

        function getDirection(index, prevIndex) {
            return index === 'next'
                ? 1
                : index === 'previous'
                    ? -1
                    : index < prevIndex
                        ? -1
                        : 1;
        }

        function speedUp(x) {
            return .5 * x + 300; // parabola through (400,500; 600,600; 1800,1200)
        }

        var Slideshow = {

            mixins: [Slider],

            props: {
                animation: String
            },

            data: {
                animation: 'slide',
                clsActivated: 'uk-transition-active',
                Animations: Animations$2,
                Transitioner: Transitioner$1
            },

            computed: {

                animation: function(ref) {
                    var animation = ref.animation;
                    var Animations = ref.Animations;

                    return assign(Animations[animation] || Animations.slide, {name: animation});
                },

                transitionOptions: function() {
                    return {animation: this.animation};
                }

            },

            events: {

                'itemshow itemhide itemshown itemhidden': function(ref) {
                    var target = ref.target;

                    this.$update(target);
                },

                beforeitemshow: function(ref) {
                    var target = ref.target;

                    addClass(target, this.clsActive);
                },

                itemshown: function(ref) {
                    var target = ref.target;

                    addClass(target, this.clsActivated);
                },

                itemhidden: function(ref) {
                    var target = ref.target;

                    removeClass(target, this.clsActive, this.clsActivated);
                }

            }

        };

        var LightboxPanel = {

            mixins: [Container, Modal, Togglable, Slideshow],

            functional: true,

            props: {
                delayControls: Number,
                preload: Number,
                videoAutoplay: Boolean,
                template: String
            },

            data: function () { return ({
                preload: 1,
                videoAutoplay: false,
                delayControls: 3000,
                items: [],
                cls: 'uk-open',
                clsPage: 'uk-lightbox-page',
                selList: '.uk-lightbox-items',
                attrItem: 'uk-lightbox-item',
                selClose: '.uk-close-large',
                selCaption: '.uk-lightbox-caption',
                pauseOnHover: false,
                velocity: 2,
                Animations: Animations$1,
                template: "<div class=\"uk-lightbox uk-overflow-hidden\"> <ul class=\"uk-lightbox-items\"></ul> <div class=\"uk-lightbox-toolbar uk-position-top uk-text-right uk-transition-slide-top uk-transition-opaque\"> <button class=\"uk-lightbox-toolbar-icon uk-close-large\" type=\"button\" uk-close></button> </div> <a class=\"uk-lightbox-button uk-position-center-left uk-position-medium uk-transition-fade\" href uk-slidenav-previous uk-lightbox-item=\"previous\"></a> <a class=\"uk-lightbox-button uk-position-center-right uk-position-medium uk-transition-fade\" href uk-slidenav-next uk-lightbox-item=\"next\"></a> <div class=\"uk-lightbox-toolbar uk-lightbox-caption uk-position-bottom uk-text-center uk-transition-slide-bottom uk-transition-opaque\"></div> </div>"
            }); },

            created: function() {

                var $el = $(this.template);
                var list = $(this.selList, $el);
                this.items.forEach(function () { return append(list, '<li>'); });

                this.$mount(append(this.container, $el));

            },

            computed: {

                caption: function(ref, $el) {
                    var selCaption = ref.selCaption;

                    return $(selCaption, $el);
                }

            },

            events: [

                {

                    name: (pointerMove + " " + pointerDown + " keydown"),

                    handler: 'showControls'

                },

                {

                    name: 'click',

                    self: true,

                    delegate: function() {
                        return this.selSlides;
                    },

                    handler: function(e) {

                        if (e.defaultPrevented) {
                            return;
                        }

                        this.hide();
                    }

                },

                {

                    name: 'shown',

                    self: true,

                    handler: function() {
                        this.showControls();
                    }

                },

                {

                    name: 'hide',

                    self: true,

                    handler: function() {

                        this.hideControls();

                        removeClass(this.slides, this.clsActive);
                        Transition.stop(this.slides);

                    }
                },

                {

                    name: 'hidden',

                    self: true,

                    handler: function() {
                        this.$destroy(true);
                    }

                },

                {

                    name: 'keyup',

                    el: function() {
                        return document;
                    },

                    handler: function(e) {

                        if (!this.isToggled(this.$el) || !this.draggable) {
                            return;
                        }

                        switch (e.keyCode) {
                            case 37:
                                this.show('previous');
                                break;
                            case 39:
                                this.show('next');
                                break;
                        }
                    }
                },

                {

                    name: 'beforeitemshow',

                    handler: function(e) {

                        if (this.isToggled()) {
                            return;
                        }

                        this.draggable = false;

                        e.preventDefault();

                        this.toggleElement(this.$el, true, false);

                        this.animation = Animations$1['scale'];
                        removeClass(e.target, this.clsActive);
                        this.stack.splice(1, 0, this.index);

                    }

                },

                {

                    name: 'itemshow',

                    handler: function() {

                        html(this.caption, this.getItem().caption || '');

                        for (var j = -this.preload; j <= this.preload; j++) {
                            this.loadItem(this.index + j);
                        }

                    }

                },

                {

                    name: 'itemshown',

                    handler: function() {
                        this.draggable = this.$props.draggable;
                    }

                },

                {

                    name: 'itemload',

                    handler: function(_, item) {
                        var this$1$1 = this;


                        var src = item.source;
                        var type = item.type;
                        var alt = item.alt; if ( alt === void 0 ) alt = '';
                        var poster = item.poster;
                        var attrs = item.attrs; if ( attrs === void 0 ) attrs = {};

                        this.setItem(item, '<span uk-spinner></span>');

                        if (!src) {
                            return;
                        }

                        var matches;
                        var iframeAttrs = {
                            frameborder: '0',
                            allow: 'autoplay',
                            allowfullscreen: '',
                            style: 'max-width: 100%; box-sizing: border-box;',
                            'uk-responsive': '',
                            'uk-video': ("" + (this.videoAutoplay))
                        };

                        // Image
                        if (type === 'image' || src.match(/\.(avif|jpe?g|a?png|gif|svg|webp)($|\?)/i)) {

                            getImage(src, attrs.srcset, attrs.size).then(
                                function (ref) {
                                    var width = ref.width;
                                    var height = ref.height;

                                    return this$1$1.setItem(item, createEl('img', assign({src: src, width: width, height: height, alt: alt}, attrs)));
                            },
                                function () { return this$1$1.setError(item); }
                            );

                        // Video
                        } else if (type === 'video' || src.match(/\.(mp4|webm|ogv)($|\?)/i)) {

                            var video = createEl('video', assign({
                                src: src,
                                poster: poster,
                                controls: '',
                                playsinline: '',
                                'uk-video': ("" + (this.videoAutoplay))
                            }, attrs));

                            on(video, 'loadedmetadata', function () {
                                attr(video, {width: video.videoWidth, height: video.videoHeight});
                                this$1$1.setItem(item, video);
                            });
                            on(video, 'error', function () { return this$1$1.setError(item); });

                        // Iframe
                        } else if (type === 'iframe' || src.match(/\.(html|php)($|\?)/i)) {

                            this.setItem(item, createEl('iframe', assign({
                                src: src,
                                frameborder: '0',
                                allowfullscreen: '',
                                class: 'uk-lightbox-iframe'
                            }, attrs)));

                        // YouTube
                        } else if ((matches = src.match(/\/\/(?:.*?youtube(-nocookie)?\..*?[?&]v=|youtu\.be\/)([\w-]{11})[&?]?(.*)?/))) {

                            this.setItem(item, createEl('iframe', assign({
                                src: ("https://www.youtube" + (matches[1] || '') + ".com/embed/" + (matches[2]) + (matches[3] ? ("?" + (matches[3])) : '')),
                                width: 1920,
                                height: 1080
                            }, iframeAttrs, attrs)));

                        // Vimeo
                        } else if ((matches = src.match(/\/\/.*?vimeo\.[a-z]+\/(\d+)[&?]?(.*)?/))) {

                            ajax(("https://vimeo.com/api/oembed.json?maxwidth=1920&url=" + (encodeURI(src))), {
                                responseType: 'json',
                                withCredentials: false
                            }).then(
                                function (ref) {
                                    var ref_response = ref.response;
                                    var height = ref_response.height;
                                    var width = ref_response.width;

                                    return this$1$1.setItem(item, createEl('iframe', assign({
                                    src: ("https://player.vimeo.com/video/" + (matches[1]) + (matches[2] ? ("?" + (matches[2])) : '')),
                                    width: width,
                                    height: height
                                }, iframeAttrs, attrs)));
                            },
                                function () { return this$1$1.setError(item); }
                            );

                        }

                    }

                }

            ],

            methods: {

                loadItem: function(index) {
                    if ( index === void 0 ) index = this.index;


                    var item = this.getItem(index);

                    if (!this.getSlide(item).childElementCount) {
                        trigger(this.$el, 'itemload', [item]);
                    }
                },

                getItem: function(index) {
                    if ( index === void 0 ) index = this.index;

                    return this.items[getIndex(index, this.slides)];
                },

                setItem: function(item, content) {
                    trigger(this.$el, 'itemloaded', [this, html(this.getSlide(item), content) ]);
                },

                getSlide: function(item) {
                    return this.slides[this.items.indexOf(item)];
                },

                setError: function(item) {
                    this.setItem(item, '<span uk-icon="icon: bolt; ratio: 2"></span>');
                },

                showControls: function() {

                    clearTimeout(this.controlsTimer);
                    this.controlsTimer = setTimeout(this.hideControls, this.delayControls);

                    addClass(this.$el, 'uk-active', 'uk-transition-active');

                },

                hideControls: function() {
                    removeClass(this.$el, 'uk-active', 'uk-transition-active');
                }

            }

        };

        function createEl(tag, attrs) {
            var el = fragment(("<" + tag + ">"));
            attr(el, attrs);
            return el;
        }

        var lightbox = {

            install: install$1,

            props: {toggle: String},

            data: {toggle: 'a'},

            computed: {

                toggles: {

                    get: function(ref, $el) {
                        var toggle = ref.toggle;

                        return $$(toggle, $el);
                    },

                    watch: function() {
                        this.hide();
                    }

                }

            },

            disconnected: function() {
                this.hide();
            },

            events: [

                {

                    name: 'click',

                    delegate: function() {
                        return ((this.toggle) + ":not(.uk-disabled)");
                    },

                    handler: function(e) {
                        e.preventDefault();
                        this.show(e.current);
                    }

                }

            ],

            methods: {

                show: function(index) {
                    var this$1$1 = this;


                    var items = uniqueBy(this.toggles.map(toItem), 'source');

                    if (isElement(index)) {
                        var ref = toItem(index);
                        var source = ref.source;
                        index = findIndex(items, function (ref) {
                            var src = ref.source;

                            return source === src;
                        });
                    }

                    this.panel = this.panel || this.$create('lightboxPanel', assign({}, this.$props, {items: items}));

                    on(this.panel.$el, 'hidden', function () { return this$1$1.panel = false; });

                    return this.panel.show(index);

                },

                hide: function() {

                    return this.panel && this.panel.hide();

                }

            }

        };

        function install$1(UIkit, Lightbox) {

            if (!UIkit.lightboxPanel) {
                UIkit.component('lightboxPanel', LightboxPanel);
            }

            assign(
                Lightbox.props,
                UIkit.component('lightboxPanel').options.props
            );

        }

        function toItem(el) {

            var item = {};

            ['href', 'caption', 'type', 'poster', 'alt', 'attrs'].forEach(function (attr) {
                item[attr === 'href' ? 'source' : attr] = data(el, attr);
            });

            item.attrs = parseOptions(item.attrs);

            return item;
        }

        var obj$1;

        var notification = {

            mixins: [Container],

            functional: true,

            args: ['message', 'status'],

            data: {
                message: '',
                status: '',
                timeout: 5000,
                group: null,
                pos: 'top-center',
                clsContainer: 'uk-notification',
                clsClose: 'uk-notification-close',
                clsMsg: 'uk-notification-message'
            },

            install: install,

            computed: {

                marginProp: function(ref) {
                    var pos = ref.pos;

                    return ("margin" + (startsWith(pos, 'top') ? 'Top' : 'Bottom'));
                },

                startProps: function() {
                    var obj;

                    return ( obj = {opacity: 0}, obj[this.marginProp] = -this.$el.offsetHeight, obj );
                }

            },

            created: function() {

                var container = $(("." + (this.clsContainer) + "-" + (this.pos)), this.container)
                    || append(this.container, ("<div class=\"" + (this.clsContainer) + " " + (this.clsContainer) + "-" + (this.pos) + "\" style=\"display: block\"></div>"));

                this.$mount(append(container,
                    ("<div class=\"" + (this.clsMsg) + (this.status ? (" " + (this.clsMsg) + "-" + (this.status)) : '') + "\"> <a href class=\"" + (this.clsClose) + "\" data-uk-close></a> <div>" + (this.message) + "</div> </div>")
                ));

            },

            connected: function() {
                var this$1$1 = this;
                var obj;


                var margin = toFloat(css(this.$el, this.marginProp));
                Transition.start(
                    css(this.$el, this.startProps),
                    ( obj = {opacity: 1}, obj[this.marginProp] = margin, obj )
                ).then(function () {
                    if (this$1$1.timeout) {
                        this$1$1.timer = setTimeout(this$1$1.close, this$1$1.timeout);
                    }
                });

            },

            events: ( obj$1 = {

                click: function(e) {
                    if (closest(e.target, 'a[href="#"],a[href=""]')) {
                        e.preventDefault();
                    }
                    this.close();
                }

            }, obj$1[pointerEnter] = function () {
                    if (this.timer) {
                        clearTimeout(this.timer);
                    }
                }, obj$1[pointerLeave] = function () {
                    if (this.timeout) {
                        this.timer = setTimeout(this.close, this.timeout);
                    }
                }, obj$1 ),

            methods: {

                close: function(immediate) {
                    var this$1$1 = this;


                    var removeFn = function (el) {

                        var container = parent(el);

                        trigger(el, 'close', [this$1$1]);
                        remove$1(el);

                        if (container && !container.hasChildNodes()) {
                            remove$1(container);
                        }

                    };

                    if (this.timer) {
                        clearTimeout(this.timer);
                    }

                    if (immediate) {
                        removeFn(this.$el);
                    } else {
                        Transition.start(this.$el, this.startProps).then(removeFn);
                    }
                }

            }

        };

        function install(UIkit) {
            UIkit.notification.closeAll = function (group, immediate) {
                apply$1(document.body, function (el) {
                    var notification = UIkit.getComponent(el, 'notification');
                    if (notification && (!group || group === notification.group)) {
                        notification.close(immediate);
                    }
                });
            };
        }

        var props = ['x', 'y', 'bgx', 'bgy', 'rotate', 'scale', 'color', 'backgroundColor', 'borderColor', 'opacity', 'blur', 'hue', 'grayscale', 'invert', 'saturate', 'sepia', 'fopacity', 'stroke'];

        var Parallax = {

            mixins: [Media],

            props: props.reduce(function (props, prop) {
                props[prop] = 'list';
                return props;
            }, {}),

            data: props.reduce(function (data, prop) {
                data[prop] = undefined;
                return data;
            }, {}),

            computed: {

                props: function(properties, $el) {
                    var this$1$1 = this;


                    return props.reduce(function (props, prop) {

                        if (isUndefined(properties[prop])) {
                            return props;
                        }

                        var isColor = prop.match(/color/i);
                        var isCssProp = isColor || prop === 'opacity';

                        var pos, bgPos, diff;
                        var steps = properties[prop].slice();

                        if (isCssProp) {
                            css($el, prop, '');
                        }

                        if (steps.length < 2) {
                            steps.unshift((prop === 'scale'
                                ? 1
                                : isCssProp
                                    ? css($el, prop)
                                    : 0) || 0);
                        }

                        var unit = getUnit(steps);

                        if (isColor) {

                            var ref = $el.style;
                            var color = ref.color;
                            steps = steps.map(function (step) { return parseColor($el, step); });
                            $el.style.color = color;

                        } else if (startsWith(prop, 'bg')) {

                            var attr = prop === 'bgy' ? 'height' : 'width';
                            steps = steps.map(function (step) { return toPx(step, attr, this$1$1.$el); });

                            css($el, ("background-position-" + (prop[2])), '');
                            bgPos = css($el, 'backgroundPosition').split(' ')[prop[2] === 'x' ? 0 : 1]; // IE 11 can't read background-position-[x|y]

                            if (this$1$1.covers) {

                                var min = Math.min.apply(Math, steps);
                                var max = Math.max.apply(Math, steps);
                                var down = steps.indexOf(min) < steps.indexOf(max);

                                diff = max - min;

                                steps = steps.map(function (step) { return step - (down ? min : max); });
                                pos = (down ? -diff : 0) + "px";

                            } else {

                                pos = bgPos;

                            }

                        } else {

                            steps = steps.map(toFloat);

                        }

                        if (prop === 'stroke') {

                            if (!steps.some(function (step) { return step; })) {
                                return props;
                            }

                            var length = getMaxPathLength(this$1$1.$el);
                            css($el, 'strokeDasharray', length);

                            if (unit === '%') {
                                steps = steps.map(function (step) { return step * length / 100; });
                            }

                            steps = steps.reverse();

                            prop = 'strokeDashoffset';
                        }

                        props[prop] = {steps: steps, unit: unit, pos: pos, bgPos: bgPos, diff: diff};

                        return props;

                    }, {});

                },

                bgProps: function() {
                    var this$1$1 = this;

                    return ['bgx', 'bgy'].filter(function (bg) { return bg in this$1$1.props; });
                },

                covers: function(_, $el) {
                    return covers($el);
                }

            },

            disconnected: function() {
                delete this._image;
            },

            update: {

                read: function(data) {
                    var this$1$1 = this;


                    if (!this.matchMedia) {
                        return;
                    }

                    if (!data.image && this.covers && this.bgProps.length) {
                        var src = css(this.$el, 'backgroundImage').replace(/^none|url\(["']?(.+?)["']?\)$/, '$1');

                        if (src) {
                            var img = new Image();
                            img.src = src;
                            data.image = img;

                            if (!img.naturalWidth) {
                                img.onload = function () { return this$1$1.$update(); };
                            }
                        }

                    }

                    var image = data.image;

                    if (!image || !image.naturalWidth) {
                        return;
                    }

                    var dimEl = {
                        width: this.$el.offsetWidth,
                        height: this.$el.offsetHeight
                    };
                    var dimImage = {
                        width: image.naturalWidth,
                        height: image.naturalHeight
                    };

                    var dim = Dimensions.cover(dimImage, dimEl);

                    this.bgProps.forEach(function (prop) {

                        var ref = this$1$1.props[prop];
                        var diff = ref.diff;
                        var bgPos = ref.bgPos;
                        var steps = ref.steps;
                        var attr = prop === 'bgy' ? 'height' : 'width';
                        var span = dim[attr] - dimEl[attr];

                        if (span < diff) {
                            dimEl[attr] = dim[attr] + diff - span;
                        } else if (span > diff) {

                            var posPercentage = dimEl[attr] / toPx(bgPos, attr, this$1$1.$el);

                            if (posPercentage) {
                                this$1$1.props[prop].steps = steps.map(function (step) { return step - (span - diff) / posPercentage; });
                            }
                        }

                        dim = Dimensions.cover(dimImage, dimEl);
                    });

                    data.dim = dim;
                },

                write: function(ref) {
                    var dim = ref.dim;


                    if (!this.matchMedia) {
                        css(this.$el, {backgroundSize: '', backgroundRepeat: ''});
                        return;
                    }

                    dim && css(this.$el, {
                        backgroundSize: ((dim.width) + "px " + (dim.height) + "px"),
                        backgroundRepeat: 'no-repeat'
                    });

                },

                events: ['resize']

            },

            methods: {

                reset: function() {
                    var this$1$1 = this;

                    each(this.getCss(0), function (_, prop) { return css(this$1$1.$el, prop, ''); });
                },

                getCss: function(percent) {

                    var ref = this;
                    var props = ref.props;
                    return Object.keys(props).reduce(function (css, prop) {

                        var ref = props[prop];
                        var steps = ref.steps;
                        var unit = ref.unit;
                        var pos = ref.pos;
                        var value = getValue(steps, percent);

                        switch (prop) {

                            // transforms
                            case 'x':
                            case 'y': {
                                unit = unit || 'px';
                                css.transform += " translate" + (ucfirst(prop)) + "(" + (toFloat(value).toFixed(unit === 'px' ? 0 : 2)) + unit + ")";
                                break;
                            }
                            case 'rotate':
                                unit = unit || 'deg';
                                css.transform += " rotate(" + (value + unit) + ")";
                                break;
                            case 'scale':
                                css.transform += " scale(" + value + ")";
                                break;

                            // bg image
                            case 'bgy':
                            case 'bgx':
                                css[("background-position-" + (prop[2]))] = "calc(" + pos + " + " + value + "px)";
                                break;

                            // color
                            case 'color':
                            case 'backgroundColor':
                            case 'borderColor': {

                                var ref$1 = getStep(steps, percent);
                                var start = ref$1[0];
                                var end = ref$1[1];
                                var p = ref$1[2];

                                css[prop] = "rgba(" + (start.map(function (value, i) {
                                        value += p * (end[i] - value);
                                        return i === 3 ? toFloat(value) : parseInt(value, 10);
                                    }).join(',')) + ")";
                                break;
                            }
                            // CSS Filter
                            case 'blur':
                                unit = unit || 'px';
                                css.filter += " blur(" + (value + unit) + ")";
                                break;
                            case 'hue':
                                unit = unit || 'deg';
                                css.filter += " hue-rotate(" + (value + unit) + ")";
                                break;
                            case 'fopacity':
                                unit = unit || '%';
                                css.filter += " opacity(" + (value + unit) + ")";
                                break;
                            case 'grayscale':
                            case 'invert':
                            case 'saturate':
                            case 'sepia':
                                unit = unit || '%';
                                css.filter += " " + prop + "(" + (value + unit) + ")";
                                break;
                            default:
                                css[prop] = value;
                        }

                        return css;

                    }, {transform: '', filter: ''});

                }

            }

        };

        function parseColor(el, color) {
            return css(css(el, 'color', color), 'color')
                .split(/[(),]/g)
                .slice(1, -1)
                .concat(1)
                .slice(0, 4)
                .map(toFloat);
        }

        function getStep(steps, percent) {
            var count = steps.length - 1;
            var index = Math.min(Math.floor(count * percent), count - 1);
            var step = steps.slice(index, index + 2);

            step.push(percent === 1 ? 1 : percent % (1 / count) * count);

            return step;
        }

        function getValue(steps, percent, digits) {
            if ( digits === void 0 ) digits = 2;

            var ref = getStep(steps, percent);
            var start = ref[0];
            var end = ref[1];
            var p = ref[2];
            return (isNumber(start)
                ? start + Math.abs(start - end) * p * (start < end ? 1 : -1)
                : +end
            ).toFixed(digits);
        }

        function getUnit(steps) {
            return steps.reduce(function (unit, step) { return isString(step) && step.replace(/-|\d/g, '').trim() || unit; }, '');
        }

        function covers(el) {
            var ref = el.style;
            var backgroundSize = ref.backgroundSize;
            var covers = css(css(el, 'backgroundSize', ''), 'backgroundSize') === 'cover';
            el.style.backgroundSize = backgroundSize;
            return covers;
        }

        var parallax = {

            mixins: [Parallax],

            props: {
                target: String,
                viewport: Number,
                easing: Number
            },

            data: {
                target: false,
                viewport: 1,
                easing: 1
            },

            computed: {

                target: function(ref, $el) {
                    var target = ref.target;

                    return getOffsetElement(target && query(target, $el) || $el);
                }

            },

            update: {

                read: function(ref, types) {
                    var percent = ref.percent;


                    if (!types.has('scroll')) {
                        percent = false;
                    }

                    if (!this.matchMedia) {
                        return;
                    }

                    var prev = percent;
                    percent = ease(scrolledOver(this.target) / (this.viewport || 1), this.easing);

                    return {
                        percent: percent,
                        style: prev !== percent ? this.getCss(percent) : false
                    };
                },

                write: function(ref) {
                    var style = ref.style;


                    if (!this.matchMedia) {
                        this.reset();
                        return;
                    }

                    style && css(this.$el, style);

                },

                events: ['scroll', 'resize']
            }

        };

        function ease(percent, easing) {
            return clamp(percent * (1 - (easing - easing * percent)));
        }

        // SVG elements do not inherit from HTMLElement
        function getOffsetElement(el) {
            return el
                ? 'offsetTop' in el
                    ? el
                    : getOffsetElement(parent(el))
                : document.body;
        }

        var SliderReactive = {

            update: {

                write: function() {

                    if (this.stack.length || this.dragging) {
                        return;
                    }

                    var index = this.getValidIndex(this.index);

                    if (!~this.prevIndex || this.index !== index) {
                        this.show(index);
                    }

                },

                events: ['resize']

            }

        };

        function Transitioner (prev, next, dir, ref) {
            var center = ref.center;
            var easing = ref.easing;
            var list = ref.list;


            var deferred = new Deferred();

            var from = prev
                ? getLeft(prev, list, center)
                : getLeft(next, list, center) + dimensions(next).width * dir;
            var to = next
                ? getLeft(next, list, center)
                : from + dimensions(prev).width * dir * (isRtl ? -1 : 1);

            return {

                dir: dir,

                show: function(duration, percent, linear) {
                    if ( percent === void 0 ) percent = 0;


                    var timing = linear ? 'linear' : easing;
                    duration -= Math.round(duration * clamp(percent, -1, 1));

                    this.translate(percent);

                    percent = prev ? percent : clamp(percent, 0, 1);
                    triggerUpdate(this.getItemIn(), 'itemin', {percent: percent, duration: duration, timing: timing, dir: dir});
                    prev && triggerUpdate(this.getItemIn(true), 'itemout', {percent: 1 - percent, duration: duration, timing: timing, dir: dir});

                    Transition
                        .start(list, {transform: translate(-to * (isRtl ? -1 : 1), 'px')}, duration, timing)
                        .then(deferred.resolve, noop);

                    return deferred.promise;

                },

                cancel: function() {
                    Transition.cancel(list);
                },

                reset: function() {
                    css(list, 'transform', '');
                },

                forward: function(duration, percent) {
                    if ( percent === void 0 ) percent = this.percent();

                    Transition.cancel(list);
                    return this.show(duration, percent, true);
                },

                translate: function(percent) {

                    var distance = this.getDistance() * dir * (isRtl ? -1 : 1);

                    css(list, 'transform', translate(clamp(
                        -to + (distance - distance * percent),
                        -getWidth(list),
                        dimensions(list).width
                    ) * (isRtl ? -1 : 1), 'px'));

                    var actives = this.getActives();
                    var itemIn = this.getItemIn();
                    var itemOut = this.getItemIn(true);

                    percent = prev ? clamp(percent, -1, 1) : 0;

                    children(list).forEach(function (slide) {
                        var isActive = includes(actives, slide);
                        var isIn = slide === itemIn;
                        var isOut = slide === itemOut;
                        var translateIn = isIn || !isOut && (isActive || dir * (isRtl ? -1 : 1) === -1 ^ getElLeft(slide, list) > getElLeft(prev || next));

                        triggerUpdate(slide, ("itemtranslate" + (translateIn ? 'in' : 'out')), {
                            dir: dir,
                            percent: isOut
                                ? 1 - percent
                                : isIn
                                    ? percent
                                    : isActive
                                        ? 1
                                        : 0
                        });
                    });

                },

                percent: function() {
                    return Math.abs((css(list, 'transform').split(',')[4] * (isRtl ? -1 : 1) + from) / (to - from));
                },

                getDistance: function() {
                    return Math.abs(to - from);
                },

                getItemIn: function(out) {
                    if ( out === void 0 ) out = false;


                    var actives = this.getActives();
                    var nextActives = inView(list, getLeft(next || prev, list, center));

                    if (out) {
                        var temp = actives;
                        actives = nextActives;
                        nextActives = temp;
                    }

                    return nextActives[findIndex(nextActives, function (el) { return !includes(actives, el); })];

                },

                getActives: function() {
                    return inView(list, getLeft(prev || next, list, center));
                }

            };

        }

        function getLeft(el, list, center) {

            var left = getElLeft(el, list);

            return center
                ? left - centerEl(el, list)
                : Math.min(left, getMax(list));

        }

        function getMax(list) {
            return Math.max(0, getWidth(list) - dimensions(list).width);
        }

        function getWidth(list) {
            return children(list).reduce(function (right, el) { return dimensions(el).width + right; }, 0);
        }

        function centerEl(el, list) {
            return dimensions(list).width / 2 - dimensions(el).width / 2;
        }

        function getElLeft(el, list) {
            return el && (position(el).left + (isRtl ? dimensions(el).width - dimensions(list).width : 0)) * (isRtl ? -1 : 1) || 0;
        }

        function inView(list, listLeft) {

            listLeft -= 1;
            var listWidth = dimensions(list).width;
            var listRight = listLeft + listWidth + 2;

            return children(list).filter(function (slide) {
                var slideLeft = getElLeft(slide, list);
                var slideRight = slideLeft + Math.min(dimensions(slide).width, listWidth);

                return slideLeft >= listLeft && slideRight <= listRight;
            });
        }

        function triggerUpdate(el, type, data) {
            trigger(el, createEvent(type, false, false, data));
        }

        var slider = {

            mixins: [Class, Slider, SliderReactive],

            props: {
                center: Boolean,
                sets: Boolean
            },

            data: {
                center: false,
                sets: false,
                attrItem: 'uk-slider-item',
                selList: '.uk-slider-items',
                selNav: '.uk-slider-nav',
                clsContainer: 'uk-slider-container',
                Transitioner: Transitioner
            },

            computed: {

                avgWidth: function() {
                    return getWidth(this.list) / this.length;
                },

                finite: function(ref) {
                    var finite = ref.finite;

                    return finite || Math.ceil(getWidth(this.list)) < dimensions(this.list).width + getMaxElWidth(this.list) + this.center;
                },

                maxIndex: function() {

                    if (!this.finite || this.center && !this.sets) {
                        return this.length - 1;
                    }

                    if (this.center) {
                        return last(this.sets);
                    }

                    var lft = 0;
                    var max = getMax(this.list);
                    var index = findIndex(this.slides, function (el) {

                        if (lft >= max) {
                            return true;
                        }

                        lft += dimensions(el).width;

                    });

                    return ~index ? index : this.length - 1;
                },

                sets: function(ref) {
                    var this$1$1 = this;
                    var sets = ref.sets;


                    if (!sets) {
                        return;
                    }

                    var width = dimensions(this.list).width / (this.center ? 2 : 1);

                    var left = 0;
                    var leftCenter = width;
                    var slideLeft = 0;

                    sets = sortBy$1(this.slides, 'offsetLeft').reduce(function (sets, slide, i) {

                        var slideWidth = dimensions(slide).width;
                        var slideRight = slideLeft + slideWidth;

                        if (slideRight > left) {

                            if (!this$1$1.center && i > this$1$1.maxIndex) {
                                i = this$1$1.maxIndex;
                            }

                            if (!includes(sets, i)) {

                                var cmp = this$1$1.slides[i + 1];
                                if (this$1$1.center && cmp && slideWidth < leftCenter - dimensions(cmp).width / 2) {
                                    leftCenter -= slideWidth;
                                } else {
                                    leftCenter = width;
                                    sets.push(i);
                                    left = slideLeft + width + (this$1$1.center ? slideWidth / 2 : 0);
                                }

                            }
                        }

                        slideLeft += slideWidth;

                        return sets;

                    }, []);

                    return !isEmpty(sets) && sets;

                },

                transitionOptions: function() {
                    return {
                        center: this.center,
                        list: this.list
                    };
                }

            },

            connected: function() {
                toggleClass(this.$el, this.clsContainer, !$(("." + (this.clsContainer)), this.$el));
            },

            update: {

                write: function() {
                    var this$1$1 = this;

                    this.navItems.forEach(function (el) {
                        var index = toNumber(data(el, this$1$1.attrItem));
                        if (index !== false) {
                            el.hidden = !this$1$1.maxIndex || index > this$1$1.maxIndex || this$1$1.sets && !includes(this$1$1.sets, index);
                        }
                    });

                    if (this.length && !this.dragging && !this.stack.length) {
                        this.reorder();
                        this._translate(1);
                    }

                    var actives = this._getTransitioner(this.index).getActives();
                    this.slides.forEach(function (slide) { return toggleClass(slide, this$1$1.clsActive, includes(actives, slide)); });

                    if (this.clsActivated && (!this.sets || includes(this.sets, toFloat(this.index)))) {
                        this.slides.forEach(function (slide) { return toggleClass(slide, this$1$1.clsActivated || '', includes(actives, slide)); });
                    }
                },

                events: ['resize']

            },

            events: {

                beforeitemshow: function(e) {

                    if (!this.dragging && this.sets && this.stack.length < 2 && !includes(this.sets, this.index)) {
                        this.index = this.getValidIndex();
                    }

                    var diff = Math.abs(
                        this.index
                        - this.prevIndex
                        + (this.dir > 0 && this.index < this.prevIndex || this.dir < 0 && this.index > this.prevIndex ? (this.maxIndex + 1) * this.dir : 0)
                    );

                    if (!this.dragging && diff > 1) {

                        for (var i = 0; i < diff; i++) {
                            this.stack.splice(1, 0, this.dir > 0 ? 'next' : 'previous');
                        }

                        e.preventDefault();
                        return;
                    }

                    var index = this.dir < 0 || !this.slides[this.prevIndex] ? this.index : this.prevIndex;
                    this.duration = speedUp(this.avgWidth / this.velocity) * (dimensions(this.slides[index]).width / this.avgWidth);

                    this.reorder();

                },

                itemshow: function() {
                    if (~this.prevIndex) {
                        addClass(this._getTransitioner().getItemIn(), this.clsActive);
                    }
                }

            },

            methods: {

                reorder: function() {
                    var this$1$1 = this;


                    if (this.finite) {
                        css(this.slides, 'order', '');
                        return;
                    }

                    var index = this.dir > 0 && this.slides[this.prevIndex] ? this.prevIndex : this.index;

                    this.slides.forEach(function (slide, i) { return css(slide, 'order', this$1$1.dir > 0 && i < index
                            ? 1
                            : this$1$1.dir < 0 && i >= this$1$1.index
                                ? -1
                                : ''
                        ); }
                    );

                    if (!this.center) {
                        return;
                    }

                    var next = this.slides[index];
                    var width = dimensions(this.list).width / 2 - dimensions(next).width / 2;
                    var j = 0;

                    while (width > 0) {
                        var slideIndex = this.getIndex(--j + index, index);
                        var slide = this.slides[slideIndex];

                        css(slide, 'order', slideIndex > index ? -2 : -1);
                        width -= dimensions(slide).width;
                    }

                },

                getValidIndex: function(index, prevIndex) {
                    if ( index === void 0 ) index = this.index;
                    if ( prevIndex === void 0 ) prevIndex = this.prevIndex;


                    index = this.getIndex(index, prevIndex);

                    if (!this.sets) {
                        return index;
                    }

                    var prev;

                    do {

                        if (includes(this.sets, index)) {
                            return index;
                        }

                        prev = index;
                        index = this.getIndex(index + this.dir, prevIndex);

                    } while (index !== prev);

                    return index;
                }

            }

        };

        function getMaxElWidth(list) {
            return Math.max.apply(Math, [ 0 ].concat( children(list).map(function (el) { return dimensions(el).width; }) ));
        }

        var sliderParallax = {

            mixins: [Parallax],

            data: {
                selItem: '!li'
            },

            computed: {

                item: function(ref, $el) {
                    var selItem = ref.selItem;

                    return query(selItem, $el);
                }

            },

            events: [

                {
                    name: 'itemin itemout',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function(ref) {
                        var this$1$1 = this;
                        var type = ref.type;
                        var ref_detail = ref.detail;
                        var percent = ref_detail.percent;
                        var duration = ref_detail.duration;
                        var timing = ref_detail.timing;
                        var dir = ref_detail.dir;


                        fastdom.read(function () {
                            var propsFrom = this$1$1.getCss(getCurrentPercent(type, dir, percent));
                            var propsTo = this$1$1.getCss(isIn(type) ? .5 : dir > 0 ? 1 : 0);
                            fastdom.write(function () {
                                css(this$1$1.$el, propsFrom);
                                Transition.start(this$1$1.$el, propsTo, duration, timing).catch(noop);
                            });
                        });

                    }
                },

                {
                    name: 'transitioncanceled transitionend',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function() {
                        Transition.cancel(this.$el);
                    }

                },

                {
                    name: 'itemtranslatein itemtranslateout',

                    self: true,

                    el: function() {
                        return this.item;
                    },

                    handler: function(ref) {
                        var this$1$1 = this;
                        var type = ref.type;
                        var ref_detail = ref.detail;
                        var percent = ref_detail.percent;
                        var dir = ref_detail.dir;

                        fastdom.read(function () {
                            var props = this$1$1.getCss(getCurrentPercent(type, dir, percent));
                            fastdom.write(function () { return css(this$1$1.$el, props); });
                        });
                    }
                }

            ]

        };

        function isIn(type) {
            return endsWith(type, 'in');
        }

        function getCurrentPercent(type, dir, percent) {

            percent /= 2;

            return isIn(type) ^ dir < 0 ? percent : 1 - percent;
        }

        var Animations = assign({}, Animations$2, {

            fade: {

                show: function() {
                    return [
                        {opacity: 0, zIndex: 0},
                        {zIndex: -1}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent, zIndex: 0},
                        {zIndex: -1}
                    ];
                }

            },

            scale: {

                show: function() {
                    return [
                        {opacity: 0, transform: scale3d(1 + .5), zIndex: 0},
                        {zIndex: -1}
                    ];
                },

                percent: function(current) {
                    return 1 - css(current, 'opacity');
                },

                translate: function(percent) {
                    return [
                        {opacity: 1 - percent, transform: scale3d(1 + .5 * percent), zIndex: 0},
                        {zIndex: -1}
                    ];
                }

            },

            pull: {

                show: function(dir) {
                    return dir < 0
                        ? [
                            {transform: translate(30), zIndex: -1},
                            {transform: translate(), zIndex: 0}
                        ]
                        : [
                            {transform: translate(-100), zIndex: 0},
                            {transform: translate(), zIndex: -1}
                        ];
                },

                percent: function(current, next, dir) {
                    return dir < 0
                        ? 1 - translated(next)
                        : translated(current);
                },

                translate: function(percent, dir) {
                    return dir < 0
                        ? [
                            {transform: translate(30 * percent), zIndex: -1},
                            {transform: translate(-100 * (1 - percent)), zIndex: 0}
                        ]
                        : [
                            {transform: translate(-percent * 100), zIndex: 0},
                            {transform: translate(30 * (1 - percent)), zIndex: -1}
                        ];
                }

            },

            push: {

                show: function(dir) {
                    return dir < 0
                        ? [
                            {transform: translate(100), zIndex: 0},
                            {transform: translate(), zIndex: -1}
                        ]
                        : [
                            {transform: translate(-30), zIndex: -1},
                            {transform: translate(), zIndex: 0}
                        ];
                },

                percent: function(current, next, dir) {
                    return dir > 0
                        ? 1 - translated(next)
                        : translated(current);
                },

                translate: function(percent, dir) {
                    return dir < 0
                        ? [
                            {transform: translate(percent * 100), zIndex: 0},
                            {transform: translate(-30 * (1 - percent)), zIndex: -1}
                        ]
                        : [
                            {transform: translate(-30 * percent), zIndex: -1},
                            {transform: translate(100 * (1 - percent)), zIndex: 0}
                        ];
                }

            }

        });

        var slideshow = {

            mixins: [Class, Slideshow, SliderReactive],

            props: {
                ratio: String,
                minHeight: Number,
                maxHeight: Number
            },

            data: {
                ratio: '16:9',
                minHeight: false,
                maxHeight: false,
                selList: '.uk-slideshow-items',
                attrItem: 'uk-slideshow-item',
                selNav: '.uk-slideshow-nav',
                Animations: Animations
            },

            update: {

                read: function() {

                    if (!this.list) {
                        return false;
                    }

                    var ref = this.ratio.split(':').map(Number);
                    var width = ref[0];
                    var height = ref[1];

                    height = height * this.list.offsetWidth / width || 0;

                    if (this.minHeight) {
                        height = Math.max(this.minHeight, height);
                    }

                    if (this.maxHeight) {
                        height = Math.min(this.maxHeight, height);
                    }

                    return {height: height - boxModelAdjust(this.list, 'height', 'content-box')};
                },

                write: function(ref) {
                    var height = ref.height;

                    height > 0 && css(this.list, 'minHeight', height);
                },

                events: ['resize']

            }

        };

        var sortable = {

            mixins: [Class, Animate],

            props: {
                group: String,
                threshold: Number,
                clsItem: String,
                clsPlaceholder: String,
                clsDrag: String,
                clsDragState: String,
                clsBase: String,
                clsNoDrag: String,
                clsEmpty: String,
                clsCustom: String,
                handle: String
            },

            data: {
                group: false,
                threshold: 5,
                clsItem: 'uk-sortable-item',
                clsPlaceholder: 'uk-sortable-placeholder',
                clsDrag: 'uk-sortable-drag',
                clsDragState: 'uk-drag',
                clsBase: 'uk-sortable',
                clsNoDrag: 'uk-sortable-nodrag',
                clsEmpty: 'uk-sortable-empty',
                clsCustom: '',
                handle: false,
                pos: {}
            },

            created: function() {
                var this$1$1 = this;

                ['init', 'start', 'move', 'end'].forEach(function (key) {
                    var fn = this$1$1[key];
                    this$1$1[key] = function (e) {
                        assign(this$1$1.pos, getEventPos(e));
                        fn(e);
                    };
                });
            },

            events: {

                name: pointerDown,
                passive: false,
                handler: 'init'

            },

            computed: {

                target: function() {
                    return (this.$el.tBodies || [this.$el])[0];
                },

                items: function() {
                    return children(this.target);
                },

                isEmpty: {

                    get: function() {
                        return isEmpty(this.items);
                    },

                    watch: function(empty) {
                        toggleClass(this.target, this.clsEmpty, empty);
                    },

                    immediate: true

                },

                handles: {

                    get: function(ref, el) {
                        var handle = ref.handle;

                        return handle ? $$(handle, el) : this.items;
                    },

                    watch: function(handles, prev) {
                        css(prev, {touchAction: '', userSelect: ''});
                        css(handles, {touchAction: hasTouch ? 'none' : '', userSelect: 'none'}); // touchAction set to 'none' causes a performance drop in Chrome 80
                    },

                    immediate: true

                }

            },

            update: {

                write: function(data) {

                    if (!this.drag || !parent(this.placeholder)) {
                        return;
                    }

                    var ref = this;
                    var ref_pos = ref.pos;
                    var x = ref_pos.x;
                    var y = ref_pos.y;
                    var ref_origin = ref.origin;
                    var offsetTop = ref_origin.offsetTop;
                    var offsetLeft = ref_origin.offsetLeft;
                    var placeholder = ref.placeholder;

                    css(this.drag, {
                        top: y - offsetTop,
                        left: x - offsetLeft
                    });

                    var sortable = this.getSortable(document.elementFromPoint(x, y));

                    if (!sortable) {
                        return;
                    }

                    var items = sortable.items;

                    if (items.some(Transition.inProgress)) {
                        return;
                    }

                    var target = findTarget(items, {x: x, y: y});

                    if (items.length && (!target || target === placeholder)) {
                        return;
                    }

                    var previous = this.getSortable(placeholder);
                    var insertTarget = findInsertTarget(sortable.target, target, placeholder, x, y, sortable === previous && data.moved !== target);

                    if (insertTarget === false) {
                        return;
                    }

                    if (insertTarget && placeholder === insertTarget) {
                        return;
                    }

                    if (sortable !== previous) {
                        previous.remove(placeholder);
                        data.moved = target;
                    } else {
                        delete data.moved;
                    }

                    sortable.insert(placeholder, insertTarget);

                    this.touched.add(sortable);
                },

                events: ['move']

            },

            methods: {

                init: function(e) {

                    var target = e.target;
                    var button = e.button;
                    var defaultPrevented = e.defaultPrevented;
                    var ref = this.items.filter(function (el) { return within(target, el); });
                    var placeholder = ref[0];

                    if (!placeholder
                        || defaultPrevented
                        || button > 0
                        || isInput(target)
                        || within(target, ("." + (this.clsNoDrag)))
                        || this.handle && !within(target, this.handle)
                    ) {
                        return;
                    }

                    e.preventDefault();

                    this.touched = new Set([this]);
                    this.placeholder = placeholder;
                    this.origin = assign({target: target, index: index(placeholder)}, this.pos);

                    on(document, pointerMove, this.move);
                    on(document, pointerUp, this.end);

                    if (!this.threshold) {
                        this.start(e);
                    }

                },

                start: function(e) {

                    this.drag = appendDrag(this.$container, this.placeholder);
                    var ref = this.placeholder.getBoundingClientRect();
                    var left = ref.left;
                    var top = ref.top;
                    assign(this.origin, {offsetLeft: this.pos.x - left, offsetTop: this.pos.y - top});

                    addClass(this.drag, this.clsDrag, this.clsCustom);
                    addClass(this.placeholder, this.clsPlaceholder);
                    addClass(this.items, this.clsItem);
                    addClass(document.documentElement, this.clsDragState);

                    trigger(this.$el, 'start', [this, this.placeholder]);

                    trackScroll(this.pos);

                    this.move(e);
                },

                move: function(e) {

                    if (this.drag) {
                        this.$emit('move');
                    } else if (Math.abs(this.pos.x - this.origin.x) > this.threshold || Math.abs(this.pos.y - this.origin.y) > this.threshold) {
                        this.start(e);
                    }

                },

                end: function() {
                    var this$1$1 = this;


                    off(document, pointerMove, this.move);
                    off(document, pointerUp, this.end);
                    off(window, 'scroll', this.scroll);

                    if (!this.drag) {
                        return;
                    }

                    untrackScroll();

                    var sortable = this.getSortable(this.placeholder);

                    if (this === sortable) {
                        if (this.origin.index !== index(this.placeholder)) {
                            trigger(this.$el, 'moved', [this, this.placeholder]);
                        }
                    } else {
                        trigger(sortable.$el, 'added', [sortable, this.placeholder]);
                        trigger(this.$el, 'removed', [this, this.placeholder]);
                    }

                    trigger(this.$el, 'stop', [this, this.placeholder]);

                    remove$1(this.drag);
                    this.drag = null;

                    this.touched.forEach(function (ref) {
                            var clsPlaceholder = ref.clsPlaceholder;
                            var clsItem = ref.clsItem;

                            return this$1$1.touched.forEach(function (sortable) { return removeClass(sortable.items, clsPlaceholder, clsItem); }
                        );
                    }
                    );
                    this.touched = null;
                    removeClass(document.documentElement, this.clsDragState);

                },

                insert: function(element, target) {
                    var this$1$1 = this;


                    addClass(this.items, this.clsItem);

                    var insert = function () { return target
                        ? before(target, element)
                        : append(this$1$1.target, element); };

                    this.animate(insert);

                },

                remove: function(element) {

                    if (!within(element, this.target)) {
                        return;
                    }

                    this.animate(function () { return remove$1(element); });

                },

                getSortable: function(element) {
                    do {
                        var sortable = this.$getComponent(element, 'sortable');

                        if (sortable && (sortable === this || this.group !== false && sortable.group === this.group)) {
                            return sortable;
                        }
                    } while ((element = parent(element)));
                }

            }

        };

        var trackTimer;
        function trackScroll(pos) {

            var last = Date.now();
            trackTimer = setInterval(function () {

                var x = pos.x;
                var y = pos.y;
                y += window.pageYOffset;

                var dist = (Date.now() - last) * .3;
                last = Date.now();

                scrollParents(document.elementFromPoint(x, pos.y), /auto|scroll/).reverse().some(function (scrollEl) {

                    var scroll = scrollEl.scrollTop;
                    var scrollHeight = scrollEl.scrollHeight;

                    var ref = offset(getViewport$1(scrollEl));
                    var top = ref.top;
                    var bottom = ref.bottom;
                    var height = ref.height;

                    if (top < y && top + 35 > y) {
                        scroll -= dist;
                    } else if (bottom > y && bottom - 35 < y) {
                        scroll += dist;
                    } else {
                        return;
                    }

                    if (scroll > 0 && scroll < scrollHeight - height) {
                        scrollTop(scrollEl, scroll);
                        return true;
                    }

                });

            }, 15);

        }

        function untrackScroll() {
            clearInterval(trackTimer);
        }

        function appendDrag(container, element) {
            var clone = append(container, element.outerHTML.replace(/(^<)(?:li|tr)|(?:li|tr)(\/>$)/g, '$1div$2'));

            css(clone, 'margin', '0', 'important');
            css(clone, assign({
                boxSizing: 'border-box',
                width: element.offsetWidth,
                height: element.offsetHeight
            }, css(element, ['paddingLeft', 'paddingRight', 'paddingTop', 'paddingBottom'])));

            height(clone.firstElementChild, height(element.firstElementChild));

            return clone;
        }

        function findTarget(items, point) {
            return items[findIndex(items, function (item) { return pointInRect(point, item.getBoundingClientRect()); })];
        }

        function findInsertTarget(list, target, placeholder, x, y, sameList) {

            if (!children(list).length) {
                return;
            }

            var rect = target.getBoundingClientRect();
            if (!sameList) {

                if (!isHorizontal(list, placeholder)) {
                    return y < rect.top + rect.height / 2
                        ? target
                        : target.nextElementSibling;
                }

                return target;
            }

            var placeholderRect = placeholder.getBoundingClientRect();
            var sameRow = linesIntersect(
                [rect.top, rect.bottom],
                [placeholderRect.top, placeholderRect.bottom]
            );

            var pointerPos = sameRow ? x : y;
            var lengthProp = sameRow ? 'width' : 'height';
            var startProp = sameRow ? 'left' : 'top';
            var endProp = sameRow ? 'right' : 'bottom';

            var diff = placeholderRect[lengthProp] < rect[lengthProp] ? rect[lengthProp] - placeholderRect[lengthProp] : 0;

            if (placeholderRect[startProp] < rect[startProp]) {

                if (diff && pointerPos < rect[startProp] + diff) {
                    return false;
                }

                return target.nextElementSibling;
            }

            if (diff && pointerPos > rect[endProp] - diff) {
                return false;
            }

            return target;
        }

        function isHorizontal(list, placeholder) {

            var single = children(list).length === 1;

            if (single) {
                append(list, placeholder);
            }

            var items = children(list);
            var isHorizontal = items.some(function (el, i) {
                var rectA = el.getBoundingClientRect();
                return items.slice(i + 1).some(function (el) {
                    var rectB = el.getBoundingClientRect();
                    return !linesIntersect([rectA.left, rectA.right], [rectB.left, rectB.right]);
                });
            });

            if (single) {
                remove$1(placeholder);
            }

            return isHorizontal;
        }

        function linesIntersect(lineA, lineB) {
            return lineA[1] > lineB[0] && lineB[1] > lineA[0];
        }

        var obj;

        var tooltip = {

            mixins: [Container, Togglable, Position],

            args: 'title',

            props: {
                delay: Number,
                title: String
            },

            data: {
                pos: 'top',
                title: '',
                delay: 0,
                animation: ['uk-animation-scale-up'],
                duration: 100,
                cls: 'uk-active',
                clsPos: 'uk-tooltip'
            },

            beforeConnect: function() {
                this._hasTitle = hasAttr(this.$el, 'title');
                attr(this.$el, 'title', '');
                this.updateAria(false);
                makeFocusable(this.$el);
            },

            disconnected: function() {
                this.hide();
                attr(this.$el, 'title', this._hasTitle ? this.title : null);
            },

            methods: {

                show: function() {
                    var this$1$1 = this;


                    if (this.isToggled(this.tooltip || null) || !this.title) {
                        return;
                    }

                    this._unbind = once(document, ("show keydown " + pointerDown), this.hide, false, function (e) { return e.type === pointerDown && !within(e.target, this$1$1.$el)
                        || e.type === 'keydown' && e.keyCode === 27
                        || e.type === 'show' && e.detail[0] !== this$1$1 && e.detail[0].$name === this$1$1.$name; }
                    );

                    clearTimeout(this.showTimer);
                    this.showTimer = setTimeout(this._show, this.delay);
                },

                hide: function() {
                    var this$1$1 = this;


                    if (matches(this.$el, 'input:focus')) {
                        return;
                    }

                    clearTimeout(this.showTimer);

                    if (!this.isToggled(this.tooltip || null)) {
                        return;
                    }

                    this.toggleElement(this.tooltip, false, false).then(function () {
                        remove$1(this$1$1.tooltip);
                        this$1$1.tooltip = null;
                        this$1$1._unbind();
                    });
                },

                _show: function() {
                    var this$1$1 = this;


                    this.tooltip = append(this.container,
                        ("<div class=\"" + (this.clsPos) + "\"> <div class=\"" + (this.clsPos) + "-inner\">" + (this.title) + "</div> </div>")
                    );

                    on(this.tooltip, 'toggled', function (e, toggled) {

                        this$1$1.updateAria(toggled);

                        if (!toggled) {
                            return;
                        }

                        this$1$1.positionAt(this$1$1.tooltip, this$1$1.$el);

                        this$1$1.origin = this$1$1.getAxis() === 'y'
                            ? ((flipPosition(this$1$1.dir)) + "-" + (this$1$1.align))
                            : ((this$1$1.align) + "-" + (flipPosition(this$1$1.dir)));
                    });

                    this.toggleElement(this.tooltip, true);

                },

                updateAria: function(toggled) {
                    attr(this.$el, 'aria-expanded', toggled);
                }

            },

            events: ( obj = {

                focus: 'show',
                blur: 'hide'

            }, obj[(pointerEnter + " " + pointerLeave)] = function (e) {
                    if (!isTouch(e)) {
                        this[e.type === pointerEnter ? 'show' : 'hide']();
                    }
                }, obj[pointerDown] = function (e) {
                    if (isTouch(e)) {
                        this.show();
                    }
                }, obj )

        };

        function makeFocusable(el) {
            if (!isFocusable(el)) {
                attr(el, 'tabindex', '0');
            }
        }

        var upload = {

            props: {
                allow: String,
                clsDragover: String,
                concurrent: Number,
                maxSize: Number,
                method: String,
                mime: String,
                msgInvalidMime: String,
                msgInvalidName: String,
                msgInvalidSize: String,
                multiple: Boolean,
                name: String,
                params: Object,
                type: String,
                url: String
            },

            data: {
                allow: false,
                clsDragover: 'uk-dragover',
                concurrent: 1,
                maxSize: 0,
                method: 'POST',
                mime: false,
                msgInvalidMime: 'Invalid File Type: %s',
                msgInvalidName: 'Invalid File Name: %s',
                msgInvalidSize: 'Invalid File Size: %s Kilobytes Max',
                multiple: false,
                name: 'files[]',
                params: {},
                type: '',
                url: '',
                abort: noop,
                beforeAll: noop,
                beforeSend: noop,
                complete: noop,
                completeAll: noop,
                error: noop,
                fail: noop,
                load: noop,
                loadEnd: noop,
                loadStart: noop,
                progress: noop
            },

            events: {

                change: function(e) {

                    if (!matches(e.target, 'input[type="file"]')) {
                        return;
                    }

                    e.preventDefault();

                    if (e.target.files) {
                        this.upload(e.target.files);
                    }

                    e.target.value = '';
                },

                drop: function(e) {
                    stop(e);

                    var transfer = e.dataTransfer;

                    if (!transfer || !transfer.files) {
                        return;
                    }

                    removeClass(this.$el, this.clsDragover);

                    this.upload(transfer.files);
                },

                dragenter: function(e) {
                    stop(e);
                },

                dragover: function(e) {
                    stop(e);
                    addClass(this.$el, this.clsDragover);
                },

                dragleave: function(e) {
                    stop(e);
                    removeClass(this.$el, this.clsDragover);
                }

            },

            methods: {

                upload: function(files) {
                    var this$1$1 = this;


                    if (!files.length) {
                        return;
                    }

                    trigger(this.$el, 'upload', [files]);

                    for (var i = 0; i < files.length; i++) {

                        if (this.maxSize && this.maxSize * 1000 < files[i].size) {
                            this.fail(this.msgInvalidSize.replace('%s', this.maxSize));
                            return;
                        }

                        if (this.allow && !match(this.allow, files[i].name)) {
                            this.fail(this.msgInvalidName.replace('%s', this.allow));
                            return;
                        }

                        if (this.mime && !match(this.mime, files[i].type)) {
                            this.fail(this.msgInvalidMime.replace('%s', this.mime));
                            return;
                        }

                    }

                    if (!this.multiple) {
                        files = [files[0]];
                    }

                    this.beforeAll(this, files);

                    var chunks = chunk(files, this.concurrent);
                    var upload = function (files) {

                        var data = new FormData();

                        files.forEach(function (file) { return data.append(this$1$1.name, file); });

                        for (var key in this$1$1.params) {
                            data.append(key, this$1$1.params[key]);
                        }

                        ajax(this$1$1.url, {
                            data: data,
                            method: this$1$1.method,
                            responseType: this$1$1.type,
                            beforeSend: function (env) {

                                var xhr = env.xhr;
                                xhr.upload && on(xhr.upload, 'progress', this$1$1.progress);
                                ['loadStart', 'load', 'loadEnd', 'abort'].forEach(function (type) { return on(xhr, type.toLowerCase(), this$1$1[type]); }
                                );

                                return this$1$1.beforeSend(env);

                            }
                        }).then(
                            function (xhr) {

                                this$1$1.complete(xhr);

                                if (chunks.length) {
                                    upload(chunks.shift());
                                } else {
                                    this$1$1.completeAll(xhr);
                                }

                            },
                            function (e) { return this$1$1.error(e); }
                        );

                    };

                    upload(chunks.shift());

                }

            }

        };

        function match(pattern, path) {
            return path.match(new RegExp(("^" + (pattern.replace(/\//g, '\\/').replace(/\*\*/g, '(\\/[^\\/]+)*').replace(/\*/g, '[^\\/]+').replace(/((?!\\))\?/g, '$1.')) + "$"), 'i'));
        }

        function chunk(files, size) {
            var chunks = [];
            for (var i = 0; i < files.length; i += size) {
                var chunk = [];
                for (var j = 0; j < size; j++) {
                    chunk.push(files[i + j]);
                }
                chunks.push(chunk);
            }
            return chunks;
        }

        function stop(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        var components = /*#__PURE__*/Object.freeze({
            __proto__: null,
            Countdown: countdown,
            Filter: filter,
            Lightbox: lightbox,
            LightboxPanel: LightboxPanel,
            Notification: notification,
            Parallax: parallax,
            Slider: slider,
            SliderParallax: sliderParallax,
            Slideshow: slideshow,
            SlideshowParallax: sliderParallax,
            Sortable: sortable,
            Tooltip: tooltip,
            Upload: upload
        });

        each(components, function (component, name) { return UIkit.component(name, component); }
        );

        return UIkit;

    }));
    });

    /*! UIkit 3.10.1 | https://www.getuikit.com | (c) 2014 - 2022 YOOtheme | MIT License */

    var uikitIcons = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
        module.exports = factory() ;
    })(commonjsGlobal, (function () {
        function plugin(UIkit) {

            if (plugin.installed) {
                return;
            }

            UIkit.icon.add({
            "500px": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.624,11.866c-0.141,0.132,0.479,0.658,0.662,0.418c0.051-0.046,0.607-0.61,0.662-0.664c0,0,0.738,0.719,0.814,0.719 c0.1,0,0.207-0.055,0.322-0.17c0.27-0.269,0.135-0.416,0.066-0.495l-0.631-0.616l0.658-0.668c0.146-0.156,0.021-0.314-0.1-0.449 c-0.182-0.18-0.359-0.226-0.471-0.125l-0.656,0.654l-0.654-0.654c-0.033-0.034-0.08-0.045-0.124-0.045 c-0.079,0-0.191,0.068-0.307,0.181c-0.202,0.202-0.247,0.351-0.133,0.462l0.665,0.665L9.624,11.866z\"/><path d=\"M11.066,2.884c-1.061,0-2.185,0.248-3.011,0.604c-0.087,0.034-0.141,0.106-0.15,0.205C7.893,3.784,7.919,3.909,7.982,4.066 c0.05,0.136,0.187,0.474,0.452,0.372c0.844-0.326,1.779-0.507,2.633-0.507c0.963,0,1.9,0.191,2.781,0.564 c0.695,0.292,1.357,0.719,2.078,1.34c0.051,0.044,0.105,0.068,0.164,0.068c0.143,0,0.273-0.137,0.389-0.271 c0.191-0.214,0.324-0.395,0.135-0.575c-0.686-0.654-1.436-1.138-2.363-1.533C13.24,3.097,12.168,2.884,11.066,2.884z\"/><path d=\"M16.43,15.747c-0.092-0.028-0.242,0.05-0.309,0.119l0,0c-0.652,0.652-1.42,1.169-2.268,1.521 c-0.877,0.371-1.814,0.551-2.779,0.551c-0.961,0-1.896-0.189-2.775-0.564c-0.848-0.36-1.612-0.879-2.268-1.53 c-0.682-0.688-1.196-1.455-1.529-2.268c-0.325-0.799-0.471-1.643-0.471-1.643c-0.045-0.24-0.258-0.249-0.567-0.203 c-0.128,0.021-0.519,0.079-0.483,0.36v0.01c0.105,0.644,0.289,1.284,0.545,1.895c0.417,0.969,1.002,1.849,1.756,2.604 c0.757,0.754,1.636,1.34,2.604,1.757C8.901,18.785,9.97,19,11.088,19c1.104,0,2.186-0.215,3.188-0.645 c1.838-0.896,2.604-1.757,2.604-1.757c0.182-0.204,0.227-0.317-0.1-0.643C16.779,15.956,16.525,15.774,16.43,15.747z\"/><path d=\"M5.633,13.287c0.293,0.71,0.723,1.341,1.262,1.882c0.54,0.54,1.172,0.971,1.882,1.264c0.731,0.303,1.509,0.461,2.298,0.461 c0.801,0,1.578-0.158,2.297-0.461c0.711-0.293,1.344-0.724,1.883-1.264c0.543-0.541,0.971-1.172,1.264-1.882 c0.314-0.721,0.463-1.5,0.463-2.298c0-0.79-0.148-1.569-0.463-2.289c-0.293-0.699-0.721-1.329-1.264-1.881 c-0.539-0.541-1.172-0.959-1.867-1.263c-0.721-0.303-1.5-0.461-2.299-0.461c-0.802,0-1.613,0.159-2.322,0.461 c-0.577,0.25-1.544,0.867-2.119,1.454v0.012V2.108h8.16C15.1,2.104,15.1,1.69,15.1,1.552C15.1,1.417,15.1,1,14.809,1H5.915 C5.676,1,5.527,1.192,5.527,1.384v6.84c0,0.214,0.273,0.372,0.529,0.428c0.5,0.105,0.614-0.056,0.737-0.224l0,0 c0.18-0.273,0.776-0.884,0.787-0.894c0.901-0.905,2.117-1.408,3.416-1.408c1.285,0,2.5,0.501,3.412,1.408 c0.914,0.914,1.408,2.122,1.408,3.405c0,1.288-0.508,2.496-1.408,3.405c-0.9,0.896-2.152,1.406-3.438,1.406 c-0.877,0-1.711-0.229-2.433-0.671v-4.158c0-0.553,0.237-1.151,0.643-1.614c0.462-0.519,1.094-0.799,1.782-0.799 c0.664,0,1.293,0.253,1.758,0.715c0.459,0.459,0.709,1.071,0.709,1.723c0,1.385-1.094,2.468-2.488,2.468 c-0.273,0-0.769-0.121-0.781-0.125c-0.281-0.087-0.405,0.306-0.438,0.436c-0.159,0.496,0.079,0.585,0.123,0.607 c0.452,0.137,0.743,0.157,1.129,0.157c1.973,0,3.572-1.6,3.572-3.57c0-1.964-1.6-3.552-3.572-3.552c-0.97,0-1.872,0.36-2.546,1.038 c-0.656,0.631-1.027,1.487-1.027,2.322v3.438v-0.011c-0.372-0.42-0.732-1.041-0.981-1.682c-0.102-0.248-0.315-0.202-0.607-0.113 c-0.135,0.035-0.519,0.157-0.44,0.439C5.372,12.799,5.577,13.164,5.633,13.287z\"/></svg>",
            "album": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"5\" y=\"2\" width=\"10\" height=\"1\"/><rect x=\"3\" y=\"4\" width=\"14\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"6.5\" width=\"17\" height=\"11\"/></svg>",
            "arrow-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,16.08 5.63,10.66 6.37,10 10.5,14.58 14.63,10 15.37,10.66\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"4\" x2=\"10.5\" y2=\"15\"/></svg>",
            "arrow-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 14 5 9.5 10 5\"/><line fill=\"none\" stroke=\"#000\" x1=\"16\" y1=\"9.5\" x2=\"5\" y2=\"9.52\"/></svg>",
            "arrow-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"10 5 15 9.5 10 14\"/><line fill=\"none\" stroke=\"#000\" x1=\"4\" y1=\"9.5\" x2=\"15\" y2=\"9.5\"/></svg>",
            "arrow-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"10.5,4 15.37,9.4 14.63,10.08 10.5,5.49 6.37,10.08 5.63,9.4\"/><line fill=\"none\" stroke=\"#000\" x1=\"10.5\" y1=\"16\" x2=\"10.5\" y2=\"5\"/></svg>",
            "bag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M7.5,7.5V4A2.48,2.48,0,0,1,10,1.5,2.54,2.54,0,0,1,12.5,4V7.5\"/><polygon fill=\"none\" stroke=\"#000\" points=\"16.5 7.5 3.5 7.5 2.5 18.5 17.5 18.5 16.5 7.5\"/></svg>",
            "ban": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"4\" y1=\"3.5\" x2=\"16\" y2=\"16.5\"/></svg>",
            "behance": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.5,10.6c-0.4-0.5-0.9-0.9-1.6-1.1c1.7-1,2.2-3.2,0.7-4.7C7.8,4,6.3,4,5.2,4C3.5,4,1.7,4,0,4v12c1.7,0,3.4,0,5.2,0 c1,0,2.1,0,3.1-0.5C10.2,14.6,10.5,12.3,9.5,10.6L9.5,10.6z M5.6,6.1c1.8,0,1.8,2.7-0.1,2.7c-1,0-2,0-2.9,0V6.1H5.6z M2.6,13.8v-3.1 c1.1,0,2.1,0,3.2,0c2.1,0,2.1,3.2,0.1,3.2L2.6,13.8z\"/><path d=\"M19.9,10.9C19.7,9.2,18.7,7.6,17,7c-4.2-1.3-7.3,3.4-5.3,7.1c0.9,1.7,2.8,2.3,4.7,2.1c1.7-0.2,2.9-1.3,3.4-2.9h-2.2 c-0.4,1.3-2.4,1.5-3.5,0.6c-0.4-0.4-0.6-1.1-0.6-1.7H20C20,11.7,19.9,10.9,19.9,10.9z M13.5,10.6c0-1.6,2.3-2.7,3.5-1.4 c0.4,0.4,0.5,0.9,0.6,1.4H13.5L13.5,10.6z\"/><rect x=\"13\" y=\"4\" width=\"5\" height=\"1.4\"/></svg>",
            "bell": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17,15.5 L3,15.5 C2.99,14.61 3.79,13.34 4.1,12.51 C4.58,11.3 4.72,10.35 5.19,7.01 C5.54,4.53 5.89,3.2 7.28,2.16 C8.13,1.56 9.37,1.5 9.81,1.5 L9.96,1.5 C9.96,1.5 11.62,1.41 12.67,2.17 C14.08,3.2 14.42,4.54 14.77,7.02 C15.26,10.35 15.4,11.31 15.87,12.52 C16.2,13.34 17.01,14.61 17,15.5 L17,15.5 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M12.39,16 C12.39,17.37 11.35,18.43 9.91,18.43 C8.48,18.43 7.42,17.37 7.42,16\"/></svg>",
            "bold": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5,15.3 C5.66,15.3 5.9,15 5.9,14.53 L5.9,5.5 C5.9,4.92 5.56,4.7 5,4.7 L5,4 L8.95,4 C12.6,4 13.7,5.37 13.7,6.9 C13.7,7.87 13.14,9.17 10.86,9.59 L10.86,9.7 C13.25,9.86 14.29,11.28 14.3,12.54 C14.3,14.47 12.94,16 9,16 L5,16 L5,15.3 Z M9,9.3 C11.19,9.3 11.8,8.5 11.85,7 C11.85,5.65 11.3,4.8 9,4.8 L7.67,4.8 L7.67,9.3 L9,9.3 Z M9.185,15.22 C11.97,15 12.39,14 12.4,12.58 C12.4,11.15 11.39,10 9,10 L7.67,10 L7.67,15 L9.18,15 Z\"/></svg>",
            "bolt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.74,20 L7.73,12 L3,12 L15.43,1 L12.32,9 L17.02,9 L4.74,20 L4.74,20 L4.74,20 Z M9.18,11 L7.1,16.39 L14.47,10 L10.86,10 L12.99,4.67 L5.61,11 L9.18,11 L9.18,11 L9.18,11 Z\"/></svg>",
            "bookmark": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"5.5 1.5 15.5 1.5 15.5 17.5 10.5 12.5 5.5 17.5\"/></svg>",
            "calendar": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M 2,3 2,17 18,17 18,3 2,3 Z M 17,16 3,16 3,8 17,8 17,16 Z M 17,7 3,7 3,4 17,4 17,7 Z\"/><rect width=\"1\" height=\"3\" x=\"6\" y=\"2\"/><rect width=\"1\" height=\"3\" x=\"13\" y=\"2\"/></svg>",
            "camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10.8\" r=\"3.8\"/><path fill=\"none\" stroke=\"#000\" d=\"M1,4.5 C0.7,4.5 0.5,4.7 0.5,5 L0.5,17 C0.5,17.3 0.7,17.5 1,17.5 L19,17.5 C19.3,17.5 19.5,17.3 19.5,17 L19.5,5 C19.5,4.7 19.3,4.5 19,4.5 L13.5,4.5 L13.5,2.9 C13.5,2.6 13.3,2.5 13,2.5 L7,2.5 C6.7,2.5 6.5,2.6 6.5,2.9 L6.5,4.5 L1,4.5 L1,4.5 Z\"/></svg>",
            "cart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"7.3\" cy=\"17.3\" r=\"1.4\"/><circle cx=\"13.3\" cy=\"17.3\" r=\"1.4\"/><polyline fill=\"none\" stroke=\"#000\" points=\"0 2 3.2 4 5.3 12.5 16 12.5 18 6.5 8 6.5\"/></svg>",
            "check": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"4,10 8,15 17,4\"/></svg>",
            "chevron-double-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 14 6 10 10 6\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"14 14 10 10 14 6\"/></svg>",
            "chevron-double-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"10 6 14 10 10 14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"6 6 10 10 6 14\"/></svg>",
            "chevron-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"16 7 10 13 4 7\"/></svg>",
            "chevron-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"13 16 7 10 13 4\"/></svg>",
            "chevron-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"7 4 13 10 7 16\"/></svg>",
            "chevron-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" points=\"4 13 10 7 16 13\"/></svg>",
            "clock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
            "close": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,16 L4,4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.06\" d=\"M16,4 L4,16\"/></svg>",
            "cloud-download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.3,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"11.75 16 9.5 18.25 7.25 16\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
            "cloud-upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.31,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6\"/><polyline fill=\"none\" stroke=\"#000\" points=\"7.25 11.75 9.5 9.5 11.75 11.75\"/><path fill=\"none\" stroke=\"#000\" d=\"M9.5,18 L9.5,9.5\"/></svg>",
            "code": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"13,4 19,10 13,16\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"7,4 1,10 7,16\"/></svg>",
            "cog": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" cx=\"9.997\" cy=\"10\" r=\"3.31\"/><path fill=\"none\" stroke=\"#000\" d=\"M18.488,12.285 L16.205,16.237 C15.322,15.496 14.185,15.281 13.303,15.791 C12.428,16.289 12.047,17.373 12.246,18.5 L7.735,18.5 C7.938,17.374 7.553,16.299 6.684,15.791 C5.801,15.27 4.655,15.492 3.773,16.237 L1.5,12.285 C2.573,11.871 3.317,10.999 3.317,9.991 C3.305,8.98 2.573,8.121 1.5,7.716 L3.765,3.784 C4.645,4.516 5.794,4.738 6.687,4.232 C7.555,3.722 7.939,2.637 7.735,1.5 L12.263,1.5 C12.072,2.637 12.441,3.71 13.314,4.22 C14.206,4.73 15.343,4.516 16.225,3.794 L18.487,7.714 C17.404,8.117 16.661,8.988 16.67,10.009 C16.672,11.018 17.415,11.88 18.488,12.285 L18.488,12.285 Z\"/></svg>",
            "comment": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,18.71 L6,14 L1,14 L1,1 L19,1 L19,14 L10.71,14 L6,18.71 L6,18.71 Z M2,13 L7,13 L7,16.29 L10.29,13 L18,13 L18,2 L2,2 L2,13 L2,13 Z\"/></svg>",
            "commenting": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"1.5,1.5 18.5,1.5 18.5,13.5 10.5,13.5 6.5,17.5 6.5,13.5 1.5,13.5\"/><circle cx=\"10\" cy=\"8\" r=\"1\"/><circle cx=\"6\" cy=\"8\" r=\"1\"/><circle cx=\"14\" cy=\"8\" r=\"1\"/></svg>",
            "comments": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"2 0.5 19.5 0.5 19.5 13\"/><path d=\"M5,19.71 L5,15 L0,15 L0,2 L18,2 L18,15 L9.71,15 L5,19.71 L5,19.71 L5,19.71 Z M1,14 L6,14 L6,17.29 L9.29,14 L17,14 L17,3 L1,3 L1,14 L1,14 L1,14 Z\"/></svg>",
            "copy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"2.5\" width=\"12\" height=\"16\"/><polyline fill=\"none\" stroke=\"#000\" points=\"5 0.5 17.5 0.5 17.5 17\"/></svg>",
            "credit-card": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"4.5\" width=\"17\" height=\"12\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"3\"/></svg>",
            "database": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"4.64\" rx=\"7.5\" ry=\"3.14\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,8.11 C17.5,9.85 14.14,11.25 10,11.25 C5.86,11.25 2.5,9.84 2.5,8.11\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.5,11.25 C17.5,12.99 14.14,14.39 10,14.39 C5.86,14.39 2.5,12.98 2.5,11.25\"/><path fill=\"none\" stroke=\"#000\" d=\"M17.49,4.64 L17.5,14.36 C17.5,16.1 14.14,17.5 10,17.5 C5.86,17.5 2.5,16.09 2.5,14.36 L2.5,4.64\"/></svg>",
            "desktop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"8\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"11\" y=\"15\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"16\" width=\"10\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"3.5\" width=\"17\" height=\"11\"/></svg>",
            "discord": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M16.074,4.361a14.243,14.243,0,0,0-3.61-1.134,10.61,10.61,0,0,0-.463.96,13.219,13.219,0,0,0-4,0,10.138,10.138,0,0,0-.468-.96A14.206,14.206,0,0,0,3.919,4.364,15.146,15.146,0,0,0,1.324,14.5a14.435,14.435,0,0,0,4.428,2.269A10.982,10.982,0,0,0,6.7,15.21a9.294,9.294,0,0,1-1.494-.727c.125-.093.248-.19.366-.289a10.212,10.212,0,0,0,8.854,0c.119.1.242.2.366.289a9.274,9.274,0,0,1-1.5.728,10.8,10.8,0,0,0,.948,1.562,14.419,14.419,0,0,0,4.431-2.27A15.128,15.128,0,0,0,16.074,4.361Zm-8.981,8.1a1.7,1.7,0,0,1-1.573-1.79A1.689,1.689,0,0,1,7.093,8.881a1.679,1.679,0,0,1,1.573,1.791A1.687,1.687,0,0,1,7.093,12.462Zm5.814,0a1.7,1.7,0,0,1-1.573-1.79,1.689,1.689,0,0,1,1.573-1.791,1.679,1.679,0,0,1,1.573,1.791A1.688,1.688,0,0,1,12.907,12.462Z\"/></svg>",
            "download": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"14,10 9.5,14.5 5,10\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"13.91\" x2=\"9.5\" y2=\"3\"/></svg>",
            "dribbble": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M1.3,8.9c0,0,5,0.1,8.6-1c1.4-0.4,2.6-0.9,4-1.9 c1.4-1.1,2.5-2.5,2.5-2.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M3.9,16.6c0,0,1.7-2.8,3.5-4.2 c1.8-1.3,4-2,5.7-2.2C16,10,19,10.6,19,10.6\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" d=\"M6.9,1.6c0,0,3.3,4.6,4.2,6.8 c0.4,0.9,1.3,3.1,1.9,5.2c0.6,2,0.9,4.4,0.9,4.4\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.4\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
            "etsy": "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" viewBox=\"0 0 20 20\"><path d=\"M8,4.26C8,4.07,8,4,8.31,4h4.46c.79,0,1.22.67,1.53,1.91l.25,1h.76c.14-2.82.26-4,.26-4S13.65,3,12.52,3H6.81L3.75,2.92v.84l1,.2c.73.11.9.27,1,1,0,0,.06,2,.06,5.17s-.06,5.14-.06,5.14c0,.59-.23.81-1,.94l-1,.2v.84l3.06-.1h5.11c1.15,0,3.82.1,3.82.1,0-.7.45-3.88.51-4.22h-.73l-.76,1.69a2.25,2.25,0,0,1-2.45,1.47H9.4c-1,0-1.44-.4-1.44-1.24V10.44s2.16,0,2.86.06c.55,0,.85.19,1.06,1l.23,1H13L12.9,9.94,13,7.41h-.85l-.28,1.13c-.16.74-.28.84-1,1-1,.1-2.89.09-2.89.09Z\"/></svg>",
            "expand": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13 2 18 2 18 7 17 7 17 3 13 3\"/><polygon points=\"2 13 3 13 3 17 7 17 7 18 2 18\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11,9 L17,3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M3,17 L9,11\"/></svg>",
            "facebook": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11,10h2.6l0.4-3H11V5.3c0-0.9,0.2-1.5,1.5-1.5H14V1.1c-0.3,0-1-0.1-2.1-0.1C9.6,1,8,2.4,8,5v2H5.5v3H8v8h3V10z\"/></svg>",
            "file-edit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M18.65,1.68 C18.41,1.45 18.109,1.33 17.81,1.33 C17.499,1.33 17.209,1.45 16.98,1.68 L8.92,9.76 L8,12.33 L10.55,11.41 L18.651,3.34 C19.12,2.87 19.12,2.15 18.65,1.68 L18.65,1.68 L18.65,1.68 Z\"/><polyline fill=\"none\" stroke=\"#000\" points=\"16.5 8.482 16.5 18.5 3.5 18.5 3.5 1.5 14.211 1.5\"/></svg>",
            "file-pdf": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><path d=\"M14.65 11.67c-.48.3-1.37-.19-1.79-.37a4.65 4.65 0 0 1 1.49.06c.35.1.36.28.3.31zm-6.3.06l.43-.79a14.7 14.7 0 0 0 .75-1.64 5.48 5.48 0 0 0 1.25 1.55l.2.15a16.36 16.36 0 0 0-2.63.73zM9.5 5.32c.2 0 .32.5.32.97a1.99 1.99 0 0 1-.23 1.04 5.05 5.05 0 0 1-.17-1.3s0-.71.08-.71zm-3.9 9a4.35 4.35 0 0 1 1.21-1.46l.24-.22a4.35 4.35 0 0 1-1.46 1.68zm9.23-3.3a2.05 2.05 0 0 0-1.32-.3 11.07 11.07 0 0 0-1.58.11 4.09 4.09 0 0 1-.74-.5 5.39 5.39 0 0 1-1.32-2.06 10.37 10.37 0 0 0 .28-2.62 1.83 1.83 0 0 0-.07-.25.57.57 0 0 0-.52-.4H9.4a.59.59 0 0 0-.6.38 6.95 6.95 0 0 0 .37 3.14c-.26.63-1 2.12-1 2.12-.3.58-.57 1.08-.82 1.5l-.8.44A3.11 3.11 0 0 0 5 14.16a.39.39 0 0 0 .15.42l.24.13c1.15.56 2.28-1.74 2.66-2.42a23.1 23.1 0 0 1 3.59-.85 4.56 4.56 0 0 0 2.91.8.5.5 0 0 0 .3-.21 1.1 1.1 0 0 0 .12-.75.84.84 0 0 0-.14-.25z\"/></svg>",
            "file-text": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" width=\"13\" height=\"17\" x=\"3.5\" y=\"1.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"12\" y1=\"12.5\" y2=\"12.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"8.5\" y2=\"8.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"6.5\" y2=\"6.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"6\" x2=\"14\" y1=\"10.5\" y2=\"10.5\"/></svg>",
            "file": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"1.5\" width=\"13\" height=\"17\"/></svg>",
            "flickr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"5.5\" cy=\"9.5\" r=\"3.5\"/><circle cx=\"14.5\" cy=\"9.5\" r=\"3.5\"/></svg>",
            "folder": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"9.5 5.5 8.5 3.5 1.5 3.5 1.5 16.5 18.5 16.5 18.5 5.5\"/></svg>",
            "forward": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.47,13.11 C4.02,10.02 6.27,7.85 9.04,6.61 C9.48,6.41 10.27,6.13 11,5.91 L11,2 L18.89,9 L11,16 L11,12.13 C9.25,12.47 7.58,13.19 6.02,14.25 C3.03,16.28 1.63,18.54 1.63,18.54 C1.63,18.54 1.38,15.28 2.47,13.11 L2.47,13.11 Z M5.3,13.53 C6.92,12.4 9.04,11.4 12,10.92 L12,13.63 L17.36,9 L12,4.25 L12,6.8 C11.71,6.86 10.86,7.02 9.67,7.49 C6.79,8.65 4.58,10.96 3.49,13.08 C3.18,13.7 2.68,14.87 2.49,16 C3.28,15.05 4.4,14.15 5.3,13.53 L5.3,13.53 Z\"/></svg>",
            "foursquare": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.23,2 C15.96,2 16.4,2.41 16.5,2.86 C16.57,3.15 16.56,3.44 16.51,3.73 C16.46,4.04 14.86,11.72 14.75,12.03 C14.56,12.56 14.16,12.82 13.61,12.83 C13.03,12.84 11.09,12.51 10.69,13 C10.38,13.38 7.79,16.39 6.81,17.53 C6.61,17.76 6.4,17.96 6.08,17.99 C5.68,18.04 5.29,17.87 5.17,17.45 C5.12,17.28 5.1,17.09 5.1,16.91 C5.1,12.4 4.86,7.81 5.11,3.31 C5.17,2.5 5.81,2.12 6.53,2 L15.23,2 L15.23,2 Z M9.76,11.42 C9.94,11.19 10.17,11.1 10.45,11.1 L12.86,11.1 C13.12,11.1 13.31,10.94 13.36,10.69 C13.37,10.64 13.62,9.41 13.74,8.83 C13.81,8.52 13.53,8.28 13.27,8.28 C12.35,8.29 11.42,8.28 10.5,8.28 C9.84,8.28 9.83,7.69 9.82,7.21 C9.8,6.85 10.13,6.55 10.5,6.55 C11.59,6.56 12.67,6.55 13.76,6.55 C14.03,6.55 14.23,6.4 14.28,6.14 C14.34,5.87 14.67,4.29 14.67,4.29 C14.67,4.29 14.82,3.74 14.19,3.74 L7.34,3.74 C7,3.75 6.84,4.02 6.84,4.33 C6.84,7.58 6.85,14.95 6.85,14.99 C6.87,15 8.89,12.51 9.76,11.42 L9.76,11.42 Z\"/></svg>",
            "future": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"19 2 18 2 18 6 14 6 14 7 19 7 19 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M18,6.548 C16.709,3.29 13.354,1 9.6,1 C4.6,1 0.6,5 0.6,10 C0.6,15 4.6,19 9.6,19 C14.6,19 18.6,15 18.6,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path d=\"M13.018,14.197 L9.445,10.625\" fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\"/></svg>",
            "git-branch": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"3\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14\" cy=\"6\" r=\"2\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"7\" cy=\"17\" r=\"2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M14,8 C14,10.41 12.43,10.87 10.56,11.25 C9.09,11.54 7,12.06 7,15 L7,5\"/></svg>",
            "git-fork": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"5.79\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"14.19\" cy=\"2.79\" r=\"1.79\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" cx=\"10.03\" cy=\"16.79\" r=\"1.79\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"2\" d=\"M5.79,4.57 L5.79,6.56 C5.79,9.19 10.03,10.22 10.03,13.31 C10.03,14.86 10.04,14.55 10.04,14.55 C10.04,14.37 10.04,14.86 10.04,13.31 C10.04,10.22 14.2,9.19 14.2,6.56 L14.2,4.57\"/></svg>",
            "github-alt": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.75,0.5 0.5,4.76 0.5,10.01 C0.5,15.26 4.75,19.51 10,19.51 C15.24,19.51 19.5,15.26 19.5,10.01 C19.5,4.76 15.25,0.5 10,0.5 L10,0.5 Z M12.81,17.69 C12.81,17.69 12.81,17.7 12.79,17.69 C12.47,17.75 12.35,17.59 12.35,17.36 L12.35,16.17 C12.35,15.45 12.09,14.92 11.58,14.56 C12.2,14.51 12.77,14.39 13.26,14.21 C13.87,13.98 14.36,13.69 14.74,13.29 C15.42,12.59 15.76,11.55 15.76,10.17 C15.76,9.25 15.45,8.46 14.83,7.8 C15.1,7.08 15.07,6.29 14.75,5.44 L14.51,5.42 C14.34,5.4 14.06,5.46 13.67,5.61 C13.25,5.78 12.79,6.03 12.31,6.35 C11.55,6.16 10.81,6.05 10.09,6.05 C9.36,6.05 8.61,6.15 7.88,6.35 C7.28,5.96 6.75,5.68 6.26,5.54 C6.07,5.47 5.9,5.44 5.78,5.44 L5.42,5.44 C5.06,6.29 5.04,7.08 5.32,7.8 C4.7,8.46 4.4,9.25 4.4,10.17 C4.4,11.94 4.96,13.16 6.08,13.84 C6.53,14.13 7.05,14.32 7.69,14.43 C8.03,14.5 8.32,14.54 8.55,14.55 C8.07,14.89 7.82,15.42 7.82,16.16 L7.82,17.51 C7.8,17.69 7.7,17.8 7.51,17.8 C4.21,16.74 1.82,13.65 1.82,10.01 C1.82,5.5 5.49,1.83 10,1.83 C14.5,1.83 18.17,5.5 18.17,10.01 C18.18,13.53 15.94,16.54 12.81,17.69 L12.81,17.69 Z\"/></svg>",
            "github": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,1 C5.03,1 1,5.03 1,10 C1,13.98 3.58,17.35 7.16,18.54 C7.61,18.62 7.77,18.34 7.77,18.11 C7.77,17.9 7.76,17.33 7.76,16.58 C5.26,17.12 4.73,15.37 4.73,15.37 C4.32,14.33 3.73,14.05 3.73,14.05 C2.91,13.5 3.79,13.5 3.79,13.5 C4.69,13.56 5.17,14.43 5.17,14.43 C5.97,15.8 7.28,15.41 7.79,15.18 C7.87,14.6 8.1,14.2 8.36,13.98 C6.36,13.75 4.26,12.98 4.26,9.53 C4.26,8.55 4.61,7.74 5.19,7.11 C5.1,6.88 4.79,5.97 5.28,4.73 C5.28,4.73 6.04,4.49 7.75,5.65 C8.47,5.45 9.24,5.35 10,5.35 C10.76,5.35 11.53,5.45 12.25,5.65 C13.97,4.48 14.72,4.73 14.72,4.73 C15.21,5.97 14.9,6.88 14.81,7.11 C15.39,7.74 15.73,8.54 15.73,9.53 C15.73,12.99 13.63,13.75 11.62,13.97 C11.94,14.25 12.23,14.8 12.23,15.64 C12.23,16.84 12.22,17.81 12.22,18.11 C12.22,18.35 12.38,18.63 12.84,18.54 C16.42,17.35 19,13.98 19,10 C19,5.03 14.97,1 10,1 L10,1 Z\"/></svg>",
            "gitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3.5\" y=\"1\" width=\"1.531\" height=\"11.471\"/><rect x=\"7.324\" y=\"4.059\" width=\"1.529\" height=\"15.294\"/><rect x=\"11.148\" y=\"4.059\" width=\"1.527\" height=\"15.294\"/><rect x=\"14.971\" y=\"4.059\" width=\"1.529\" height=\"8.412\"/></svg>",
            "google": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.86,9.09 C18.46,12.12 17.14,16.05 13.81,17.56 C9.45,19.53 4.13,17.68 2.47,12.87 C0.68,7.68 4.22,2.42 9.5,2.03 C11.57,1.88 13.42,2.37 15.05,3.65 C15.22,3.78 15.37,3.93 15.61,4.14 C14.9,4.81 14.23,5.45 13.5,6.14 C12.27,5.08 10.84,4.72 9.28,4.98 C8.12,5.17 7.16,5.76 6.37,6.63 C4.88,8.27 4.62,10.86 5.76,12.82 C6.95,14.87 9.17,15.8 11.57,15.25 C13.27,14.87 14.76,13.33 14.89,11.75 L10.51,11.75 L10.51,9.09 L17.86,9.09 L17.86,9.09 Z\"/></svg>",
            "grid": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"2\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"8\" width=\"3\" height=\"3\"/><rect x=\"2\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"8\" y=\"14\" width=\"3\" height=\"3\"/><rect x=\"14\" y=\"14\" width=\"3\" height=\"3\"/></svg>",
            "happy": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"13\" cy=\"7\" r=\"1\"/><circle cx=\"7\" cy=\"7\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"8.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M14.6,11.4 C13.9,13.3 12.1,14.5 10,14.5 C7.9,14.5 6.1,13.3 5.4,11.4\"/></svg>",
            "hashtag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.431,8 L15.661,7 L12.911,7 L13.831,3 L12.901,3 L11.98,7 L9.29,7 L10.21,3 L9.281,3 L8.361,7 L5.23,7 L5,8 L8.13,8 L7.21,12 L4.23,12 L4,13 L6.98,13 L6.061,17 L6.991,17 L7.911,13 L10.601,13 L9.681,17 L10.611,17 L11.531,13 L14.431,13 L14.661,12 L11.76,12 L12.681,8 L15.431,8 Z M10.831,12 L8.141,12 L9.061,8 L11.75,8 L10.831,12 Z\"/></svg>",
            "heart": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.03\" d=\"M10,4 C10,4 8.1,2 5.74,2 C3.38,2 1,3.55 1,6.73 C1,8.84 2.67,10.44 2.67,10.44 L10,18 L17.33,10.44 C17.33,10.44 19,8.84 19,6.73 C19,3.55 16.62,2 14.26,2 C11.9,2 10,4 10,4 L10,4 Z\"/></svg>",
            "history": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"#000\" points=\"1 2 2 2 2 6 6 6 6 7 1 7 1 2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2.1,6.548 C3.391,3.29 6.746,1 10.5,1 C15.5,1 19.5,5 19.5,10 C19.5,15 15.5,19 10.5,19 C5.5,19 1.5,15 1.5,10\"/><rect x=\"9\" y=\"4\" width=\"1\" height=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.018,14.197 L9.445,10.625\"/></svg>",
            "home": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"18.65 11.35 10 2.71 1.35 11.35 0.65 10.65 10 1.29 19.35 10.65\"/><polygon points=\"15 4 18 4 18 7 17 7 17 5 15 5\"/><polygon points=\"3 11 4 11 4 18 7 18 7 12 12 12 12 18 16 18 16 11 17 11 17 19 11 19 11 13 8 13 8 19 3 19\"/></svg>",
            "image": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"16.1\" cy=\"6.1\" r=\"1.1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"2.5\" width=\"19\" height=\"15\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"4,13 8,9 13,14\"/><polyline fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"11,12 12.5,10.5 16,14\"/></svg>",
            "info": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.13,11.59 C11.97,12.84 10.35,14.12 9.1,14.16 C6.17,14.2 9.89,9.46 8.74,8.37 C9.3,8.16 10.62,7.83 10.62,8.81 C10.62,9.63 10.12,10.55 9.88,11.32 C8.66,15.16 12.13,11.15 12.14,11.18 C12.16,11.21 12.16,11.35 12.13,11.59 C12.08,11.95 12.16,11.35 12.13,11.59 L12.13,11.59 Z M11.56,5.67 C11.56,6.67 9.36,7.15 9.36,6.03 C9.36,5 11.56,4.54 11.56,5.67 L11.56,5.67 Z\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
            "instagram": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M13.55,1H6.46C3.45,1,1,3.44,1,6.44v7.12c0,3,2.45,5.44,5.46,5.44h7.08c3.02,0,5.46-2.44,5.46-5.44V6.44 C19.01,3.44,16.56,1,13.55,1z M17.5,14c0,1.93-1.57,3.5-3.5,3.5H6c-1.93,0-3.5-1.57-3.5-3.5V6c0-1.93,1.57-3.5,3.5-3.5h8 c1.93,0,3.5,1.57,3.5,3.5V14z\"/><circle cx=\"14.87\" cy=\"5.26\" r=\"1.09\"/><path d=\"M10.03,5.45c-2.55,0-4.63,2.06-4.63,4.6c0,2.55,2.07,4.61,4.63,4.61c2.56,0,4.63-2.061,4.63-4.61 C14.65,7.51,12.58,5.45,10.03,5.45L10.03,5.45L10.03,5.45z M10.08,13c-1.66,0-3-1.34-3-2.99c0-1.65,1.34-2.99,3-2.99s3,1.34,3,2.99 C13.08,11.66,11.74,13,10.08,13L10.08,13L10.08,13z\"/></svg>",
            "italic": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.63,5.48 L10.15,14.52 C10,15.08 10.37,15.25 11.92,15.3 L11.72,16 L6,16 L6.2,15.31 C7.78,15.26 8.19,15.09 8.34,14.53 L10.82,5.49 C10.97,4.92 10.63,4.76 9.09,4.71 L9.28,4 L15,4 L14.81,4.69 C13.23,4.75 12.78,4.91 12.63,5.48 L12.63,5.48 Z\"/></svg>",
            "joomla": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7.8,13.4l1.7-1.7L5.9,8c-0.6-0.5-0.6-1.5,0-2c0.6-0.6,1.4-0.6,2,0l1.7-1.7c-1-1-2.3-1.3-3.6-1C5.8,2.2,4.8,1.4,3.7,1.4 c-1.3,0-2.3,1-2.3,2.3c0,1.1,0.8,2,1.8,2.3c-0.4,1.3-0.1,2.8,1,3.8L7.8,13.4L7.8,13.4z\"/><path d=\"M10.2,4.3c1-1,2.5-1.4,3.8-1c0.2-1.1,1.1-2,2.3-2c1.3,0,2.3,1,2.3,2.3c0,1.2-0.9,2.2-2,2.3c0.4,1.3,0,2.8-1,3.8L13.9,8 c0.6-0.5,0.6-1.5,0-2c-0.5-0.6-1.5-0.6-2,0L8.2,9.7L6.5,8\"/><path d=\"M14.1,16.8c-1.3,0.4-2.8,0.1-3.8-1l1.7-1.7c0.6,0.6,1.5,0.6,2,0c0.5-0.6,0.6-1.5,0-2l-3.7-3.7L12,6.7l3.7,3.7 c1,1,1.3,2.4,1,3.6c1.1,0.2,2,1.1,2,2.3c0,1.3-1,2.3-2.3,2.3C15.2,18.6,14.3,17.8,14.1,16.8\"/><path d=\"M13.2,12.2l-3.7,3.7c-1,1-2.4,1.3-3.6,1c-0.2,1-1.2,1.8-2.2,1.8c-1.3,0-2.3-1-2.3-2.3c0-1.1,0.8-2,1.8-2.3 c-0.3-1.3,0-2.7,1-3.7l1.7,1.7c-0.6,0.6-0.6,1.5,0,2c0.6,0.6,1.4,0.6,2,0l3.7-3.7\"/></svg>",
            "laptop": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect y=\"16\" width=\"20\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"2.5\" y=\"4.5\" width=\"15\" height=\"10\"/></svg>",
            "lifesaver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5 C4.76,0.5 0.5,4.76 0.5,10 C0.5,15.24 4.76,19.5 10,19.5 C15.24,19.5 19.5,15.24 19.5,10 C19.5,4.76 15.24,0.5 10,0.5 L10,0.5 Z M10,1.5 C11.49,1.5 12.89,1.88 14.11,2.56 L11.85,4.82 C11.27,4.61 10.65,4.5 10,4.5 C9.21,4.5 8.47,4.67 7.79,4.96 L5.58,2.75 C6.87,1.95 8.38,1.5 10,1.5 L10,1.5 Z M4.96,7.8 C4.67,8.48 4.5,9.21 4.5,10 C4.5,10.65 4.61,11.27 4.83,11.85 L2.56,14.11 C1.88,12.89 1.5,11.49 1.5,10 C1.5,8.38 1.95,6.87 2.75,5.58 L4.96,7.79 L4.96,7.8 L4.96,7.8 Z M10,18.5 C8.25,18.5 6.62,17.97 5.27,17.06 L7.46,14.87 C8.22,15.27 9.08,15.5 10,15.5 C10.79,15.5 11.53,15.33 12.21,15.04 L14.42,17.25 C13.13,18.05 11.62,18.5 10,18.5 L10,18.5 Z M10,14.5 C7.52,14.5 5.5,12.48 5.5,10 C5.5,7.52 7.52,5.5 10,5.5 C12.48,5.5 14.5,7.52 14.5,10 C14.5,12.48 12.48,14.5 10,14.5 L10,14.5 Z M15.04,12.21 C15.33,11.53 15.5,10.79 15.5,10 C15.5,9.08 15.27,8.22 14.87,7.46 L17.06,5.27 C17.97,6.62 18.5,8.25 18.5,10 C18.5,11.62 18.05,13.13 17.25,14.42 L15.04,12.21 L15.04,12.21 Z\"/></svg>",
            "link": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M10.625,12.375 L7.525,15.475 C6.825,16.175 5.925,16.175 5.225,15.475 L4.525,14.775 C3.825,14.074 3.825,13.175 4.525,12.475 L7.625,9.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M9.325,7.375 L12.425,4.275 C13.125,3.575 14.025,3.575 14.724,4.275 L15.425,4.975 C16.125,5.675 16.125,6.575 15.425,7.275 L12.325,10.375\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M7.925,11.875 L11.925,7.975\"/></svg>",
            "linkedin": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.77,17.89 L5.77,7.17 L2.21,7.17 L2.21,17.89 L5.77,17.89 L5.77,17.89 Z M3.99,5.71 C5.23,5.71 6.01,4.89 6.01,3.86 C5.99,2.8 5.24,2 4.02,2 C2.8,2 2,2.8 2,3.85 C2,4.88 2.77,5.7 3.97,5.7 L3.99,5.7 L3.99,5.71 L3.99,5.71 Z\"/><path d=\"M7.75,17.89 L11.31,17.89 L11.31,11.9 C11.31,11.58 11.33,11.26 11.43,11.03 C11.69,10.39 12.27,9.73 13.26,9.73 C14.55,9.73 15.06,10.71 15.06,12.15 L15.06,17.89 L18.62,17.89 L18.62,11.74 C18.62,8.45 16.86,6.92 14.52,6.92 C12.6,6.92 11.75,7.99 11.28,8.73 L11.3,8.73 L11.3,7.17 L7.75,7.17 C7.79,8.17 7.75,17.89 7.75,17.89 L7.75,17.89 L7.75,17.89 Z\"/></svg>",
            "list": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"6\" y=\"4\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"9\" width=\"12\" height=\"1\"/><rect x=\"6\" y=\"14\" width=\"12\" height=\"1\"/><rect x=\"2\" y=\"4\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"2\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"2\" height=\"1\"/></svg>",
            "location": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M10,0.5 C6.41,0.5 3.5,3.39 3.5,6.98 C3.5,11.83 10,19 10,19 C10,19 16.5,11.83 16.5,6.98 C16.5,3.39 13.59,0.5 10,0.5 L10,0.5 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"6.8\" r=\"2.3\"/></svg>",
            "lock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" height=\"10\" width=\"13\" y=\"8.5\" x=\"3.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8 L6.5,4.88 C6.5,3.01 8.07,1.5 10,1.5 C11.93,1.5 13.5,3.01 13.5,4.88 L13.5,8\"/></svg>",
            "mail": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"1.4,6.5 10,11 18.6,6.5\"/><path d=\"M 1,4 1,16 19,16 19,4 1,4 Z M 18,15 2,15 2,5 18,5 18,15 Z\"/></svg>",
            "menu": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"2\" y=\"4\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"9\" width=\"16\" height=\"1\"/><rect x=\"2\" y=\"14\" width=\"16\" height=\"1\"/></svg>",
            "microphone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" x1=\"10\" x2=\"10\" y1=\"16.44\" y2=\"18.5\"/><line fill=\"none\" stroke=\"#000\" x1=\"7\" x2=\"13\" y1=\"18.5\" y2=\"18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M13.5 4.89v5.87a3.5 3.5 0 0 1-7 0V4.89a3.5 3.5 0 0 1 7 0z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M15.5 10.36V11a5.5 5.5 0 0 1-11 0v-.6\"/></svg>",
            "minus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
            "minus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect height=\"1\" width=\"18\" y=\"9\" x=\"1\"/></svg>",
            "more-vertical": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"3\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"17\" r=\"2\"/></svg>",
            "more": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3\" cy=\"10\" r=\"2\"/><circle cx=\"10\" cy=\"10\" r=\"2\"/><circle cx=\"17\" cy=\"10\" r=\"2\"/></svg>",
            "move": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"4,5 1,5 1,9 2,9 2,6 4,6\"/><polygon points=\"1,16 2,16 2,18 4,18 4,19 1,19\"/><polygon points=\"14,16 14,19 11,19 11,18 13,18 13,16\"/><rect fill=\"none\" stroke=\"#000\" x=\"5.5\" y=\"1.5\" width=\"13\" height=\"13\"/><rect x=\"1\" y=\"11\" width=\"1\" height=\"3\"/><rect x=\"6\" y=\"18\" width=\"3\" height=\"1\"/></svg>",
            "nut": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"2.5,5.7 10,1.3 17.5,5.7 17.5,14.3 10,18.7 2.5,14.3\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10\" r=\"3.5\"/></svg>",
            "pagekit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"3,1 17,1 17,16 10,16 10,13 14,13 14,4 6,4 6,16 10,16 10,19 3,19\"/></svg>",
            "paint-bucket": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 L0,11.21 L8.1,19.31 L18.31,9.1 L10.21,1 L10.21,1 Z M16.89,9.1 L15,11 L1.7,11 L10.21,2.42 L16.89,9.1 Z\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M6.42,2.33 L11.7,7.61\"/><path d=\"M18.49,12 C18.49,12 20,14.06 20,15.36 C20,16.28 19.24,17 18.49,17 L18.49,17 C17.74,17 17,16.28 17,15.36 C17,14.06 18.49,12 18.49,12 L18.49,12 Z\"/></svg>",
            "pencil": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17.25,6.01 L7.12,16.1 L3.82,17.2 L5.02,13.9 L15.12,3.88 C15.71,3.29 16.66,3.29 17.25,3.88 C17.83,4.47 17.83,5.42 17.25,6.01 L17.25,6.01 Z\"/><path fill=\"none\" stroke=\"#000\" d=\"M15.98,7.268 L13.851,5.148\"/></svg>",
            "phone-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M17,5.5 C17.8,5.5 18.5,6.2 18.5,7 L18.5,14 C18.5,14.8 17.8,15.5 17,15.5 L3,15.5 C2.2,15.5 1.5,14.8 1.5,14 L1.5,7 C1.5,6.2 2.2,5.5 3,5.5 L17,5.5 L17,5.5 L17,5.5 Z\"/><circle cx=\"3.8\" cy=\"10.5\" r=\".8\"/></svg>",
            "phone": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M15.5,17 C15.5,17.8 14.8,18.5 14,18.5 L7,18.5 C6.2,18.5 5.5,17.8 5.5,17 L5.5,3 C5.5,2.2 6.2,1.5 7,1.5 L14,1.5 C14.8,1.5 15.5,2.2 15.5,3 L15.5,17 L15.5,17 L15.5,17 Z\"/><circle cx=\"10.5\" cy=\"16.5\" r=\".8\"/></svg>",
            "pinterest": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.21,1 C5.5,1 3,4.16 3,7.61 C3,9.21 3.85,11.2 5.22,11.84 C5.43,11.94 5.54,11.89 5.58,11.69 C5.62,11.54 5.8,10.8 5.88,10.45 C5.91,10.34 5.89,10.24 5.8,10.14 C5.36,9.59 5,8.58 5,7.65 C5,5.24 6.82,2.91 9.93,2.91 C12.61,2.91 14.49,4.74 14.49,7.35 C14.49,10.3 13,12.35 11.06,12.35 C9.99,12.35 9.19,11.47 9.44,10.38 C9.75,9.08 10.35,7.68 10.35,6.75 C10.35,5.91 9.9,5.21 8.97,5.21 C7.87,5.21 6.99,6.34 6.99,7.86 C6.99,8.83 7.32,9.48 7.32,9.48 C7.32,9.48 6.24,14.06 6.04,14.91 C5.7,16.35 6.08,18.7 6.12,18.9 C6.14,19.01 6.26,19.05 6.33,18.95 C6.44,18.81 7.74,16.85 8.11,15.44 C8.24,14.93 8.79,12.84 8.79,12.84 C9.15,13.52 10.19,14.09 11.29,14.09 C14.58,14.09 16.96,11.06 16.96,7.3 C16.94,3.7 14,1 10.21,1\"/></svg>",
            "play-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" points=\"8.5 7 13.5 10 8.5 13\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/></svg>",
            "play": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"6.5,5 14.5,10 6.5,15\"/></svg>",
            "plus-circle": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.5\" cy=\"9.5\" r=\"9\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"5\" x2=\"9.5\" y2=\"14\"/><line fill=\"none\" stroke=\"#000\" x1=\"5\" y1=\"9.5\" x2=\"14\" y2=\"9.5\"/></svg>",
            "plus": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"9\" y=\"1\" width=\"1\" height=\"17\"/><rect x=\"1\" y=\"9\" width=\"17\" height=\"1\"/></svg>",
            "print": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 13.5 1.5 13.5 1.5 6.5 18.5 6.5 18.5 13.5 15.5 13.5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"15.5 6.5 15.5 2.5 4.5 2.5 4.5 6.5\"/><rect fill=\"none\" stroke=\"#000\" width=\"11\" height=\"6\" x=\"4.5\" y=\"11.5\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"13\"/><rect width=\"8\" height=\"1\" x=\"6\" y=\"15\"/></svg>",
            "pull": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"6.85,8 9.5,10.6 12.15,8 12.85,8.7 9.5,12 6.15,8.7\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"11\" x2=\"9.5\" y2=\"2\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6,5.5 3.5,5.5 3.5,18.5 15.5,18.5 15.5,5.5 13,5.5\"/></svg>",
            "push": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12.15,4 9.5,1.4 6.85,4 6.15,3.3 9.5,0 12.85,3.3\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"10\" x2=\"9.5\" y2=\"1\"/><polyline fill=\"none\" stroke=\"#000\" points=\"6 5.5 3.5 5.5 3.5 18.5 15.5 18.5 15.5 5.5 13 5.5\"/></svg>",
            "question": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><circle cx=\"10.44\" cy=\"14.42\" r=\"1.05\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.2\" d=\"M8.17,7.79 C8.17,4.75 12.72,4.73 12.72,7.72 C12.72,8.67 11.81,9.15 11.23,9.75 C10.75,10.24 10.51,10.73 10.45,11.4 C10.44,11.53 10.43,11.64 10.43,11.75\"/></svg>",
            "quote-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.27,7.79 C17.27,9.45 16.97,10.43 15.99,12.02 C14.98,13.64 13,15.23 11.56,15.97 L11.1,15.08 C12.34,14.2 13.14,13.51 14.02,11.82 C14.27,11.34 14.41,10.92 14.49,10.54 C14.3,10.58 14.09,10.6 13.88,10.6 C12.06,10.6 10.59,9.12 10.59,7.3 C10.59,5.48 12.06,4 13.88,4 C15.39,4 16.67,5.02 17.05,6.42 C17.19,6.82 17.27,7.27 17.27,7.79 L17.27,7.79 Z\"/><path d=\"M8.68,7.79 C8.68,9.45 8.38,10.43 7.4,12.02 C6.39,13.64 4.41,15.23 2.97,15.97 L2.51,15.08 C3.75,14.2 4.55,13.51 5.43,11.82 C5.68,11.34 5.82,10.92 5.9,10.54 C5.71,10.58 5.5,10.6 5.29,10.6 C3.47,10.6 2,9.12 2,7.3 C2,5.48 3.47,4 5.29,4 C6.8,4 8.08,5.02 8.46,6.42 C8.6,6.82 8.68,7.27 8.68,7.79 L8.68,7.79 Z\"/></svg>",
            "receiver": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" d=\"M6.189,13.611C8.134,15.525 11.097,18.239 13.867,18.257C16.47,18.275 18.2,16.241 18.2,16.241L14.509,12.551L11.539,13.639L6.189,8.29L7.313,5.355L3.76,1.8C3.76,1.8 1.732,3.537 1.7,6.092C1.667,8.809 4.347,11.738 6.189,13.611\"/></svg>",
            "reddit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19 9.05a2.56 2.56 0 0 0-2.56-2.56 2.59 2.59 0 0 0-1.88.82 10.63 10.63 0 0 0-4.14-1v-.08c.58-1.62 1.58-3.89 2.7-4.1.38-.08.77.12 1.19.57a1.15 1.15 0 0 0-.06.37 1.48 1.48 0 1 0 1.51-1.45 1.43 1.43 0 0 0-.76.19A2.29 2.29 0 0 0 12.91 1c-2.11.43-3.39 4.38-3.63 5.19 0 0 0 .11-.06.11a10.65 10.65 0 0 0-3.75 1A2.56 2.56 0 0 0 1 9.05a2.42 2.42 0 0 0 .72 1.76A5.18 5.18 0 0 0 1.24 13c0 3.66 3.92 6.64 8.73 6.64s8.74-3 8.74-6.64a5.23 5.23 0 0 0-.46-2.13A2.58 2.58 0 0 0 19 9.05zm-16.88 0a1.44 1.44 0 0 1 2.27-1.19 7.68 7.68 0 0 0-2.07 1.91 1.33 1.33 0 0 1-.2-.72zM10 18.4c-4.17 0-7.55-2.4-7.55-5.4S5.83 7.53 10 7.53 17.5 10 17.5 13s-3.38 5.4-7.5 5.4zm7.69-8.61a7.62 7.62 0 0 0-2.09-1.91 1.41 1.41 0 0 1 .84-.28 1.47 1.47 0 0 1 1.44 1.45 1.34 1.34 0 0 1-.21.72z\"/><path d=\"M6.69 12.58a1.39 1.39 0 1 1 1.39-1.39 1.38 1.38 0 0 1-1.38 1.39z\"/><path d=\"M14.26 11.2a1.39 1.39 0 1 1-1.39-1.39 1.39 1.39 0 0 1 1.39 1.39z\"/><path d=\"M13.09 14.88a.54.54 0 0 1-.09.77 5.3 5.3 0 0 1-3.26 1.19 5.61 5.61 0 0 1-3.4-1.22.55.55 0 1 1 .73-.83 4.09 4.09 0 0 0 5.25 0 .56.56 0 0 1 .77.09z\"/></svg>",
            "refresh": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.08,11.15 C17.09,11.31 17.1,11.47 17.1,11.64 C17.1,15.53 13.94,18.69 10.05,18.69 C6.16,18.68 3,15.53 3,11.63 C3,7.74 6.16,4.58 10.05,4.58 C10.9,4.58 11.71,4.73 12.46,5\"/><polyline fill=\"none\" stroke=\"#000\" points=\"9.9 2 12.79 4.89 9.79 7.9\"/></svg>",
            "reply": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.7,13.11 C16.12,10.02 13.84,7.85 11.02,6.61 C10.57,6.41 9.75,6.13 9,5.91 L9,2 L1,9 L9,16 L9,12.13 C10.78,12.47 12.5,13.19 14.09,14.25 C17.13,16.28 18.56,18.54 18.56,18.54 C18.56,18.54 18.81,15.28 17.7,13.11 L17.7,13.11 Z M14.82,13.53 C13.17,12.4 11.01,11.4 8,10.92 L8,13.63 L2.55,9 L8,4.25 L8,6.8 C8.3,6.86 9.16,7.02 10.37,7.49 C13.3,8.65 15.54,10.96 16.65,13.08 C16.97,13.7 17.48,14.86 17.68,16 C16.87,15.05 15.73,14.15 14.82,13.53 L14.82,13.53 Z\"/></svg>",
            "rss": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"3.12\" cy=\"16.8\" r=\"1.85\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,8.2 C1.78,8.18 2.06,8.16 2.35,8.16 C7.57,8.16 11.81,12.37 11.81,17.57 C11.81,17.89 11.79,18.19 11.76,18.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,2.52 C1.78,2.51 2.06,2.5 2.35,2.5 C10.72,2.5 17.5,9.24 17.5,17.57 C17.5,17.89 17.49,18.19 17.47,18.5\"/></svg>",
            "search": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9\" cy=\"9\" r=\"7\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M14,14 L18,18 L14,14 Z\"/></svg>",
            "server": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"3\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"7\" y=\"3\" width=\"1\" height=\"2\"/><rect x=\"16\" y=\"3\" width=\"1\" height=\"1\"/><rect x=\"16\" y=\"10\" width=\"1\" height=\"1\"/><circle fill=\"none\" stroke=\"#000\" cx=\"9.9\" cy=\"17.4\" r=\"1.4\"/><rect x=\"3\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"5\" y=\"10\" width=\"1\" height=\"2\"/><rect x=\"9.5\" y=\"14\" width=\"1\" height=\"2\"/><rect x=\"3\" y=\"17\" width=\"6\" height=\"1\"/><rect x=\"11\" y=\"17\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"1.5\" width=\"17\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"1.5\" y=\"8.5\" width=\"17\" height=\"5\"/></svg>",
            "settings": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"3.55\" rx=\"2.11\" ry=\"2.15\"/><ellipse fill=\"none\" stroke=\"#000\" cx=\"6.11\" cy=\"15.55\" rx=\"2.11\" ry=\"2.15\"/><circle fill=\"none\" stroke=\"#000\" cx=\"13.15\" cy=\"9.55\" r=\"2.15\"/><rect x=\"1\" y=\"3\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"3\" width=\"8\" height=\"1\"/><rect x=\"1\" y=\"9\" width=\"8\" height=\"1\"/><rect x=\"15\" y=\"9\" width=\"3\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"3\" height=\"1\"/><rect x=\"10\" y=\"15\" width=\"8\" height=\"1\"/></svg>",
            "shrink": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"11 4 12 4 12 8 16 8 16 9 11 9\"/><polygon points=\"4 11 9 11 9 16 8 16 8 12 4 12\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M12,8 L18,2\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M2,18 L8,12\"/></svg>",
            "sign-in": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"7 2 17 2 17 17 7 17 7 16 16 16 16 3 7 3\"/><polygon points=\"9.1 13.4 8.5 12.8 11.28 10 4 10 4 9 11.28 9 8.5 6.2 9.1 5.62 13 9.5\"/></svg>",
            "sign-out": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"13.1 13.4 12.5 12.8 15.28 10 8 10 8 9 15.28 9 12.5 6.2 13.1 5.62 17 9.5\"/><polygon points=\"13 2 3 2 3 17 13 17 13 16 4 16 4 3 13 3\"/></svg>",
            "social": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.4\" y1=\"14\" x2=\"6.3\" y2=\"10.7\"/><line fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" x1=\"13.5\" y1=\"5.5\" x2=\"6.5\" y2=\"8.8\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"4.6\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"15.5\" cy=\"14.8\" r=\"2.3\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"4.5\" cy=\"9.8\" r=\"2.3\"/></svg>",
            "soundcloud": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.2,9.4c-0.4,0-0.8,0.1-1.101,0.2c-0.199-2.5-2.399-4.5-5-4.5c-0.6,0-1.2,0.1-1.7,0.3C9.2,5.5,9.1,5.6,9.1,5.6V15h8 c1.601,0,2.801-1.2,2.801-2.8C20,10.7,18.7,9.4,17.2,9.4L17.2,9.4z\"/><rect x=\"6\" y=\"6.5\" width=\"1.5\" height=\"8.5\"/><rect x=\"3\" y=\"8\" width=\"1.5\" height=\"7\"/><rect y=\"10\" width=\"1.5\" height=\"5\"/></svg>",
            "star": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" stroke-width=\"1.01\" points=\"10 2 12.63 7.27 18.5 8.12 14.25 12.22 15.25 18 10 15.27 4.75 18 5.75 12.22 1.5 8.12 7.37 7.27\"/></svg>",
            "strikethrough": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6,13.02 L6.65,13.02 C7.64,15.16 8.86,16.12 10.41,16.12 C12.22,16.12 12.92,14.93 12.92,13.89 C12.92,12.55 11.99,12.03 9.74,11.23 C8.05,10.64 6.23,10.11 6.23,7.83 C6.23,5.5 8.09,4.09 10.4,4.09 C11.44,4.09 12.13,4.31 12.72,4.54 L13.33,4 L13.81,4 L13.81,7.59 L13.16,7.59 C12.55,5.88 11.52,4.89 10.07,4.89 C8.84,4.89 7.89,5.69 7.89,7.03 C7.89,8.29 8.89,8.78 10.88,9.45 C12.57,10.03 14.38,10.6 14.38,12.91 C14.38,14.75 13.27,16.93 10.18,16.93 C9.18,16.93 8.17,16.69 7.46,16.39 L6.52,17 L6,17 L6,13.02 L6,13.02 Z\"/><rect x=\"3\" y=\"10\" width=\"15\" height=\"1\"/></svg>",
            "table": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"1\" y=\"3\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"7\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"11\" width=\"18\" height=\"1\"/><rect x=\"1\" y=\"15\" width=\"18\" height=\"1\"/></svg>",
            "tablet-landscape": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1.5,5 C1.5,4.2 2.2,3.5 3,3.5 L17,3.5 C17.8,3.5 18.5,4.2 18.5,5 L18.5,16 C18.5,16.8 17.8,17.5 17,17.5 L3,17.5 C2.2,17.5 1.5,16.8 1.5,16 L1.5,5 L1.5,5 L1.5,5 Z\"/><circle cx=\"3.7\" cy=\"10.5\" r=\".8\"/></svg>",
            "tablet": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M5,18.5 C4.2,18.5 3.5,17.8 3.5,17 L3.5,3 C3.5,2.2 4.2,1.5 5,1.5 L16,1.5 C16.8,1.5 17.5,2.2 17.5,3 L17.5,17 C17.5,17.8 16.8,18.5 16,18.5 L5,18.5 L5,18.5 L5,18.5 Z\"/><circle cx=\"10.5\" cy=\"16.3\" r=\".8\"/></svg>",
            "tag": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M17.5,3.71 L17.5,7.72 C17.5,7.96 17.4,8.2 17.21,8.39 L8.39,17.2 C7.99,17.6 7.33,17.6 6.93,17.2 L2.8,13.07 C2.4,12.67 2.4,12.01 2.8,11.61 L11.61,2.8 C11.81,2.6 12.08,2.5 12.34,2.5 L16.19,2.5 C16.52,2.5 16.86,2.63 17.11,2.88 C17.35,3.11 17.48,3.4 17.5,3.71 L17.5,3.71 Z\"/><circle cx=\"14\" cy=\"6\" r=\"1\"/></svg>",
            "thumbnails": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"3.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"11.5\" y=\"11.5\" width=\"5\" height=\"5\"/><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"11.5\" width=\"5\" height=\"5\"/></svg>",
            "tiktok": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.24,6V8.82a6.79,6.79,0,0,1-4-1.28v5.81A5.26,5.26,0,1,1,8,8.1a4.36,4.36,0,0,1,.72.05v2.9A2.57,2.57,0,0,0,7.64,11a2.4,2.4,0,1,0,2.77,2.38V2h2.86a4,4,0,0,0,1.84,3.38A4,4,0,0,0,17.24,6Z\"/></svg>",
            "trash": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"6.5 3 6.5 1.5 13.5 1.5 13.5 3\"/><polyline fill=\"none\" stroke=\"#000\" points=\"4.5 4 4.5 18.5 15.5 18.5 15.5 4\"/><rect x=\"8\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"11\" y=\"7\" width=\"1\" height=\"9\"/><rect x=\"2\" y=\"3\" width=\"16\" height=\"1\"/></svg>",
            "triangle-down": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 7 15 7 10 12\"/></svg>",
            "triangle-left": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"12 5 7 10 12 15\"/></svg>",
            "triangle-right": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"8 5 13 10 8 15\"/></svg>",
            "triangle-up": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"5 13 10 8 15 13\"/></svg>",
            "tripadvisor": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19.021,7.866C19.256,6.862,20,5.854,20,5.854h-3.346C14.781,4.641,12.504,4,9.98,4C7.363,4,4.999,4.651,3.135,5.876H0\tc0,0,0.738,0.987,0.976,1.988c-0.611,0.837-0.973,1.852-0.973,2.964c0,2.763,2.249,5.009,5.011,5.009\tc1.576,0,2.976-0.737,3.901-1.879l1.063,1.599l1.075-1.615c0.475,0.611,1.1,1.111,1.838,1.451c1.213,0.547,2.574,0.612,3.825,0.15\tc2.589-0.963,3.913-3.852,2.964-6.439c-0.175-0.463-0.4-0.876-0.675-1.238H19.021z M16.38,14.594\tc-1.002,0.371-2.088,0.328-3.06-0.119c-0.688-0.317-1.252-0.817-1.657-1.438c-0.164-0.25-0.313-0.52-0.417-0.811\tc-0.124-0.328-0.186-0.668-0.217-1.014c-0.063-0.689,0.037-1.396,0.339-2.043c0.448-0.971,1.251-1.71,2.25-2.079\tc2.075-0.765,4.375,0.3,5.14,2.366c0.762,2.066-0.301,4.37-2.363,5.134L16.38,14.594L16.38,14.594z M8.322,13.066\tc-0.72,1.059-1.935,1.76-3.309,1.76c-2.207,0-4.001-1.797-4.001-3.996c0-2.203,1.795-4.002,4.001-4.002\tc2.204,0,3.999,1.8,3.999,4.002c0,0.137-0.024,0.261-0.04,0.396c-0.067,0.678-0.284,1.313-0.648,1.853v-0.013H8.322z M2.472,10.775\tc0,1.367,1.112,2.479,2.476,2.479c1.363,0,2.472-1.11,2.472-2.479c0-1.359-1.11-2.468-2.472-2.468\tC3.584,8.306,2.473,9.416,2.472,10.775L2.472,10.775z M12.514,10.775c0,1.367,1.104,2.479,2.471,2.479\tc1.363,0,2.474-1.108,2.474-2.479c0-1.359-1.11-2.468-2.474-2.468c-1.364,0-2.477,1.109-2.477,2.468H12.514z M3.324,10.775\tc0-0.893,0.726-1.618,1.614-1.618c0.889,0,1.625,0.727,1.625,1.618c0,0.898-0.725,1.627-1.625,1.627\tc-0.901,0-1.625-0.729-1.625-1.627H3.324z M13.354,10.775c0-0.893,0.726-1.618,1.627-1.618c0.886,0,1.61,0.727,1.61,1.618\tc0,0.898-0.726,1.627-1.626,1.627s-1.625-0.729-1.625-1.627H13.354z M9.977,4.875c1.798,0,3.425,0.324,4.849,0.968\tc-0.535,0.015-1.061,0.108-1.586,0.3c-1.264,0.463-2.264,1.388-2.815,2.604c-0.262,0.551-0.398,1.133-0.448,1.72\tC9.79,7.905,7.677,5.873,5.076,5.82C6.501,5.208,8.153,4.875,9.94,4.875H9.977z\"/></svg>",
            "tumblr": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.885,8.598c0,0,0,3.393,0,4.996c0,0.282,0,0.66,0.094,0.942c0.377,1.509,1.131,2.545,2.545,3.11 c1.319,0.472,2.356,0.472,3.676,0c0.565-0.188,1.132-0.659,1.132-0.659l-0.849-2.263c0,0-1.036,0.378-1.603,0.283 c-0.565-0.094-1.226-0.66-1.226-1.508c0-1.603,0-4.902,0-4.902h2.828V5.771h-2.828V2H8.205c0,0-0.094,0.66-0.188,0.942 C7.828,3.791,7.262,4.733,6.603,5.394C5.848,6.147,5,6.43,5,6.43v2.168H6.885z\"/></svg>",
            "tv": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect x=\"7\" y=\"16\" width=\"6\" height=\"1\"/><rect fill=\"none\" stroke=\"#000\" x=\".5\" y=\"3.5\" width=\"19\" height=\"11\"/></svg>",
            "twitch": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.23,1,2,4.23V15.85H5.88v3.23L9.1,15.85h2.59L17.5,10V1Zm11,8.4L13.62,12H11L8.78,14.24V12H5.88V2.29H16.21Z\"/><rect x=\"12.98\" y=\"4.55\" width=\"1.29\" height=\"3.88\"/><rect x=\"9.43\" y=\"4.55\" width=\"1.29\" height=\"3.88\"/></svg>",
            "twitter": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M19,4.74 C18.339,5.029 17.626,5.229 16.881,5.32 C17.644,4.86 18.227,4.139 18.503,3.28 C17.79,3.7 17.001,4.009 16.159,4.17 C15.485,3.45 14.526,3 13.464,3 C11.423,3 9.771,4.66 9.771,6.7 C9.771,6.99 9.804,7.269 9.868,7.539 C6.795,7.38 4.076,5.919 2.254,3.679 C1.936,4.219 1.754,4.86 1.754,5.539 C1.754,6.82 2.405,7.95 3.397,8.61 C2.79,8.589 2.22,8.429 1.723,8.149 L1.723,8.189 C1.723,9.978 2.997,11.478 4.686,11.82 C4.376,11.899 4.049,11.939 3.713,11.939 C3.475,11.939 3.245,11.919 3.018,11.88 C3.49,13.349 4.852,14.419 6.469,14.449 C5.205,15.429 3.612,16.019 1.882,16.019 C1.583,16.019 1.29,16.009 1,15.969 C2.635,17.019 4.576,17.629 6.662,17.629 C13.454,17.629 17.17,12 17.17,7.129 C17.17,6.969 17.166,6.809 17.157,6.649 C17.879,6.129 18.504,5.478 19,4.74\"/></svg>",
            "uikit": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon points=\"14.4,3.1 11.3,5.1 15,7.3 15,12.9 10,15.7 5,12.9 5,8.5 2,6.8 2,14.8 9.9,19.5 18,14.8 18,5.3\"/><polygon points=\"9.8,4.2 6.7,2.4 9.8,0.4 12.9,2.3\"/></svg>",
            "unlock": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><rect fill=\"none\" stroke=\"#000\" x=\"3.5\" y=\"8.5\" width=\"13\" height=\"10\"/><path fill=\"none\" stroke=\"#000\" d=\"M6.5,8.5 L6.5,4.9 C6.5,3 8.1,1.5 10,1.5 C11.9,1.5 13.5,3 13.5,4.9\"/></svg>",
            "upload": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline fill=\"none\" stroke=\"#000\" points=\"5 8 9.5 3.5 14 8\"/><rect x=\"3\" y=\"17\" width=\"13\" height=\"1\"/><line fill=\"none\" stroke=\"#000\" x1=\"9.5\" y1=\"15\" x2=\"9.5\" y2=\"4\"/></svg>",
            "user": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"9.9\" cy=\"6.4\" r=\"4.4\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1.5,19 C2.3,14.5 5.8,11.2 10,11.2 C14.2,11.2 17.7,14.6 18.5,19.2\"/></svg>",
            "users": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"7.7\" cy=\"8.6\" r=\"3.5\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M1,18.1 C1.7,14.6 4.4,12.1 7.6,12.1 C10.9,12.1 13.7,14.8 14.3,18.3\"/><path fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" d=\"M11.4,4 C12.8,2.4 15.4,2.8 16.3,4.7 C17.2,6.6 15.7,8.9 13.6,8.9 C16.5,8.9 18.8,11.3 19.2,14.1\"/></svg>",
            "video-camera": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><polygon fill=\"none\" stroke=\"#000\" points=\"17.5 6.9 17.5 13.1 13.5 10.4 13.5 14.5 2.5 14.5 2.5 5.5 13.5 5.5 13.5 9.6 17.5 6.9\"/></svg>",
            "vimeo": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.065,7.59C1.84,7.367,1.654,7.082,1.468,6.838c-0.332-0.42-0.137-0.411,0.274-0.772c1.026-0.91,2.004-1.896,3.127-2.688 c1.017-0.713,2.365-1.173,3.286-0.039c0.849,1.045,0.869,2.629,1.084,3.891c0.215,1.309,0.421,2.648,0.88,3.901 c0.127,0.352,0.37,1.018,0.81,1.074c0.567,0.078,1.145-0.917,1.408-1.289c0.684-0.987,1.611-2.317,1.494-3.587 c-0.115-1.349-1.572-1.095-2.482-0.773c0.146-1.514,1.555-3.216,2.912-3.792c1.439-0.597,3.579-0.587,4.302,1.036 c0.772,1.759,0.078,3.802-0.763,5.396c-0.918,1.731-2.1,3.333-3.363,4.829c-1.114,1.329-2.432,2.787-4.093,3.422 c-1.897,0.723-3.021-0.686-3.667-2.318c-0.705-1.777-1.056-3.771-1.565-5.621C4.898,8.726,4.644,7.836,4.136,7.191 C3.473,6.358,2.72,7.141,2.065,7.59C1.977,7.502,2.115,7.551,2.065,7.59L2.065,7.59z\"/></svg>",
            "warning": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"10\" cy=\"14\" r=\"1\"/><circle fill=\"none\" stroke=\"#000\" stroke-width=\"1.1\" cx=\"10\" cy=\"10\" r=\"9\"/><path d=\"M10.97,7.72 C10.85,9.54 10.56,11.29 10.56,11.29 C10.51,11.87 10.27,12 9.99,12 C9.69,12 9.49,11.87 9.43,11.29 C9.43,11.29 9.16,9.54 9.03,7.72 C8.96,6.54 9.03,6 9.03,6 C9.03,5.45 9.46,5.02 9.99,5 C10.53,5.01 10.97,5.44 10.97,6 C10.97,6 11.04,6.54 10.97,7.72 L10.97,7.72 Z\"/></svg>",
            "whatsapp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M16.7,3.3c-1.8-1.8-4.1-2.8-6.7-2.8c-5.2,0-9.4,4.2-9.4,9.4c0,1.7,0.4,3.3,1.3,4.7l-1.3,4.9l5-1.3c1.4,0.8,2.9,1.2,4.5,1.2 l0,0l0,0c5.2,0,9.4-4.2,9.4-9.4C19.5,7.4,18.5,5,16.7,3.3 M10.1,17.7L10.1,17.7c-1.4,0-2.8-0.4-4-1.1l-0.3-0.2l-3,0.8l0.8-2.9 l-0.2-0.3c-0.8-1.2-1.2-2.7-1.2-4.2c0-4.3,3.5-7.8,7.8-7.8c2.1,0,4.1,0.8,5.5,2.3c1.5,1.5,2.3,3.4,2.3,5.5 C17.9,14.2,14.4,17.7,10.1,17.7 M14.4,11.9c-0.2-0.1-1.4-0.7-1.6-0.8c-0.2-0.1-0.4-0.1-0.5,0.1c-0.2,0.2-0.6,0.8-0.8,0.9 c-0.1,0.2-0.3,0.2-0.5,0.1c-0.2-0.1-1-0.4-1.9-1.2c-0.7-0.6-1.2-1.4-1.3-1.6c-0.1-0.2,0-0.4,0.1-0.5C8,8.8,8.1,8.7,8.2,8.5 c0.1-0.1,0.2-0.2,0.2-0.4c0.1-0.2,0-0.3,0-0.4C8.4,7.6,7.9,6.5,7.7,6C7.5,5.5,7.3,5.6,7.2,5.6c-0.1,0-0.3,0-0.4,0 c-0.2,0-0.4,0.1-0.6,0.3c-0.2,0.2-0.8,0.8-0.8,2c0,1.2,0.8,2.3,1,2.4c0.1,0.2,1.7,2.5,4,3.5c0.6,0.2,1,0.4,1.3,0.5 c0.6,0.2,1.1,0.2,1.5,0.1c0.5-0.1,1.4-0.6,1.6-1.1c0.2-0.5,0.2-1,0.1-1.1C14.8,12.1,14.6,12,14.4,11.9\"/></svg>",
            "wordpress": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10,0.5c-5.2,0-9.5,4.3-9.5,9.5s4.3,9.5,9.5,9.5c5.2,0,9.5-4.3,9.5-9.5S15.2,0.5,10,0.5L10,0.5L10,0.5z M15.6,3.9h-0.1 c-0.8,0-1.4,0.7-1.4,1.5c0,0.7,0.4,1.3,0.8,1.9c0.3,0.6,0.7,1.3,0.7,2.3c0,0.7-0.3,1.5-0.6,2.7L14.1,15l-3-8.9 c0.5,0,0.9-0.1,0.9-0.1C12.5,6,12.5,5.3,12,5.4c0,0-1.3,0.1-2.2,0.1C9,5.5,7.7,5.4,7.7,5.4C7.2,5.3,7.2,6,7.6,6c0,0,0.4,0.1,0.9,0.1 l1.3,3.5L8,15L5,6.1C5.5,6.1,5.9,6,5.9,6C6.4,6,6.3,5.3,5.9,5.4c0,0-1.3,0.1-2.2,0.1c-0.2,0-0.3,0-0.5,0c1.5-2.2,4-3.7,6.9-3.7 C12.2,1.7,14.1,2.6,15.6,3.9L15.6,3.9L15.6,3.9z M2.5,6.6l3.9,10.8c-2.7-1.3-4.6-4.2-4.6-7.4C1.8,8.8,2,7.6,2.5,6.6L2.5,6.6L2.5,6.6 z M10.2,10.7l2.5,6.9c0,0,0,0.1,0.1,0.1C11.9,18,11,18.2,10,18.2c-0.8,0-1.6-0.1-2.3-0.3L10.2,10.7L10.2,10.7L10.2,10.7z M14.2,17.1 l2.5-7.3c0.5-1.2,0.6-2.1,0.6-2.9c0-0.3,0-0.6-0.1-0.8c0.6,1.2,1,2.5,1,4C18.3,13,16.6,15.7,14.2,17.1L14.2,17.1L14.2,17.1z\"/></svg>",
            "world": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path fill=\"none\" stroke=\"#000\" d=\"M1,10.5 L19,10.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,15.5 L17.65,15.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M2.35,5.5 L17.523,5.5\"/><path fill=\"none\" stroke=\"#000\" d=\"M10,19.46 L9.98,19.46 C7.31,17.33 5.61,14.141 5.61,10.58 C5.61,7.02 7.33,3.83 10,1.7 C10.01,1.7 9.99,1.7 10,1.7 L10,1.7 C12.67,3.83 14.4,7.02 14.4,10.58 C14.4,14.141 12.67,17.33 10,19.46 L10,19.46 L10,19.46 L10,19.46 Z\"/><circle fill=\"none\" stroke=\"#000\" cx=\"10\" cy=\"10.5\" r=\"9\"/></svg>",
            "xing": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4.4,4.56 C4.24,4.56 4.11,4.61 4.05,4.72 C3.98,4.83 3.99,4.97 4.07,5.12 L5.82,8.16 L5.82,8.17 L3.06,13.04 C2.99,13.18 2.99,13.33 3.06,13.44 C3.12,13.55 3.24,13.62 3.4,13.62 L6,13.62 C6.39,13.62 6.57,13.36 6.71,13.12 C6.71,13.12 9.41,8.35 9.51,8.16 C9.49,8.14 7.72,5.04 7.72,5.04 C7.58,4.81 7.39,4.56 6.99,4.56 L4.4,4.56 L4.4,4.56 Z\"/><path d=\"M15.3,1 C14.91,1 14.74,1.25 14.6,1.5 C14.6,1.5 9.01,11.42 8.82,11.74 C8.83,11.76 12.51,18.51 12.51,18.51 C12.64,18.74 12.84,19 13.23,19 L15.82,19 C15.98,19 16.1,18.94 16.16,18.83 C16.23,18.72 16.23,18.57 16.16,18.43 L12.5,11.74 L12.5,11.72 L18.25,1.56 C18.32,1.42 18.32,1.27 18.25,1.16 C18.21,1.06 18.08,1 17.93,1 L15.3,1 L15.3,1 Z\"/></svg>",
            "yelp": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M17.175,14.971c-0.112,0.77-1.686,2.767-2.406,3.054c-0.246,0.1-0.487,0.076-0.675-0.069\tc-0.122-0.096-2.446-3.859-2.446-3.859c-0.194-0.293-0.157-0.682,0.083-0.978c0.234-0.284,0.581-0.393,0.881-0.276\tc0.016,0.01,4.21,1.394,4.332,1.482c0.178,0.148,0.263,0.379,0.225,0.646L17.175,14.971L17.175,14.971z M11.464,10.789\tc-0.203-0.307-0.199-0.666,0.009-0.916c0,0,2.625-3.574,2.745-3.657c0.203-0.135,0.452-0.141,0.69-0.025\tc0.691,0.335,2.085,2.405,2.167,3.199v0.027c0.024,0.271-0.082,0.491-0.273,0.623c-0.132,0.083-4.43,1.155-4.43,1.155\tc-0.322,0.096-0.68-0.06-0.882-0.381L11.464,10.789z M9.475,9.563C9.32,9.609,8.848,9.757,8.269,8.817c0,0-3.916-6.16-4.007-6.351\tc-0.057-0.212,0.011-0.455,0.202-0.65C5.047,1.211,8.21,0.327,9.037,0.529c0.27,0.069,0.457,0.238,0.522,0.479\tc0.047,0.266,0.433,5.982,0.488,7.264C10.098,9.368,9.629,9.517,9.475,9.563z M9.927,19.066c-0.083,0.225-0.273,0.373-0.54,0.421\tc-0.762,0.13-3.15-0.751-3.647-1.342c-0.096-0.131-0.155-0.262-0.167-0.394c-0.011-0.095,0-0.189,0.036-0.272\tc0.061-0.155,2.917-3.538,2.917-3.538c0.214-0.272,0.595-0.355,0.952-0.213c0.345,0.13,0.56,0.428,0.536,0.749\tC10.014,14.479,9.977,18.923,9.927,19.066z M3.495,13.912c-0.235-0.009-0.444-0.148-0.568-0.382c-0.089-0.17-0.151-0.453-0.19-0.794\tC2.63,11.701,2.761,10.144,3.07,9.648c0.145-0.226,0.357-0.345,0.592-0.336c0.154,0,4.255,1.667,4.255,1.667\tc0.321,0.118,0.521,0.453,0.5,0.833c-0.023,0.37-0.236,0.655-0.551,0.738L3.495,13.912z\"/></svg>",
            "youtube": "<svg width=\"20\" height=\"20\" viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15,4.1c1,0.1,2.3,0,3,0.8c0.8,0.8,0.9,2.1,0.9,3.1C19,9.2,19,10.9,19,12c-0.1,1.1,0,2.4-0.5,3.4c-0.5,1.1-1.4,1.5-2.5,1.6 c-1.2,0.1-8.6,0.1-11,0c-1.1-0.1-2.4-0.1-3.2-1c-0.7-0.8-0.7-2-0.8-3C1,11.8,1,10.1,1,8.9c0-1.1,0-2.4,0.5-3.4C2,4.5,3,4.3,4.1,4.2 C5.3,4.1,12.6,4,15,4.1z M8,7.5v6l5.5-3L8,7.5z\"/></svg>"
        });

        }

        if (typeof window !== 'undefined' && window.UIkit) {
            window.UIkit.use(plugin);
        }

        return plugin;

    }));
    });

    var bind = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    // utils is a library of generic helper functions non-specific to axios

    var toString$2 = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray$1(val) {
      return toString$2.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined$1(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined$1(val) && val.constructor !== null && !isUndefined$1(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString$2.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString$1(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber$1(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject$2(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */
    function isPlainObject(val) {
      if (toString$2.call(val) !== '[object Object]') {
        return false;
      }

      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate$2(val) {
      return toString$2.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString$2.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString$2.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction$1(val) {
      return toString$2.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject$2(val) && isFunction$1(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim$1(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach$1(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray$1(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge$1(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge$1(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge$1({}, val);
        } else if (isArray$1(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach$1(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend$1(a, b, thisArg) {
      forEach$1(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */
    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    }

    var utils = {
      isArray: isArray$1,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString$1,
      isNumber: isNumber$1,
      isObject: isObject$2,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined$1,
      isDate: isDate$2,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction$1,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach$1,
      merge: merge$1,
      extend: extend$1,
      trim: trim$1,
      stripBOM: stripBOM
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        function onloadend() {
          if (!request) {
            return;
          }
          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
            request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        }

        if ('onloadend' in request) {
          // Use onloadend if available
          request.onloadend = onloadend;
        } else {
          // Listen for ready state to emulate onloadend
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
              return;
            }
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
          };
        }

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(
            timeoutErrorMessage,
            config,
            config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (responseType && responseType !== 'json') {
          request.responseType = config.responseType;
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (!requestData) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== 'SyntaxError') {
            throw e;
          }
        }
      }

      return (encoder || JSON.stringify)(rawValue);
    }

    var defaults$1 = {

      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },

      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');

        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {
          setContentTypeIfUnset(headers, 'application/json');
          return stringifySafely(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

        if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === 'SyntaxError') {
                throw enhanceError(e, this, 'E_JSON_PARSE');
              }
              throw e;
            }
          }
        }

        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,
      maxBodyLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults$1.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults$1.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults$1.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults$1;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      var context = this || defaults_1;
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      var valueFromConfig2Keys = ['url', 'method', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
      var defaultToConfig2Keys = [
        'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
        'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
      ];
      var directMergeKeys = ['validateStatus'];

      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }

      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      }

      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        }
      });

      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys)
        .concat(directMergeKeys);

      var otherKeys = Object
        .keys(config1)
        .concat(Object.keys(config2))
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

      utils.forEach(otherKeys, mergeDeepProperties);

      return config;
    };

    var name = "axios";
    var version$1 = "0.21.4";
    var description = "Promise based HTTP client for the browser and node.js";
    var main = "index.js";
    var scripts = {
    	test: "grunt test",
    	start: "node ./sandbox/server.js",
    	build: "NODE_ENV=production grunt build",
    	preversion: "npm test",
    	version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
    	postversion: "git push && git push --tags",
    	examples: "node ./examples/server.js",
    	coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
    	fix: "eslint --fix lib/**/*.js"
    };
    var repository = {
    	type: "git",
    	url: "https://github.com/axios/axios.git"
    };
    var keywords = [
    	"xhr",
    	"http",
    	"ajax",
    	"promise",
    	"node"
    ];
    var author = "Matt Zabriskie";
    var license = "MIT";
    var bugs = {
    	url: "https://github.com/axios/axios/issues"
    };
    var homepage = "https://axios-http.com";
    var devDependencies = {
    	coveralls: "^3.0.0",
    	"es6-promise": "^4.2.4",
    	grunt: "^1.3.0",
    	"grunt-banner": "^0.6.0",
    	"grunt-cli": "^1.2.0",
    	"grunt-contrib-clean": "^1.1.0",
    	"grunt-contrib-watch": "^1.0.0",
    	"grunt-eslint": "^23.0.0",
    	"grunt-karma": "^4.0.0",
    	"grunt-mocha-test": "^0.13.3",
    	"grunt-ts": "^6.0.0-beta.19",
    	"grunt-webpack": "^4.0.2",
    	"istanbul-instrumenter-loader": "^1.0.0",
    	"jasmine-core": "^2.4.1",
    	karma: "^6.3.2",
    	"karma-chrome-launcher": "^3.1.0",
    	"karma-firefox-launcher": "^2.1.0",
    	"karma-jasmine": "^1.1.1",
    	"karma-jasmine-ajax": "^0.1.13",
    	"karma-safari-launcher": "^1.0.0",
    	"karma-sauce-launcher": "^4.3.6",
    	"karma-sinon": "^1.0.5",
    	"karma-sourcemap-loader": "^0.3.8",
    	"karma-webpack": "^4.0.2",
    	"load-grunt-tasks": "^3.5.2",
    	minimist: "^1.2.0",
    	mocha: "^8.2.1",
    	sinon: "^4.5.0",
    	"terser-webpack-plugin": "^4.2.3",
    	typescript: "^4.0.5",
    	"url-search-params": "^0.10.0",
    	webpack: "^4.44.2",
    	"webpack-dev-server": "^3.11.0"
    };
    var browser = {
    	"./lib/adapters/http.js": "./lib/adapters/xhr.js"
    };
    var jsdelivr = "dist/axios.min.js";
    var unpkg = "dist/axios.min.js";
    var typings = "./index.d.ts";
    var dependencies = {
    	"follow-redirects": "^1.14.0"
    };
    var bundlesize = [
    	{
    		path: "./dist/axios.min.js",
    		threshold: "5kB"
    	}
    ];
    var pkg = {
    	name: name,
    	version: version$1,
    	description: description,
    	main: main,
    	scripts: scripts,
    	repository: repository,
    	keywords: keywords,
    	author: author,
    	license: license,
    	bugs: bugs,
    	homepage: homepage,
    	devDependencies: devDependencies,
    	browser: browser,
    	jsdelivr: jsdelivr,
    	unpkg: unpkg,
    	typings: typings,
    	dependencies: dependencies,
    	bundlesize: bundlesize
    };

    var validators$1 = {};

    // eslint-disable-next-line func-names
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
      validators$1[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
      };
    });

    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split('.');

    /**
     * Compare package versions
     * @param {string} version
     * @param {string?} thanVersion
     * @returns {boolean}
     */
    function isOlderVersion(version, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
      var destVer = version.split('.');
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }

    /**
     * Transitional option validator
     * @param {function|boolean?} validator
     * @param {string?} version
     * @param {string} message
     * @returns {function}
     */
    validators$1.transitional = function transitional(validator, version, message) {
      var isDeprecated = version && isOlderVersion(version);

      function formatMessage(opt, desc) {
        return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
      }

      // eslint-disable-next-line func-names
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, ' has been removed in ' + version));
        }

        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          // eslint-disable-next-line no-console
          console.warn(
            formatMessage(
              opt,
              ' has been deprecated since v' + version + ' and will be removed in the near future'
            )
          );
        }

        return validator ? validator(value, opt, opts) : true;
      };
    };

    /**
     * Assert object's properties type
     * @param {object} options
     * @param {object} schema
     * @param {boolean?} allowUnknown
     */

    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== 'object') {
        throw new TypeError('options must be an object');
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === undefined || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError('option ' + opt + ' must be ' + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error('Unknown option ' + opt);
        }
      }
    }

    var validator = {
      isOlderVersion: isOlderVersion,
      assertOptions: assertOptions,
      validators: validators$1
    };

    var validators = validator.validators;
    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      var transitional = config.transitional;

      if (transitional !== undefined) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
          forcedJSONParsing: validators.transitional(validators.boolean, '1.0.0'),
          clarifyTimeoutError: validators.transitional(validators.boolean, '1.0.0')
        }, false);
      }

      // filter out skipped interceptors
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
          return;
        }

        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });

      var promise;

      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, undefined];

        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);

        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }

        return promise;
      }


      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }

      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }

      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: (config || {}).data
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    var isAxiosError = function isAxiosError(payload) {
      return (typeof payload === 'object') && (payload.isAxiosError === true);
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios$1 = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios$1.Axios = Axios_1;

    // Factory for creating new instances
    axios$1.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios$1.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios$1.Cancel = Cancel_1;
    axios$1.CancelToken = CancelToken_1;
    axios$1.isCancel = isCancel;

    // Expose all/spread
    axios$1.all = function all(promises) {
      return Promise.all(promises);
    };
    axios$1.spread = spread;

    // Expose isAxiosError
    axios$1.isAxiosError = isAxiosError;

    var axios_1 = axios$1;

    // Allow use of default import syntax in TypeScript
    var _default = axios$1;
    axios_1.default = _default;

    var axios = axios_1;

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$4) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$4) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$4;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop$4;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop$4;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    const api = axios.create({
        baseURL: 'http://localhost:3333'
        // baseURL: 'https://api.pa-f.net'
    });

    const loggedIn = writable({authenticating: true, loggedIn: false});
    const role = writable('');
    const settings = writable({});
    const version = '1.2.4';


    async function validateAuth() {
        if (sessionStorage.token !== undefined && sessionStorage.token !== null  && sessionStorage.token !== 'null') {
            api.defaults.headers.common['Authorization'] = `Bearer ${sessionStorage.token}`;
            try {
                const result = await api.head('/');
                loggedIn.set({authenticating: false, loggedIn: result.status === 200});
                role.set(sessionStorage.role);
            } catch (error) {
                loggedIn.set({authenticating: false, loggedIn: false});
            }
        } else
            loggedIn.set({authenticating: false, loggedIn: false});
    }

    async function login(credentials) {
        try {
            const result = await api.post('/login/', credentials);
            if (result.data.token !== undefined && result.data.token !== null) {
                api.defaults.headers.common['Authorization'] = `Bearer ${result.data.token}`;
                sessionStorage.token = result.data.token;
                sessionStorage.role = result.data.role;
                role.set(result.data.role);
                await validateAuth();
            }
        } catch (error) {}
    }

    async function logout() {
        try {
            const result = await api.post('/logout/');
            sessionStorage.token = null;
            loggedIn.set(result.status !== 200);
        } catch (error) {}
    }

    async function fetchSettings() {
        try {
            const result = await api.get('/settings/');
            settings.set(result.data);
        } catch (error) {}
    }

    async function updateSettings(settings) {
        try {
            const result = await api.put('/settings/', settings);
            return result.status === 200
        } catch (error) {}
    }

    function getSettings() {
        return get_store_value(settings)
    }

    /* src/components/Login.svelte generated by Svelte v3.45.0 */
    const file$x = "src/components/Login.svelte";

    // (21:12) {:else}
    function create_else_block$t(ctx) {
    	let h3;
    	let t1;
    	let form;
    	let div1;
    	let div0;
    	let span0;
    	let t2;
    	let input0;
    	let t3;
    	let div3;
    	let div2;
    	let span1;
    	let t4;
    	let input1;
    	let t5;
    	let div4;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Welcome back!";
    			t1 = space();
    			form = element("form");
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t2 = space();
    			input0 = element("input");
    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			span1 = element("span");
    			t4 = space();
    			input1 = element("input");
    			t5 = space();
    			div4 = element("div");
    			button = element("button");
    			button.textContent = "Login";
    			attr_dev(h3, "class", "uk-card-title uk-text-center uk-margin-remove-top");
    			add_location(h3, file$x, 21, 16, 836);
    			attr_dev(span0, "class", "uk-form-icon");
    			attr_dev(span0, "uk-icon", "icon: user");
    			add_location(span0, file$x, 25, 28, 1113);
    			attr_dev(input0, "class", "uk-input uk-form-large");
    			attr_dev(input0, "id", "username");
    			attr_dev(input0, "type", "text");
    			add_location(input0, file$x, 26, 28, 1197);
    			attr_dev(div0, "class", "uk-inline uk-width-1-1");
    			add_location(div0, file$x, 24, 24, 1048);
    			attr_dev(div1, "class", "uk-margin");
    			add_location(div1, file$x, 23, 20, 1000);
    			attr_dev(span1, "class", "uk-form-icon");
    			attr_dev(span1, "uk-icon", "icon: lock");
    			add_location(span1, file$x, 31, 28, 1471);
    			attr_dev(input1, "class", "uk-input uk-form-large");
    			attr_dev(input1, "id", "password");
    			attr_dev(input1, "type", "password");
    			add_location(input1, file$x, 32, 28, 1555);
    			attr_dev(div2, "class", "uk-inline uk-width-1-1");
    			add_location(div2, file$x, 30, 24, 1406);
    			attr_dev(div3, "class", "uk-margin");
    			add_location(div3, file$x, 29, 20, 1358);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "uk-button uk-button-primary uk-button-large uk-width-1-1");
    			add_location(button, file$x, 36, 24, 1772);
    			attr_dev(div4, "class", "uk-margin");
    			add_location(div4, file$x, 35, 20, 1724);
    			add_location(form, file$x, 22, 16, 933);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, form, anchor);
    			append_dev(form, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(div0, t2);
    			append_dev(div0, input0);
    			set_input_value(input0, /*user*/ ctx[0]);
    			append_dev(form, t3);
    			append_dev(form, div3);
    			append_dev(div3, div2);
    			append_dev(div2, span1);
    			append_dev(div2, t4);
    			append_dev(div2, input1);
    			set_input_value(input1, /*password*/ ctx[1]);
    			append_dev(form, t5);
    			append_dev(form, div4);
    			append_dev(div4, button);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[4]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[5]),
    					listen_dev(form, "submit", prevent_default(/*handleSubmit*/ ctx[3]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*user*/ 1 && input0.value !== /*user*/ ctx[0]) {
    				set_input_value(input0, /*user*/ ctx[0]);
    			}

    			if (dirty & /*password*/ 2 && input1.value !== /*password*/ ctx[1]) {
    				set_input_value(input1, /*password*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(form);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$t.name,
    		type: "else",
    		source: "(21:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (17:12) {#if $loggedIn.authenticating}
    function create_if_block$w(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "uk-align-center");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$x, 18, 20, 719);
    			attr_dev(div1, "class", "uk-flex uk-flex-center");
    			add_location(div1, file$x, 17, 16, 662);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(17:12) {#if $loggedIn.authenticating}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let img;
    	let img_src_value;
    	let t;

    	function select_block_type(ctx, dirty) {
    		if (/*$loggedIn*/ ctx[2].authenticating) return create_if_block$w;
    		return create_else_block$t;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t = space();
    			if_block.c();
    			if (!src_url_equal(img.src, img_src_value = "/paf-header.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "class", "uk-align-center");
    			attr_dev(img, "width", "240");
    			attr_dev(img, "alt", "PAF logo");
    			add_location(img, file$x, 15, 12, 523);
    			attr_dev(div0, "class", "uk-card-body");
    			add_location(div0, file$x, 14, 8, 484);
    			attr_dev(div1, "class", "uk-margin uk-width-large uk-margin-auto uk-card uk-card-default uk-box-shadow-large");
    			add_location(div1, file$x, 13, 4, 378);
    			attr_dev(div2, "class", "uk-section uk-section-muted uk-flex uk-flex-middle uk-animation-fade");
    			attr_dev(div2, "uk-height-viewport", "");
    			add_location(div2, file$x, 12, 0, 272);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, img);
    			append_dev(div0, t);
    			if_block.m(div0, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let $loggedIn;
    	validate_store(loggedIn, 'loggedIn');
    	component_subscribe($$self, loggedIn, $$value => $$invalidate(2, $loggedIn = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Login', slots, []);
    	let user = '';
    	let password = '';

    	async function handleSubmit() {
    		if (user.length > 0 && password.length > 0) await login({ user, password });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		user = this.value;
    		$$invalidate(0, user);
    	}

    	function input1_input_handler() {
    		password = this.value;
    		$$invalidate(1, password);
    	}

    	$$self.$capture_state = () => ({
    		login,
    		loggedIn,
    		user,
    		password,
    		handleSubmit,
    		$loggedIn
    	});

    	$$self.$inject_state = $$props => {
    		if ('user' in $$props) $$invalidate(0, user = $$props.user);
    		if ('password' in $$props) $$invalidate(1, password = $$props.password);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		user,
    		password,
    		$loggedIn,
    		handleSubmit,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    let navData = {
        dashboard: true,
        booking: false,
        data: false,
        datain: false,
        member: false,
        payment: false,
        invoice: false,
        mattress: false,
        event: false,
        accounting: false,
        reconciliation: false,
        bankrun: false,
        sci: false,
        reservations: false,
        newsletter: false,
        settings: false,
        users: false
    };

    const navigation = writable(navData);
    const screenWidthS = writable(false);
    const screenWidthM = writable(false);
    const screenWidthL = writable(false);
    const screenWidthXL = writable(false);

    async function navigateTo(target) {
        Object.keys(navData).forEach(k => navData[k] = (k === target));
        navigation.set(navData);
        await fetchSettings();
    }

    /* src/components/NavBar.svelte generated by Svelte v3.45.0 */
    const file$w = "src/components/NavBar.svelte";

    // (34:16) {#if $role === 'admin' || $role === 'mattress' || $role === 'root'}
    function create_if_block_5$c(ctx) {
    	let li;
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			a.textContent = "Mattress";
    			attr_dev(a, "href", "#");
    			add_location(a, file$w, 34, 63, 1797);
    			toggle_class(li, "uk-active", /*$navigation*/ ctx[1].mattress);
    			add_location(li, file$w, 34, 20, 1754);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_6*/ ctx[12], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li, "uk-active", /*$navigation*/ ctx[1].mattress);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$c.name,
    		type: "if",
    		source: "(34:16) {#if $role === 'admin' || $role === 'mattress' || $role === 'root'}",
    		ctx
    	});

    	return block;
    }

    // (49:12) {#if appUpdate}
    function create_if_block_4$d(ctx) {
    	let div1;
    	let div0;
    	let span;
    	let t0;
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t0 = space();
    			a = element("a");
    			a.textContent = "Please click here to update to the latest version!";
    			attr_dev(span, "uk-icon", "warning");
    			add_location(span, file$w, 51, 24, 2686);
    			attr_dev(a, "href", "#");
    			add_location(a, file$w, 51, 56, 2718);
    			attr_dev(div0, "class", "uk-alert-warning uk-text-center");
    			attr_dev(div0, "uk-alert", "");
    			add_location(div0, file$w, 50, 20, 2607);
    			attr_dev(div1, "class", "uk-width-auto uk-align-center uk-margin-remove-vertical");
    			add_location(div1, file$w, 49, 16, 2517);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span);
    			append_dev(div0, t0);
    			append_dev(div0, a);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_8*/ ctx[14], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$d.name,
    		type: "if",
    		source: "(49:12) {#if appUpdate}",
    		ctx
    	});

    	return block;
    }

    // (69:12) {#if $role === 'admin' || $role === 'mattress' || $role === 'root'}
    function create_if_block_3$h(ctx) {
    	let li;
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			a.textContent = "Mattress";
    			attr_dev(a, "href", "#");
    			add_location(a, file$w, 69, 59, 3897);
    			toggle_class(li, "uk-active", /*$navigation*/ ctx[1].mattress);
    			add_location(li, file$w, 69, 16, 3854);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_14*/ ctx[20], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li, "uk-active", /*$navigation*/ ctx[1].mattress);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$h.name,
    		type: "if",
    		source: "(69:12) {#if $role === 'admin' || $role === 'mattress' || $role === 'root'}",
    		ctx
    	});

    	return block;
    }

    // (79:12) {#if $role === 'admin' || $role === 'root'}
    function create_if_block$v(ctx) {
    	let li0;
    	let t0;
    	let li1;
    	let t2;
    	let li2;
    	let a0;
    	let t4;
    	let li3;
    	let a1;
    	let t6;
    	let li4;
    	let a2;
    	let t8;
    	let li5;
    	let a3;
    	let t10;
    	let li6;
    	let t11;
    	let li7;
    	let t13;
    	let li8;
    	let a4;
    	let t15;
    	let t16;
    	let li9;
    	let t17;
    	let li10;
    	let t19;
    	let li11;
    	let a5;
    	let t21;
    	let if_block1_anchor;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$role*/ ctx[2] === 'root' && create_if_block_2$k(ctx);
    	let if_block1 = /*$role*/ ctx[2] === 'root' && create_if_block_1$l(ctx);

    	const block = {
    		c: function create() {
    			li0 = element("li");
    			t0 = space();
    			li1 = element("li");
    			li1.textContent = "Accounting";
    			t2 = space();
    			li2 = element("li");
    			a0 = element("a");
    			a0.textContent = "Monthly";
    			t4 = space();
    			li3 = element("li");
    			a1 = element("a");
    			a1.textContent = "Reconciliation";
    			t6 = space();
    			li4 = element("li");
    			a2 = element("a");
    			a2.textContent = "Deposit";
    			t8 = space();
    			li5 = element("li");
    			a3 = element("a");
    			a3.textContent = "SCI";
    			t10 = space();
    			li6 = element("li");
    			t11 = space();
    			li7 = element("li");
    			li7.textContent = "Data";
    			t13 = space();
    			li8 = element("li");
    			a4 = element("a");
    			a4.textContent = "Export";
    			t15 = space();
    			if (if_block0) if_block0.c();
    			t16 = space();
    			li9 = element("li");
    			t17 = space();
    			li10 = element("li");
    			li10.textContent = "Settings";
    			t19 = space();
    			li11 = element("li");
    			a5 = element("a");
    			a5.textContent = "Defaults";
    			t21 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(li0, "class", "uk-hidden@m");
    			add_location(li0, file$w, 79, 16, 4583);
    			attr_dev(li1, "class", "uk-nav-header");
    			add_location(li1, file$w, 80, 16, 4629);
    			attr_dev(a0, "href", "#");
    			add_location(a0, file$w, 81, 61, 4732);
    			toggle_class(li2, "uk-active", /*$navigation*/ ctx[1].accounting);
    			add_location(li2, file$w, 81, 16, 4687);
    			attr_dev(a1, "href", "#");
    			add_location(a1, file$w, 82, 65, 4870);
    			toggle_class(li3, "uk-active", /*$navigation*/ ctx[1].reconciliation);
    			add_location(li3, file$w, 82, 16, 4821);
    			attr_dev(a2, "href", "#");
    			add_location(a2, file$w, 83, 58, 5012);
    			toggle_class(li4, "uk-active", /*$navigation*/ ctx[1].bankrun);
    			add_location(li4, file$w, 83, 16, 4970);
    			attr_dev(a3, "href", "#");
    			add_location(a3, file$w, 84, 54, 5136);
    			toggle_class(li5, "uk-active", /*$navigation*/ ctx[1].sci);
    			add_location(li5, file$w, 84, 16, 5098);
    			attr_dev(li6, "class", "uk-hidden@m");
    			add_location(li6, file$w, 85, 16, 5214);
    			attr_dev(li7, "class", "uk-nav-header");
    			add_location(li7, file$w, 86, 16, 5260);
    			attr_dev(a4, "href", "#");
    			add_location(a4, file$w, 87, 55, 5351);
    			toggle_class(li8, "uk-active", /*$navigation*/ ctx[1].data);
    			add_location(li8, file$w, 87, 16, 5312);
    			attr_dev(li9, "class", "uk-hidden@m");
    			add_location(li9, file$w, 91, 16, 5623);
    			attr_dev(li10, "class", "uk-nav-header");
    			add_location(li10, file$w, 92, 16, 5669);
    			attr_dev(a5, "href", "#");
    			add_location(a5, file$w, 93, 59, 5768);
    			toggle_class(li11, "uk-active", /*$navigation*/ ctx[1].settings);
    			add_location(li11, file$w, 93, 16, 5725);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, li1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, li2, anchor);
    			append_dev(li2, a0);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, li3, anchor);
    			append_dev(li3, a1);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, li4, anchor);
    			append_dev(li4, a2);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, li5, anchor);
    			append_dev(li5, a3);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, li6, anchor);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, li7, anchor);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, li8, anchor);
    			append_dev(li8, a4);
    			insert_dev(target, t15, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, li9, anchor);
    			insert_dev(target, t17, anchor);
    			insert_dev(target, li10, anchor);
    			insert_dev(target, t19, anchor);
    			insert_dev(target, li11, anchor);
    			append_dev(li11, a5);
    			insert_dev(target, t21, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*click_handler_18*/ ctx[24], false, false, false),
    					listen_dev(a1, "click", /*click_handler_19*/ ctx[25], false, false, false),
    					listen_dev(a2, "click", /*click_handler_20*/ ctx[26], false, false, false),
    					listen_dev(a3, "click", /*click_handler_21*/ ctx[27], false, false, false),
    					listen_dev(a4, "click", /*click_handler_22*/ ctx[28], false, false, false),
    					listen_dev(a5, "click", /*click_handler_24*/ ctx[30], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li2, "uk-active", /*$navigation*/ ctx[1].accounting);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li3, "uk-active", /*$navigation*/ ctx[1].reconciliation);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li4, "uk-active", /*$navigation*/ ctx[1].bankrun);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li5, "uk-active", /*$navigation*/ ctx[1].sci);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li8, "uk-active", /*$navigation*/ ctx[1].data);
    			}

    			if (/*$role*/ ctx[2] === 'root') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$k(ctx);
    					if_block0.c();
    					if_block0.m(t16.parentNode, t16);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li11, "uk-active", /*$navigation*/ ctx[1].settings);
    			}

    			if (/*$role*/ ctx[2] === 'root') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$l(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(li1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(li2);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(li3);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(li4);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(li5);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(li6);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(li7);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(li8);
    			if (detaching) detach_dev(t15);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(li9);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(li10);
    			if (detaching) detach_dev(t19);
    			if (detaching) detach_dev(li11);
    			if (detaching) detach_dev(t21);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(79:12) {#if $role === 'admin' || $role === 'root'}",
    		ctx
    	});

    	return block;
    }

    // (89:16) {#if $role === 'root'}
    function create_if_block_2$k(ctx) {
    	let li;
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			a.textContent = "Import";
    			attr_dev(a, "href", "#");
    			add_location(a, file$w, 89, 61, 5517);
    			toggle_class(li, "uk-active", /*$navigation*/ ctx[1].datain);
    			add_location(li, file$w, 89, 20, 5476);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_23*/ ctx[29], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li, "uk-active", /*$navigation*/ ctx[1].datain);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$k.name,
    		type: "if",
    		source: "(89:16) {#if $role === 'root'}",
    		ctx
    	});

    	return block;
    }

    // (95:16) {#if $role === 'root'}
    function create_if_block_1$l(ctx) {
    	let li;
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			a.textContent = "Users";
    			attr_dev(a, "href", "#");
    			add_location(a, file$w, 95, 60, 5939);
    			toggle_class(li, "uk-active", /*$navigation*/ ctx[1].users);
    			add_location(li, file$w, 95, 20, 5899);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_25*/ ctx[31], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li, "uk-active", /*$navigation*/ ctx[1].users);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$l.name,
    		type: "if",
    		source: "(95:16) {#if $role === 'root'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let div7;
    	let nav;
    	let div0;
    	let a0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div1;
    	let ul0;
    	let li0;
    	let a1;
    	let t2;
    	let li1;
    	let a2;
    	let t4;
    	let li2;
    	let a3;
    	let t6;
    	let li3;
    	let a4;
    	let t8;
    	let li4;
    	let a5;
    	let t10;
    	let t11;
    	let li5;
    	let a6;
    	let t13;
    	let div2;
    	let a7;
    	let t14;
    	let div6;
    	let div5;
    	let div4;
    	let div3;
    	let t15;
    	let t16;
    	let div9;
    	let div8;
    	let ul1;
    	let li6;
    	let t18;
    	let li7;
    	let a8;
    	let t20;
    	let li8;
    	let a9;
    	let t22;
    	let li9;
    	let a10;
    	let t24;
    	let li10;
    	let a11;
    	let t26;
    	let li11;
    	let a12;
    	let t28;
    	let t29;
    	let li12;
    	let a13;
    	let t31;
    	let li13;
    	let t33;
    	let ul2;
    	let li14;
    	let t35;
    	let li15;
    	let a14;
    	let t37;
    	let li16;
    	let a15;
    	let t39;
    	let t40;
    	let li17;
    	let t41;
    	let li18;
    	let t43;
    	let li19;
    	let a16;
    	let t45;
    	let li20;
    	let t47;
    	let li21;
    	let t49;
    	let li22;
    	let t51;
    	let li23;
    	let t53;
    	let li24;
    	let t54;
    	let t55;
    	let li25;
    	let t57;
    	let li26;
    	let t59;
    	let li27;
    	let mounted;
    	let dispose;
    	let if_block0 = (/*$role*/ ctx[2] === 'admin' || /*$role*/ ctx[2] === 'mattress' || /*$role*/ ctx[2] === 'root') && create_if_block_5$c(ctx);
    	let if_block1 = /*appUpdate*/ ctx[0] && create_if_block_4$d(ctx);
    	let if_block2 = (/*$role*/ ctx[2] === 'admin' || /*$role*/ ctx[2] === 'mattress' || /*$role*/ ctx[2] === 'root') && create_if_block_3$h(ctx);
    	let if_block3 = (/*$role*/ ctx[2] === 'admin' || /*$role*/ ctx[2] === 'root') && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			nav = element("nav");
    			div0 = element("div");
    			a0 = element("a");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			a1 = element("a");
    			a1.textContent = "Dashboard";
    			t2 = space();
    			li1 = element("li");
    			a2 = element("a");
    			a2.textContent = "Booking";
    			t4 = space();
    			li2 = element("li");
    			a3 = element("a");
    			a3.textContent = "Member";
    			t6 = space();
    			li3 = element("li");
    			a4 = element("a");
    			a4.textContent = "Payment";
    			t8 = space();
    			li4 = element("li");
    			a5 = element("a");
    			a5.textContent = "Invoice";
    			t10 = space();
    			if (if_block0) if_block0.c();
    			t11 = space();
    			li5 = element("li");
    			a6 = element("a");
    			a6.textContent = "Event";
    			t13 = space();
    			div2 = element("div");
    			a7 = element("a");
    			t14 = space();
    			div6 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			t15 = space();
    			if (if_block1) if_block1.c();
    			t16 = space();
    			div9 = element("div");
    			div8 = element("div");
    			ul1 = element("ul");
    			li6 = element("li");
    			li6.textContent = "Admin";
    			t18 = space();
    			li7 = element("li");
    			a8 = element("a");
    			a8.textContent = "Dashboard";
    			t20 = space();
    			li8 = element("li");
    			a9 = element("a");
    			a9.textContent = "Booking";
    			t22 = space();
    			li9 = element("li");
    			a10 = element("a");
    			a10.textContent = "Member";
    			t24 = space();
    			li10 = element("li");
    			a11 = element("a");
    			a11.textContent = "Payment";
    			t26 = space();
    			li11 = element("li");
    			a12 = element("a");
    			a12.textContent = "Invoice";
    			t28 = space();
    			if (if_block2) if_block2.c();
    			t29 = space();
    			li12 = element("li");
    			a13 = element("a");
    			a13.textContent = "Event";
    			t31 = space();
    			li13 = element("li");
    			li13.textContent = "";
    			t33 = space();
    			ul2 = element("ul");
    			li14 = element("li");
    			li14.textContent = "Lists";
    			t35 = space();
    			li15 = element("li");
    			a14 = element("a");
    			a14.textContent = "Reservations";
    			t37 = space();
    			li16 = element("li");
    			a15 = element("a");
    			a15.textContent = "Newsletter";
    			t39 = space();
    			if (if_block3) if_block3.c();
    			t40 = space();
    			li17 = element("li");
    			t41 = space();
    			li18 = element("li");
    			li18.textContent = "Logout";
    			t43 = space();
    			li19 = element("li");
    			a16 = element("a");
    			a16.textContent = "Logout";
    			t45 = space();
    			li20 = element("li");
    			li20.textContent = "";
    			t47 = space();
    			li21 = element("li");
    			li21.textContent = "";
    			t49 = space();
    			li22 = element("li");
    			li22.textContent = "";
    			t51 = space();
    			li23 = element("li");
    			li23.textContent = "User:";
    			t53 = space();
    			li24 = element("li");
    			t54 = text$1(/*$role*/ ctx[2]);
    			t55 = space();
    			li25 = element("li");
    			li25.textContent = "";
    			t57 = space();
    			li26 = element("li");
    			li26.textContent = "Version:";
    			t59 = space();
    			li27 = element("li");
    			li27.textContent = `${version}`;
    			if (!src_url_equal(img.src, img_src_value = "/paf-logo.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "width", "100");
    			attr_dev(img, "alt", "PAF logo");
    			add_location(img, file$w, 23, 16, 830);
    			attr_dev(a0, "href", "#");
    			attr_dev(a0, "class", "uk-navbar-item uk-logo");
    			add_location(a0, file$w, 22, 12, 727);
    			attr_dev(div0, "class", "uk-navbar-left");
    			add_location(div0, file$w, 21, 8, 686);
    			attr_dev(a1, "href", "#");
    			add_location(a1, file$w, 28, 60, 1067);
    			toggle_class(li0, "uk-active", /*$navigation*/ ctx[1].dashboard);
    			add_location(li0, file$w, 28, 16, 1023);
    			attr_dev(a2, "href", "#");
    			add_location(a2, file$w, 29, 58, 1199);
    			toggle_class(li1, "uk-active", /*$navigation*/ ctx[1].booking);
    			add_location(li1, file$w, 29, 16, 1157);
    			attr_dev(a3, "href", "#");
    			add_location(a3, file$w, 30, 57, 1326);
    			toggle_class(li2, "uk-active", /*$navigation*/ ctx[1].member);
    			add_location(li2, file$w, 30, 16, 1285);
    			attr_dev(a4, "href", "#");
    			add_location(a4, file$w, 31, 58, 1452);
    			toggle_class(li3, "uk-active", /*$navigation*/ ctx[1].payment);
    			add_location(li3, file$w, 31, 16, 1410);
    			attr_dev(a5, "href", "#");
    			add_location(a5, file$w, 32, 58, 1580);
    			toggle_class(li4, "uk-active", /*$navigation*/ ctx[1].invoice);
    			add_location(li4, file$w, 32, 16, 1538);
    			attr_dev(a6, "href", "#");
    			add_location(a6, file$w, 36, 56, 1947);
    			toggle_class(li5, "uk-active", /*$navigation*/ ctx[1].event);
    			add_location(li5, file$w, 36, 16, 1907);
    			attr_dev(ul0, "class", "uk-navbar-nav");
    			add_location(ul0, file$w, 27, 12, 980);
    			attr_dev(div1, "class", "uk-navbar-center uk-visible@m");
    			add_location(div1, file$w, 26, 8, 924);
    			attr_dev(a7, "class", "uk-navbar-toggle");
    			attr_dev(a7, "uk-navbar-toggle-icon", "");
    			attr_dev(a7, "href", "#");
    			attr_dev(a7, "uk-toggle", "target: #offcanvas-nav");
    			add_location(a7, file$w, 40, 12, 2096);
    			attr_dev(div2, "class", "uk-navbar-right");
    			add_location(div2, file$w, 39, 8, 2054);
    			attr_dev(nav, "class", "uk-navbar-container uk-navbar-transparent");
    			attr_dev(nav, "uk-navbar", "");
    			set_style(nav, "position", "relative");
    			set_style(nav, "z-index", "980");
    			set_style(nav, "box-bottom", "solid");
    			set_style(nav, "border-bottom-color", "#080808");
    			add_location(nav, file$w, 20, 4, 522);
    			attr_dev(div3, "class", "uk-align-center");
    			set_style(div3, "border-top", "solid black 1.5px");
    			set_style(div3, "width", "750px");
    			add_location(div3, file$w, 46, 16, 2365);
    			attr_dev(div4, "class", "uk-width-1-1");
    			add_location(div4, file$w, 45, 12, 2322);
    			attr_dev(div5, "class", "uk-grid-small");
    			attr_dev(div5, "uk-grid", "");
    			add_location(div5, file$w, 44, 8, 2274);
    			attr_dev(div6, "class", "uk-flex uk-flex-center");
    			add_location(div6, file$w, 43, 4, 2229);
    			attr_dev(div7, "uk-sticky", "sel-target: .uk-navbar-container; cls-active: uk-navbar-sticky; bottom: #transparent-sticky-navbar");
    			attr_dev(div7, "class", "paf-navi-bg");
    			add_location(div7, file$w, 19, 0, 381);
    			attr_dev(li6, "class", "uk-nav-header");
    			add_location(li6, file$w, 62, 12, 3098);
    			attr_dev(a8, "href", "#");
    			add_location(a8, file$w, 63, 56, 3191);
    			toggle_class(li7, "uk-active", /*$navigation*/ ctx[1].dashboard);
    			add_location(li7, file$w, 63, 12, 3147);
    			attr_dev(a9, "href", "#");
    			add_location(a9, file$w, 64, 54, 3319);
    			toggle_class(li8, "uk-active", /*$navigation*/ ctx[1].booking);
    			add_location(li8, file$w, 64, 12, 3277);
    			attr_dev(a10, "href", "#");
    			add_location(a10, file$w, 65, 53, 3442);
    			toggle_class(li9, "uk-active", /*$navigation*/ ctx[1].member);
    			add_location(li9, file$w, 65, 12, 3401);
    			attr_dev(a11, "href", "#");
    			add_location(a11, file$w, 66, 54, 3564);
    			toggle_class(li10, "uk-active", /*$navigation*/ ctx[1].payment);
    			add_location(li10, file$w, 66, 12, 3522);
    			attr_dev(a12, "href", "#");
    			add_location(a12, file$w, 67, 54, 3688);
    			toggle_class(li11, "uk-active", /*$navigation*/ ctx[1].invoice);
    			add_location(li11, file$w, 67, 12, 3646);
    			attr_dev(a13, "href", "#");
    			add_location(a13, file$w, 71, 52, 4039);
    			toggle_class(li12, "uk-active", /*$navigation*/ ctx[1].event);
    			add_location(li12, file$w, 71, 12, 3999);
    			add_location(li13, file$w, 72, 12, 4117);
    			attr_dev(ul1, "class", "uk-nav uk-nav-default uk-hidden@m");
    			add_location(ul1, file$w, 61, 8, 3039);
    			attr_dev(li14, "class", "uk-nav-header");
    			add_location(li14, file$w, 75, 12, 4202);
    			attr_dev(a14, "href", "#");
    			add_location(a14, file$w, 76, 59, 4298);
    			toggle_class(li15, "uk-active", /*$navigation*/ ctx[1].reservations);
    			add_location(li15, file$w, 76, 12, 4251);
    			attr_dev(a15, "href", "#");
    			add_location(a15, file$w, 77, 57, 4435);
    			toggle_class(li16, "uk-active", /*$navigation*/ ctx[1].newsletter);
    			add_location(li16, file$w, 77, 12, 4390);
    			attr_dev(li17, "class", "uk-hidden@m");
    			add_location(li17, file$w, 98, 12, 6057);
    			attr_dev(li18, "class", "uk-nav-header");
    			add_location(li18, file$w, 99, 12, 6099);
    			attr_dev(a16, "href", "#");
    			add_location(a16, file$w, 100, 40, 6177);
    			add_location(li19, file$w, 100, 12, 6149);
    			add_location(li20, file$w, 101, 12, 6219);
    			add_location(li21, file$w, 102, 12, 6247);
    			add_location(li22, file$w, 103, 12, 6275);
    			attr_dev(li23, "class", "uk-text-small uk-text-meta");
    			add_location(li23, file$w, 104, 12, 6303);
    			attr_dev(li24, "class", "uk-text-small");
    			add_location(li24, file$w, 105, 12, 6365);
    			attr_dev(li25, "class", "uk-text-small");
    			add_location(li25, file$w, 106, 12, 6416);
    			attr_dev(li26, "class", "uk-text-small uk-text-meta");
    			add_location(li26, file$w, 107, 12, 6466);
    			attr_dev(li27, "class", "uk-text-small");
    			add_location(li27, file$w, 108, 12, 6531);
    			attr_dev(ul2, "class", "uk-nav uk-nav-default");
    			add_location(ul2, file$w, 74, 8, 4155);
    			attr_dev(div8, "class", "uk-offcanvas-bar uk-width-small");
    			add_location(div8, file$w, 60, 4, 2985);
    			attr_dev(div9, "id", "offcanvas-nav");
    			attr_dev(div9, "uk-offcanvas", "overlay: true; flip: true");
    			add_location(div9, file$w, 59, 0, 2915);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, nav);
    			append_dev(nav, div0);
    			append_dev(div0, a0);
    			append_dev(a0, img);
    			append_dev(nav, t0);
    			append_dev(nav, div1);
    			append_dev(div1, ul0);
    			append_dev(ul0, li0);
    			append_dev(li0, a1);
    			append_dev(ul0, t2);
    			append_dev(ul0, li1);
    			append_dev(li1, a2);
    			append_dev(ul0, t4);
    			append_dev(ul0, li2);
    			append_dev(li2, a3);
    			append_dev(ul0, t6);
    			append_dev(ul0, li3);
    			append_dev(li3, a4);
    			append_dev(ul0, t8);
    			append_dev(ul0, li4);
    			append_dev(li4, a5);
    			append_dev(ul0, t10);
    			if (if_block0) if_block0.m(ul0, null);
    			append_dev(ul0, t11);
    			append_dev(ul0, li5);
    			append_dev(li5, a6);
    			append_dev(nav, t13);
    			append_dev(nav, div2);
    			append_dev(div2, a7);
    			append_dev(div7, t14);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div5, t15);
    			if (if_block1) if_block1.m(div5, null);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div8);
    			append_dev(div8, ul1);
    			append_dev(ul1, li6);
    			append_dev(ul1, t18);
    			append_dev(ul1, li7);
    			append_dev(li7, a8);
    			append_dev(ul1, t20);
    			append_dev(ul1, li8);
    			append_dev(li8, a9);
    			append_dev(ul1, t22);
    			append_dev(ul1, li9);
    			append_dev(li9, a10);
    			append_dev(ul1, t24);
    			append_dev(ul1, li10);
    			append_dev(li10, a11);
    			append_dev(ul1, t26);
    			append_dev(ul1, li11);
    			append_dev(li11, a12);
    			append_dev(ul1, t28);
    			if (if_block2) if_block2.m(ul1, null);
    			append_dev(ul1, t29);
    			append_dev(ul1, li12);
    			append_dev(li12, a13);
    			append_dev(ul1, t31);
    			append_dev(ul1, li13);
    			append_dev(div8, t33);
    			append_dev(div8, ul2);
    			append_dev(ul2, li14);
    			append_dev(ul2, t35);
    			append_dev(ul2, li15);
    			append_dev(li15, a14);
    			append_dev(ul2, t37);
    			append_dev(ul2, li16);
    			append_dev(li16, a15);
    			append_dev(ul2, t39);
    			if (if_block3) if_block3.m(ul2, null);
    			append_dev(ul2, t40);
    			append_dev(ul2, li17);
    			append_dev(ul2, t41);
    			append_dev(ul2, li18);
    			append_dev(ul2, t43);
    			append_dev(ul2, li19);
    			append_dev(li19, a16);
    			append_dev(ul2, t45);
    			append_dev(ul2, li20);
    			append_dev(ul2, t47);
    			append_dev(ul2, li21);
    			append_dev(ul2, t49);
    			append_dev(ul2, li22);
    			append_dev(ul2, t51);
    			append_dev(ul2, li23);
    			append_dev(ul2, t53);
    			append_dev(ul2, li24);
    			append_dev(li24, t54);
    			append_dev(ul2, t55);
    			append_dev(ul2, li25);
    			append_dev(ul2, t57);
    			append_dev(ul2, li26);
    			append_dev(ul2, t59);
    			append_dev(ul2, li27);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*click_handler*/ ctx[6], false, false, false),
    					listen_dev(a1, "click", /*click_handler_1*/ ctx[7], false, false, false),
    					listen_dev(a2, "click", /*click_handler_2*/ ctx[8], false, false, false),
    					listen_dev(a3, "click", /*click_handler_3*/ ctx[9], false, false, false),
    					listen_dev(a4, "click", /*click_handler_4*/ ctx[10], false, false, false),
    					listen_dev(a5, "click", /*click_handler_5*/ ctx[11], false, false, false),
    					listen_dev(a6, "click", /*click_handler_7*/ ctx[13], false, false, false),
    					listen_dev(a8, "click", /*click_handler_9*/ ctx[15], false, false, false),
    					listen_dev(a9, "click", /*click_handler_10*/ ctx[16], false, false, false),
    					listen_dev(a10, "click", /*click_handler_11*/ ctx[17], false, false, false),
    					listen_dev(a11, "click", /*click_handler_12*/ ctx[18], false, false, false),
    					listen_dev(a12, "click", /*click_handler_13*/ ctx[19], false, false, false),
    					listen_dev(a13, "click", /*click_handler_15*/ ctx[21], false, false, false),
    					listen_dev(a14, "click", /*click_handler_16*/ ctx[22], false, false, false),
    					listen_dev(a15, "click", /*click_handler_17*/ ctx[23], false, false, false),
    					listen_dev(li19, "click", /*handleLogout*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li0, "uk-active", /*$navigation*/ ctx[1].dashboard);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li1, "uk-active", /*$navigation*/ ctx[1].booking);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li2, "uk-active", /*$navigation*/ ctx[1].member);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li3, "uk-active", /*$navigation*/ ctx[1].payment);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li4, "uk-active", /*$navigation*/ ctx[1].invoice);
    			}

    			if (/*$role*/ ctx[2] === 'admin' || /*$role*/ ctx[2] === 'mattress' || /*$role*/ ctx[2] === 'root') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_5$c(ctx);
    					if_block0.c();
    					if_block0.m(ul0, t11);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li5, "uk-active", /*$navigation*/ ctx[1].event);
    			}

    			if (/*appUpdate*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$d(ctx);
    					if_block1.c();
    					if_block1.m(div5, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li7, "uk-active", /*$navigation*/ ctx[1].dashboard);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li8, "uk-active", /*$navigation*/ ctx[1].booking);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li9, "uk-active", /*$navigation*/ ctx[1].member);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li10, "uk-active", /*$navigation*/ ctx[1].payment);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li11, "uk-active", /*$navigation*/ ctx[1].invoice);
    			}

    			if (/*$role*/ ctx[2] === 'admin' || /*$role*/ ctx[2] === 'mattress' || /*$role*/ ctx[2] === 'root') {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_3$h(ctx);
    					if_block2.c();
    					if_block2.m(ul1, t29);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li12, "uk-active", /*$navigation*/ ctx[1].event);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li15, "uk-active", /*$navigation*/ ctx[1].reservations);
    			}

    			if (dirty[0] & /*$navigation*/ 2) {
    				toggle_class(li16, "uk-active", /*$navigation*/ ctx[1].newsletter);
    			}

    			if (/*$role*/ ctx[2] === 'admin' || /*$role*/ ctx[2] === 'root') {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block$v(ctx);
    					if_block3.c();
    					if_block3.m(ul2, t40);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (dirty[0] & /*$role*/ 4) set_data_dev(t54, /*$role*/ ctx[2]);
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(div9);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $settings;
    	let $navigation;
    	let $role;
    	validate_store(settings, 'settings');
    	component_subscribe($$self, settings, $$value => $$invalidate(5, $settings = $$value));
    	validate_store(navigation, 'navigation');
    	component_subscribe($$self, navigation, $$value => $$invalidate(1, $navigation = $$value));
    	validate_store(role, 'role');
    	component_subscribe($$self, role, $$value => $$invalidate(2, $role = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NavBar', slots, []);
    	let appUpdate = false;

    	function update() {
    		$$invalidate(0, appUpdate = false);
    		location.reload();
    	}

    	async function handleLogout() {
    		await logout();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NavBar> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => navigateTo('dashboard');
    	const click_handler_1 = () => navigateTo('dashboard');
    	const click_handler_2 = () => navigateTo('booking');
    	const click_handler_3 = () => navigateTo('member');
    	const click_handler_4 = () => navigateTo('payment');
    	const click_handler_5 = () => navigateTo('invoice');
    	const click_handler_6 = () => navigateTo('mattress');
    	const click_handler_7 = () => navigateTo('event');
    	const click_handler_8 = () => update();
    	const click_handler_9 = () => navigateTo('dashboard');
    	const click_handler_10 = () => navigateTo('booking');
    	const click_handler_11 = () => navigateTo('member');
    	const click_handler_12 = () => navigateTo('payment');
    	const click_handler_13 = () => navigateTo('invoice');
    	const click_handler_14 = () => navigateTo('mattress');
    	const click_handler_15 = () => navigateTo('event');
    	const click_handler_16 = () => navigateTo('reservations');
    	const click_handler_17 = () => navigateTo('newsletter');
    	const click_handler_18 = () => navigateTo('accounting');
    	const click_handler_19 = () => navigateTo('reconciliation');
    	const click_handler_20 = () => navigateTo('bankrun');
    	const click_handler_21 = () => navigateTo('sci');
    	const click_handler_22 = () => navigateTo('data');
    	const click_handler_23 = () => navigateTo('datain');
    	const click_handler_24 = () => navigateTo('settings');
    	const click_handler_25 = () => navigateTo('users');

    	$$self.$capture_state = () => ({
    		logout,
    		role,
    		settings,
    		version,
    		navigateTo,
    		navigation,
    		appUpdate,
    		update,
    		handleLogout,
    		$settings,
    		$navigation,
    		$role
    	});

    	$$self.$inject_state = $$props => {
    		if ('appUpdate' in $$props) $$invalidate(0, appUpdate = $$props.appUpdate);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$settings*/ 32) {
    			$$invalidate(0, appUpdate = $settings.app_version !== version);
    		}
    	};

    	return [
    		appUpdate,
    		$navigation,
    		$role,
    		update,
    		handleLogout,
    		$settings,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8,
    		click_handler_9,
    		click_handler_10,
    		click_handler_11,
    		click_handler_12,
    		click_handler_13,
    		click_handler_14,
    		click_handler_15,
    		click_handler_16,
    		click_handler_17,
    		click_handler_18,
    		click_handler_19,
    		click_handler_20,
    		click_handler_21,
    		click_handler_22,
    		click_handler_23,
    		click_handler_24,
    		click_handler_25
    	];
    }

    class NavBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$w, create_fragment$w, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavBar",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    const memberEmails = writable([]);
    const memberNames = writable([]);
    const sciMembers = writable([]);

    async function getMembers(page) {
        try {
            const result = await api.post('/members/', {page: page, limit: 50});
            return result.data
        } catch (error) {}
    }

    async function getSciMembers() {
        try {
            const result = await api.get('/members/sci');
            sciMembers.set(result.data);
        } catch (error) {}
    }

    async function getMemberByEmail(email) {
        try {
            const result = await api.post('/members/byEmail', {email: email});
            return result.data[0]
        } catch (error) {}
    }

    async function getMemberById(id) {
        try {
            const result = await api.get('/member/'+id);
            return result.data
        } catch (error) {}
    }

    async function getMemberByName(name) {
        try {
            const result = await api.post('/members/byName/', {name: name});
            return result.data
        } catch (error) {}
    }

    async function getMemberEmails() {
        try {
            const result = await api.get('/memberEmails/');
            memberEmails.set(result.data);
        } catch (error) {}
    }

    async function getNewsletterEmails(date) {
        try {
            const result = await api.post('/newsletterEmails/', {date: date});
            return result.data
        } catch (error) {}
    }

    async function getMemberNames() {
        try {
            const result = await api.get('/members/');
            memberNames.set(result.data);
        } catch (error) {}
    }

    async function createMember(member) {
        try {
            const result = await api.post('/member/', member);
            return result.status === 200
        } catch (error) {}
    }

    async function updateMember(member) {
        try {
            const result = await api.put('/member/'+member.id, member);
            return result.status === 200
        } catch (error) {}
    }

    function getSciMember(id) {
        return get_store_value(sciMembers).find(m => m.id === id)
    }

    const countryArray = [
        {title: "Afghanistan", value: "AF"},
        {title: "land Islands", value: "AX"},
        {title: "Albania", value: "AL"},
        {title: "Algeria", value: "DZ"},
        {title: "American Samoa", value: "AS"},
        {title: "Andorra", value: "AD"},
        {title: "Angola", value: "AO"},
        {title: "Anguilla", value: "AI"},
        {title: "Antarctica", value: "AQ"},
        {title: "Antigua and Barbuda", value: "AG"},
        {title: "Argentina", value: "AR"},
        {title: "Armenia", value: "AM"},
        {title: "Aruba", value: "AW"},
        {title: "Australia", value: "AU"},
        {title: "Austria", value: "AT"},
        {title: "Azerbaijan", value: "AZ"},
        {title: "Bahamas", value: "BS"},
        {title: "Bahrain", value: "BH"},
        {title: "Bangladesh", value: "BD"},
        {title: "Barbados", value: "BB"},
        {title: "Belarus", value: "BY"},
        {title: "Belgium", value: "BE"},
        {title: "Belize", value: "BZ"},
        {title: "Benin", value: "BJ"},
        {title: "Bermuda", value: "BM"},
        {title: "Bhutan", value: "BT"},
        {title: "Bolivia", value: "BO"},
        {title: "Bosnia and Herzegovina", value: "BA"},
        {title: "Botswana", value: "BW"},
        {title: "Bouvet Island", value: "BV"},
        {title: "Brazil", value: "BR"},
        {title: "British Indian Ocean Territory", value: "IO"},
        {title: "Brunei Darussalam", value: "BN"},
        {title: "Bulgaria", value: "BG"},
        {title: "Burkina Faso", value: "BF"},
        {title: "Burundi", value: "BI"},
        {title: "Cambodia", value: "KH"},
        {title: "Cameroon", value: "CM"},
        {title: "Canada", value: "CA"},
        {title: "Cape Verde", value: "CV"},
        {title: "Cayman Islands", value: "KY"},
        {title: "Central African Republic", value: "CF"},
        {title: "Chad", value: "TD"},
        {title: "Chile", value: "CL"},
        {title: "China", value: "CN"},
        {title: "Christmas Island", value: "CX"},
        {title: "Cocos (Keeling) Islands", value: "CC"},
        {title: "Colombia", value: "CO"},
        {title: "Comoros", value: "KM"},
        {title: "Congo", value: "CG"},
        {title: "Congo, The Democratic Republic of the", value: "CD"},
        {title: "Cook Islands", value: "CK"},
        {title: "Costa Rica", value: "CR"},
        {title: "Cote D'Ivoire", value: "CI"},
        {title: "Croatia", value: "HR"},
        {title: "Cuba", value: "CU"},
        {title: "Cyprus", value: "CY"},
        {title: "Czech Republic", value: "CZ"},
        {title: "Denmark", value: "DK"},
        {title: "Djibouti", value: "DJ"},
        {title: "Dominica", value: "DM"},
        {title: "Dominican Republic", value: "DO"},
        {title: "Ecuador", value: "EC"},
        {title: "Egypt", value: "EG"},
        {title: "El Salvador", value: "SV"},
        {title: "Equatorial Guinea", value: "GQ"},
        {title: "Eritrea", value: "ER"},
        {title: "Estonia", value: "EE"},
        {title: "Ethiopia", value: "ET"},
        {title: "Falkland Islands (Malvinas)", value: "FK"},
        {title: "Faroe Islands", value: "FO"},
        {title: "Fiji", value: "FJ"},
        {title: "Finland", value: "FI"},
        {title: "France", value: "FR"},
        {title: "French Guiana", value: "GF"},
        {title: "French Polynesia", value: "PF"},
        {title: "French Southern Territories", value: "TF"},
        {title: "Gabon", value: "GA"},
        {title: "Gambia", value: "GM"},
        {title: "Georgia", value: "GE"},
        {title: "Germany", value: "DE"},
        {title: "Ghana", value: "GH"},
        {title: "Gibraltar", value: "GI"},
        {title: "Greece", value: "GR"},
        {title: "Greenland", value: "GL"},
        {title: "Grenada", value: "GD"},
        {title: "Guadeloupe", value: "GP"},
        {title: "Guam", value: "GU"},
        {title: "Guatemala", value: "GT"},
        {title: "Guernsey", value: "GG"},
        {title: "Guinea", value: "GN"},
        {title: "Guinea-Bissau", value: "GW"},
        {title: "Guyana", value: "GY"},
        {title: "Haiti", value: "HT"},
        {title: "Heard Island and Mcdonald Islands", value: "HM"},
        {title: "Holy See (Vatican City State)", value: "VA"},
        {title: "Honduras", value: "HN"},
        {title: "Hong Kong", value: "HK"},
        {title: "Hungary", value: "HU"},
        {title: "Iceland", value: "IS"},
        {title: "India", value: "IN"},
        {title: "Indonesia", value: "ID"},
        {title: "Iran, Islamic Republic Of", value: "IR"},
        {title: "Iraq", value: "IQ"},
        {title: "Ireland", value: "IE"},
        {title: "Isle of Man", value: "IM"},
        {title: "Israel", value: "IL"},
        {title: "Italy", value: "IT"},
        {title: "Jamaica", value: "JM"},
        {title: "Japan", value: "JP"},
        {title: "Jersey", value: "JE"},
        {title: "Jordan", value: "JO"},
        {title: "Kazakhstan", value: "KZ"},
        {title: "Kenya", value: "KE"},
        {title: "Kiribati", value: "KI"},
        {title: "Korea, Democratic People's Republic of", value: "KP"},
        {title: "Korea, Republic of", value: "KR"},
        {title: "Kuwait", value: "KW"},
        {title: "Kyrgyzstan", value: "KG"},
        {title: "Lao People's Democratic Republic", value: "LA"},
        {title: "Latvia", value: "LV"},
        {title: "Lebanon", value: "LB"},
        {title: "Lesotho", value: "LS"},
        {title: "Liberia", value: "LR"},
        {title: "Libyan Arab Jamahiriya", value: "LY"},
        {title: "Liechtenstein", value: "LI"},
        {title: "Lithuania", value: "LT"},
        {title: "Luxembourg", value: "LU"},
        {title: "Macao", value: "MO"},
        {title: "Macedonia, The Former Yugoslav Republic of", value: "MK"},
        {title: "Madagascar", value: "MG"},
        {title: "Malawi", value: "MW"},
        {title: "Malaysia", value: "MY"},
        {title: "Maldives", value: "MV"},
        {title: "Mali", value: "ML"},
        {title: "Malta", value: "MT"},
        {title: "Marshall Islands", value: "MH"},
        {title: "Martinique", value: "MQ"},
        {title: "Mauritania", value: "MR"},
        {title: "Mauritius", value: "MU"},
        {title: "Mayotte", value: "YT"},
        {title: "Mexico", value: "MX"},
        {title: "Micronesia, Federated States of", value: "FM"},
        {title: "Moldova, Republic of", value: "MD"},
        {title: "Monaco", value: "MC"},
        {title: "Mongolia", value: "MN"},
        {title: "Montserrat", value: "MS"},
        {title: "Morocco", value: "MA"},
        {title: "Mozambique", value: "MZ"},
        {title: "Myanmar", value: "MM"},
        {title: "Namibia", value: "NA"},
        {title: "Nauru", value: "NR"},
        {title: "Nepal", value: "NP"},
        {title: "Netherlands", value: "NL"},
        {title: "Netherlands Antilles", value: "AN"},
        {title: "New Caledonia", value: "NC"},
        {title: "New Zealand", value: "NZ"},
        {title: "Nicaragua", value: "NI"},
        {title: "Niger", value: "NE"},
        {title: "Nigeria", value: "NG"},
        {title: "Niue", value: "NU"},
        {title: "Norfolk Island", value: "NF"},
        {title: "Northern Mariana Islands", value: "MP"},
        {title: "Norway", value: "NO"},
        {title: "Oman", value: "OM"},
        {title: "Pakistan", value: "PK"},
        {title: "Palau", value: "PW"},
        {title: "Palestinian Territory, Occupied", value: "PS"},
        {title: "Panama", value: "PA"},
        {title: "Papua New Guinea", value: "PG"},
        {title: "Paraguay", value: "PY"},
        {title: "Peru", value: "PE"},
        {title: "Philippines", value: "PH"},
        {title: "Pitcairn", value: "PN"},
        {title: "Poland", value: "PL"},
        {title: "Portugal", value: "PT"},
        {title: "Puerto Rico", value: "PR"},
        {title: "Qatar", value: "QA"},
        {title: "Reunion", value: "RE"},
        {title: "Romania", value: "RO"},
        {title: "Russian Federation", value: "RU"},
        {title: "RWANDA", value: "RW"},
        {title: "Saint Helena", value: "SH"},
        {title: "Saint Kitts and Nevis", value: "KN"},
        {title: "Saint Lucia", value: "LC"},
        {title: "Saint Pierre and Miquelon", value: "PM"},
        {title: "Saint Vincent and the Grenadines", value: "VC"},
        {title: "Samoa", value: "WS"},
        {title: "San Marino", value: "SM"},
        {title: "Sao Tome and Principe", value: "ST"},
        {title: "Saudi Arabia", value: "SA"},
        {title: "Senegal", value: "SN"},
        {title: "Serbia and Montenegro", value: "CS"},
        {title: "Seychelles", value: "SC"},
        {title: "Sierra Leone", value: "SL"},
        {title: "Singapore", value: "SG"},
        {title: "Slovakia", value: "SK"},
        {title: "Slovenia", value: "SI"},
        {title: "Solomon Islands", value: "SB"},
        {title: "Somalia", value: "SO"},
        {title: "South Africa", value: "ZA"},
        {title: "South Georgia and the South Sandwich Islands", value: "GS"},
        {title: "Spain", value: "ES"},
        {title: "Sri Lanka", value: "LK"},
        {title: "Sudan", value: "SD"},
        {title: "Suriname", value: "SR"},
        {title: "Svalbard and Jan Mayen", value: "SJ"},
        {title: "Swaziland", value: "SZ"},
        {title: "Sweden", value: "SE"},
        {title: "Switzerland", value: "CH"},
        {title: "Syrian Arab Republic", value: "SY"},
        {title: "Taiwan, Province of China", value: "TW"},
        {title: "Tajikistan", value: "TJ"},
        {title: "Tanzania, United Republic of", value: "TZ"},
        {title: "Thailand", value: "TH"},
        {title: "Timor-Leste", value: "TL"},
        {title: "Togo", value: "TG"},
        {title: "Tokelau", value: "TK"},
        {title: "Tonga", value: "TO"},
        {title: "Trinidad and Tobago", value: "TT"},
        {title: "Tunisia", value: "TN"},
        {title: "Turkey", value: "TR"},
        {title: "Turkmenistan", value: "TM"},
        {title: "Turks and Caicos Islands", value: "TC"},
        {title: "Tuvalu", value: "TV"},
        {title: "Uganda", value: "UG"},
        {title: "Ukraine", value: "UA"},
        {title: "United Arab Emirates", value: "AE"},
        {title: "United Kingdom", value: "GB"},
        {title: "United States of America", value: "US"},
        {title: "United States Minor Outlying Islands", value: "UM"},
        {title: "Uruguay", value: "UY"},
        {title: "Uzbekistan", value: "UZ"},
        {title: "Vanuatu", value: "VU"},
        {title: "Venezuela", value: "VE"},
        {title: "Vietnam", value: "VN"},
        {title: "Virgin Islands, British", value: "VG"},
        {title: "Virgin Islands, U.S.", value: "VI"},
        {title: "Wallis and Futuna", value: "WF"},
        {title: "Western Sahara", value: "EH"},
        {title: "Yemen", value: "YE"},
        {title: "Zambia", value: "ZM"},
        {title: "Zimbabwe", value: "ZW"}
    ];

    /* node_modules/svelte-infinite-scroll/dist/InfiniteScroll.svelte generated by Svelte v3.45.0 */
    const file$v = "node_modules/svelte-infinite-scroll/dist/InfiniteScroll.svelte";

    // (73:0) {#if !window && !elementScroll}
    function create_if_block$u(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "id", "svelte-infinite-scroll");
    			set_style(div, "width", "0");
    			add_location(div, file$v, 73, 2, 1974);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			/*div_binding*/ ctx[11](div);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			/*div_binding*/ ctx[11](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(73:0) {#if !window && !elementScroll}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let if_block_anchor;
    	let if_block = !/*window*/ ctx[1] && !/*elementScroll*/ ctx[0] && create_if_block$u(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*window*/ ctx[1] && !/*elementScroll*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$u(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InfiniteScroll', slots, []);
    	let { threshold = 0 } = $$props;
    	let { horizontal = false } = $$props;
    	let { elementScroll = null } = $$props;
    	let { hasMore = true } = $$props;
    	let { reverse = false } = $$props;
    	let { window = false } = $$props;
    	const dispatch = createEventDispatcher();
    	let isLoadMore = false;
    	let component;
    	let beforeScrollHeight;
    	let beforeScrollTop;
    	let element;

    	const onScroll = e => {
    		if (!hasMore) return;
    		const target = e.target;
    		const offset = calcOffset(target, reverse, horizontal);

    		if (offset <= threshold) {
    			if (!isLoadMore && hasMore) {
    				dispatch("loadMore");
    				$$invalidate(8, beforeScrollHeight = target.scrollHeight);
    				$$invalidate(9, beforeScrollTop = target.scrollTop);
    			}

    			$$invalidate(7, isLoadMore = true);
    		} else {
    			$$invalidate(7, isLoadMore = false);
    		}
    	};

    	const calcOffset = (target, reverse, horizontal) => {
    		const element = target.documentElement ? target.documentElement : target;

    		if (reverse) {
    			return horizontal ? element.scrollLeft : element.scrollTop;
    		}

    		return horizontal
    		? element.scrollWidth - element.clientWidth - element.scrollLeft
    		: element.scrollHeight - element.clientHeight - element.scrollTop;
    	};

    	onMount(() => {
    		if (window) {
    			$$invalidate(10, element = document);
    		} else if (elementScroll) {
    			$$invalidate(10, element = elementScroll);
    		} else {
    			$$invalidate(10, element = component.parentNode);
    		}
    	});

    	onDestroy(() => {
    		if (element) {
    			element.removeEventListener("scroll", onScroll);
    			element.removeEventListener("resize", onScroll);
    		}
    	});

    	const writable_props = ['threshold', 'horizontal', 'elementScroll', 'hasMore', 'reverse', 'window'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<InfiniteScroll> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			component = $$value;
    			$$invalidate(2, component);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('threshold' in $$props) $$invalidate(3, threshold = $$props.threshold);
    		if ('horizontal' in $$props) $$invalidate(4, horizontal = $$props.horizontal);
    		if ('elementScroll' in $$props) $$invalidate(0, elementScroll = $$props.elementScroll);
    		if ('hasMore' in $$props) $$invalidate(5, hasMore = $$props.hasMore);
    		if ('reverse' in $$props) $$invalidate(6, reverse = $$props.reverse);
    		if ('window' in $$props) $$invalidate(1, window = $$props.window);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onDestroy,
    		createEventDispatcher,
    		threshold,
    		horizontal,
    		elementScroll,
    		hasMore,
    		reverse,
    		window,
    		dispatch,
    		isLoadMore,
    		component,
    		beforeScrollHeight,
    		beforeScrollTop,
    		element,
    		onScroll,
    		calcOffset
    	});

    	$$self.$inject_state = $$props => {
    		if ('threshold' in $$props) $$invalidate(3, threshold = $$props.threshold);
    		if ('horizontal' in $$props) $$invalidate(4, horizontal = $$props.horizontal);
    		if ('elementScroll' in $$props) $$invalidate(0, elementScroll = $$props.elementScroll);
    		if ('hasMore' in $$props) $$invalidate(5, hasMore = $$props.hasMore);
    		if ('reverse' in $$props) $$invalidate(6, reverse = $$props.reverse);
    		if ('window' in $$props) $$invalidate(1, window = $$props.window);
    		if ('isLoadMore' in $$props) $$invalidate(7, isLoadMore = $$props.isLoadMore);
    		if ('component' in $$props) $$invalidate(2, component = $$props.component);
    		if ('beforeScrollHeight' in $$props) $$invalidate(8, beforeScrollHeight = $$props.beforeScrollHeight);
    		if ('beforeScrollTop' in $$props) $$invalidate(9, beforeScrollTop = $$props.beforeScrollTop);
    		if ('element' in $$props) $$invalidate(10, element = $$props.element);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*element, reverse*/ 1088) {
    			if (element) {
    				if (reverse) {
    					$$invalidate(10, element.scrollTop = element.scrollHeight, element);
    				}

    				element.addEventListener("scroll", onScroll);
    				element.addEventListener("resize", onScroll);
    			}
    		}

    		if ($$self.$$.dirty & /*isLoadMore, reverse, element, beforeScrollHeight, beforeScrollTop*/ 1984) {
    			if (isLoadMore && reverse) {
    				$$invalidate(10, element.scrollTop = element.scrollHeight - beforeScrollHeight + beforeScrollTop, element);
    			}
    		}
    	};

    	return [
    		elementScroll,
    		window,
    		component,
    		threshold,
    		horizontal,
    		hasMore,
    		reverse,
    		isLoadMore,
    		beforeScrollHeight,
    		beforeScrollTop,
    		element,
    		div_binding
    	];
    }

    class InfiniteScroll extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			threshold: 3,
    			horizontal: 4,
    			elementScroll: 0,
    			hasMore: 5,
    			reverse: 6,
    			window: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InfiniteScroll",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get threshold() {
    		throw new Error("<InfiniteScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set threshold(value) {
    		throw new Error("<InfiniteScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get horizontal() {
    		throw new Error("<InfiniteScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set horizontal(value) {
    		throw new Error("<InfiniteScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get elementScroll() {
    		throw new Error("<InfiniteScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set elementScroll(value) {
    		throw new Error("<InfiniteScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasMore() {
    		throw new Error("<InfiniteScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasMore(value) {
    		throw new Error("<InfiniteScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get reverse() {
    		throw new Error("<InfiniteScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set reverse(value) {
    		throw new Error("<InfiniteScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get window() {
    		throw new Error("<InfiniteScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set window(value) {
    		throw new Error("<InfiniteScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var autoComplete_min = createCommonjsModule(function (module, exports) {
    var e;e=function(){function t(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,r);}return n}function e(e){for(var n=1;n<arguments.length;n++){var i=null!=arguments[n]?arguments[n]:{};n%2?t(Object(i),!0).forEach((function(t){r(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):t(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function n(t){return (n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t){return function(t){if(Array.isArray(t))return s(t)}(t)||function(t){if("undefined"!=typeof Symbol&&null!=t[Symbol.iterator]||null!=t["@@iterator"])return Array.from(t)}(t)||o(t)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function o(t,e){if(t){if("string"==typeof t)return s(t,e);var n=Object.prototype.toString.call(t).slice(8,-1);return "Object"===n&&t.constructor&&(n=t.constructor.name),"Map"===n||"Set"===n?Array.from(t):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?s(t,e):void 0}}function s(t,e){(null==e||e>t.length)&&(e=t.length);for(var n=0,r=new Array(e);n<e;n++)r[n]=t[n];return r}var u=function(t){return "string"==typeof t?document.querySelector(t):t()},a=function(t,e){var n="string"==typeof t?document.createElement(t):t;for(var r in e){var i=e[r];if("inside"===r)i.append(n);else if("dest"===r)u(i[0]).insertAdjacentElement(i[1],n);else if("around"===r){var o=i;o.parentNode.insertBefore(n,o),n.append(o),null!=o.getAttribute("autofocus")&&o.focus();}else r in n?n[r]=i:n.setAttribute(r,i);}return n},c=function(t,e){return t=t.toString().toLowerCase(),e?t.normalize("NFD").replace(/[\u0300-\u036f]/g,"").normalize("NFC"):t},l=function(t,n){return a("mark",e({innerHTML:t},"string"==typeof n&&{class:n})).outerHTML},f=function(t,e){e.input.dispatchEvent(new CustomEvent(t,{bubbles:!0,detail:e.feedback,cancelable:!0}));},p=function(t,e,n){var r=n||{},i=r.mode,o=r.diacritics,s=r.highlight,u=c(e,o);if(e=e.toString(),t=c(t,o),"loose"===i){var a=(t=t.replace(/ /g,"")).length,f=0,p=Array.from(e).map((function(e,n){return f<a&&u[n]===t[f]&&(e=s?l(e,s):e,f++),e})).join("");if(f===a)return p}else {var d=u.indexOf(t);if(~d)return t=e.substring(d,d+t.length),d=s?e.replace(t,l(t,s)):e}},d=function(t,e){return new Promise((function(n,r){var i;return (i=t.data).cache&&i.store?n():new Promise((function(t,n){return "function"==typeof i.src?i.src(e).then(t,n):t(i.src)})).then((function(e){try{return t.feedback=i.store=e,f("response",t),n()}catch(t){return r(t)}}),r)}))},h=function(t,e){var n=e.data,r=e.searchEngine,i=[];n.store.forEach((function(s,u){var a=function(n){var o=n?s[n]:s,u="function"==typeof r?r(t,o):p(t,o,{mode:r,diacritics:e.diacritics,highlight:e.resultItem.highlight});if(u){var a={match:u,value:s};n&&(a.key=n),i.push(a);}};if(n.keys){var c,l=function(t,e){var n="undefined"!=typeof Symbol&&t[Symbol.iterator]||t["@@iterator"];if(!n){if(Array.isArray(t)||(n=o(t))||e&&t&&"number"==typeof t.length){n&&(t=n);var r=0,i=function(){};return {s:i,n:function(){return r>=t.length?{done:!0}:{done:!1,value:t[r++]}},e:function(t){throw t},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,u=!0,a=!1;return {s:function(){n=n.call(t);},n:function(){var t=n.next();return u=t.done,t},e:function(t){a=!0,s=t;},f:function(){try{u||null==n.return||n.return();}finally{if(a)throw s}}}}(n.keys);try{for(l.s();!(c=l.n()).done;)a(c.value);}catch(t){l.e(t);}finally{l.f();}}else a();})),n.filter&&(i=n.filter(i));var s=i.slice(0,e.resultsList.maxResults);e.feedback={query:t,matches:i,results:s},f("results",e);},m="aria-expanded",b="aria-activedescendant",y="aria-selected",v=function(t,n){t.feedback.selection=e({index:n},t.feedback.results[n]);},g=function(t){t.isOpen||((t.wrapper||t.input).setAttribute(m,!0),t.list.removeAttribute("hidden"),t.isOpen=!0,f("open",t));},w=function(t){t.isOpen&&((t.wrapper||t.input).setAttribute(m,!1),t.input.setAttribute(b,""),t.list.setAttribute("hidden",""),t.isOpen=!1,f("close",t));},O=function(t,e){var n=e.resultItem,r=e.list.getElementsByTagName(n.tag),o=!!n.selected&&n.selected.split(" ");if(e.isOpen&&r.length){var s,u,a=e.cursor;t>=r.length&&(t=0),t<0&&(t=r.length-1),e.cursor=t,a>-1&&(r[a].removeAttribute(y),o&&(u=r[a].classList).remove.apply(u,i(o))),r[t].setAttribute(y,!0),o&&(s=r[t].classList).add.apply(s,i(o)),e.input.setAttribute(b,r[e.cursor].id),e.list.scrollTop=r[t].offsetTop-e.list.clientHeight+r[t].clientHeight+5,e.feedback.cursor=e.cursor,v(e,t),f("navigate",e);}},A=function(t){O(t.cursor+1,t);},k=function(t){O(t.cursor-1,t);},L=function(t,e,n){(n=n>=0?n:t.cursor)<0||(t.feedback.event=e,v(t,n),f("selection",t),w(t));};function j(t,n){var r=this;return new Promise((function(i,o){var s,u;return s=n||((u=t.input)instanceof HTMLInputElement||u instanceof HTMLTextAreaElement?u.value:u.innerHTML),function(t,e,n){return e?e(t):t.length>=n}(s=t.query?t.query(s):s,t.trigger,t.threshold)?d(t,s).then((function(n){try{return t.feedback instanceof Error?i():(h(s,t),t.resultsList&&function(t){var n=t.resultsList,r=t.list,i=t.resultItem,o=t.feedback,s=o.matches,u=o.results;if(t.cursor=-1,r.innerHTML="",s.length||n.noResults){var c=new DocumentFragment;u.forEach((function(t,n){var r=a(i.tag,e({id:"".concat(i.id,"_").concat(n),role:"option",innerHTML:t.match,inside:c},i.class&&{class:i.class}));i.element&&i.element(r,t);})),r.append(c),n.element&&n.element(r,o),g(t);}else w(t);}(t),c.call(r))}catch(t){return o(t)}}),o):(w(t),c.call(r));function c(){return i()}}))}var S=function(t,e){for(var n in t)for(var r in t[n])e(n,r);},T=function(t){var n,r,i,o=t.events,s=(n=function(){return j(t)},r=t.debounce,function(){clearTimeout(i),i=setTimeout((function(){return n()}),r);}),u=t.events=e({input:e({},o&&o.input)},t.resultsList&&{list:o?e({},o.list):{}}),a={input:{input:function(){s();},keydown:function(e){!function(t,e){switch(t.keyCode){case 40:case 38:t.preventDefault(),40===t.keyCode?A(e):k(e);break;case 13:e.submit||t.preventDefault(),e.cursor>=0&&L(e,t);break;case 9:e.resultsList.tabSelect&&e.cursor>=0&&L(e,t);break;case 27:e.input.value="",w(e);}}(e,t);},blur:function(){w(t);}},list:{mousedown:function(t){t.preventDefault();},click:function(e){!function(t,e){var n=e.resultItem.tag.toUpperCase(),r=Array.from(e.list.querySelectorAll(n)),i=t.target.closest(n);i&&i.nodeName===n&&L(e,t,r.indexOf(i));}(e,t);}}};S(a,(function(e,n){(t.resultsList||"input"===n)&&(u[e][n]||(u[e][n]=a[e][n]));})),S(u,(function(e,n){t[e].addEventListener(n,u[e][n]);}));};function E(t){var n=this;return new Promise((function(r,i){var o,s,u;if(o=t.placeHolder,u={role:"combobox","aria-owns":(s=t.resultsList).id,"aria-haspopup":!0,"aria-expanded":!1},a(t.input,e(e({"aria-controls":s.id,"aria-autocomplete":"both"},o&&{placeholder:o}),!t.wrapper&&e({},u))),t.wrapper&&(t.wrapper=a("div",e({around:t.input,class:t.name+"_wrapper"},u))),s&&(t.list=a(s.tag,e({dest:[s.destination,s.position],id:s.id,role:"listbox",hidden:"hidden"},s.class&&{class:s.class}))),T(t),t.data.cache)return d(t).then((function(t){try{return c.call(n)}catch(t){return i(t)}}),i);function c(){return f("init",t),r()}return c.call(n)}))}function x(t){var e=t.prototype;e.init=function(){E(this);},e.start=function(t){j(this,t);},e.unInit=function(){if(this.wrapper){var t=this.wrapper.parentNode;t.insertBefore(this.input,this.wrapper),t.removeChild(this.wrapper);}var e;S((e=this).events,(function(t,n){e[t].removeEventListener(n,e.events[t][n]);}));},e.open=function(){g(this);},e.close=function(){w(this);},e.goTo=function(t){O(t,this);},e.next=function(){A(this);},e.previous=function(){k(this);},e.select=function(t){L(this,null,t);},e.search=function(t,e,n){return p(t,e,n)};}return function t(e){this.options=e,this.id=t.instances=(t.instances||0)+1,this.name="autoComplete",this.wrapper=1,this.threshold=1,this.debounce=0,this.resultsList={position:"afterend",tag:"ul",maxResults:5},this.resultItem={tag:"li"},function(t){var e=t.name,r=t.options,i=t.resultsList,o=t.resultItem;for(var s in r)if("object"===n(r[s]))for(var a in t[s]||(t[s]={}),r[s])t[s][a]=r[s][a];else t[s]=r[s];t.selector=t.selector||"#"+e,i.destination=i.destination||t.selector,i.id=i.id||e+"_list_"+t.id,o.id=o.id||e+"_result",t.input=u(t.selector);}(this),x.call(this,t),E(this);}},module.exports=e();
    });

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _extends$5() {
      _extends$5 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];

          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }

        return target;
      };

      return _extends$5.apply(this, arguments);
    }

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;

      _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };

      return _wrapNativeSuper(Class);
    }

    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;

      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }

      return target;
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

      return arr2;
    }

    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it) return (it = it.call(o)).next.bind(it);

      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    // these aren't really private, but nor are they really useful to document

    /**
     * @private
     */
    var LuxonError = /*#__PURE__*/function (_Error) {
      _inheritsLoose(LuxonError, _Error);

      function LuxonError() {
        return _Error.apply(this, arguments) || this;
      }

      return LuxonError;
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    /**
     * @private
     */


    var InvalidDateTimeError = /*#__PURE__*/function (_LuxonError) {
      _inheritsLoose(InvalidDateTimeError, _LuxonError);

      function InvalidDateTimeError(reason) {
        return _LuxonError.call(this, "Invalid DateTime: " + reason.toMessage()) || this;
      }

      return InvalidDateTimeError;
    }(LuxonError);
    /**
     * @private
     */

    var InvalidIntervalError = /*#__PURE__*/function (_LuxonError2) {
      _inheritsLoose(InvalidIntervalError, _LuxonError2);

      function InvalidIntervalError(reason) {
        return _LuxonError2.call(this, "Invalid Interval: " + reason.toMessage()) || this;
      }

      return InvalidIntervalError;
    }(LuxonError);
    /**
     * @private
     */

    var InvalidDurationError = /*#__PURE__*/function (_LuxonError3) {
      _inheritsLoose(InvalidDurationError, _LuxonError3);

      function InvalidDurationError(reason) {
        return _LuxonError3.call(this, "Invalid Duration: " + reason.toMessage()) || this;
      }

      return InvalidDurationError;
    }(LuxonError);
    /**
     * @private
     */

    var ConflictingSpecificationError = /*#__PURE__*/function (_LuxonError4) {
      _inheritsLoose(ConflictingSpecificationError, _LuxonError4);

      function ConflictingSpecificationError() {
        return _LuxonError4.apply(this, arguments) || this;
      }

      return ConflictingSpecificationError;
    }(LuxonError);
    /**
     * @private
     */

    var InvalidUnitError = /*#__PURE__*/function (_LuxonError5) {
      _inheritsLoose(InvalidUnitError, _LuxonError5);

      function InvalidUnitError(unit) {
        return _LuxonError5.call(this, "Invalid unit " + unit) || this;
      }

      return InvalidUnitError;
    }(LuxonError);
    /**
     * @private
     */

    var InvalidArgumentError = /*#__PURE__*/function (_LuxonError6) {
      _inheritsLoose(InvalidArgumentError, _LuxonError6);

      function InvalidArgumentError() {
        return _LuxonError6.apply(this, arguments) || this;
      }

      return InvalidArgumentError;
    }(LuxonError);
    /**
     * @private
     */

    var ZoneIsAbstractError = /*#__PURE__*/function (_LuxonError7) {
      _inheritsLoose(ZoneIsAbstractError, _LuxonError7);

      function ZoneIsAbstractError() {
        return _LuxonError7.call(this, "Zone is an abstract class") || this;
      }

      return ZoneIsAbstractError;
    }(LuxonError);

    /**
     * @private
     */
    var n = "numeric",
        s$1 = "short",
        l = "long";
    var DATE_SHORT = {
      year: n,
      month: n,
      day: n
    };
    var DATE_MED = {
      year: n,
      month: s$1,
      day: n
    };
    var DATE_MED_WITH_WEEKDAY = {
      year: n,
      month: s$1,
      day: n,
      weekday: s$1
    };
    var DATE_FULL = {
      year: n,
      month: l,
      day: n
    };
    var DATE_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l
    };
    var TIME_SIMPLE = {
      hour: n,
      minute: n
    };
    var TIME_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n
    };
    var TIME_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s$1
    };
    var TIME_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };
    var TIME_24_SIMPLE = {
      hour: n,
      minute: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SECONDS = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23"
    };
    var TIME_24_WITH_SHORT_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: s$1
    };
    var TIME_24_WITH_LONG_OFFSET = {
      hour: n,
      minute: n,
      second: n,
      hourCycle: "h23",
      timeZoneName: l
    };
    var DATETIME_SHORT = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_SHORT_WITH_SECONDS = {
      year: n,
      month: n,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED = {
      year: n,
      month: s$1,
      day: n,
      hour: n,
      minute: n
    };
    var DATETIME_MED_WITH_SECONDS = {
      year: n,
      month: s$1,
      day: n,
      hour: n,
      minute: n,
      second: n
    };
    var DATETIME_MED_WITH_WEEKDAY = {
      year: n,
      month: s$1,
      day: n,
      weekday: s$1,
      hour: n,
      minute: n
    };
    var DATETIME_FULL = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      timeZoneName: s$1
    };
    var DATETIME_FULL_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: s$1
    };
    var DATETIME_HUGE = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      timeZoneName: l
    };
    var DATETIME_HUGE_WITH_SECONDS = {
      year: n,
      month: l,
      day: n,
      weekday: l,
      hour: n,
      minute: n,
      second: n,
      timeZoneName: l
    };

    /**
     * @private
     */
    // TYPES

    function isUndefined(o) {
      return typeof o === "undefined";
    }
    function isNumber(o) {
      return typeof o === "number";
    }
    function isInteger(o) {
      return typeof o === "number" && o % 1 === 0;
    }
    function isString(o) {
      return typeof o === "string";
    }
    function isDate$1(o) {
      return Object.prototype.toString.call(o) === "[object Date]";
    } // CAPABILITIES

    function hasRelative() {
      try {
        return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
      } catch (e) {
        return false;
      }
    } // OBJECTS AND ARRAYS

    function maybeArray(thing) {
      return Array.isArray(thing) ? thing : [thing];
    }
    function bestBy(arr, by, compare) {
      if (arr.length === 0) {
        return undefined;
      }

      return arr.reduce(function (best, next) {
        var pair = [by(next), next];

        if (!best) {
          return pair;
        } else if (compare(best[0], pair[0]) === best[0]) {
          return best;
        } else {
          return pair;
        }
      }, null)[1];
    }
    function pick(obj, keys) {
      return keys.reduce(function (a, k) {
        a[k] = obj[k];
        return a;
      }, {});
    }
    function hasOwnProperty$a(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    } // NUMBERS AND STRINGS

    function integerBetween(thing, bottom, top) {
      return isInteger(thing) && thing >= bottom && thing <= top;
    } // x % n but takes the sign of n instead of x

    function floorMod(x, n) {
      return x - n * Math.floor(x / n);
    }
    function padStart(input, n) {
      if (n === void 0) {
        n = 2;
      }

      var isNeg = input < 0;
      var padded;

      if (isNeg) {
        padded = "-" + ("" + -input).padStart(n, "0");
      } else {
        padded = ("" + input).padStart(n, "0");
      }

      return padded;
    }
    function parseInteger(string) {
      if (isUndefined(string) || string === null || string === "") {
        return undefined;
      } else {
        return parseInt(string, 10);
      }
    }
    function parseFloating(string) {
      if (isUndefined(string) || string === null || string === "") {
        return undefined;
      } else {
        return parseFloat(string);
      }
    }
    function parseMillis(fraction) {
      // Return undefined (instead of 0) in these cases, where fraction is not set
      if (isUndefined(fraction) || fraction === null || fraction === "") {
        return undefined;
      } else {
        var f = parseFloat("0." + fraction) * 1000;
        return Math.floor(f);
      }
    }
    function roundTo(number, digits, towardZero) {
      if (towardZero === void 0) {
        towardZero = false;
      }

      var factor = Math.pow(10, digits),
          rounder = towardZero ? Math.trunc : Math.round;
      return rounder(number * factor) / factor;
    } // DATE BASICS

    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    function daysInMonth(year, month) {
      var modMonth = floorMod(month - 1, 12) + 1,
          modYear = year + (month - modMonth) / 12;

      if (modMonth === 2) {
        return isLeapYear(modYear) ? 29 : 28;
      } else {
        return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
      }
    } // covert a calendar object to a local timestamp (epoch, but with the offset baked in)

    function objToLocalTS(obj) {
      var d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond); // for legacy reasons, years between 0 and 99 are interpreted as 19XX; revert that

      if (obj.year < 100 && obj.year >= 0) {
        d = new Date(d);
        d.setUTCFullYear(d.getUTCFullYear() - 1900);
      }

      return +d;
    }
    function weeksInWeekYear(weekYear) {
      var p1 = (weekYear + Math.floor(weekYear / 4) - Math.floor(weekYear / 100) + Math.floor(weekYear / 400)) % 7,
          last = weekYear - 1,
          p2 = (last + Math.floor(last / 4) - Math.floor(last / 100) + Math.floor(last / 400)) % 7;
      return p1 === 4 || p2 === 3 ? 53 : 52;
    }
    function untruncateYear(year) {
      if (year > 99) {
        return year;
      } else return year > 60 ? 1900 + year : 2000 + year;
    } // PARSING

    function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
      if (timeZone === void 0) {
        timeZone = null;
      }

      var date = new Date(ts),
          intlOpts = {
        hourCycle: "h23",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit"
      };

      if (timeZone) {
        intlOpts.timeZone = timeZone;
      }

      var modified = _extends$5({
        timeZoneName: offsetFormat
      }, intlOpts);

      var parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find(function (m) {
        return m.type.toLowerCase() === "timezonename";
      });
      return parsed ? parsed.value : null;
    } // signedOffset('-5', '30') -> -330

    function signedOffset(offHourStr, offMinuteStr) {
      var offHour = parseInt(offHourStr, 10); // don't || this because we want to preserve -0

      if (Number.isNaN(offHour)) {
        offHour = 0;
      }

      var offMin = parseInt(offMinuteStr, 10) || 0,
          offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
      return offHour * 60 + offMinSigned;
    } // COERCION

    function asNumber(value) {
      var numericValue = Number(value);
      if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) throw new InvalidArgumentError("Invalid unit value " + value);
      return numericValue;
    }
    function normalizeObject(obj, normalizer) {
      var normalized = {};

      for (var u in obj) {
        if (hasOwnProperty$a(obj, u)) {
          var v = obj[u];
          if (v === undefined || v === null) continue;
          normalized[normalizer(u)] = asNumber(v);
        }
      }

      return normalized;
    }
    function formatOffset(offset, format) {
      var hours = Math.trunc(Math.abs(offset / 60)),
          minutes = Math.trunc(Math.abs(offset % 60)),
          sign = offset >= 0 ? "+" : "-";

      switch (format) {
        case "short":
          return "" + sign + padStart(hours, 2) + ":" + padStart(minutes, 2);

        case "narrow":
          return "" + sign + hours + (minutes > 0 ? ":" + minutes : "");

        case "techie":
          return "" + sign + padStart(hours, 2) + padStart(minutes, 2);

        default:
          throw new RangeError("Value format " + format + " is out of range for property format");
      }
    }
    function timeObject(obj) {
      return pick(obj, ["hour", "minute", "second", "millisecond"]);
    }
    var ianaRegex = /[A-Za-z_+-]{1,256}(:?\/[A-Za-z0-9_+-]{1,256}(\/[A-Za-z0-9_+-]{1,256})?)?/;

    /**
     * @private
     */


    var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
    function months$1(length) {
      switch (length) {
        case "narrow":
          return [].concat(monthsNarrow);

        case "short":
          return [].concat(monthsShort);

        case "long":
          return [].concat(monthsLong);

        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];

        case "2-digit":
          return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];

        default:
          return null;
      }
    }
    var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
    var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
    var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
    function weekdays(length) {
      switch (length) {
        case "narrow":
          return [].concat(weekdaysNarrow);

        case "short":
          return [].concat(weekdaysShort);

        case "long":
          return [].concat(weekdaysLong);

        case "numeric":
          return ["1", "2", "3", "4", "5", "6", "7"];

        default:
          return null;
      }
    }
    var meridiems = ["AM", "PM"];
    var erasLong = ["Before Christ", "Anno Domini"];
    var erasShort = ["BC", "AD"];
    var erasNarrow = ["B", "A"];
    function eras(length) {
      switch (length) {
        case "narrow":
          return [].concat(erasNarrow);

        case "short":
          return [].concat(erasShort);

        case "long":
          return [].concat(erasLong);

        default:
          return null;
      }
    }
    function meridiemForDateTime(dt) {
      return meridiems[dt.hour < 12 ? 0 : 1];
    }
    function weekdayForDateTime(dt, length) {
      return weekdays(length)[dt.weekday - 1];
    }
    function monthForDateTime(dt, length) {
      return months$1(length)[dt.month - 1];
    }
    function eraForDateTime(dt, length) {
      return eras(length)[dt.year < 0 ? 0 : 1];
    }
    function formatRelativeTime(unit, count, numeric, narrow) {
      if (numeric === void 0) {
        numeric = "always";
      }

      if (narrow === void 0) {
        narrow = false;
      }

      var units = {
        years: ["year", "yr."],
        quarters: ["quarter", "qtr."],
        months: ["month", "mo."],
        weeks: ["week", "wk."],
        days: ["day", "day", "days"],
        hours: ["hour", "hr."],
        minutes: ["minute", "min."],
        seconds: ["second", "sec."]
      };
      var lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;

      if (numeric === "auto" && lastable) {
        var isDay = unit === "days";

        switch (count) {
          case 1:
            return isDay ? "tomorrow" : "next " + units[unit][0];

          case -1:
            return isDay ? "yesterday" : "last " + units[unit][0];

          case 0:
            return isDay ? "today" : "this " + units[unit][0];

        }
      }

      var isInPast = Object.is(count, -0) || count < 0,
          fmtValue = Math.abs(count),
          singular = fmtValue === 1,
          lilUnits = units[unit],
          fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
      return isInPast ? fmtValue + " " + fmtUnit + " ago" : "in " + fmtValue + " " + fmtUnit;
    }

    function stringifyTokens(splits, tokenToString) {
      var s = "";

      for (var _iterator = _createForOfIteratorHelperLoose(splits), _step; !(_step = _iterator()).done;) {
        var token = _step.value;

        if (token.literal) {
          s += token.val;
        } else {
          s += tokenToString(token.val);
        }
      }

      return s;
    }

    var _macroTokenToFormatOpts = {
      D: DATE_SHORT,
      DD: DATE_MED,
      DDD: DATE_FULL,
      DDDD: DATE_HUGE,
      t: TIME_SIMPLE,
      tt: TIME_WITH_SECONDS,
      ttt: TIME_WITH_SHORT_OFFSET,
      tttt: TIME_WITH_LONG_OFFSET,
      T: TIME_24_SIMPLE,
      TT: TIME_24_WITH_SECONDS,
      TTT: TIME_24_WITH_SHORT_OFFSET,
      TTTT: TIME_24_WITH_LONG_OFFSET,
      f: DATETIME_SHORT,
      ff: DATETIME_MED,
      fff: DATETIME_FULL,
      ffff: DATETIME_HUGE,
      F: DATETIME_SHORT_WITH_SECONDS,
      FF: DATETIME_MED_WITH_SECONDS,
      FFF: DATETIME_FULL_WITH_SECONDS,
      FFFF: DATETIME_HUGE_WITH_SECONDS
    };
    /**
     * @private
     */

    var Formatter = /*#__PURE__*/function () {
      Formatter.create = function create(locale, opts) {
        if (opts === void 0) {
          opts = {};
        }

        return new Formatter(locale, opts);
      };

      Formatter.parseFormat = function parseFormat(fmt) {
        var current = null,
            currentFull = "",
            bracketed = false;
        var splits = [];

        for (var i = 0; i < fmt.length; i++) {
          var c = fmt.charAt(i);

          if (c === "'") {
            if (currentFull.length > 0) {
              splits.push({
                literal: bracketed,
                val: currentFull
              });
            }

            current = null;
            currentFull = "";
            bracketed = !bracketed;
          } else if (bracketed) {
            currentFull += c;
          } else if (c === current) {
            currentFull += c;
          } else {
            if (currentFull.length > 0) {
              splits.push({
                literal: false,
                val: currentFull
              });
            }

            currentFull = c;
            current = c;
          }
        }

        if (currentFull.length > 0) {
          splits.push({
            literal: bracketed,
            val: currentFull
          });
        }

        return splits;
      };

      Formatter.macroTokenToFormatOpts = function macroTokenToFormatOpts(token) {
        return _macroTokenToFormatOpts[token];
      };

      function Formatter(locale, formatOpts) {
        this.opts = formatOpts;
        this.loc = locale;
        this.systemLoc = null;
      }

      var _proto = Formatter.prototype;

      _proto.formatWithSystemDefault = function formatWithSystemDefault(dt, opts) {
        if (this.systemLoc === null) {
          this.systemLoc = this.loc.redefaultToSystem();
        }

        var df = this.systemLoc.dtFormatter(dt, _extends$5({}, this.opts, opts));
        return df.format();
      };

      _proto.formatDateTime = function formatDateTime(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }

        var df = this.loc.dtFormatter(dt, _extends$5({}, this.opts, opts));
        return df.format();
      };

      _proto.formatDateTimeParts = function formatDateTimeParts(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }

        var df = this.loc.dtFormatter(dt, _extends$5({}, this.opts, opts));
        return df.formatToParts();
      };

      _proto.resolvedOptions = function resolvedOptions(dt, opts) {
        if (opts === void 0) {
          opts = {};
        }

        var df = this.loc.dtFormatter(dt, _extends$5({}, this.opts, opts));
        return df.resolvedOptions();
      };

      _proto.num = function num(n, p) {
        if (p === void 0) {
          p = 0;
        }

        // we get some perf out of doing this here, annoyingly
        if (this.opts.forceSimple) {
          return padStart(n, p);
        }

        var opts = _extends$5({}, this.opts);

        if (p > 0) {
          opts.padTo = p;
        }

        return this.loc.numberFormatter(opts).format(n);
      };

      _proto.formatDateTimeFromString = function formatDateTimeFromString(dt, fmt) {
        var _this = this;

        var knownEnglish = this.loc.listingMode() === "en",
            useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
            string = function string(opts, extract) {
          return _this.loc.extract(dt, opts, extract);
        },
            formatOffset = function formatOffset(opts) {
          if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
            return "Z";
          }

          return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
        },
            meridiem = function meridiem() {
          return knownEnglish ? meridiemForDateTime(dt) : string({
            hour: "numeric",
            hourCycle: "h12"
          }, "dayperiod");
        },
            month = function month(length, standalone) {
          return knownEnglish ? monthForDateTime(dt, length) : string(standalone ? {
            month: length
          } : {
            month: length,
            day: "numeric"
          }, "month");
        },
            weekday = function weekday(length, standalone) {
          return knownEnglish ? weekdayForDateTime(dt, length) : string(standalone ? {
            weekday: length
          } : {
            weekday: length,
            month: "long",
            day: "numeric"
          }, "weekday");
        },
            maybeMacro = function maybeMacro(token) {
          var formatOpts = Formatter.macroTokenToFormatOpts(token);

          if (formatOpts) {
            return _this.formatWithSystemDefault(dt, formatOpts);
          } else {
            return token;
          }
        },
            era = function era(length) {
          return knownEnglish ? eraForDateTime(dt, length) : string({
            era: length
          }, "era");
        },
            tokenToString = function tokenToString(token) {
          // Where possible: http://cldr.unicode.org/translation/date-time-1/date-time#TOC-Standalone-vs.-Format-Styles
          switch (token) {
            // ms
            case "S":
              return _this.num(dt.millisecond);

            case "u": // falls through

            case "SSS":
              return _this.num(dt.millisecond, 3);
            // seconds

            case "s":
              return _this.num(dt.second);

            case "ss":
              return _this.num(dt.second, 2);
            // fractional seconds

            case "uu":
              return _this.num(Math.floor(dt.millisecond / 10), 2);

            case "uuu":
              return _this.num(Math.floor(dt.millisecond / 100));
            // minutes

            case "m":
              return _this.num(dt.minute);

            case "mm":
              return _this.num(dt.minute, 2);
            // hours

            case "h":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);

            case "hh":
              return _this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);

            case "H":
              return _this.num(dt.hour);

            case "HH":
              return _this.num(dt.hour, 2);
            // offset

            case "Z":
              // like +6
              return formatOffset({
                format: "narrow",
                allowZ: _this.opts.allowZ
              });

            case "ZZ":
              // like +06:00
              return formatOffset({
                format: "short",
                allowZ: _this.opts.allowZ
              });

            case "ZZZ":
              // like +0600
              return formatOffset({
                format: "techie",
                allowZ: _this.opts.allowZ
              });

            case "ZZZZ":
              // like EST
              return dt.zone.offsetName(dt.ts, {
                format: "short",
                locale: _this.loc.locale
              });

            case "ZZZZZ":
              // like Eastern Standard Time
              return dt.zone.offsetName(dt.ts, {
                format: "long",
                locale: _this.loc.locale
              });
            // zone

            case "z":
              // like America/New_York
              return dt.zoneName;
            // meridiems

            case "a":
              return meridiem();
            // dates

            case "d":
              return useDateTimeFormatter ? string({
                day: "numeric"
              }, "day") : _this.num(dt.day);

            case "dd":
              return useDateTimeFormatter ? string({
                day: "2-digit"
              }, "day") : _this.num(dt.day, 2);
            // weekdays - standalone

            case "c":
              // like 1
              return _this.num(dt.weekday);

            case "ccc":
              // like 'Tues'
              return weekday("short", true);

            case "cccc":
              // like 'Tuesday'
              return weekday("long", true);

            case "ccccc":
              // like 'T'
              return weekday("narrow", true);
            // weekdays - format

            case "E":
              // like 1
              return _this.num(dt.weekday);

            case "EEE":
              // like 'Tues'
              return weekday("short", false);

            case "EEEE":
              // like 'Tuesday'
              return weekday("long", false);

            case "EEEEE":
              // like 'T'
              return weekday("narrow", false);
            // months - standalone

            case "L":
              // like 1
              return useDateTimeFormatter ? string({
                month: "numeric",
                day: "numeric"
              }, "month") : _this.num(dt.month);

            case "LL":
              // like 01, doesn't seem to work
              return useDateTimeFormatter ? string({
                month: "2-digit",
                day: "numeric"
              }, "month") : _this.num(dt.month, 2);

            case "LLL":
              // like Jan
              return month("short", true);

            case "LLLL":
              // like January
              return month("long", true);

            case "LLLLL":
              // like J
              return month("narrow", true);
            // months - format

            case "M":
              // like 1
              return useDateTimeFormatter ? string({
                month: "numeric"
              }, "month") : _this.num(dt.month);

            case "MM":
              // like 01
              return useDateTimeFormatter ? string({
                month: "2-digit"
              }, "month") : _this.num(dt.month, 2);

            case "MMM":
              // like Jan
              return month("short", false);

            case "MMMM":
              // like January
              return month("long", false);

            case "MMMMM":
              // like J
              return month("narrow", false);
            // years

            case "y":
              // like 2014
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year);

            case "yy":
              // like 14
              return useDateTimeFormatter ? string({
                year: "2-digit"
              }, "year") : _this.num(dt.year.toString().slice(-2), 2);

            case "yyyy":
              // like 0012
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 4);

            case "yyyyyy":
              // like 000012
              return useDateTimeFormatter ? string({
                year: "numeric"
              }, "year") : _this.num(dt.year, 6);
            // eras

            case "G":
              // like AD
              return era("short");

            case "GG":
              // like Anno Domini
              return era("long");

            case "GGGGG":
              return era("narrow");

            case "kk":
              return _this.num(dt.weekYear.toString().slice(-2), 2);

            case "kkkk":
              return _this.num(dt.weekYear, 4);

            case "W":
              return _this.num(dt.weekNumber);

            case "WW":
              return _this.num(dt.weekNumber, 2);

            case "o":
              return _this.num(dt.ordinal);

            case "ooo":
              return _this.num(dt.ordinal, 3);

            case "q":
              // like 1
              return _this.num(dt.quarter);

            case "qq":
              // like 01
              return _this.num(dt.quarter, 2);

            case "X":
              return _this.num(Math.floor(dt.ts / 1000));

            case "x":
              return _this.num(dt.ts);

            default:
              return maybeMacro(token);
          }
        };

        return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
      };

      _proto.formatDurationFromString = function formatDurationFromString(dur, fmt) {
        var _this2 = this;

        var tokenToField = function tokenToField(token) {
          switch (token[0]) {
            case "S":
              return "millisecond";

            case "s":
              return "second";

            case "m":
              return "minute";

            case "h":
              return "hour";

            case "d":
              return "day";

            case "M":
              return "month";

            case "y":
              return "year";

            default:
              return null;
          }
        },
            tokenToString = function tokenToString(lildur) {
          return function (token) {
            var mapped = tokenToField(token);

            if (mapped) {
              return _this2.num(lildur.get(mapped), token.length);
            } else {
              return token;
            }
          };
        },
            tokens = Formatter.parseFormat(fmt),
            realTokens = tokens.reduce(function (found, _ref) {
          var literal = _ref.literal,
              val = _ref.val;
          return literal ? found : found.concat(val);
        }, []),
            collapsed = dur.shiftTo.apply(dur, realTokens.map(tokenToField).filter(function (t) {
          return t;
        }));

        return stringifyTokens(tokens, tokenToString(collapsed));
      };

      return Formatter;
    }();

    var Invalid = /*#__PURE__*/function () {
      function Invalid(reason, explanation) {
        this.reason = reason;
        this.explanation = explanation;
      }

      var _proto = Invalid.prototype;

      _proto.toMessage = function toMessage() {
        if (this.explanation) {
          return this.reason + ": " + this.explanation;
        } else {
          return this.reason;
        }
      };

      return Invalid;
    }();

    /**
     * @interface
     */

    var Zone = /*#__PURE__*/function () {
      function Zone() {}

      var _proto = Zone.prototype;

      /**
       * Returns the offset's common name (such as EST) at the specified timestamp
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the name
       * @param {Object} opts - Options to affect the format
       * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
       * @param {string} opts.locale - What locale to return the offset name in.
       * @return {string}
       */
      _proto.offsetName = function offsetName(ts, opts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Returns the offset's value as a string
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to get the offset
       * @param {string} format - What style of offset to return.
       *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
       * @return {string}
       */
      ;

      _proto.formatOffset = function formatOffset(ts, format) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return the offset in minutes for this zone at the specified timestamp.
       * @abstract
       * @param {number} ts - Epoch milliseconds for which to compute the offset
       * @return {number}
       */
      ;

      _proto.offset = function offset(ts) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is equal to another zone
       * @abstract
       * @param {Zone} otherZone - the zone to compare
       * @return {boolean}
       */
      ;

      _proto.equals = function equals(otherZone) {
        throw new ZoneIsAbstractError();
      }
      /**
       * Return whether this Zone is valid.
       * @abstract
       * @type {boolean}
       */
      ;

      _createClass(Zone, [{
        key: "type",
        get:
        /**
         * The type of zone
         * @abstract
         * @type {string}
         */
        function get() {
          throw new ZoneIsAbstractError();
        }
        /**
         * The name of this zone.
         * @abstract
         * @type {string}
         */

      }, {
        key: "name",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
        /**
         * Returns whether the offset is known to be fixed for the whole year.
         * @abstract
         * @type {boolean}
         */

      }, {
        key: "isUniversal",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }, {
        key: "isValid",
        get: function get() {
          throw new ZoneIsAbstractError();
        }
      }]);

      return Zone;
    }();

    var singleton$1 = null;
    /**
     * Represents the local zone for this JavaScript environment.
     * @implements {Zone}
     */

    var SystemZone = /*#__PURE__*/function (_Zone) {
      _inheritsLoose(SystemZone, _Zone);

      function SystemZone() {
        return _Zone.apply(this, arguments) || this;
      }

      var _proto = SystemZone.prototype;

      /** @override **/
      _proto.offsetName = function offsetName(ts, _ref) {
        var format = _ref.format,
            locale = _ref.locale;
        return parseZoneInfo(ts, format, locale);
      }
      /** @override **/
      ;

      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      ;

      _proto.offset = function offset(ts) {
        return -new Date(ts).getTimezoneOffset();
      }
      /** @override **/
      ;

      _proto.equals = function equals(otherZone) {
        return otherZone.type === "system";
      }
      /** @override **/
      ;

      _createClass(SystemZone, [{
        key: "type",
        get:
        /** @override **/
        function get() {
          return "system";
        }
        /** @override **/

      }, {
        key: "name",
        get: function get() {
          return new Intl.DateTimeFormat().resolvedOptions().timeZone;
        }
        /** @override **/

      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }], [{
        key: "instance",
        get:
        /**
         * Get a singleton instance of the local zone
         * @return {SystemZone}
         */
        function get() {
          if (singleton$1 === null) {
            singleton$1 = new SystemZone();
          }

          return singleton$1;
        }
      }]);

      return SystemZone;
    }(Zone);

    var matchingRegex = RegExp("^" + ianaRegex.source + "$");
    var dtfCache = {};

    function makeDTF(zone) {
      if (!dtfCache[zone]) {
        dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
          hour12: false,
          timeZone: zone,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit"
        });
      }

      return dtfCache[zone];
    }

    var typeToPos = {
      year: 0,
      month: 1,
      day: 2,
      hour: 3,
      minute: 4,
      second: 5
    };

    function hackyOffset(dtf, date) {
      var formatted = dtf.format(date).replace(/\u200E/g, ""),
          parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted),
          fMonth = parsed[1],
          fDay = parsed[2],
          fYear = parsed[3],
          fHour = parsed[4],
          fMinute = parsed[5],
          fSecond = parsed[6];
      return [fYear, fMonth, fDay, fHour, fMinute, fSecond];
    }

    function partsOffset(dtf, date) {
      var formatted = dtf.formatToParts(date),
          filled = [];

      for (var i = 0; i < formatted.length; i++) {
        var _formatted$i = formatted[i],
            type = _formatted$i.type,
            value = _formatted$i.value,
            pos = typeToPos[type];

        if (!isUndefined(pos)) {
          filled[pos] = parseInt(value, 10);
        }
      }

      return filled;
    }

    var ianaZoneCache = {};
    /**
     * A zone identified by an IANA identifier, like America/New_York
     * @implements {Zone}
     */

    var IANAZone = /*#__PURE__*/function (_Zone) {
      _inheritsLoose(IANAZone, _Zone);

      /**
       * @param {string} name - Zone name
       * @return {IANAZone}
       */
      IANAZone.create = function create(name) {
        if (!ianaZoneCache[name]) {
          ianaZoneCache[name] = new IANAZone(name);
        }

        return ianaZoneCache[name];
      }
      /**
       * Reset local caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      ;

      IANAZone.resetCache = function resetCache() {
        ianaZoneCache = {};
        dtfCache = {};
      }
      /**
       * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
       * @param {string} s - The string to check validity on
       * @example IANAZone.isValidSpecifier("America/New_York") //=> true
       * @example IANAZone.isValidSpecifier("Fantasia/Castle") //=> true
       * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
       * @return {boolean}
       */
      ;

      IANAZone.isValidSpecifier = function isValidSpecifier(s) {
        return !!(s && s.match(matchingRegex));
      }
      /**
       * Returns whether the provided string identifies a real zone
       * @param {string} zone - The string to check
       * @example IANAZone.isValidZone("America/New_York") //=> true
       * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
       * @example IANAZone.isValidZone("Sport~~blorp") //=> false
       * @return {boolean}
       */
      ;

      IANAZone.isValidZone = function isValidZone(zone) {
        if (!zone) {
          return false;
        }

        try {
          new Intl.DateTimeFormat("en-US", {
            timeZone: zone
          }).format();
          return true;
        } catch (e) {
          return false;
        }
      };

      function IANAZone(name) {
        var _this;

        _this = _Zone.call(this) || this;
        /** @private **/

        _this.zoneName = name;
        /** @private **/

        _this.valid = IANAZone.isValidZone(name);
        return _this;
      }
      /** @override **/


      var _proto = IANAZone.prototype;

      /** @override **/
      _proto.offsetName = function offsetName(ts, _ref) {
        var format = _ref.format,
            locale = _ref.locale;
        return parseZoneInfo(ts, format, locale, this.name);
      }
      /** @override **/
      ;

      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.offset(ts), format);
      }
      /** @override **/
      ;

      _proto.offset = function offset(ts) {
        var date = new Date(ts);
        if (isNaN(date)) return NaN;

        var dtf = makeDTF(this.name),
            _ref2 = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date),
            year = _ref2[0],
            month = _ref2[1],
            day = _ref2[2],
            hour = _ref2[3],
            minute = _ref2[4],
            second = _ref2[5]; // because we're using hour12 and https://bugs.chromium.org/p/chromium/issues/detail?id=1025564&can=2&q=%2224%3A00%22%20datetimeformat


        var adjustedHour = hour === 24 ? 0 : hour;
        var asUTC = objToLocalTS({
          year: year,
          month: month,
          day: day,
          hour: adjustedHour,
          minute: minute,
          second: second,
          millisecond: 0
        });
        var asTS = +date;
        var over = asTS % 1000;
        asTS -= over >= 0 ? over : 1000 + over;
        return (asUTC - asTS) / (60 * 1000);
      }
      /** @override **/
      ;

      _proto.equals = function equals(otherZone) {
        return otherZone.type === "iana" && otherZone.name === this.name;
      }
      /** @override **/
      ;

      _createClass(IANAZone, [{
        key: "type",
        get: function get() {
          return "iana";
        }
        /** @override **/

      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
        /** @override **/

      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return this.valid;
        }
      }]);

      return IANAZone;
    }(Zone);

    var singleton = null;
    /**
     * A zone with a fixed offset (meaning no DST)
     * @implements {Zone}
     */

    var FixedOffsetZone = /*#__PURE__*/function (_Zone) {
      _inheritsLoose(FixedOffsetZone, _Zone);

      /**
       * Get an instance with a specified offset
       * @param {number} offset - The offset in minutes
       * @return {FixedOffsetZone}
       */
      FixedOffsetZone.instance = function instance(offset) {
        return offset === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset);
      }
      /**
       * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
       * @param {string} s - The offset string to parse
       * @example FixedOffsetZone.parseSpecifier("UTC+6")
       * @example FixedOffsetZone.parseSpecifier("UTC+06")
       * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
       * @return {FixedOffsetZone}
       */
      ;

      FixedOffsetZone.parseSpecifier = function parseSpecifier(s) {
        if (s) {
          var r = s.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);

          if (r) {
            return new FixedOffsetZone(signedOffset(r[1], r[2]));
          }
        }

        return null;
      };

      function FixedOffsetZone(offset) {
        var _this;

        _this = _Zone.call(this) || this;
        /** @private **/

        _this.fixed = offset;
        return _this;
      }
      /** @override **/


      var _proto = FixedOffsetZone.prototype;

      /** @override **/
      _proto.offsetName = function offsetName() {
        return this.name;
      }
      /** @override **/
      ;

      _proto.formatOffset = function formatOffset$1(ts, format) {
        return formatOffset(this.fixed, format);
      }
      /** @override **/
      ;

      /** @override **/
      _proto.offset = function offset() {
        return this.fixed;
      }
      /** @override **/
      ;

      _proto.equals = function equals(otherZone) {
        return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
      }
      /** @override **/
      ;

      _createClass(FixedOffsetZone, [{
        key: "type",
        get: function get() {
          return "fixed";
        }
        /** @override **/

      }, {
        key: "name",
        get: function get() {
          return this.fixed === 0 ? "UTC" : "UTC" + formatOffset(this.fixed, "narrow");
        }
      }, {
        key: "isUniversal",
        get: function get() {
          return true;
        }
      }, {
        key: "isValid",
        get: function get() {
          return true;
        }
      }], [{
        key: "utcInstance",
        get:
        /**
         * Get a singleton instance of UTC
         * @return {FixedOffsetZone}
         */
        function get() {
          if (singleton === null) {
            singleton = new FixedOffsetZone(0);
          }

          return singleton;
        }
      }]);

      return FixedOffsetZone;
    }(Zone);

    /**
     * A zone that failed to parse. You should never need to instantiate this.
     * @implements {Zone}
     */

    var InvalidZone = /*#__PURE__*/function (_Zone) {
      _inheritsLoose(InvalidZone, _Zone);

      function InvalidZone(zoneName) {
        var _this;

        _this = _Zone.call(this) || this;
        /**  @private */

        _this.zoneName = zoneName;
        return _this;
      }
      /** @override **/


      var _proto = InvalidZone.prototype;

      /** @override **/
      _proto.offsetName = function offsetName() {
        return null;
      }
      /** @override **/
      ;

      _proto.formatOffset = function formatOffset() {
        return "";
      }
      /** @override **/
      ;

      _proto.offset = function offset() {
        return NaN;
      }
      /** @override **/
      ;

      _proto.equals = function equals() {
        return false;
      }
      /** @override **/
      ;

      _createClass(InvalidZone, [{
        key: "type",
        get: function get() {
          return "invalid";
        }
        /** @override **/

      }, {
        key: "name",
        get: function get() {
          return this.zoneName;
        }
        /** @override **/

      }, {
        key: "isUniversal",
        get: function get() {
          return false;
        }
      }, {
        key: "isValid",
        get: function get() {
          return false;
        }
      }]);

      return InvalidZone;
    }(Zone);

    /**
     * @private
     */
    function normalizeZone(input, defaultZone) {

      if (isUndefined(input) || input === null) {
        return defaultZone;
      } else if (input instanceof Zone) {
        return input;
      } else if (isString(input)) {
        var lowered = input.toLowerCase();
        if (lowered === "local" || lowered === "system") return defaultZone;else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;else if (IANAZone.isValidSpecifier(lowered)) return IANAZone.create(input);else return FixedOffsetZone.parseSpecifier(lowered) || new InvalidZone(input);
      } else if (isNumber(input)) {
        return FixedOffsetZone.instance(input);
      } else if (typeof input === "object" && input.offset && typeof input.offset === "number") {
        // This is dumb, but the instanceof check above doesn't seem to really work
        // so we're duck checking it
        return input;
      } else {
        return new InvalidZone(input);
      }
    }

    var now$1 = function now() {
      return Date.now();
    },
        defaultZone = "system",
        defaultLocale$2 = null,
        defaultNumberingSystem = null,
        defaultOutputCalendar = null,
        throwOnInvalid;
    /**
     * Settings contains static getters and setters that control Luxon's overall behavior. Luxon is a simple library with few options, but the ones it does have live here.
     */


    var Settings$1 = /*#__PURE__*/function () {
      function Settings() {}

      /**
       * Reset Luxon's global caches. Should only be necessary in testing scenarios.
       * @return {void}
       */
      Settings.resetCaches = function resetCaches() {
        Locale.resetCache();
        IANAZone.resetCache();
      };

      _createClass(Settings, null, [{
        key: "now",
        get:
        /**
         * Get the callback for returning the current timestamp.
         * @type {function}
         */
        function get() {
          return now$1;
        }
        /**
         * Set the callback for returning the current timestamp.
         * The function should return a number, which will be interpreted as an Epoch millisecond count
         * @type {function}
         * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
         * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
         */
        ,
        set: function set(n) {
          now$1 = n;
        }
        /**
         * Set the default time zone to create DateTimes in. Does not affect existing instances.
         * Use the value "system" to reset this value to the system's time zone.
         * @type {string}
         */

      }, {
        key: "defaultZone",
        get:
        /**
         * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
         * The default value is the system's time zone (the one set on the machine that runs this code).
         * @type {Zone}
         */
        function get() {
          return normalizeZone(defaultZone, SystemZone.instance);
        }
        /**
         * Get the default locale to create DateTimes with. Does not affect existing instances.
         * @type {string}
         */
        ,
        set: function set(zone) {
          defaultZone = zone;
        }
      }, {
        key: "defaultLocale",
        get: function get() {
          return defaultLocale$2;
        }
        /**
         * Set the default locale to create DateTimes with. Does not affect existing instances.
         * @type {string}
         */
        ,
        set: function set(locale) {
          defaultLocale$2 = locale;
        }
        /**
         * Get the default numbering system to create DateTimes with. Does not affect existing instances.
         * @type {string}
         */

      }, {
        key: "defaultNumberingSystem",
        get: function get() {
          return defaultNumberingSystem;
        }
        /**
         * Set the default numbering system to create DateTimes with. Does not affect existing instances.
         * @type {string}
         */
        ,
        set: function set(numberingSystem) {
          defaultNumberingSystem = numberingSystem;
        }
        /**
         * Get the default output calendar to create DateTimes with. Does not affect existing instances.
         * @type {string}
         */

      }, {
        key: "defaultOutputCalendar",
        get: function get() {
          return defaultOutputCalendar;
        }
        /**
         * Set the default output calendar to create DateTimes with. Does not affect existing instances.
         * @type {string}
         */
        ,
        set: function set(outputCalendar) {
          defaultOutputCalendar = outputCalendar;
        }
        /**
         * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
         * @type {boolean}
         */

      }, {
        key: "throwOnInvalid",
        get: function get() {
          return throwOnInvalid;
        }
        /**
         * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
         * @type {boolean}
         */
        ,
        set: function set(t) {
          throwOnInvalid = t;
        }
      }]);

      return Settings;
    }();

    var _excluded = ["base"],
        _excluded2 = ["padTo", "floor"];

    var intlLFCache = {};

    function getCachedLF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var key = JSON.stringify([locString, opts]);
      var dtf = intlLFCache[key];

      if (!dtf) {
        dtf = new Intl.ListFormat(locString, opts);
        intlLFCache[key] = dtf;
      }

      return dtf;
    }

    var intlDTCache = {};

    function getCachedDTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var key = JSON.stringify([locString, opts]);
      var dtf = intlDTCache[key];

      if (!dtf) {
        dtf = new Intl.DateTimeFormat(locString, opts);
        intlDTCache[key] = dtf;
      }

      return dtf;
    }

    var intlNumCache = {};

    function getCachedINF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var key = JSON.stringify([locString, opts]);
      var inf = intlNumCache[key];

      if (!inf) {
        inf = new Intl.NumberFormat(locString, opts);
        intlNumCache[key] = inf;
      }

      return inf;
    }

    var intlRelCache = {};

    function getCachedRTF(locString, opts) {
      if (opts === void 0) {
        opts = {};
      }

      var _opts = opts;
          _opts.base;
          var cacheKeyOpts = _objectWithoutPropertiesLoose$1(_opts, _excluded); // exclude `base` from the options


      var key = JSON.stringify([locString, cacheKeyOpts]);
      var inf = intlRelCache[key];

      if (!inf) {
        inf = new Intl.RelativeTimeFormat(locString, opts);
        intlRelCache[key] = inf;
      }

      return inf;
    }

    var sysLocaleCache = null;

    function systemLocale() {
      if (sysLocaleCache) {
        return sysLocaleCache;
      } else {
        sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
        return sysLocaleCache;
      }
    }

    function parseLocaleString(localeStr) {
      // I really want to avoid writing a BCP 47 parser
      // see, e.g. https://github.com/wooorm/bcp-47
      // Instead, we'll do this:
      // a) if the string has no -u extensions, just leave it alone
      // b) if it does, use Intl to resolve everything
      // c) if Intl fails, try again without the -u
      var uIndex = localeStr.indexOf("-u-");

      if (uIndex === -1) {
        return [localeStr];
      } else {
        var options;
        var smaller = localeStr.substring(0, uIndex);

        try {
          options = getCachedDTF(localeStr).resolvedOptions();
        } catch (e) {
          options = getCachedDTF(smaller).resolvedOptions();
        }

        var _options = options,
            numberingSystem = _options.numberingSystem,
            calendar = _options.calendar; // return the smaller one so that we can append the calendar and numbering overrides to it

        return [smaller, numberingSystem, calendar];
      }
    }

    function intlConfigString(localeStr, numberingSystem, outputCalendar) {
      if (outputCalendar || numberingSystem) {
        localeStr += "-u";

        if (outputCalendar) {
          localeStr += "-ca-" + outputCalendar;
        }

        if (numberingSystem) {
          localeStr += "-nu-" + numberingSystem;
        }

        return localeStr;
      } else {
        return localeStr;
      }
    }

    function mapMonths(f) {
      var ms = [];

      for (var i = 1; i <= 12; i++) {
        var dt = DateTime.utc(2016, i, 1);
        ms.push(f(dt));
      }

      return ms;
    }

    function mapWeekdays(f) {
      var ms = [];

      for (var i = 1; i <= 7; i++) {
        var dt = DateTime.utc(2016, 11, 13 + i);
        ms.push(f(dt));
      }

      return ms;
    }

    function listStuff(loc, length, defaultOK, englishFn, intlFn) {
      var mode = loc.listingMode(defaultOK);

      if (mode === "error") {
        return null;
      } else if (mode === "en") {
        return englishFn(length);
      } else {
        return intlFn(length);
      }
    }

    function supportsFastNumbers(loc) {
      if (loc.numberingSystem && loc.numberingSystem !== "latn") {
        return false;
      } else {
        return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
      }
    }
    /**
     * @private
     */


    var PolyNumberFormatter = /*#__PURE__*/function () {
      function PolyNumberFormatter(intl, forceSimple, opts) {
        this.padTo = opts.padTo || 0;
        this.floor = opts.floor || false;

        opts.padTo;
            opts.floor;
            var otherOpts = _objectWithoutPropertiesLoose$1(opts, _excluded2);

        if (!forceSimple || Object.keys(otherOpts).length > 0) {
          var intlOpts = _extends$5({
            useGrouping: false
          }, opts);

          if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
          this.inf = getCachedINF(intl, intlOpts);
        }
      }

      var _proto = PolyNumberFormatter.prototype;

      _proto.format = function format(i) {
        if (this.inf) {
          var fixed = this.floor ? Math.floor(i) : i;
          return this.inf.format(fixed);
        } else {
          // to match the browser's numberformatter defaults
          var _fixed = this.floor ? Math.floor(i) : roundTo(i, 3);

          return padStart(_fixed, this.padTo);
        }
      };

      return PolyNumberFormatter;
    }();
    /**
     * @private
     */


    var PolyDateFormatter = /*#__PURE__*/function () {
      function PolyDateFormatter(dt, intl, opts) {
        this.opts = opts;
        var z;

        if (dt.zone.isUniversal) {
          // UTC-8 or Etc/UTC-8 are not part of tzdata, only Etc/GMT+8 and the like.
          // That is why fixed-offset TZ is set to that unless it is:
          // 1. Representing offset 0 when UTC is used to maintain previous behavior and does not become GMT.
          // 2. Unsupported by the browser:
          //    - some do not support Etc/
          //    - < Etc/GMT-14, > Etc/GMT+12, and 30-minute or 45-minute offsets are not part of tzdata
          var gmtOffset = -1 * (dt.offset / 60);
          var offsetZ = gmtOffset >= 0 ? "Etc/GMT+" + gmtOffset : "Etc/GMT" + gmtOffset;

          if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
            z = offsetZ;
            this.dt = dt;
          } else {
            // Not all fixed-offset zones like Etc/+4:30 are present in tzdata.
            // So we have to make do. Two cases:
            // 1. The format options tell us to show the zone. We can't do that, so the best
            // we can do is format the date in UTC.
            // 2. The format options don't tell us to show the zone. Then we can adjust them
            // the time and tell the formatter to show it to us in UTC, so that the time is right
            // and the bad zone doesn't show up.
            z = "UTC";

            if (opts.timeZoneName) {
              this.dt = dt;
            } else {
              this.dt = dt.offset === 0 ? dt : DateTime.fromMillis(dt.ts + dt.offset * 60 * 1000);
            }
          }
        } else if (dt.zone.type === "system") {
          this.dt = dt;
        } else {
          this.dt = dt;
          z = dt.zone.name;
        }

        var intlOpts = _extends$5({}, this.opts);

        if (z) {
          intlOpts.timeZone = z;
        }

        this.dtf = getCachedDTF(intl, intlOpts);
      }

      var _proto2 = PolyDateFormatter.prototype;

      _proto2.format = function format() {
        return this.dtf.format(this.dt.toJSDate());
      };

      _proto2.formatToParts = function formatToParts() {
        return this.dtf.formatToParts(this.dt.toJSDate());
      };

      _proto2.resolvedOptions = function resolvedOptions() {
        return this.dtf.resolvedOptions();
      };

      return PolyDateFormatter;
    }();
    /**
     * @private
     */


    var PolyRelFormatter = /*#__PURE__*/function () {
      function PolyRelFormatter(intl, isEnglish, opts) {
        this.opts = _extends$5({
          style: "long"
        }, opts);

        if (!isEnglish && hasRelative()) {
          this.rtf = getCachedRTF(intl, opts);
        }
      }

      var _proto3 = PolyRelFormatter.prototype;

      _proto3.format = function format(count, unit) {
        if (this.rtf) {
          return this.rtf.format(count, unit);
        } else {
          return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
        }
      };

      _proto3.formatToParts = function formatToParts(count, unit) {
        if (this.rtf) {
          return this.rtf.formatToParts(count, unit);
        } else {
          return [];
        }
      };

      return PolyRelFormatter;
    }();
    /**
     * @private
     */


    var Locale = /*#__PURE__*/function () {
      Locale.fromOpts = function fromOpts(opts) {
        return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.defaultToEN);
      };

      Locale.create = function create(locale, numberingSystem, outputCalendar, defaultToEN) {
        if (defaultToEN === void 0) {
          defaultToEN = false;
        }

        var specifiedLocale = locale || Settings$1.defaultLocale; // the system locale is useful for human readable strings but annoying for parsing/formatting known formats

        var localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
        var numberingSystemR = numberingSystem || Settings$1.defaultNumberingSystem;
        var outputCalendarR = outputCalendar || Settings$1.defaultOutputCalendar;
        return new Locale(localeR, numberingSystemR, outputCalendarR, specifiedLocale);
      };

      Locale.resetCache = function resetCache() {
        sysLocaleCache = null;
        intlDTCache = {};
        intlNumCache = {};
        intlRelCache = {};
      };

      Locale.fromObject = function fromObject(_temp) {
        var _ref = _temp === void 0 ? {} : _temp,
            locale = _ref.locale,
            numberingSystem = _ref.numberingSystem,
            outputCalendar = _ref.outputCalendar;

        return Locale.create(locale, numberingSystem, outputCalendar);
      };

      function Locale(locale, numbering, outputCalendar, specifiedLocale) {
        var _parseLocaleString = parseLocaleString(locale),
            parsedLocale = _parseLocaleString[0],
            parsedNumberingSystem = _parseLocaleString[1],
            parsedOutputCalendar = _parseLocaleString[2];

        this.locale = parsedLocale;
        this.numberingSystem = numbering || parsedNumberingSystem || null;
        this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
        this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
        this.weekdaysCache = {
          format: {},
          standalone: {}
        };
        this.monthsCache = {
          format: {},
          standalone: {}
        };
        this.meridiemCache = null;
        this.eraCache = {};
        this.specifiedLocale = specifiedLocale;
        this.fastNumbersCached = null;
      }

      var _proto4 = Locale.prototype;

      _proto4.listingMode = function listingMode() {
        var isActuallyEn = this.isEnglish();
        var hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
        return isActuallyEn && hasNoWeirdness ? "en" : "intl";
      };

      _proto4.clone = function clone(alts) {
        if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
          return this;
        } else {
          return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, alts.defaultToEN || false);
        }
      };

      _proto4.redefaultToEN = function redefaultToEN(alts) {
        if (alts === void 0) {
          alts = {};
        }

        return this.clone(_extends$5({}, alts, {
          defaultToEN: true
        }));
      };

      _proto4.redefaultToSystem = function redefaultToSystem(alts) {
        if (alts === void 0) {
          alts = {};
        }

        return this.clone(_extends$5({}, alts, {
          defaultToEN: false
        }));
      };

      _proto4.months = function months$1$1(length, format, defaultOK) {
        var _this = this;

        if (format === void 0) {
          format = false;
        }

        if (defaultOK === void 0) {
          defaultOK = true;
        }

        return listStuff(this, length, defaultOK, months$1, function () {
          var intl = format ? {
            month: length,
            day: "numeric"
          } : {
            month: length
          },
              formatStr = format ? "format" : "standalone";

          if (!_this.monthsCache[formatStr][length]) {
            _this.monthsCache[formatStr][length] = mapMonths(function (dt) {
              return _this.extract(dt, intl, "month");
            });
          }

          return _this.monthsCache[formatStr][length];
        });
      };

      _proto4.weekdays = function weekdays$1(length, format, defaultOK) {
        var _this2 = this;

        if (format === void 0) {
          format = false;
        }

        if (defaultOK === void 0) {
          defaultOK = true;
        }

        return listStuff(this, length, defaultOK, weekdays, function () {
          var intl = format ? {
            weekday: length,
            year: "numeric",
            month: "long",
            day: "numeric"
          } : {
            weekday: length
          },
              formatStr = format ? "format" : "standalone";

          if (!_this2.weekdaysCache[formatStr][length]) {
            _this2.weekdaysCache[formatStr][length] = mapWeekdays(function (dt) {
              return _this2.extract(dt, intl, "weekday");
            });
          }

          return _this2.weekdaysCache[formatStr][length];
        });
      };

      _proto4.meridiems = function meridiems$1(defaultOK) {
        var _this3 = this;

        if (defaultOK === void 0) {
          defaultOK = true;
        }

        return listStuff(this, undefined, defaultOK, function () {
          return meridiems;
        }, function () {
          // In theory there could be aribitrary day periods. We're gonna assume there are exactly two
          // for AM and PM. This is probably wrong, but it's makes parsing way easier.
          if (!_this3.meridiemCache) {
            var intl = {
              hour: "numeric",
              hourCycle: "h12"
            };
            _this3.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(function (dt) {
              return _this3.extract(dt, intl, "dayperiod");
            });
          }

          return _this3.meridiemCache;
        });
      };

      _proto4.eras = function eras$1(length, defaultOK) {
        var _this4 = this;

        if (defaultOK === void 0) {
          defaultOK = true;
        }

        return listStuff(this, length, defaultOK, eras, function () {
          var intl = {
            era: length
          }; // This is problematic. Different calendars are going to define eras totally differently. What I need is the minimum set of dates
          // to definitely enumerate them.

          if (!_this4.eraCache[length]) {
            _this4.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(function (dt) {
              return _this4.extract(dt, intl, "era");
            });
          }

          return _this4.eraCache[length];
        });
      };

      _proto4.extract = function extract(dt, intlOpts, field) {
        var df = this.dtFormatter(dt, intlOpts),
            results = df.formatToParts(),
            matching = results.find(function (m) {
          return m.type.toLowerCase() === field;
        });
        return matching ? matching.value : null;
      };

      _proto4.numberFormatter = function numberFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }

        // this forcesimple option is never used (the only caller short-circuits on it, but it seems safer to leave)
        // (in contrast, the rest of the condition is used heavily)
        return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
      };

      _proto4.dtFormatter = function dtFormatter(dt, intlOpts) {
        if (intlOpts === void 0) {
          intlOpts = {};
        }

        return new PolyDateFormatter(dt, this.intl, intlOpts);
      };

      _proto4.relFormatter = function relFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }

        return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
      };

      _proto4.listFormatter = function listFormatter(opts) {
        if (opts === void 0) {
          opts = {};
        }

        return getCachedLF(this.intl, opts);
      };

      _proto4.isEnglish = function isEnglish() {
        return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
      };

      _proto4.equals = function equals(other) {
        return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
      };

      _createClass(Locale, [{
        key: "fastNumbers",
        get: function get() {
          if (this.fastNumbersCached == null) {
            this.fastNumbersCached = supportsFastNumbers(this);
          }

          return this.fastNumbersCached;
        }
      }]);

      return Locale;
    }();

    /*
     * This file handles parsing for well-specified formats. Here's how it works:
     * Two things go into parsing: a regex to match with and an extractor to take apart the groups in the match.
     * An extractor is just a function that takes a regex match array and returns a { year: ..., month: ... } object
     * parse() does the work of executing the regex and applying the extractor. It takes multiple regex/extractor pairs to try in sequence.
     * Extractors can take a "cursor" representing the offset in the match to look at. This makes it easy to combine extractors.
     * combineExtractors() does the work of combining them, keeping track of the cursor through multiple extractions.
     * Some extractions are super dumb and simpleParse and fromStrings help DRY them.
     */

    function combineRegexes() {
      for (var _len = arguments.length, regexes = new Array(_len), _key = 0; _key < _len; _key++) {
        regexes[_key] = arguments[_key];
      }

      var full = regexes.reduce(function (f, r) {
        return f + r.source;
      }, "");
      return RegExp("^" + full + "$");
    }

    function combineExtractors() {
      for (var _len2 = arguments.length, extractors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        extractors[_key2] = arguments[_key2];
      }

      return function (m) {
        return extractors.reduce(function (_ref, ex) {
          var mergedVals = _ref[0],
              mergedZone = _ref[1],
              cursor = _ref[2];

          var _ex = ex(m, cursor),
              val = _ex[0],
              zone = _ex[1],
              next = _ex[2];

          return [_extends$5({}, mergedVals, val), mergedZone || zone, next];
        }, [{}, null, 1]).slice(0, 2);
      };
    }

    function parse(s) {
      if (s == null) {
        return [null, null];
      }

      for (var _len3 = arguments.length, patterns = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        patterns[_key3 - 1] = arguments[_key3];
      }

      for (var _i = 0, _patterns = patterns; _i < _patterns.length; _i++) {
        var _patterns$_i = _patterns[_i],
            regex = _patterns$_i[0],
            extractor = _patterns$_i[1];
        var m = regex.exec(s);

        if (m) {
          return extractor(m);
        }
      }

      return [null, null];
    }

    function simpleParse() {
      for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        keys[_key4] = arguments[_key4];
      }

      return function (match, cursor) {
        var ret = {};
        var i;

        for (i = 0; i < keys.length; i++) {
          ret[keys[i]] = parseInteger(match[cursor + i]);
        }

        return [ret, null, cursor + i];
      };
    } // ISO and SQL parsing


    var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/,
        isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/,
        isoTimeRegex = RegExp("" + isoTimeBaseRegex.source + offsetRegex.source + "?"),
        isoTimeExtensionRegex = RegExp("(?:T" + isoTimeRegex.source + ")?"),
        isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/,
        isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/,
        isoOrdinalRegex = /(\d{4})-?(\d{3})/,
        extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay"),
        extractISOOrdinalData = simpleParse("year", "ordinal"),
        sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/,
        // dumbed-down version of the ISO one
    sqlTimeRegex = RegExp(isoTimeBaseRegex.source + " ?(?:" + offsetRegex.source + "|(" + ianaRegex.source + "))?"),
        sqlTimeExtensionRegex = RegExp("(?: " + sqlTimeRegex.source + ")?");

    function int$2(match, pos, fallback) {
      var m = match[pos];
      return isUndefined(m) ? fallback : parseInteger(m);
    }

    function extractISOYmd(match, cursor) {
      var item = {
        year: int$2(match, cursor),
        month: int$2(match, cursor + 1, 1),
        day: int$2(match, cursor + 2, 1)
      };
      return [item, null, cursor + 3];
    }

    function extractISOTime(match, cursor) {
      var item = {
        hours: int$2(match, cursor, 0),
        minutes: int$2(match, cursor + 1, 0),
        seconds: int$2(match, cursor + 2, 0),
        milliseconds: parseMillis(match[cursor + 3])
      };
      return [item, null, cursor + 4];
    }

    function extractISOOffset(match, cursor) {
      var local = !match[cursor] && !match[cursor + 1],
          fullOffset = signedOffset(match[cursor + 1], match[cursor + 2]),
          zone = local ? null : FixedOffsetZone.instance(fullOffset);
      return [{}, zone, cursor + 3];
    }

    function extractIANAZone(match, cursor) {
      var zone = match[cursor] ? IANAZone.create(match[cursor]) : null;
      return [{}, zone, cursor + 1];
    } // ISO time parsing


    var isoTimeOnly = RegExp("^T?" + isoTimeBaseRegex.source + "$"); // ISO duration parsing

    var isoDuration = /^-?P(?:(?:(-?\d{1,9}(?:\.\d{1,9})?)Y)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,9}(?:\.\d{1,9})?)W)?(?:(-?\d{1,9}(?:\.\d{1,9})?)D)?(?:T(?:(-?\d{1,9}(?:\.\d{1,9})?)H)?(?:(-?\d{1,9}(?:\.\d{1,9})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,9}))?S)?)?)$/;

    function extractISODuration(match) {
      var s = match[0],
          yearStr = match[1],
          monthStr = match[2],
          weekStr = match[3],
          dayStr = match[4],
          hourStr = match[5],
          minuteStr = match[6],
          secondStr = match[7],
          millisecondsStr = match[8];
      var hasNegativePrefix = s[0] === "-";
      var negativeSeconds = secondStr && secondStr[0] === "-";

      var maybeNegate = function maybeNegate(num, force) {
        if (force === void 0) {
          force = false;
        }

        return num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
      };

      return [{
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }];
    } // These are a little braindead. EDT *should* tell us that we're in, say, America/New_York
    // and not just that we're in -240 *right now*. But since I don't think these are used that often
    // I'm just going to ignore that


    var obsOffsets = {
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };

    function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = {
        year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
        month: monthsShort.indexOf(monthStr) + 1,
        day: parseInteger(dayStr),
        hour: parseInteger(hourStr),
        minute: parseInteger(minuteStr)
      };
      if (secondStr) result.second = parseInteger(secondStr);

      if (weekdayStr) {
        result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
      }

      return result;
    } // RFC 2822/5322


    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;

    function extractRFC2822(match) {
      var weekdayStr = match[1],
          dayStr = match[2],
          monthStr = match[3],
          yearStr = match[4],
          hourStr = match[5],
          minuteStr = match[6],
          secondStr = match[7],
          obsOffset = match[8],
          milOffset = match[9],
          offHourStr = match[10],
          offMinuteStr = match[11],
          result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      var offset;

      if (obsOffset) {
        offset = obsOffsets[obsOffset];
      } else if (milOffset) {
        offset = 0;
      } else {
        offset = signedOffset(offHourStr, offMinuteStr);
      }

      return [result, new FixedOffsetZone(offset)];
    }

    function preprocessRFC2822(s) {
      // Remove comments and folding whitespace and replace multiple-spaces with a single space
      return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
    } // http date


    var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
        rfc850 = /^(Monday|Tuesday|Wedsday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
        ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;

    function extractRFC1123Or850(match) {
      var weekdayStr = match[1],
          dayStr = match[2],
          monthStr = match[3],
          yearStr = match[4],
          hourStr = match[5],
          minuteStr = match[6],
          secondStr = match[7],
          result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }

    function extractASCII(match) {
      var weekdayStr = match[1],
          monthStr = match[2],
          dayStr = match[3],
          hourStr = match[4],
          minuteStr = match[5],
          secondStr = match[6],
          yearStr = match[7],
          result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
      return [result, FixedOffsetZone.utcInstance];
    }

    var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
    var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
    var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
    var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
    var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset);
    var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset);
    var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset);
    var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset);
    /**
     * @private
     */

    function parseISODate(s) {
      return parse(s, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
    }
    function parseRFC2822Date(s) {
      return parse(preprocessRFC2822(s), [rfc2822, extractRFC2822]);
    }
    function parseHTTPDate(s) {
      return parse(s, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
    }
    function parseISODuration(s) {
      return parse(s, [isoDuration, extractISODuration]);
    }
    var extractISOTimeOnly = combineExtractors(extractISOTime);
    function parseISOTimeOnly(s) {
      return parse(s, [isoTimeOnly, extractISOTimeOnly]);
    }
    var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
    var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
    var extractISOYmdTimeOffsetAndIANAZone = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
    var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
    function parseSQL(s) {
      return parse(s, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeOffsetAndIANAZone], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
    }

    var INVALID$2 = "Invalid Duration"; // unit conversion constants

    var lowOrderMatrix = {
      weeks: {
        days: 7,
        hours: 7 * 24,
        minutes: 7 * 24 * 60,
        seconds: 7 * 24 * 60 * 60,
        milliseconds: 7 * 24 * 60 * 60 * 1000
      },
      days: {
        hours: 24,
        minutes: 24 * 60,
        seconds: 24 * 60 * 60,
        milliseconds: 24 * 60 * 60 * 1000
      },
      hours: {
        minutes: 60,
        seconds: 60 * 60,
        milliseconds: 60 * 60 * 1000
      },
      minutes: {
        seconds: 60,
        milliseconds: 60 * 1000
      },
      seconds: {
        milliseconds: 1000
      }
    },
        casualMatrix = _extends$5({
      years: {
        quarters: 4,
        months: 12,
        weeks: 52,
        days: 365,
        hours: 365 * 24,
        minutes: 365 * 24 * 60,
        seconds: 365 * 24 * 60 * 60,
        milliseconds: 365 * 24 * 60 * 60 * 1000
      },
      quarters: {
        months: 3,
        weeks: 13,
        days: 91,
        hours: 91 * 24,
        minutes: 91 * 24 * 60,
        seconds: 91 * 24 * 60 * 60,
        milliseconds: 91 * 24 * 60 * 60 * 1000
      },
      months: {
        weeks: 4,
        days: 30,
        hours: 30 * 24,
        minutes: 30 * 24 * 60,
        seconds: 30 * 24 * 60 * 60,
        milliseconds: 30 * 24 * 60 * 60 * 1000
      }
    }, lowOrderMatrix),
        daysInYearAccurate = 146097.0 / 400,
        daysInMonthAccurate = 146097.0 / 4800,
        accurateMatrix = _extends$5({
      years: {
        quarters: 4,
        months: 12,
        weeks: daysInYearAccurate / 7,
        days: daysInYearAccurate,
        hours: daysInYearAccurate * 24,
        minutes: daysInYearAccurate * 24 * 60,
        seconds: daysInYearAccurate * 24 * 60 * 60,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
      },
      quarters: {
        months: 3,
        weeks: daysInYearAccurate / 28,
        days: daysInYearAccurate / 4,
        hours: daysInYearAccurate * 24 / 4,
        minutes: daysInYearAccurate * 24 * 60 / 4,
        seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
        milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
      },
      months: {
        weeks: daysInMonthAccurate / 7,
        days: daysInMonthAccurate,
        hours: daysInMonthAccurate * 24,
        minutes: daysInMonthAccurate * 24 * 60,
        seconds: daysInMonthAccurate * 24 * 60 * 60,
        milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
      }
    }, lowOrderMatrix); // units ordered by size

    var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
    var reverseUnits = orderedUnits$1.slice(0).reverse(); // clone really means "create another instance just like this one, but with these changes"

    function clone$1(dur, alts, clear) {
      if (clear === void 0) {
        clear = false;
      }

      // deep merge for vals
      var conf = {
        values: clear ? alts.values : _extends$5({}, dur.values, alts.values || {}),
        loc: dur.loc.clone(alts.loc),
        conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy
      };
      return new Duration(conf);
    }

    function antiTrunc(n) {
      return n < 0 ? Math.floor(n) : Math.ceil(n);
    } // NB: mutates parameters


    function convert(matrix, fromMap, fromUnit, toMap, toUnit) {
      var conv = matrix[toUnit][fromUnit],
          raw = fromMap[fromUnit] / conv,
          sameSign = Math.sign(raw) === Math.sign(toMap[toUnit]),
          // ok, so this is wild, but see the matrix in the tests
      added = !sameSign && toMap[toUnit] !== 0 && Math.abs(raw) <= 1 ? antiTrunc(raw) : Math.trunc(raw);
      toMap[toUnit] += added;
      fromMap[fromUnit] -= added * conv;
    } // NB: mutates parameters


    function normalizeValues(matrix, vals) {
      reverseUnits.reduce(function (previous, current) {
        if (!isUndefined(vals[current])) {
          if (previous) {
            convert(matrix, vals, previous, vals, current);
          }

          return current;
        } else {
          return previous;
        }
      }, null);
    }
    /**
     * A Duration object represents a period of time, like "2 months" or "1 day, 1 hour". Conceptually, it's just a map of units to their quantities, accompanied by some additional configuration and methods for creating, parsing, interrogating, transforming, and formatting them. They can be used on their own or in conjunction with other Luxon types; for example, you can use {@link DateTime#plus} to add a Duration object to a DateTime, producing another DateTime.
     *
     * Here is a brief overview of commonly used methods and getters in Duration:
     *
     * * **Creation** To create a Duration, use {@link Duration#fromMillis}, {@link Duration#fromObject}, or {@link Duration#fromISO}.
     * * **Unit values** See the {@link Duration#years}, {@link Duration.months}, {@link Duration#weeks}, {@link Duration#days}, {@link Duration#hours}, {@link Duration#minutes}, {@link Duration#seconds}, {@link Duration#milliseconds} accessors.
     * * **Configuration** See  {@link Duration#locale} and {@link Duration#numberingSystem} accessors.
     * * **Transformation** To create new Durations out of old ones use {@link Duration#plus}, {@link Duration#minus}, {@link Duration#normalize}, {@link Duration#set}, {@link Duration#reconfigure}, {@link Duration#shiftTo}, and {@link Duration#negate}.
     * * **Output** To convert the Duration into other representations, see {@link Duration#as}, {@link Duration#toISO}, {@link Duration#toFormat}, and {@link Duration#toJSON}
     *
     * There's are more methods documented below. In addition, for more information on subtler topics like internationalization and validity, see the external documentation.
     */


    var Duration = /*#__PURE__*/function () {
      /**
       * @private
       */
      function Duration(config) {
        var accurate = config.conversionAccuracy === "longterm" || false;
        /**
         * @access private
         */

        this.values = config.values;
        /**
         * @access private
         */

        this.loc = config.loc || Locale.create();
        /**
         * @access private
         */

        this.conversionAccuracy = accurate ? "longterm" : "casual";
        /**
         * @access private
         */

        this.invalid = config.invalid || null;
        /**
         * @access private
         */

        this.matrix = accurate ? accurateMatrix : casualMatrix;
        /**
         * @access private
         */

        this.isLuxonDuration = true;
      }
      /**
       * Create Duration from a number of milliseconds.
       * @param {number} count of milliseconds
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */


      Duration.fromMillis = function fromMillis(count, opts) {
        return Duration.fromObject({
          milliseconds: count
        }, opts);
      }
      /**
       * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
       * If this object is empty then a zero milliseconds duration is returned.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.years
       * @param {number} obj.quarters
       * @param {number} obj.months
       * @param {number} obj.weeks
       * @param {number} obj.days
       * @param {number} obj.hours
       * @param {number} obj.minutes
       * @param {number} obj.seconds
       * @param {number} obj.milliseconds
       * @param {Object} [opts=[]] - options for creating this Duration
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      ;

      Duration.fromObject = function fromObject(obj, opts) {
        if (opts === void 0) {
          opts = {};
        }

        if (obj == null || typeof obj !== "object") {
          throw new InvalidArgumentError("Duration.fromObject: argument expected to be an object, got " + (obj === null ? "null" : typeof obj));
        }

        return new Duration({
          values: normalizeObject(obj, Duration.normalizeUnit),
          loc: Locale.fromObject(opts),
          conversionAccuracy: opts.conversionAccuracy
        });
      }
      /**
       * Create a Duration from DurationLike.
       *
       * @param {Object | number | Duration} durationLike
       * One of:
       * - object with keys like 'years' and 'hours'.
       * - number representing milliseconds
       * - Duration instance
       * @return {Duration}
       */
      ;

      Duration.fromDurationLike = function fromDurationLike(durationLike) {
        if (isNumber(durationLike)) {
          return Duration.fromMillis(durationLike);
        } else if (Duration.isDuration(durationLike)) {
          return durationLike;
        } else if (typeof durationLike === "object") {
          return Duration.fromObject(durationLike);
        } else {
          throw new InvalidArgumentError("Unknown duration argument " + durationLike + " of type " + typeof durationLike);
        }
      }
      /**
       * Create a Duration from an ISO 8601 duration string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
       * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
       * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
       * @return {Duration}
       */
      ;

      Duration.fromISO = function fromISO(text, opts) {
        var _parseISODuration = parseISODuration(text),
            parsed = _parseISODuration[0];

        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", "the input \"" + text + "\" can't be parsed as ISO 8601");
        }
      }
      /**
       * Create a Duration from an ISO 8601 time string.
       * @param {string} text - text to parse
       * @param {Object} opts - options for parsing
       * @param {string} [opts.locale='en-US'] - the locale to use
       * @param {string} opts.numberingSystem - the numbering system to use
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
       * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
       * @return {Duration}
       */
      ;

      Duration.fromISOTime = function fromISOTime(text, opts) {
        var _parseISOTimeOnly = parseISOTimeOnly(text),
            parsed = _parseISOTimeOnly[0];

        if (parsed) {
          return Duration.fromObject(parsed, opts);
        } else {
          return Duration.invalid("unparsable", "the input \"" + text + "\" can't be parsed as ISO 8601");
        }
      }
      /**
       * Create an invalid Duration.
       * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Duration}
       */
      ;

      Duration.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }

        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
        }

        var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

        if (Settings$1.throwOnInvalid) {
          throw new InvalidDurationError(invalid);
        } else {
          return new Duration({
            invalid: invalid
          });
        }
      }
      /**
       * @private
       */
      ;

      Duration.normalizeUnit = function normalizeUnit(unit) {
        var normalized = {
          year: "years",
          years: "years",
          quarter: "quarters",
          quarters: "quarters",
          month: "months",
          months: "months",
          week: "weeks",
          weeks: "weeks",
          day: "days",
          days: "days",
          hour: "hours",
          hours: "hours",
          minute: "minutes",
          minutes: "minutes",
          second: "seconds",
          seconds: "seconds",
          millisecond: "milliseconds",
          milliseconds: "milliseconds"
        }[unit ? unit.toLowerCase() : unit];
        if (!normalized) throw new InvalidUnitError(unit);
        return normalized;
      }
      /**
       * Check if an object is a Duration. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      ;

      Duration.isDuration = function isDuration(o) {
        return o && o.isLuxonDuration || false;
      }
      /**
       * Get  the locale of a Duration, such 'en-GB'
       * @type {string}
       */
      ;

      var _proto = Duration.prototype;

      /**
       * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
       * * `S` for milliseconds
       * * `s` for seconds
       * * `m` for minutes
       * * `h` for hours
       * * `d` for days
       * * `M` for months
       * * `y` for years
       * Notes:
       * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
       * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
       * @param {string} fmt - the format string
       * @param {Object} opts - options
       * @param {boolean} [opts.floor=true] - floor numerical values
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
       * @return {string}
       */
      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }

        // reverse-compat since 1.2; we always round down now, never up, and we do it by default
        var fmtOpts = _extends$5({}, opts, {
          floor: opts.round !== false && opts.floor !== false
        });

        return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
      }
      /**
       * Returns a string representation of a Duration with all units included
       * To modify its behavior use the `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant. See {@link Intl.NumberFormat}.
       * @param opts - On option object to override the formatting. Accepts the same keys as the options parameter of the native `Int.NumberFormat` constructor, as well as `listStyle`.
       * @example
       * ```js
       * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
       * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
       * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
       * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
       * ```
       */
      ;

      _proto.toHuman = function toHuman(opts) {
        var _this = this;

        if (opts === void 0) {
          opts = {};
        }

        var l = orderedUnits$1.map(function (unit) {
          var val = _this.values[unit];

          if (isUndefined(val)) {
            return null;
          }

          return _this.loc.numberFormatter(_extends$5({
            style: "unit",
            unitDisplay: "long"
          }, opts, {
            unit: unit.slice(0, -1)
          })).format(val);
        }).filter(function (n) {
          return n;
        });
        return this.loc.listFormatter(_extends$5({
          type: "conjunction",
          style: opts.listStyle || "narrow"
        }, opts)).format(l);
      }
      /**
       * Returns a JavaScript object with this Duration's values.
       * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
       * @return {Object}
       */
      ;

      _proto.toObject = function toObject() {
        if (!this.isValid) return {};
        return _extends$5({}, this.values);
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
       * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
       * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
       * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
       * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
       * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
       * @return {string}
       */
      ;

      _proto.toISO = function toISO() {
        // we could use the formatter, but this is an easier way to get the minimum string
        if (!this.isValid) return null;
        var s = "P";
        if (this.years !== 0) s += this.years + "Y";
        if (this.months !== 0 || this.quarters !== 0) s += this.months + this.quarters * 3 + "M";
        if (this.weeks !== 0) s += this.weeks + "W";
        if (this.days !== 0) s += this.days + "D";
        if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) s += "T";
        if (this.hours !== 0) s += this.hours + "H";
        if (this.minutes !== 0) s += this.minutes + "M";
        if (this.seconds !== 0 || this.milliseconds !== 0) // this will handle "floating point madness" by removing extra decimal places
          // https://stackoverflow.com/questions/588004/is-floating-point-math-broken
          s += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
        if (s === "P") s += "T0S";
        return s;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
       * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Times
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
       * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
       * @return {string}
       */
      ;

      _proto.toISOTime = function toISOTime(opts) {
        if (opts === void 0) {
          opts = {};
        }

        if (!this.isValid) return null;
        var millis = this.toMillis();
        if (millis < 0 || millis >= 86400000) return null;
        opts = _extends$5({
          suppressMilliseconds: false,
          suppressSeconds: false,
          includePrefix: false,
          format: "extended"
        }, opts);
        var value = this.shiftTo("hours", "minutes", "seconds", "milliseconds");
        var fmt = opts.format === "basic" ? "hhmm" : "hh:mm";

        if (!opts.suppressSeconds || value.seconds !== 0 || value.milliseconds !== 0) {
          fmt += opts.format === "basic" ? "ss" : ":ss";

          if (!opts.suppressMilliseconds || value.milliseconds !== 0) {
            fmt += ".SSS";
          }
        }

        var str = value.toFormat(fmt);

        if (opts.includePrefix) {
          str = "T" + str;
        }

        return str;
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
       * @return {string}
       */
      ;

      _proto.toJSON = function toJSON() {
        return this.toISO();
      }
      /**
       * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
       * @return {string}
       */
      ;

      _proto.toString = function toString() {
        return this.toISO();
      }
      /**
       * Returns an milliseconds value of this Duration.
       * @return {number}
       */
      ;

      _proto.toMillis = function toMillis() {
        return this.as("milliseconds");
      }
      /**
       * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
       * @return {number}
       */
      ;

      _proto.valueOf = function valueOf() {
        return this.toMillis();
      }
      /**
       * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      ;

      _proto.plus = function plus(duration) {
        if (!this.isValid) return this;
        var dur = Duration.fromDurationLike(duration),
            result = {};

        for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits$1), _step; !(_step = _iterator()).done;) {
          var k = _step.value;

          if (hasOwnProperty$a(dur.values, k) || hasOwnProperty$a(this.values, k)) {
            result[k] = dur.get(k) + this.get(k);
          }
        }

        return clone$1(this, {
          values: result
        }, true);
      }
      /**
       * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @return {Duration}
       */
      ;

      _proto.minus = function minus(duration) {
        if (!this.isValid) return this;
        var dur = Duration.fromDurationLike(duration);
        return this.plus(dur.negate());
      }
      /**
       * Scale this Duration by the specified amount. Return a newly-constructed Duration.
       * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
       * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hour" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
       * @return {Duration}
       */
      ;

      _proto.mapUnits = function mapUnits(fn) {
        if (!this.isValid) return this;
        var result = {};

        for (var _i = 0, _Object$keys = Object.keys(this.values); _i < _Object$keys.length; _i++) {
          var k = _Object$keys[_i];
          result[k] = asNumber(fn(this.values[k], k));
        }

        return clone$1(this, {
          values: result
        }, true);
      }
      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
       * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
       * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
       * @return {number}
       */
      ;

      _proto.get = function get(unit) {
        return this[Duration.normalizeUnit(unit)];
      }
      /**
       * "Set" the values of specified units. Return a newly-constructed Duration.
       * @param {Object} values - a mapping of units to numbers
       * @example dur.set({ years: 2017 })
       * @example dur.set({ hours: 8, minutes: 30 })
       * @return {Duration}
       */
      ;

      _proto.set = function set(values) {
        if (!this.isValid) return this;

        var mixed = _extends$5({}, this.values, normalizeObject(values, Duration.normalizeUnit));

        return clone$1(this, {
          values: mixed
        });
      }
      /**
       * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
       * @example dur.reconfigure({ locale: 'en-GB' })
       * @return {Duration}
       */
      ;

      _proto.reconfigure = function reconfigure(_temp) {
        var _ref = _temp === void 0 ? {} : _temp,
            locale = _ref.locale,
            numberingSystem = _ref.numberingSystem,
            conversionAccuracy = _ref.conversionAccuracy;

        var loc = this.loc.clone({
          locale: locale,
          numberingSystem: numberingSystem
        }),
            opts = {
          loc: loc
        };

        if (conversionAccuracy) {
          opts.conversionAccuracy = conversionAccuracy;
        }

        return clone$1(this, opts);
      }
      /**
       * Return the length of the duration in the specified unit.
       * @param {string} unit - a unit such as 'minutes' or 'days'
       * @example Duration.fromObject({years: 1}).as('days') //=> 365
       * @example Duration.fromObject({years: 1}).as('months') //=> 12
       * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
       * @return {number}
       */
      ;

      _proto.as = function as(unit) {
        return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
      }
      /**
       * Reduce this Duration to its canonical representation in its current units.
       * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
       * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
       * @return {Duration}
       */
      ;

      _proto.normalize = function normalize() {
        if (!this.isValid) return this;
        var vals = this.toObject();
        normalizeValues(this.matrix, vals);
        return clone$1(this, {
          values: vals
        }, true);
      }
      /**
       * Convert this Duration into its representation in a different set of units.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
       * @return {Duration}
       */
      ;

      _proto.shiftTo = function shiftTo() {
        for (var _len = arguments.length, units = new Array(_len), _key = 0; _key < _len; _key++) {
          units[_key] = arguments[_key];
        }

        if (!this.isValid) return this;

        if (units.length === 0) {
          return this;
        }

        units = units.map(function (u) {
          return Duration.normalizeUnit(u);
        });
        var built = {},
            accumulated = {},
            vals = this.toObject();
        var lastUnit;

        for (var _iterator2 = _createForOfIteratorHelperLoose(orderedUnits$1), _step2; !(_step2 = _iterator2()).done;) {
          var k = _step2.value;

          if (units.indexOf(k) >= 0) {
            lastUnit = k;
            var own = 0; // anything we haven't boiled down yet should get boiled to this unit

            for (var ak in accumulated) {
              own += this.matrix[ak][k] * accumulated[ak];
              accumulated[ak] = 0;
            } // plus anything that's already in this unit


            if (isNumber(vals[k])) {
              own += vals[k];
            }

            var i = Math.trunc(own);
            built[k] = i;
            accumulated[k] = (own * 1000 - i * 1000) / 1000; // plus anything further down the chain that should be rolled up in to this

            for (var down in vals) {
              if (orderedUnits$1.indexOf(down) > orderedUnits$1.indexOf(k)) {
                convert(this.matrix, vals, down, built, k);
              }
            } // otherwise, keep it in the wings to boil it later

          } else if (isNumber(vals[k])) {
            accumulated[k] = vals[k];
          }
        } // anything leftover becomes the decimal for the last unit
        // lastUnit must be defined since units is not empty


        for (var key in accumulated) {
          if (accumulated[key] !== 0) {
            built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
          }
        }

        return clone$1(this, {
          values: built
        }, true).normalize();
      }
      /**
       * Return the negative of this Duration.
       * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
       * @return {Duration}
       */
      ;

      _proto.negate = function negate() {
        if (!this.isValid) return this;
        var negated = {};

        for (var _i2 = 0, _Object$keys2 = Object.keys(this.values); _i2 < _Object$keys2.length; _i2++) {
          var k = _Object$keys2[_i2];
          negated[k] = -this.values[k];
        }

        return clone$1(this, {
          values: negated
        }, true);
      }
      /**
       * Get the years.
       * @type {number}
       */
      ;

      /**
       * Equality check
       * Two Durations are equal iff they have the same units and the same values for each unit.
       * @param {Duration} other
       * @return {boolean}
       */
      _proto.equals = function equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }

        if (!this.loc.equals(other.loc)) {
          return false;
        }

        function eq(v1, v2) {
          // Consider 0 and undefined as equal
          if (v1 === undefined || v1 === 0) return v2 === undefined || v2 === 0;
          return v1 === v2;
        }

        for (var _iterator3 = _createForOfIteratorHelperLoose(orderedUnits$1), _step3; !(_step3 = _iterator3()).done;) {
          var u = _step3.value;

          if (!eq(this.values[u], other.values[u])) {
            return false;
          }
        }

        return true;
      };

      _createClass(Duration, [{
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
        /**
         * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
         *
         * @type {string}
         */

      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
      }, {
        key: "years",
        get: function get() {
          return this.isValid ? this.values.years || 0 : NaN;
        }
        /**
         * Get the quarters.
         * @type {number}
         */

      }, {
        key: "quarters",
        get: function get() {
          return this.isValid ? this.values.quarters || 0 : NaN;
        }
        /**
         * Get the months.
         * @type {number}
         */

      }, {
        key: "months",
        get: function get() {
          return this.isValid ? this.values.months || 0 : NaN;
        }
        /**
         * Get the weeks
         * @type {number}
         */

      }, {
        key: "weeks",
        get: function get() {
          return this.isValid ? this.values.weeks || 0 : NaN;
        }
        /**
         * Get the days.
         * @type {number}
         */

      }, {
        key: "days",
        get: function get() {
          return this.isValid ? this.values.days || 0 : NaN;
        }
        /**
         * Get the hours.
         * @type {number}
         */

      }, {
        key: "hours",
        get: function get() {
          return this.isValid ? this.values.hours || 0 : NaN;
        }
        /**
         * Get the minutes.
         * @type {number}
         */

      }, {
        key: "minutes",
        get: function get() {
          return this.isValid ? this.values.minutes || 0 : NaN;
        }
        /**
         * Get the seconds.
         * @return {number}
         */

      }, {
        key: "seconds",
        get: function get() {
          return this.isValid ? this.values.seconds || 0 : NaN;
        }
        /**
         * Get the milliseconds.
         * @return {number}
         */

      }, {
        key: "milliseconds",
        get: function get() {
          return this.isValid ? this.values.milliseconds || 0 : NaN;
        }
        /**
         * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
         * on invalid DateTimes or Intervals.
         * @return {boolean}
         */

      }, {
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
        /**
         * Returns an error code if this Duration became invalid, or null if the Duration is valid
         * @return {string}
         */

      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
        /**
         * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
         * @type {string}
         */

      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);

      return Duration;
    }();

    var INVALID$1 = "Invalid Interval"; // checks if the start is equal to or before the end

    function validateStartEnd(start, end) {
      if (!start || !start.isValid) {
        return Interval.invalid("missing or invalid start");
      } else if (!end || !end.isValid) {
        return Interval.invalid("missing or invalid end");
      } else if (end < start) {
        return Interval.invalid("end before start", "The end of an interval must be after its start, but you had start=" + start.toISO() + " and end=" + end.toISO());
      } else {
        return null;
      }
    }
    /**
     * An Interval object represents a half-open interval of time, where each endpoint is a {@link DateTime}. Conceptually, it's a container for those two endpoints, accompanied by methods for creating, parsing, interrogating, comparing, transforming, and formatting them.
     *
     * Here is a brief overview of the most commonly used methods and getters in Interval:
     *
     * * **Creation** To create an Interval, use {@link Interval#fromDateTimes}, {@link Interval#after}, {@link Interval#before}, or {@link Interval#fromISO}.
     * * **Accessors** Use {@link Interval#start} and {@link Interval#end} to get the start and end.
     * * **Interrogation** To analyze the Interval, use {@link Interval#count}, {@link Interval#length}, {@link Interval#hasSame}, {@link Interval#contains}, {@link Interval#isAfter}, or {@link Interval#isBefore}.
     * * **Transformation** To create other Intervals out of this one, use {@link Interval#set}, {@link Interval#splitAt}, {@link Interval#splitBy}, {@link Interval#divideEqually}, {@link Interval#merge}, {@link Interval#xor}, {@link Interval#union}, {@link Interval#intersection}, or {@link Interval#difference}.
     * * **Comparison** To compare this Interval to another one, use {@link Interval#equals}, {@link Interval#overlaps}, {@link Interval#abutsStart}, {@link Interval#abutsEnd}, {@link Interval#engulfs}
     * * **Output** To convert the Interval into other representations, see {@link Interval#toString}, {@link Interval#toISO}, {@link Interval#toISODate}, {@link Interval#toISOTime}, {@link Interval#toFormat}, and {@link Interval#toDuration}.
     */


    var Interval = /*#__PURE__*/function () {
      /**
       * @private
       */
      function Interval(config) {
        /**
         * @access private
         */
        this.s = config.start;
        /**
         * @access private
         */

        this.e = config.end;
        /**
         * @access private
         */

        this.invalid = config.invalid || null;
        /**
         * @access private
         */

        this.isLuxonInterval = true;
      }
      /**
       * Create an invalid Interval.
       * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {Interval}
       */


      Interval.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }

        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
        }

        var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

        if (Settings$1.throwOnInvalid) {
          throw new InvalidIntervalError(invalid);
        } else {
          return new Interval({
            invalid: invalid
          });
        }
      }
      /**
       * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
       * @param {DateTime|Date|Object} start
       * @param {DateTime|Date|Object} end
       * @return {Interval}
       */
      ;

      Interval.fromDateTimes = function fromDateTimes(start, end) {
        var builtStart = friendlyDateTime(start),
            builtEnd = friendlyDateTime(end);
        var validateError = validateStartEnd(builtStart, builtEnd);

        if (validateError == null) {
          return new Interval({
            start: builtStart,
            end: builtEnd
          });
        } else {
          return validateError;
        }
      }
      /**
       * Create an Interval from a start DateTime and a Duration to extend to.
       * @param {DateTime|Date|Object} start
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      ;

      Interval.after = function after(start, duration) {
        var dur = Duration.fromDurationLike(duration),
            dt = friendlyDateTime(start);
        return Interval.fromDateTimes(dt, dt.plus(dur));
      }
      /**
       * Create an Interval from an end DateTime and a Duration to extend backwards to.
       * @param {DateTime|Date|Object} end
       * @param {Duration|Object|number} duration - the length of the Interval.
       * @return {Interval}
       */
      ;

      Interval.before = function before(end, duration) {
        var dur = Duration.fromDurationLike(duration),
            dt = friendlyDateTime(end);
        return Interval.fromDateTimes(dt.minus(dur), dt);
      }
      /**
       * Create an Interval from an ISO 8601 string.
       * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
       * @param {string} text - the ISO string to parse
       * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {Interval}
       */
      ;

      Interval.fromISO = function fromISO(text, opts) {
        var _split = (text || "").split("/", 2),
            s = _split[0],
            e = _split[1];

        if (s && e) {
          var start, startIsValid;

          try {
            start = DateTime.fromISO(s, opts);
            startIsValid = start.isValid;
          } catch (e) {
            startIsValid = false;
          }

          var end, endIsValid;

          try {
            end = DateTime.fromISO(e, opts);
            endIsValid = end.isValid;
          } catch (e) {
            endIsValid = false;
          }

          if (startIsValid && endIsValid) {
            return Interval.fromDateTimes(start, end);
          }

          if (startIsValid) {
            var dur = Duration.fromISO(e, opts);

            if (dur.isValid) {
              return Interval.after(start, dur);
            }
          } else if (endIsValid) {
            var _dur = Duration.fromISO(s, opts);

            if (_dur.isValid) {
              return Interval.before(end, _dur);
            }
          }
        }

        return Interval.invalid("unparsable", "the input \"" + text + "\" can't be parsed as ISO 8601");
      }
      /**
       * Check if an object is an Interval. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      ;

      Interval.isInterval = function isInterval(o) {
        return o && o.isLuxonInterval || false;
      }
      /**
       * Returns the start of the Interval
       * @type {DateTime}
       */
      ;

      var _proto = Interval.prototype;

      /**
       * Returns the length of the Interval in the specified unit.
       * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
       * @return {number}
       */
      _proto.length = function length(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }

        return this.isValid ? this.toDuration.apply(this, [unit]).get(unit) : NaN;
      }
      /**
       * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
       * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
       * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
       * @param {string} [unit='milliseconds'] - the unit of time to count.
       * @return {number}
       */
      ;

      _proto.count = function count(unit) {
        if (unit === void 0) {
          unit = "milliseconds";
        }

        if (!this.isValid) return NaN;
        var start = this.start.startOf(unit),
            end = this.end.startOf(unit);
        return Math.floor(end.diff(start, unit).get(unit)) + 1;
      }
      /**
       * Returns whether this Interval's start and end are both in the same unit of time
       * @param {string} unit - the unit of time to check sameness on
       * @return {boolean}
       */
      ;

      _proto.hasSame = function hasSame(unit) {
        return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
      }
      /**
       * Return whether this Interval has the same start and end DateTimes.
       * @return {boolean}
       */
      ;

      _proto.isEmpty = function isEmpty() {
        return this.s.valueOf() === this.e.valueOf();
      }
      /**
       * Return whether this Interval's start is after the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      ;

      _proto.isAfter = function isAfter(dateTime) {
        if (!this.isValid) return false;
        return this.s > dateTime;
      }
      /**
       * Return whether this Interval's end is before the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      ;

      _proto.isBefore = function isBefore(dateTime) {
        if (!this.isValid) return false;
        return this.e <= dateTime;
      }
      /**
       * Return whether this Interval contains the specified DateTime.
       * @param {DateTime} dateTime
       * @return {boolean}
       */
      ;

      _proto.contains = function contains(dateTime) {
        if (!this.isValid) return false;
        return this.s <= dateTime && this.e > dateTime;
      }
      /**
       * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
       * @param {Object} values - the values to set
       * @param {DateTime} values.start - the starting DateTime
       * @param {DateTime} values.end - the ending DateTime
       * @return {Interval}
       */
      ;

      _proto.set = function set(_temp) {
        var _ref = _temp === void 0 ? {} : _temp,
            start = _ref.start,
            end = _ref.end;

        if (!this.isValid) return this;
        return Interval.fromDateTimes(start || this.s, end || this.e);
      }
      /**
       * Split this Interval at each of the specified DateTimes
       * @param {...DateTime} dateTimes - the unit of time to count.
       * @return {Array}
       */
      ;

      _proto.splitAt = function splitAt() {
        var _this = this;

        if (!this.isValid) return [];

        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }

        var sorted = dateTimes.map(friendlyDateTime).filter(function (d) {
          return _this.contains(d);
        }).sort(),
            results = [];
        var s = this.s,
            i = 0;

        while (s < this.e) {
          var added = sorted[i] || this.e,
              next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s, next));
          s = next;
          i += 1;
        }

        return results;
      }
      /**
       * Split this Interval into smaller Intervals, each of the specified length.
       * Left over time is grouped into a smaller interval
       * @param {Duration|Object|number} duration - The length of each resulting interval.
       * @return {Array}
       */
      ;

      _proto.splitBy = function splitBy(duration) {
        var dur = Duration.fromDurationLike(duration);

        if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
          return [];
        }

        var s = this.s,
            idx = 1,
            next;
        var results = [];

        while (s < this.e) {
          var added = this.start.plus(dur.mapUnits(function (x) {
            return x * idx;
          }));
          next = +added > +this.e ? this.e : added;
          results.push(Interval.fromDateTimes(s, next));
          s = next;
          idx += 1;
        }

        return results;
      }
      /**
       * Split this Interval into the specified number of smaller intervals.
       * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
       * @return {Array}
       */
      ;

      _proto.divideEqually = function divideEqually(numberOfParts) {
        if (!this.isValid) return [];
        return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
      }
      /**
       * Return whether this Interval overlaps with the specified Interval
       * @param {Interval} other
       * @return {boolean}
       */
      ;

      _proto.overlaps = function overlaps(other) {
        return this.e > other.s && this.s < other.e;
      }
      /**
       * Return whether this Interval's end is adjacent to the specified Interval's start.
       * @param {Interval} other
       * @return {boolean}
       */
      ;

      _proto.abutsStart = function abutsStart(other) {
        if (!this.isValid) return false;
        return +this.e === +other.s;
      }
      /**
       * Return whether this Interval's start is adjacent to the specified Interval's end.
       * @param {Interval} other
       * @return {boolean}
       */
      ;

      _proto.abutsEnd = function abutsEnd(other) {
        if (!this.isValid) return false;
        return +other.e === +this.s;
      }
      /**
       * Return whether this Interval engulfs the start and end of the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      ;

      _proto.engulfs = function engulfs(other) {
        if (!this.isValid) return false;
        return this.s <= other.s && this.e >= other.e;
      }
      /**
       * Return whether this Interval has the same start and end as the specified Interval.
       * @param {Interval} other
       * @return {boolean}
       */
      ;

      _proto.equals = function equals(other) {
        if (!this.isValid || !other.isValid) {
          return false;
        }

        return this.s.equals(other.s) && this.e.equals(other.e);
      }
      /**
       * Return an Interval representing the intersection of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
       * Returns null if the intersection is empty, meaning, the intervals don't intersect.
       * @param {Interval} other
       * @return {Interval}
       */
      ;

      _proto.intersection = function intersection(other) {
        if (!this.isValid) return this;
        var s = this.s > other.s ? this.s : other.s,
            e = this.e < other.e ? this.e : other.e;

        if (s >= e) {
          return null;
        } else {
          return Interval.fromDateTimes(s, e);
        }
      }
      /**
       * Return an Interval representing the union of this Interval and the specified Interval.
       * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
       * @param {Interval} other
       * @return {Interval}
       */
      ;

      _proto.union = function union(other) {
        if (!this.isValid) return this;
        var s = this.s < other.s ? this.s : other.s,
            e = this.e > other.e ? this.e : other.e;
        return Interval.fromDateTimes(s, e);
      }
      /**
       * Merge an array of Intervals into a equivalent minimal set of Intervals.
       * Combines overlapping and adjacent Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      ;

      Interval.merge = function merge(intervals) {
        var _intervals$sort$reduc = intervals.sort(function (a, b) {
          return a.s - b.s;
        }).reduce(function (_ref2, item) {
          var sofar = _ref2[0],
              current = _ref2[1];

          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        }, [[], null]),
            found = _intervals$sort$reduc[0],
            final = _intervals$sort$reduc[1];

        if (final) {
          found.push(final);
        }

        return found;
      }
      /**
       * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
       * @param {Array} intervals
       * @return {Array}
       */
      ;

      Interval.xor = function xor(intervals) {
        var _Array$prototype;

        var start = null,
            currentCount = 0;

        var results = [],
            ends = intervals.map(function (i) {
          return [{
            time: i.s,
            type: "s"
          }, {
            time: i.e,
            type: "e"
          }];
        }),
            flattened = (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, ends),
            arr = flattened.sort(function (a, b) {
          return a.time - b.time;
        });

        for (var _iterator = _createForOfIteratorHelperLoose(arr), _step; !(_step = _iterator()).done;) {
          var i = _step.value;
          currentCount += i.type === "s" ? 1 : -1;

          if (currentCount === 1) {
            start = i.time;
          } else {
            if (start && +start !== +i.time) {
              results.push(Interval.fromDateTimes(start, i.time));
            }

            start = null;
          }
        }

        return Interval.merge(results);
      }
      /**
       * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
       * @param {...Interval} intervals
       * @return {Array}
       */
      ;

      _proto.difference = function difference() {
        var _this2 = this;

        for (var _len2 = arguments.length, intervals = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          intervals[_key2] = arguments[_key2];
        }

        return Interval.xor([this].concat(intervals)).map(function (i) {
          return _this2.intersection(i);
        }).filter(function (i) {
          return i && !i.isEmpty();
        });
      }
      /**
       * Returns a string representation of this Interval appropriate for debugging.
       * @return {string}
       */
      ;

      _proto.toString = function toString() {
        if (!this.isValid) return INVALID$1;
        return "[" + this.s.toISO() + " \u2013 " + this.e.toISO() + ")";
      }
      /**
       * Returns an ISO 8601-compliant string representation of this Interval.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      ;

      _proto.toISO = function toISO(opts) {
        if (!this.isValid) return INVALID$1;
        return this.s.toISO(opts) + "/" + this.e.toISO(opts);
      }
      /**
       * Returns an ISO 8601-compliant string representation of date of this Interval.
       * The time components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @return {string}
       */
      ;

      _proto.toISODate = function toISODate() {
        if (!this.isValid) return INVALID$1;
        return this.s.toISODate() + "/" + this.e.toISODate();
      }
      /**
       * Returns an ISO 8601-compliant string representation of time of this Interval.
       * The date components are ignored.
       * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
       * @param {Object} opts - The same options as {@link DateTime#toISO}
       * @return {string}
       */
      ;

      _proto.toISOTime = function toISOTime(opts) {
        if (!this.isValid) return INVALID$1;
        return this.s.toISOTime(opts) + "/" + this.e.toISOTime(opts);
      }
      /**
       * Returns a string representation of this Interval formatted according to the specified format string.
       * @param {string} dateFormat - the format string. This string formats the start and end time. See {@link DateTime#toFormat} for details.
       * @param {Object} opts - options
       * @param {string} [opts.separator =  '  '] - a separator to place between the start and end representations
       * @return {string}
       */
      ;

      _proto.toFormat = function toFormat(dateFormat, _temp2) {
        var _ref3 = _temp2 === void 0 ? {} : _temp2,
            _ref3$separator = _ref3.separator,
            separator = _ref3$separator === void 0 ? "  " : _ref3$separator;

        if (!this.isValid) return INVALID$1;
        return "" + this.s.toFormat(dateFormat) + separator + this.e.toFormat(dateFormat);
      }
      /**
       * Return a Duration representing the time spanned by this interval.
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
       * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
       * @return {Duration}
       */
      ;

      _proto.toDuration = function toDuration(unit, opts) {
        if (!this.isValid) {
          return Duration.invalid(this.invalidReason);
        }

        return this.e.diff(this.s, unit, opts);
      }
      /**
       * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
       * @param {function} mapFn
       * @return {Interval}
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
       * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
       */
      ;

      _proto.mapEndpoints = function mapEndpoints(mapFn) {
        return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
      };

      _createClass(Interval, [{
        key: "start",
        get: function get() {
          return this.isValid ? this.s : null;
        }
        /**
         * Returns the end of the Interval
         * @type {DateTime}
         */

      }, {
        key: "end",
        get: function get() {
          return this.isValid ? this.e : null;
        }
        /**
         * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
         * @type {boolean}
         */

      }, {
        key: "isValid",
        get: function get() {
          return this.invalidReason === null;
        }
        /**
         * Returns an error code if this Interval is invalid, or null if the Interval is valid
         * @type {string}
         */

      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
        /**
         * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
         * @type {string}
         */

      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
      }]);

      return Interval;
    }();

    /**
     * The Info class contains static methods for retrieving general time and date related data. For example, it has methods for finding out if a time zone has a DST, for listing the months in any supported locale, and for discovering which of Luxon features are available in the current environment.
     */

    var Info = /*#__PURE__*/function () {
      function Info() {}

      /**
       * Return whether the specified zone contains a DST.
       * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
       * @return {boolean}
       */
      Info.hasDST = function hasDST(zone) {
        if (zone === void 0) {
          zone = Settings$1.defaultZone;
        }

        var proto = DateTime.now().setZone(zone).set({
          month: 12
        });
        return !zone.isUniversal && proto.offset !== proto.set({
          month: 6
        }).offset;
      }
      /**
       * Return whether the specified zone is a valid IANA specifier.
       * @param {string} zone - Zone to check
       * @return {boolean}
       */
      ;

      Info.isValidIANAZone = function isValidIANAZone(zone) {
        return IANAZone.isValidSpecifier(zone) && IANAZone.isValidZone(zone);
      }
      /**
       * Converts the input into a {@link Zone} instance.
       *
       * * If `input` is already a Zone instance, it is returned unchanged.
       * * If `input` is a string containing a valid time zone name, a Zone instance
       *   with that name is returned.
       * * If `input` is a string that doesn't refer to a known time zone, a Zone
       *   instance with {@link Zone#isValid} == false is returned.
       * * If `input is a number, a Zone instance with the specified fixed offset
       *   in minutes is returned.
       * * If `input` is `null` or `undefined`, the default zone is returned.
       * @param {string|Zone|number} [input] - the value to be converted
       * @return {Zone}
       */
      ;

      Info.normalizeZone = function normalizeZone$1(input) {
        return normalizeZone(input, Settings$1.defaultZone);
      }
      /**
       * Return an array of standalone month names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @example Info.months()[0] //=> 'January'
       * @example Info.months('short')[0] //=> 'Jan'
       * @example Info.months('numeric')[0] //=> '1'
       * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
       * @example Info.months('numeric', { locale: 'ar' })[0] //=> ''
       * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabi I'
       * @return {Array}
       */
      ;

      Info.months = function months(length, _temp) {
        if (length === void 0) {
          length = "long";
        }

        var _ref = _temp === void 0 ? {} : _temp,
            _ref$locale = _ref.locale,
            locale = _ref$locale === void 0 ? null : _ref$locale,
            _ref$numberingSystem = _ref.numberingSystem,
            numberingSystem = _ref$numberingSystem === void 0 ? null : _ref$numberingSystem,
            _ref$locObj = _ref.locObj,
            locObj = _ref$locObj === void 0 ? null : _ref$locObj,
            _ref$outputCalendar = _ref.outputCalendar,
            outputCalendar = _ref$outputCalendar === void 0 ? "gregory" : _ref$outputCalendar;

        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
      }
      /**
       * Return an array of format month names.
       * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
       * changes the string.
       * See {@link Info#months}
       * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @param {string} [opts.outputCalendar='gregory'] - the calendar
       * @return {Array}
       */
      ;

      Info.monthsFormat = function monthsFormat(length, _temp2) {
        if (length === void 0) {
          length = "long";
        }

        var _ref2 = _temp2 === void 0 ? {} : _temp2,
            _ref2$locale = _ref2.locale,
            locale = _ref2$locale === void 0 ? null : _ref2$locale,
            _ref2$numberingSystem = _ref2.numberingSystem,
            numberingSystem = _ref2$numberingSystem === void 0 ? null : _ref2$numberingSystem,
            _ref2$locObj = _ref2.locObj,
            locObj = _ref2$locObj === void 0 ? null : _ref2$locObj,
            _ref2$outputCalendar = _ref2.outputCalendar,
            outputCalendar = _ref2$outputCalendar === void 0 ? "gregory" : _ref2$outputCalendar;

        return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
      }
      /**
       * Return an array of standalone week names.
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @example Info.weekdays()[0] //=> 'Monday'
       * @example Info.weekdays('short')[0] //=> 'Mon'
       * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
       * @example Info.weekdays('short', { locale: 'ar' })[0] //=> ''
       * @return {Array}
       */
      ;

      Info.weekdays = function weekdays(length, _temp3) {
        if (length === void 0) {
          length = "long";
        }

        var _ref3 = _temp3 === void 0 ? {} : _temp3,
            _ref3$locale = _ref3.locale,
            locale = _ref3$locale === void 0 ? null : _ref3$locale,
            _ref3$numberingSystem = _ref3.numberingSystem,
            numberingSystem = _ref3$numberingSystem === void 0 ? null : _ref3$numberingSystem,
            _ref3$locObj = _ref3.locObj,
            locObj = _ref3$locObj === void 0 ? null : _ref3$locObj;

        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
      }
      /**
       * Return an array of format week names.
       * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
       * changes the string.
       * See {@link Info#weekdays}
       * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale=null] - the locale code
       * @param {string} [opts.numberingSystem=null] - the numbering system
       * @param {string} [opts.locObj=null] - an existing locale object to use
       * @return {Array}
       */
      ;

      Info.weekdaysFormat = function weekdaysFormat(length, _temp4) {
        if (length === void 0) {
          length = "long";
        }

        var _ref4 = _temp4 === void 0 ? {} : _temp4,
            _ref4$locale = _ref4.locale,
            locale = _ref4$locale === void 0 ? null : _ref4$locale,
            _ref4$numberingSystem = _ref4.numberingSystem,
            numberingSystem = _ref4$numberingSystem === void 0 ? null : _ref4$numberingSystem,
            _ref4$locObj = _ref4.locObj,
            locObj = _ref4$locObj === void 0 ? null : _ref4$locObj;

        return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
      }
      /**
       * Return an array of meridiems.
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.meridiems() //=> [ 'AM', 'PM' ]
       * @example Info.meridiems({ locale: 'my' }) //=> [ '', '' ]
       * @return {Array}
       */
      ;

      Info.meridiems = function meridiems(_temp5) {
        var _ref5 = _temp5 === void 0 ? {} : _temp5,
            _ref5$locale = _ref5.locale,
            locale = _ref5$locale === void 0 ? null : _ref5$locale;

        return Locale.create(locale).meridiems();
      }
      /**
       * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
       * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
       * @param {Object} opts - options
       * @param {string} [opts.locale] - the locale code
       * @example Info.eras() //=> [ 'BC', 'AD' ]
       * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
       * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jsus-Christ', 'aprs Jsus-Christ' ]
       * @return {Array}
       */
      ;

      Info.eras = function eras(length, _temp6) {
        if (length === void 0) {
          length = "short";
        }

        var _ref6 = _temp6 === void 0 ? {} : _temp6,
            _ref6$locale = _ref6.locale,
            locale = _ref6$locale === void 0 ? null : _ref6$locale;

        return Locale.create(locale, null, "gregory").eras(length);
      }
      /**
       * Return the set of available features in this environment.
       * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
       * Keys:
       * * `relative`: whether this environment supports relative time formatting
       * @example Info.features() //=> { relative: false }
       * @return {Object}
       */
      ;

      Info.features = function features() {
        return {
          relative: hasRelative()
        };
      };

      return Info;
    }();

    function dayDiff(earlier, later) {
      var utcDayStart = function utcDayStart(dt) {
        return dt.toUTC(0, {
          keepLocalTime: true
        }).startOf("day").valueOf();
      },
          ms = utcDayStart(later) - utcDayStart(earlier);

      return Math.floor(Duration.fromMillis(ms).as("days"));
    }

    function highOrderDiffs(cursor, later, units) {
      var differs = [["years", function (a, b) {
        return b.year - a.year;
      }], ["quarters", function (a, b) {
        return b.quarter - a.quarter;
      }], ["months", function (a, b) {
        return b.month - a.month + (b.year - a.year) * 12;
      }], ["weeks", function (a, b) {
        var days = dayDiff(a, b);
        return (days - days % 7) / 7;
      }], ["days", dayDiff]];
      var results = {};
      var lowestOrder, highWater;

      for (var _i = 0, _differs = differs; _i < _differs.length; _i++) {
        var _differs$_i = _differs[_i],
            unit = _differs$_i[0],
            differ = _differs$_i[1];

        if (units.indexOf(unit) >= 0) {
          var _cursor$plus;

          lowestOrder = unit;
          var delta = differ(cursor, later);
          highWater = cursor.plus((_cursor$plus = {}, _cursor$plus[unit] = delta, _cursor$plus));

          if (highWater > later) {
            var _cursor$plus2;

            cursor = cursor.plus((_cursor$plus2 = {}, _cursor$plus2[unit] = delta - 1, _cursor$plus2));
            delta -= 1;
          } else {
            cursor = highWater;
          }

          results[unit] = delta;
        }
      }

      return [cursor, results, highWater, lowestOrder];
    }

    function _diff (earlier, later, units, opts) {
      var _highOrderDiffs = highOrderDiffs(earlier, later, units),
          cursor = _highOrderDiffs[0],
          results = _highOrderDiffs[1],
          highWater = _highOrderDiffs[2],
          lowestOrder = _highOrderDiffs[3];

      var remainingMillis = later - cursor;
      var lowerOrderUnits = units.filter(function (u) {
        return ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0;
      });

      if (lowerOrderUnits.length === 0) {
        if (highWater < later) {
          var _cursor$plus3;

          highWater = cursor.plus((_cursor$plus3 = {}, _cursor$plus3[lowestOrder] = 1, _cursor$plus3));
        }

        if (highWater !== cursor) {
          results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
        }
      }

      var duration = Duration.fromObject(results, opts);

      if (lowerOrderUnits.length > 0) {
        var _Duration$fromMillis;

        return (_Duration$fromMillis = Duration.fromMillis(remainingMillis, opts)).shiftTo.apply(_Duration$fromMillis, lowerOrderUnits).plus(duration);
      } else {
        return duration;
      }
    }

    var numberingSystems = {
      arab: "[\u0660-\u0669]",
      arabext: "[\u06F0-\u06F9]",
      bali: "[\u1B50-\u1B59]",
      beng: "[\u09E6-\u09EF]",
      deva: "[\u0966-\u096F]",
      fullwide: "[\uFF10-\uFF19]",
      gujr: "[\u0AE6-\u0AEF]",
      hanidec: "[|||||||||]",
      khmr: "[\u17E0-\u17E9]",
      knda: "[\u0CE6-\u0CEF]",
      laoo: "[\u0ED0-\u0ED9]",
      limb: "[\u1946-\u194F]",
      mlym: "[\u0D66-\u0D6F]",
      mong: "[\u1810-\u1819]",
      mymr: "[\u1040-\u1049]",
      orya: "[\u0B66-\u0B6F]",
      tamldec: "[\u0BE6-\u0BEF]",
      telu: "[\u0C66-\u0C6F]",
      thai: "[\u0E50-\u0E59]",
      tibt: "[\u0F20-\u0F29]",
      latn: "\\d"
    };
    var numberingSystemsUTF16 = {
      arab: [1632, 1641],
      arabext: [1776, 1785],
      bali: [6992, 7001],
      beng: [2534, 2543],
      deva: [2406, 2415],
      fullwide: [65296, 65303],
      gujr: [2790, 2799],
      khmr: [6112, 6121],
      knda: [3302, 3311],
      laoo: [3792, 3801],
      limb: [6470, 6479],
      mlym: [3430, 3439],
      mong: [6160, 6169],
      mymr: [4160, 4169],
      orya: [2918, 2927],
      tamldec: [3046, 3055],
      telu: [3174, 3183],
      thai: [3664, 3673],
      tibt: [3872, 3881]
    };
    var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
    function parseDigits(str) {
      var value = parseInt(str, 10);

      if (isNaN(value)) {
        value = "";

        for (var i = 0; i < str.length; i++) {
          var code = str.charCodeAt(i);

          if (str[i].search(numberingSystems.hanidec) !== -1) {
            value += hanidecChars.indexOf(str[i]);
          } else {
            for (var key in numberingSystemsUTF16) {
              var _numberingSystemsUTF = numberingSystemsUTF16[key],
                  min = _numberingSystemsUTF[0],
                  max = _numberingSystemsUTF[1];

              if (code >= min && code <= max) {
                value += code - min;
              }
            }
          }
        }

        return parseInt(value, 10);
      } else {
        return value;
      }
    }
    function digitRegex(_ref, append) {
      var numberingSystem = _ref.numberingSystem;

      if (append === void 0) {
        append = "";
      }

      return new RegExp("" + numberingSystems[numberingSystem || "latn"] + append);
    }

    var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";

    function intUnit(regex, post) {
      if (post === void 0) {
        post = function post(i) {
          return i;
        };
      }

      return {
        regex: regex,
        deser: function deser(_ref) {
          var s = _ref[0];
          return post(parseDigits(s));
        }
      };
    }

    var NBSP = String.fromCharCode(160);
    var spaceOrNBSP = "( |" + NBSP + ")";
    var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");

    function fixListRegex(s) {
      // make dots optional and also make them literal
      // make space and non breakable space characters interchangeable
      return s.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
    }

    function stripInsensitivities(s) {
      return s.replace(/\./g, "") // ignore dots that were made optional
      .replace(spaceOrNBSPRegExp, " ") // interchange space and nbsp
      .toLowerCase();
    }

    function oneOf(strings, startIndex) {
      if (strings === null) {
        return null;
      } else {
        return {
          regex: RegExp(strings.map(fixListRegex).join("|")),
          deser: function deser(_ref2) {
            var s = _ref2[0];
            return strings.findIndex(function (i) {
              return stripInsensitivities(s) === stripInsensitivities(i);
            }) + startIndex;
          }
        };
      }
    }

    function offset(regex, groups) {
      return {
        regex: regex,
        deser: function deser(_ref3) {
          var h = _ref3[1],
              m = _ref3[2];
          return signedOffset(h, m);
        },
        groups: groups
      };
    }

    function simple(regex) {
      return {
        regex: regex,
        deser: function deser(_ref4) {
          var s = _ref4[0];
          return s;
        }
      };
    }

    function escapeToken(value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
    }

    function unitForToken(token, loc) {
      var one = digitRegex(loc),
          two = digitRegex(loc, "{2}"),
          three = digitRegex(loc, "{3}"),
          four = digitRegex(loc, "{4}"),
          six = digitRegex(loc, "{6}"),
          oneOrTwo = digitRegex(loc, "{1,2}"),
          oneToThree = digitRegex(loc, "{1,3}"),
          oneToSix = digitRegex(loc, "{1,6}"),
          oneToNine = digitRegex(loc, "{1,9}"),
          twoToFour = digitRegex(loc, "{2,4}"),
          fourToSix = digitRegex(loc, "{4,6}"),
          literal = function literal(t) {
        return {
          regex: RegExp(escapeToken(t.val)),
          deser: function deser(_ref5) {
            var s = _ref5[0];
            return s;
          },
          literal: true
        };
      },
          unitate = function unitate(t) {
        if (token.literal) {
          return literal(t);
        }

        switch (t.val) {
          // era
          case "G":
            return oneOf(loc.eras("short", false), 0);

          case "GG":
            return oneOf(loc.eras("long", false), 0);
          // years

          case "y":
            return intUnit(oneToSix);

          case "yy":
            return intUnit(twoToFour, untruncateYear);

          case "yyyy":
            return intUnit(four);

          case "yyyyy":
            return intUnit(fourToSix);

          case "yyyyyy":
            return intUnit(six);
          // months

          case "M":
            return intUnit(oneOrTwo);

          case "MM":
            return intUnit(two);

          case "MMM":
            return oneOf(loc.months("short", true, false), 1);

          case "MMMM":
            return oneOf(loc.months("long", true, false), 1);

          case "L":
            return intUnit(oneOrTwo);

          case "LL":
            return intUnit(two);

          case "LLL":
            return oneOf(loc.months("short", false, false), 1);

          case "LLLL":
            return oneOf(loc.months("long", false, false), 1);
          // dates

          case "d":
            return intUnit(oneOrTwo);

          case "dd":
            return intUnit(two);
          // ordinals

          case "o":
            return intUnit(oneToThree);

          case "ooo":
            return intUnit(three);
          // time

          case "HH":
            return intUnit(two);

          case "H":
            return intUnit(oneOrTwo);

          case "hh":
            return intUnit(two);

          case "h":
            return intUnit(oneOrTwo);

          case "mm":
            return intUnit(two);

          case "m":
            return intUnit(oneOrTwo);

          case "q":
            return intUnit(oneOrTwo);

          case "qq":
            return intUnit(two);

          case "s":
            return intUnit(oneOrTwo);

          case "ss":
            return intUnit(two);

          case "S":
            return intUnit(oneToThree);

          case "SSS":
            return intUnit(three);

          case "u":
            return simple(oneToNine);

          case "uu":
            return simple(oneOrTwo);

          case "uuu":
            return intUnit(one);
          // meridiem

          case "a":
            return oneOf(loc.meridiems(), 0);
          // weekYear (k)

          case "kkkk":
            return intUnit(four);

          case "kk":
            return intUnit(twoToFour, untruncateYear);
          // weekNumber (W)

          case "W":
            return intUnit(oneOrTwo);

          case "WW":
            return intUnit(two);
          // weekdays

          case "E":
          case "c":
            return intUnit(one);

          case "EEE":
            return oneOf(loc.weekdays("short", false, false), 1);

          case "EEEE":
            return oneOf(loc.weekdays("long", false, false), 1);

          case "ccc":
            return oneOf(loc.weekdays("short", true, false), 1);

          case "cccc":
            return oneOf(loc.weekdays("long", true, false), 1);
          // offset/zone

          case "Z":
          case "ZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(?::(" + two.source + "))?"), 2);

          case "ZZZ":
            return offset(new RegExp("([+-]" + oneOrTwo.source + ")(" + two.source + ")?"), 2);
          // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
          // because we don't have any way to figure out what they are

          case "z":
            return simple(/[a-z_+-/]{1,256}?/i);

          default:
            return literal(t);
        }
      };

      var unit = unitate(token) || {
        invalidReason: MISSING_FTP
      };
      unit.token = token;
      return unit;
    }

    var partTypeStyleToTokenVal = {
      year: {
        "2-digit": "yy",
        numeric: "yyyyy"
      },
      month: {
        numeric: "M",
        "2-digit": "MM",
        short: "MMM",
        long: "MMMM"
      },
      day: {
        numeric: "d",
        "2-digit": "dd"
      },
      weekday: {
        short: "EEE",
        long: "EEEE"
      },
      dayperiod: "a",
      dayPeriod: "a",
      hour: {
        numeric: "h",
        "2-digit": "hh"
      },
      minute: {
        numeric: "m",
        "2-digit": "mm"
      },
      second: {
        numeric: "s",
        "2-digit": "ss"
      }
    };

    function tokenForPart(part, locale, formatOpts) {
      var type = part.type,
          value = part.value;

      if (type === "literal") {
        return {
          literal: true,
          val: value
        };
      }

      var style = formatOpts[type];
      var val = partTypeStyleToTokenVal[type];

      if (typeof val === "object") {
        val = val[style];
      }

      if (val) {
        return {
          literal: false,
          val: val
        };
      }

      return undefined;
    }

    function buildRegex(units) {
      var re = units.map(function (u) {
        return u.regex;
      }).reduce(function (f, r) {
        return f + "(" + r.source + ")";
      }, "");
      return ["^" + re + "$", units];
    }

    function match(input, regex, handlers) {
      var matches = input.match(regex);

      if (matches) {
        var all = {};
        var matchIndex = 1;

        for (var i in handlers) {
          if (hasOwnProperty$a(handlers, i)) {
            var h = handlers[i],
                groups = h.groups ? h.groups + 1 : 1;

            if (!h.literal && h.token) {
              all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
            }

            matchIndex += groups;
          }
        }

        return [matches, all];
      } else {
        return [matches, {}];
      }
    }

    function dateTimeFromMatches(matches) {
      var toField = function toField(token) {
        switch (token) {
          case "S":
            return "millisecond";

          case "s":
            return "second";

          case "m":
            return "minute";

          case "h":
          case "H":
            return "hour";

          case "d":
            return "day";

          case "o":
            return "ordinal";

          case "L":
          case "M":
            return "month";

          case "y":
            return "year";

          case "E":
          case "c":
            return "weekday";

          case "W":
            return "weekNumber";

          case "k":
            return "weekYear";

          case "q":
            return "quarter";

          default:
            return null;
        }
      };

      var zone = null;
      var specificOffset;

      if (!isUndefined(matches.z)) {
        zone = IANAZone.create(matches.z);
      }

      if (!isUndefined(matches.Z)) {
        if (!zone) {
          zone = new FixedOffsetZone(matches.Z);
        }

        specificOffset = matches.Z;
      }

      if (!isUndefined(matches.q)) {
        matches.M = (matches.q - 1) * 3 + 1;
      }

      if (!isUndefined(matches.h)) {
        if (matches.h < 12 && matches.a === 1) {
          matches.h += 12;
        } else if (matches.h === 12 && matches.a === 0) {
          matches.h = 0;
        }
      }

      if (matches.G === 0 && matches.y) {
        matches.y = -matches.y;
      }

      if (!isUndefined(matches.u)) {
        matches.S = parseMillis(matches.u);
      }

      var vals = Object.keys(matches).reduce(function (r, k) {
        var f = toField(k);

        if (f) {
          r[f] = matches[k];
        }

        return r;
      }, {});
      return [vals, zone, specificOffset];
    }

    var dummyDateTimeCache = null;

    function getDummyDateTime() {
      if (!dummyDateTimeCache) {
        dummyDateTimeCache = DateTime.fromMillis(1555555555555);
      }

      return dummyDateTimeCache;
    }

    function maybeExpandMacroToken(token, locale) {
      if (token.literal) {
        return token;
      }

      var formatOpts = Formatter.macroTokenToFormatOpts(token.val);

      if (!formatOpts) {
        return token;
      }

      var formatter = Formatter.create(locale, formatOpts);
      var parts = formatter.formatDateTimeParts(getDummyDateTime());
      var tokens = parts.map(function (p) {
        return tokenForPart(p, locale, formatOpts);
      });

      if (tokens.includes(undefined)) {
        return token;
      }

      return tokens;
    }

    function expandMacroTokens(tokens, locale) {
      var _Array$prototype;

      return (_Array$prototype = Array.prototype).concat.apply(_Array$prototype, tokens.map(function (t) {
        return maybeExpandMacroToken(t, locale);
      }));
    }
    /**
     * @private
     */


    function explainFromTokens(locale, input, format) {
      var tokens = expandMacroTokens(Formatter.parseFormat(format), locale),
          units = tokens.map(function (t) {
        return unitForToken(t, locale);
      }),
          disqualifyingUnit = units.find(function (t) {
        return t.invalidReason;
      });

      if (disqualifyingUnit) {
        return {
          input: input,
          tokens: tokens,
          invalidReason: disqualifyingUnit.invalidReason
        };
      } else {
        var _buildRegex = buildRegex(units),
            regexString = _buildRegex[0],
            handlers = _buildRegex[1],
            regex = RegExp(regexString, "i"),
            _match = match(input, regex, handlers),
            rawMatches = _match[0],
            matches = _match[1],
            _ref6 = matches ? dateTimeFromMatches(matches) : [null, null, undefined],
            result = _ref6[0],
            zone = _ref6[1],
            specificOffset = _ref6[2];

        if (hasOwnProperty$a(matches, "a") && hasOwnProperty$a(matches, "H")) {
          throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
        }

        return {
          input: input,
          tokens: tokens,
          regex: regex,
          rawMatches: rawMatches,
          matches: matches,
          result: result,
          zone: zone,
          specificOffset: specificOffset
        };
      }
    }
    function parseFromTokens(locale, input, format) {
      var _explainFromTokens = explainFromTokens(locale, input, format),
          result = _explainFromTokens.result,
          zone = _explainFromTokens.zone,
          specificOffset = _explainFromTokens.specificOffset,
          invalidReason = _explainFromTokens.invalidReason;

      return [result, zone, specificOffset, invalidReason];
    }

    var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
        leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];

    function unitOutOfRange(unit, value) {
      return new Invalid("unit out of range", "you specified " + value + " (of type " + typeof value + ") as a " + unit + ", which is invalid");
    }

    function dayOfWeek(year, month, day) {
      var js = new Date(Date.UTC(year, month - 1, day)).getUTCDay();
      return js === 0 ? 7 : js;
    }

    function computeOrdinal(year, month, day) {
      return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
    }

    function uncomputeOrdinal(year, ordinal) {
      var table = isLeapYear(year) ? leapLadder : nonLeapLadder,
          month0 = table.findIndex(function (i) {
        return i < ordinal;
      }),
          day = ordinal - table[month0];
      return {
        month: month0 + 1,
        day: day
      };
    }
    /**
     * @private
     */


    function gregorianToWeek(gregObj) {
      var year = gregObj.year,
          month = gregObj.month,
          day = gregObj.day,
          ordinal = computeOrdinal(year, month, day),
          weekday = dayOfWeek(year, month, day);
      var weekNumber = Math.floor((ordinal - weekday + 10) / 7),
          weekYear;

      if (weekNumber < 1) {
        weekYear = year - 1;
        weekNumber = weeksInWeekYear(weekYear);
      } else if (weekNumber > weeksInWeekYear(year)) {
        weekYear = year + 1;
        weekNumber = 1;
      } else {
        weekYear = year;
      }

      return _extends$5({
        weekYear: weekYear,
        weekNumber: weekNumber,
        weekday: weekday
      }, timeObject(gregObj));
    }
    function weekToGregorian(weekData) {
      var weekYear = weekData.weekYear,
          weekNumber = weekData.weekNumber,
          weekday = weekData.weekday,
          weekdayOfJan4 = dayOfWeek(weekYear, 1, 4),
          yearInDays = daysInYear(weekYear);
      var ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 3,
          year;

      if (ordinal < 1) {
        year = weekYear - 1;
        ordinal += daysInYear(year);
      } else if (ordinal > yearInDays) {
        year = weekYear + 1;
        ordinal -= daysInYear(weekYear);
      } else {
        year = weekYear;
      }

      var _uncomputeOrdinal = uncomputeOrdinal(year, ordinal),
          month = _uncomputeOrdinal.month,
          day = _uncomputeOrdinal.day;

      return _extends$5({
        year: year,
        month: month,
        day: day
      }, timeObject(weekData));
    }
    function gregorianToOrdinal(gregData) {
      var year = gregData.year,
          month = gregData.month,
          day = gregData.day;
      var ordinal = computeOrdinal(year, month, day);
      return _extends$5({
        year: year,
        ordinal: ordinal
      }, timeObject(gregData));
    }
    function ordinalToGregorian(ordinalData) {
      var year = ordinalData.year,
          ordinal = ordinalData.ordinal;

      var _uncomputeOrdinal2 = uncomputeOrdinal(year, ordinal),
          month = _uncomputeOrdinal2.month,
          day = _uncomputeOrdinal2.day;

      return _extends$5({
        year: year,
        month: month,
        day: day
      }, timeObject(ordinalData));
    }
    function hasInvalidWeekData(obj) {
      var validYear = isInteger(obj.weekYear),
          validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear)),
          validWeekday = integerBetween(obj.weekday, 1, 7);

      if (!validYear) {
        return unitOutOfRange("weekYear", obj.weekYear);
      } else if (!validWeek) {
        return unitOutOfRange("week", obj.week);
      } else if (!validWeekday) {
        return unitOutOfRange("weekday", obj.weekday);
      } else return false;
    }
    function hasInvalidOrdinalData(obj) {
      var validYear = isInteger(obj.year),
          validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));

      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validOrdinal) {
        return unitOutOfRange("ordinal", obj.ordinal);
      } else return false;
    }
    function hasInvalidGregorianData(obj) {
      var validYear = isInteger(obj.year),
          validMonth = integerBetween(obj.month, 1, 12),
          validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));

      if (!validYear) {
        return unitOutOfRange("year", obj.year);
      } else if (!validMonth) {
        return unitOutOfRange("month", obj.month);
      } else if (!validDay) {
        return unitOutOfRange("day", obj.day);
      } else return false;
    }
    function hasInvalidTimeData(obj) {
      var hour = obj.hour,
          minute = obj.minute,
          second = obj.second,
          millisecond = obj.millisecond;
      var validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0,
          validMinute = integerBetween(minute, 0, 59),
          validSecond = integerBetween(second, 0, 59),
          validMillisecond = integerBetween(millisecond, 0, 999);

      if (!validHour) {
        return unitOutOfRange("hour", hour);
      } else if (!validMinute) {
        return unitOutOfRange("minute", minute);
      } else if (!validSecond) {
        return unitOutOfRange("second", second);
      } else if (!validMillisecond) {
        return unitOutOfRange("millisecond", millisecond);
      } else return false;
    }

    var INVALID = "Invalid DateTime";
    var MAX_DATE = 8.64e15;

    function unsupportedZone(zone) {
      return new Invalid("unsupported zone", "the zone \"" + zone.name + "\" is not supported");
    } // we cache week data on the DT object and this intermediates the cache


    function possiblyCachedWeekData(dt) {
      if (dt.weekData === null) {
        dt.weekData = gregorianToWeek(dt.c);
      }

      return dt.weekData;
    } // clone really means, "make a new object with these modifications". all "setters" really use this
    // to create a new object while only changing some of the properties


    function clone$2(inst, alts) {
      var current = {
        ts: inst.ts,
        zone: inst.zone,
        c: inst.c,
        o: inst.o,
        loc: inst.loc,
        invalid: inst.invalid
      };
      return new DateTime(_extends$5({}, current, alts, {
        old: current
      }));
    } // find the right offset a given local time. The o input is our guess, which determines which
    // offset we'll pick in ambiguous cases (e.g. there are two 3 AMs b/c Fallback DST)


    function fixOffset(localTS, o, tz) {
      // Our UTC time is just a guess because our offset is just a guess
      var utcGuess = localTS - o * 60 * 1000; // Test whether the zone matches the offset for this ts

      var o2 = tz.offset(utcGuess); // If so, offset didn't change and we're done

      if (o === o2) {
        return [utcGuess, o];
      } // If not, change the ts by the difference in the offset


      utcGuess -= (o2 - o) * 60 * 1000; // If that gives us the local time we want, we're done

      var o3 = tz.offset(utcGuess);

      if (o2 === o3) {
        return [utcGuess, o2];
      } // If it's different, we're in a hole time. The offset has changed, but the we don't adjust the time


      return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
    } // convert an epoch timestamp into a calendar object with the given offset


    function tsToObj(ts, offset) {
      ts += offset * 60 * 1000;
      var d = new Date(ts);
      return {
        year: d.getUTCFullYear(),
        month: d.getUTCMonth() + 1,
        day: d.getUTCDate(),
        hour: d.getUTCHours(),
        minute: d.getUTCMinutes(),
        second: d.getUTCSeconds(),
        millisecond: d.getUTCMilliseconds()
      };
    } // convert a calendar object to a epoch timestamp


    function objToTS(obj, offset, zone) {
      return fixOffset(objToLocalTS(obj), offset, zone);
    } // create a new DT instance by adding a duration, adjusting for DSTs


    function adjustTime(inst, dur) {
      var oPre = inst.o,
          year = inst.c.year + Math.trunc(dur.years),
          month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3,
          c = _extends$5({}, inst.c, {
        year: year,
        month: month,
        day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
      }),
          millisToAdd = Duration.fromObject({
        years: dur.years - Math.trunc(dur.years),
        quarters: dur.quarters - Math.trunc(dur.quarters),
        months: dur.months - Math.trunc(dur.months),
        weeks: dur.weeks - Math.trunc(dur.weeks),
        days: dur.days - Math.trunc(dur.days),
        hours: dur.hours,
        minutes: dur.minutes,
        seconds: dur.seconds,
        milliseconds: dur.milliseconds
      }).as("milliseconds"),
          localTS = objToLocalTS(c);

      var _fixOffset = fixOffset(localTS, oPre, inst.zone),
          ts = _fixOffset[0],
          o = _fixOffset[1];

      if (millisToAdd !== 0) {
        ts += millisToAdd; // that could have changed the offset by going over a DST, but we want to keep the ts the same

        o = inst.zone.offset(ts);
      }

      return {
        ts: ts,
        o: o
      };
    } // helper useful in turning the results of parsing into real dates
    // by handling the zone options


    function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
      var setZone = opts.setZone,
          zone = opts.zone;

      if (parsed && Object.keys(parsed).length !== 0) {
        var interpretationZone = parsedZone || zone,
            inst = DateTime.fromObject(parsed, _extends$5({}, opts, {
          zone: interpretationZone,
          specificOffset: specificOffset
        }));
        return setZone ? inst : inst.setZone(zone);
      } else {
        return DateTime.invalid(new Invalid("unparsable", "the input \"" + text + "\" can't be parsed as " + format));
      }
    } // if you want to output a technical format (e.g. RFC 2822), this helper
    // helps handle the details


    function toTechFormat(dt, format, allowZ) {
      if (allowZ === void 0) {
        allowZ = true;
      }

      return dt.isValid ? Formatter.create(Locale.create("en-US"), {
        allowZ: allowZ,
        forceSimple: true
      }).formatDateTimeFromString(dt, format) : null;
    }

    function _toISODate(o, extended) {
      var longFormat = o.c.year > 9999 || o.c.year < 0;
      var c = "";
      if (longFormat && o.c.year >= 0) c += "+";
      c += padStart(o.c.year, longFormat ? 6 : 4);

      if (extended) {
        c += "-";
        c += padStart(o.c.month);
        c += "-";
        c += padStart(o.c.day);
      } else {
        c += padStart(o.c.month);
        c += padStart(o.c.day);
      }

      return c;
    }

    function _toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset) {
      var c = padStart(o.c.hour);

      if (extended) {
        c += ":";
        c += padStart(o.c.minute);

        if (o.c.second !== 0 || !suppressSeconds) {
          c += ":";
        }
      } else {
        c += padStart(o.c.minute);
      }

      if (o.c.second !== 0 || !suppressSeconds) {
        c += padStart(o.c.second);

        if (o.c.millisecond !== 0 || !suppressMilliseconds) {
          c += ".";
          c += padStart(o.c.millisecond, 3);
        }
      }

      if (includeOffset) {
        if (o.isOffsetFixed && o.offset === 0) {
          c += "Z";
        } else if (o.o < 0) {
          c += "-";
          c += padStart(Math.trunc(-o.o / 60));
          c += ":";
          c += padStart(Math.trunc(-o.o % 60));
        } else {
          c += "+";
          c += padStart(Math.trunc(o.o / 60));
          c += ":";
          c += padStart(Math.trunc(o.o % 60));
        }
      }

      return c;
    } // defaults for unspecified units in the supported calendars


    var defaultUnitValues = {
      month: 1,
      day: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    },
        defaultWeekUnitValues = {
      weekNumber: 1,
      weekday: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    },
        defaultOrdinalUnitValues = {
      ordinal: 1,
      hour: 0,
      minute: 0,
      second: 0,
      millisecond: 0
    }; // Units in the supported calendars, sorted by bigness

    var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
        orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
        orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"]; // standardize case and plurality in units

    function normalizeUnit(unit) {
      var normalized = {
        year: "year",
        years: "year",
        month: "month",
        months: "month",
        day: "day",
        days: "day",
        hour: "hour",
        hours: "hour",
        minute: "minute",
        minutes: "minute",
        quarter: "quarter",
        quarters: "quarter",
        second: "second",
        seconds: "second",
        millisecond: "millisecond",
        milliseconds: "millisecond",
        weekday: "weekday",
        weekdays: "weekday",
        weeknumber: "weekNumber",
        weeksnumber: "weekNumber",
        weeknumbers: "weekNumber",
        weekyear: "weekYear",
        weekyears: "weekYear",
        ordinal: "ordinal"
      }[unit.toLowerCase()];
      if (!normalized) throw new InvalidUnitError(unit);
      return normalized;
    } // this is a dumbed down version of fromObject() that runs about 60% faster
    // but doesn't do any validation, makes a bunch of assumptions about what units
    // are present, and so on.
    // this is a dumbed down version of fromObject() that runs about 60% faster
    // but doesn't do any validation, makes a bunch of assumptions about what units
    // are present, and so on.


    function quickDT(obj, opts) {
      var zone = normalizeZone(opts.zone, Settings$1.defaultZone),
          loc = Locale.fromObject(opts),
          tsNow = Settings$1.now();
      var ts, o; // assume we have the higher-order units

      if (!isUndefined(obj.year)) {
        for (var _iterator = _createForOfIteratorHelperLoose(orderedUnits), _step; !(_step = _iterator()).done;) {
          var u = _step.value;

          if (isUndefined(obj[u])) {
            obj[u] = defaultUnitValues[u];
          }
        }

        var invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);

        if (invalid) {
          return DateTime.invalid(invalid);
        }

        var offsetProvis = zone.offset(tsNow);

        var _objToTS = objToTS(obj, offsetProvis, zone);

        ts = _objToTS[0];
        o = _objToTS[1];
      } else {
        ts = tsNow;
      }

      return new DateTime({
        ts: ts,
        zone: zone,
        loc: loc,
        o: o
      });
    }

    function diffRelative(start, end, opts) {
      var round = isUndefined(opts.round) ? true : opts.round,
          format = function format(c, unit) {
        c = roundTo(c, round || opts.calendary ? 0 : 2, true);
        var formatter = end.loc.clone(opts).relFormatter(opts);
        return formatter.format(c, unit);
      },
          differ = function differ(unit) {
        if (opts.calendary) {
          if (!end.hasSame(start, unit)) {
            return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
          } else return 0;
        } else {
          return end.diff(start, unit).get(unit);
        }
      };

      if (opts.unit) {
        return format(differ(opts.unit), opts.unit);
      }

      for (var _iterator2 = _createForOfIteratorHelperLoose(opts.units), _step2; !(_step2 = _iterator2()).done;) {
        var unit = _step2.value;
        var count = differ(unit);

        if (Math.abs(count) >= 1) {
          return format(count, unit);
        }
      }

      return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
    }

    function lastOpts(argList) {
      var opts = {},
          args;

      if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
        opts = argList[argList.length - 1];
        args = Array.from(argList).slice(0, argList.length - 1);
      } else {
        args = Array.from(argList);
      }

      return [opts, args];
    }
    /**
     * A DateTime is an immutable data structure representing a specific date and time and accompanying methods. It contains class and instance methods for creating, parsing, interrogating, transforming, and formatting them.
     *
     * A DateTime comprises of:
     * * A timestamp. Each DateTime instance refers to a specific millisecond of the Unix epoch.
     * * A time zone. Each instance is considered in the context of a specific zone (by default the local system's zone).
     * * Configuration properties that effect how output strings are formatted, such as `locale`, `numberingSystem`, and `outputCalendar`.
     *
     * Here is a brief overview of the most commonly used functionality it provides:
     *
     * * **Creation**: To create a DateTime from its components, use one of its factory class methods: {@link DateTime#local}, {@link DateTime#utc}, and (most flexibly) {@link DateTime#fromObject}. To create one from a standard string format, use {@link DateTime#fromISO}, {@link DateTime#fromHTTP}, and {@link DateTime#fromRFC2822}. To create one from a custom string format, use {@link DateTime#fromFormat}. To create one from a native JS date, use {@link DateTime#fromJSDate}.
     * * **Gregorian calendar and time**: To examine the Gregorian properties of a DateTime individually (i.e as opposed to collectively through {@link DateTime#toObject}), use the {@link DateTime#year}, {@link DateTime#month},
     * {@link DateTime#day}, {@link DateTime#hour}, {@link DateTime#minute}, {@link DateTime#second}, {@link DateTime#millisecond} accessors.
     * * **Week calendar**: For ISO week calendar attributes, see the {@link DateTime#weekYear}, {@link DateTime#weekNumber}, and {@link DateTime#weekday} accessors.
     * * **Configuration** See the {@link DateTime#locale} and {@link DateTime#numberingSystem} accessors.
     * * **Transformation**: To transform the DateTime into other DateTimes, use {@link DateTime#set}, {@link DateTime#reconfigure}, {@link DateTime#setZone}, {@link DateTime#setLocale}, {@link DateTime.plus}, {@link DateTime#minus}, {@link DateTime#endOf}, {@link DateTime#startOf}, {@link DateTime#toUTC}, and {@link DateTime#toLocal}.
     * * **Output**: To convert the DateTime to other representations, use the {@link DateTime#toRelative}, {@link DateTime#toRelativeCalendar}, {@link DateTime#toJSON}, {@link DateTime#toISO}, {@link DateTime#toHTTP}, {@link DateTime#toObject}, {@link DateTime#toRFC2822}, {@link DateTime#toString}, {@link DateTime#toLocaleString}, {@link DateTime#toFormat}, {@link DateTime#toMillis} and {@link DateTime#toJSDate}.
     *
     * There's plenty others documented below. In addition, for more information on subtler topics like internationalization, time zones, alternative calendars, validity, and so on, see the external documentation.
     */


    var DateTime = /*#__PURE__*/function () {
      /**
       * @access private
       */
      function DateTime(config) {
        var zone = config.zone || Settings$1.defaultZone;
        var invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
        /**
         * @access private
         */

        this.ts = isUndefined(config.ts) ? Settings$1.now() : config.ts;
        var c = null,
            o = null;

        if (!invalid) {
          var unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);

          if (unchanged) {
            var _ref = [config.old.c, config.old.o];
            c = _ref[0];
            o = _ref[1];
          } else {
            var ot = zone.offset(this.ts);
            c = tsToObj(this.ts, ot);
            invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
            c = invalid ? null : c;
            o = invalid ? null : ot;
          }
        }
        /**
         * @access private
         */


        this._zone = zone;
        /**
         * @access private
         */

        this.loc = config.loc || Locale.create();
        /**
         * @access private
         */

        this.invalid = invalid;
        /**
         * @access private
         */

        this.weekData = null;
        /**
         * @access private
         */

        this.c = c;
        /**
         * @access private
         */

        this.o = o;
        /**
         * @access private
         */

        this.isLuxonDateTime = true;
      } // CONSTRUCT

      /**
       * Create a DateTime for the current instant, in the system's time zone.
       *
       * Use Settings to override these default values if needed.
       * @example DateTime.now().toISO() //~> now in the ISO format
       * @return {DateTime}
       */


      DateTime.now = function now() {
        return new DateTime({});
      }
      /**
       * Create a local DateTime
       * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month, 1-indexed
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @example DateTime.local()                                  //~> now
       * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
       * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
       * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
       * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
       * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
       * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
       * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
       * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
       * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
       * @return {DateTime}
       */
      ;

      DateTime.local = function local() {
        var _lastOpts = lastOpts(arguments),
            opts = _lastOpts[0],
            args = _lastOpts[1],
            year = args[0],
            month = args[1],
            day = args[2],
            hour = args[3],
            minute = args[4],
            second = args[5],
            millisecond = args[6];

        return quickDT({
          year: year,
          month: month,
          day: day,
          hour: hour,
          minute: minute,
          second: second,
          millisecond: millisecond
        }, opts);
      }
      /**
       * Create a DateTime in UTC
       * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
       * @param {number} [month=1] - The month, 1-indexed
       * @param {number} [day=1] - The day of the month
       * @param {number} [hour=0] - The hour of the day, in 24-hour time
       * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
       * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
       * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
       * @param {Object} options - configuration options for the DateTime
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.utc()                                              //~> now
       * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
       * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
       * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
       * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
       * @return {DateTime}
       */
      ;

      DateTime.utc = function utc() {
        var _lastOpts2 = lastOpts(arguments),
            opts = _lastOpts2[0],
            args = _lastOpts2[1],
            year = args[0],
            month = args[1],
            day = args[2],
            hour = args[3],
            minute = args[4],
            second = args[5],
            millisecond = args[6];

        opts.zone = FixedOffsetZone.utcInstance;
        return quickDT({
          year: year,
          month: month,
          day: day,
          hour: hour,
          minute: minute,
          second: second,
          millisecond: millisecond
        }, opts);
      }
      /**
       * Create a DateTime from a JavaScript Date object. Uses the default zone.
       * @param {Date} date - a JavaScript Date object
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @return {DateTime}
       */
      ;

      DateTime.fromJSDate = function fromJSDate(date, options) {
        if (options === void 0) {
          options = {};
        }

        var ts = isDate$1(date) ? date.valueOf() : NaN;

        if (Number.isNaN(ts)) {
          return DateTime.invalid("invalid input");
        }

        var zoneToUse = normalizeZone(options.zone, Settings$1.defaultZone);

        if (!zoneToUse.isValid) {
          return DateTime.invalid(unsupportedZone(zoneToUse));
        }

        return new DateTime({
          ts: ts,
          zone: zoneToUse,
          loc: Locale.fromObject(options)
        });
      }
      /**
       * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} milliseconds - a number of milliseconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      ;

      DateTime.fromMillis = function fromMillis(milliseconds, options) {
        if (options === void 0) {
          options = {};
        }

        if (!isNumber(milliseconds)) {
          throw new InvalidArgumentError("fromMillis requires a numerical input, but received a " + typeof milliseconds + " with value " + milliseconds);
        } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
          // this isn't perfect because because we can still end up out of range because of additional shifting, but it's a start
          return DateTime.invalid("Timestamp out of range");
        } else {
          return new DateTime({
            ts: milliseconds,
            zone: normalizeZone(options.zone, Settings$1.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
       * @param {number} seconds - a number of seconds since 1970 UTC
       * @param {Object} options - configuration options for the DateTime
       * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
       * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
       * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @return {DateTime}
       */
      ;

      DateTime.fromSeconds = function fromSeconds(seconds, options) {
        if (options === void 0) {
          options = {};
        }

        if (!isNumber(seconds)) {
          throw new InvalidArgumentError("fromSeconds requires a numerical input");
        } else {
          return new DateTime({
            ts: seconds * 1000,
            zone: normalizeZone(options.zone, Settings$1.defaultZone),
            loc: Locale.fromObject(options)
          });
        }
      }
      /**
       * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
       * @param {Object} obj - the object to create the DateTime from
       * @param {number} obj.year - a year, such as 1987
       * @param {number} obj.month - a month, 1-12
       * @param {number} obj.day - a day of the month, 1-31, depending on the month
       * @param {number} obj.ordinal - day of the year, 1-365 or 366
       * @param {number} obj.weekYear - an ISO week year
       * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
       * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
       * @param {number} obj.hour - hour of the day, 0-23
       * @param {number} obj.minute - minute of the hour, 0-59
       * @param {number} obj.second - second of the minute, 0-59
       * @param {number} obj.millisecond - millisecond of the second, 0-999
       * @param {Object} opts - options for creating this DateTime
       * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
       * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
       * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
       * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
       * @return {DateTime}
       */
      ;

      DateTime.fromObject = function fromObject(obj, opts) {
        if (opts === void 0) {
          opts = {};
        }

        obj = obj || {};
        var zoneToUse = normalizeZone(opts.zone, Settings$1.defaultZone);

        if (!zoneToUse.isValid) {
          return DateTime.invalid(unsupportedZone(zoneToUse));
        }

        var tsNow = Settings$1.now(),
            offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow),
            normalized = normalizeObject(obj, normalizeUnit),
            containsOrdinal = !isUndefined(normalized.ordinal),
            containsGregorYear = !isUndefined(normalized.year),
            containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
            containsGregor = containsGregorYear || containsGregorMD,
            definiteWeekDef = normalized.weekYear || normalized.weekNumber,
            loc = Locale.fromObject(opts); // cases:
        // just a weekday -> this week's instance of that weekday, no worries
        // (gregorian data or ordinal) + (weekYear or weekNumber) -> error
        // (gregorian month or day) + ordinal -> error
        // otherwise just use weeks or ordinals or gregorian, depending on what's specified

        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }

        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }

        var useWeekData = definiteWeekDef || normalized.weekday && !containsGregor; // configure ourselves to deal with gregorian dates or week stuff

        var units,
            defaultValues,
            objNow = tsToObj(tsNow, offsetProvis);

        if (useWeekData) {
          units = orderedWeekUnits;
          defaultValues = defaultWeekUnitValues;
          objNow = gregorianToWeek(objNow);
        } else if (containsOrdinal) {
          units = orderedOrdinalUnits;
          defaultValues = defaultOrdinalUnitValues;
          objNow = gregorianToOrdinal(objNow);
        } else {
          units = orderedUnits;
          defaultValues = defaultUnitValues;
        } // set default values for missing stuff


        var foundFirst = false;

        for (var _iterator3 = _createForOfIteratorHelperLoose(units), _step3; !(_step3 = _iterator3()).done;) {
          var u = _step3.value;
          var v = normalized[u];

          if (!isUndefined(v)) {
            foundFirst = true;
          } else if (foundFirst) {
            normalized[u] = defaultValues[u];
          } else {
            normalized[u] = objNow[u];
          }
        } // make sure the values we have are in range


        var higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized),
            invalid = higherOrderInvalid || hasInvalidTimeData(normalized);

        if (invalid) {
          return DateTime.invalid(invalid);
        } // compute the actual time


        var gregorian = useWeekData ? weekToGregorian(normalized) : containsOrdinal ? ordinalToGregorian(normalized) : normalized,
            _objToTS2 = objToTS(gregorian, offsetProvis, zoneToUse),
            tsFinal = _objToTS2[0],
            offsetFinal = _objToTS2[1],
            inst = new DateTime({
          ts: tsFinal,
          zone: zoneToUse,
          o: offsetFinal,
          loc: loc
        }); // gregorian data + weekday serves only to validate


        if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
          return DateTime.invalid("mismatched weekday", "you can't specify both a weekday of " + normalized.weekday + " and a date of " + inst.toISO());
        }

        return inst;
      }
      /**
       * Create a DateTime from an ISO 8601 string
       * @param {string} text - the ISO string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
       * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromISO('2016-05-25T09:08:34.123')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
       * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
       * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
       * @example DateTime.fromISO('2016-W05-4')
       * @return {DateTime}
       */
      ;

      DateTime.fromISO = function fromISO(text, opts) {
        if (opts === void 0) {
          opts = {};
        }

        var _parseISODate = parseISODate(text),
            vals = _parseISODate[0],
            parsedZone = _parseISODate[1];

        return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
      }
      /**
       * Create a DateTime from an RFC 2822 string
       * @param {string} text - the RFC 2822 string
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
       * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
       * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
       * @return {DateTime}
       */
      ;

      DateTime.fromRFC2822 = function fromRFC2822(text, opts) {
        if (opts === void 0) {
          opts = {};
        }

        var _parseRFC2822Date = parseRFC2822Date(text),
            vals = _parseRFC2822Date[0],
            parsedZone = _parseRFC2822Date[1];

        return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
      }
      /**
       * Create a DateTime from an HTTP header date
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @param {string} text - the HTTP header date
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
       * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
       * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
       * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
       * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
       * @return {DateTime}
       */
      ;

      DateTime.fromHTTP = function fromHTTP(text, opts) {
        if (opts === void 0) {
          opts = {};
        }

        var _parseHTTPDate = parseHTTPDate(text),
            vals = _parseHTTPDate[0],
            parsedZone = _parseHTTPDate[1];

        return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
      }
      /**
       * Create a DateTime from an input string and format string.
       * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @return {DateTime}
       */
      ;

      DateTime.fromFormat = function fromFormat(text, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }

        if (isUndefined(text) || isUndefined(fmt)) {
          throw new InvalidArgumentError("fromFormat requires an input string and a format");
        }

        var _opts = opts,
            _opts$locale = _opts.locale,
            locale = _opts$locale === void 0 ? null : _opts$locale,
            _opts$numberingSystem = _opts.numberingSystem,
            numberingSystem = _opts$numberingSystem === void 0 ? null : _opts$numberingSystem,
            localeToUse = Locale.fromOpts({
          locale: locale,
          numberingSystem: numberingSystem,
          defaultToEN: true
        }),
            _parseFromTokens = parseFromTokens(localeToUse, text, fmt),
            vals = _parseFromTokens[0],
            parsedZone = _parseFromTokens[1],
            specificOffset = _parseFromTokens[2],
            invalid = _parseFromTokens[3];

        if (invalid) {
          return DateTime.invalid(invalid);
        } else {
          return parseDataToDateTime(vals, parsedZone, opts, "format " + fmt, text, specificOffset);
        }
      }
      /**
       * @deprecated use fromFormat instead
       */
      ;

      DateTime.fromString = function fromString(text, fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }

        return DateTime.fromFormat(text, fmt, opts);
      }
      /**
       * Create a DateTime from a SQL date, time, or datetime
       * Defaults to en-US if no locale has been specified, regardless of the system's locale
       * @param {string} text - the string to parse
       * @param {Object} opts - options to affect the creation
       * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
       * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
       * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
       * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
       * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
       * @example DateTime.fromSQL('2017-05-15')
       * @example DateTime.fromSQL('2017-05-15 09:12:34')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
       * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
       * @example DateTime.fromSQL('09:12:34.342')
       * @return {DateTime}
       */
      ;

      DateTime.fromSQL = function fromSQL(text, opts) {
        if (opts === void 0) {
          opts = {};
        }

        var _parseSQL = parseSQL(text),
            vals = _parseSQL[0],
            parsedZone = _parseSQL[1];

        return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
      }
      /**
       * Create an invalid DateTime.
       * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent
       * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
       * @return {DateTime}
       */
      ;

      DateTime.invalid = function invalid(reason, explanation) {
        if (explanation === void 0) {
          explanation = null;
        }

        if (!reason) {
          throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
        }

        var invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);

        if (Settings$1.throwOnInvalid) {
          throw new InvalidDateTimeError(invalid);
        } else {
          return new DateTime({
            invalid: invalid
          });
        }
      }
      /**
       * Check if an object is a DateTime. Works across context boundaries
       * @param {object} o
       * @return {boolean}
       */
      ;

      DateTime.isDateTime = function isDateTime(o) {
        return o && o.isLuxonDateTime || false;
      } // INFO

      /**
       * Get the value of unit.
       * @param {string} unit - a unit such as 'minute' or 'day'
       * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
       * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
       * @return {number}
       */
      ;

      var _proto = DateTime.prototype;

      _proto.get = function get(unit) {
        return this[unit];
      }
      /**
       * Returns whether the DateTime is valid. Invalid DateTimes occur when:
       * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
       * * The DateTime was created by an operation on another invalid date
       * @type {boolean}
       */
      ;

      /**
       * Returns the resolved Intl options for this DateTime.
       * This is useful in understanding the behavior of formatting methods
       * @param {Object} opts - the same options as toLocaleString
       * @return {Object}
       */
      _proto.resolvedLocaleOptions = function resolvedLocaleOptions(opts) {
        if (opts === void 0) {
          opts = {};
        }

        var _Formatter$create$res = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this),
            locale = _Formatter$create$res.locale,
            numberingSystem = _Formatter$create$res.numberingSystem,
            calendar = _Formatter$create$res.calendar;

        return {
          locale: locale,
          numberingSystem: numberingSystem,
          outputCalendar: calendar
        };
      } // TRANSFORM

      /**
       * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
       *
       * Equivalent to {@link DateTime#setZone}('utc')
       * @param {number} [offset=0] - optionally, an offset from UTC in minutes
       * @param {Object} [opts={}] - options to pass to `setZone()`
       * @return {DateTime}
       */
      ;

      _proto.toUTC = function toUTC(offset, opts) {
        if (offset === void 0) {
          offset = 0;
        }

        if (opts === void 0) {
          opts = {};
        }

        return this.setZone(FixedOffsetZone.instance(offset), opts);
      }
      /**
       * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
       *
       * Equivalent to `setZone('local')`
       * @return {DateTime}
       */
      ;

      _proto.toLocal = function toLocal() {
        return this.setZone(Settings$1.defaultZone);
      }
      /**
       * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
       *
       * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
       * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
       * @param {Object} opts - options
       * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
       * @return {DateTime}
       */
      ;

      _proto.setZone = function setZone(zone, _temp) {
        var _ref2 = _temp === void 0 ? {} : _temp,
            _ref2$keepLocalTime = _ref2.keepLocalTime,
            keepLocalTime = _ref2$keepLocalTime === void 0 ? false : _ref2$keepLocalTime,
            _ref2$keepCalendarTim = _ref2.keepCalendarTime,
            keepCalendarTime = _ref2$keepCalendarTim === void 0 ? false : _ref2$keepCalendarTim;

        zone = normalizeZone(zone, Settings$1.defaultZone);

        if (zone.equals(this.zone)) {
          return this;
        } else if (!zone.isValid) {
          return DateTime.invalid(unsupportedZone(zone));
        } else {
          var newTS = this.ts;

          if (keepLocalTime || keepCalendarTime) {
            var offsetGuess = zone.offset(this.ts);
            var asObj = this.toObject();

            var _objToTS3 = objToTS(asObj, offsetGuess, zone);

            newTS = _objToTS3[0];
          }

          return clone$2(this, {
            ts: newTS,
            zone: zone
          });
        }
      }
      /**
       * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
       * @param {Object} properties - the properties to set
       * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
       * @return {DateTime}
       */
      ;

      _proto.reconfigure = function reconfigure(_temp2) {
        var _ref3 = _temp2 === void 0 ? {} : _temp2,
            locale = _ref3.locale,
            numberingSystem = _ref3.numberingSystem,
            outputCalendar = _ref3.outputCalendar;

        var loc = this.loc.clone({
          locale: locale,
          numberingSystem: numberingSystem,
          outputCalendar: outputCalendar
        });
        return clone$2(this, {
          loc: loc
        });
      }
      /**
       * "Set" the locale. Returns a newly-constructed DateTime.
       * Just a convenient alias for reconfigure({ locale })
       * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
       * @return {DateTime}
       */
      ;

      _proto.setLocale = function setLocale(locale) {
        return this.reconfigure({
          locale: locale
        });
      }
      /**
       * "Set" the values of specified units. Returns a newly-constructed DateTime.
       * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
       * @param {Object} values - a mapping of units to numbers
       * @example dt.set({ year: 2017 })
       * @example dt.set({ hour: 8, minute: 30 })
       * @example dt.set({ weekday: 5 })
       * @example dt.set({ year: 2005, ordinal: 234 })
       * @return {DateTime}
       */
      ;

      _proto.set = function set(values) {
        if (!this.isValid) return this;
        var normalized = normalizeObject(values, normalizeUnit),
            settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday),
            containsOrdinal = !isUndefined(normalized.ordinal),
            containsGregorYear = !isUndefined(normalized.year),
            containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day),
            containsGregor = containsGregorYear || containsGregorMD,
            definiteWeekDef = normalized.weekYear || normalized.weekNumber;

        if ((containsGregor || containsOrdinal) && definiteWeekDef) {
          throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
        }

        if (containsGregorMD && containsOrdinal) {
          throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
        }

        var mixed;

        if (settingWeekStuff) {
          mixed = weekToGregorian(_extends$5({}, gregorianToWeek(this.c), normalized));
        } else if (!isUndefined(normalized.ordinal)) {
          mixed = ordinalToGregorian(_extends$5({}, gregorianToOrdinal(this.c), normalized));
        } else {
          mixed = _extends$5({}, this.toObject(), normalized); // if we didn't set the day but we ended up on an overflow date,
          // use the last day of the right month

          if (isUndefined(normalized.day)) {
            mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
          }
        }

        var _objToTS4 = objToTS(mixed, this.o, this.zone),
            ts = _objToTS4[0],
            o = _objToTS4[1];

        return clone$2(this, {
          ts: ts,
          o: o
        });
      }
      /**
       * Add a period of time to this DateTime and return the resulting DateTime
       *
       * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
       * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       * @example DateTime.now().plus(123) //~> in 123 milliseconds
       * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
       * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
       * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
       * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
       * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
       * @return {DateTime}
       */
      ;

      _proto.plus = function plus(duration) {
        if (!this.isValid) return this;
        var dur = Duration.fromDurationLike(duration);
        return clone$2(this, adjustTime(this, dur));
      }
      /**
       * Subtract a period of time to this DateTime and return the resulting DateTime
       * See {@link DateTime#plus}
       * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
       @return {DateTime}
       */
      ;

      _proto.minus = function minus(duration) {
        if (!this.isValid) return this;
        var dur = Duration.fromDurationLike(duration).negate();
        return clone$2(this, adjustTime(this, dur));
      }
      /**
       * "Set" this DateTime to the beginning of a unit of time.
       * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
       * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
       * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
       * @return {DateTime}
       */
      ;

      _proto.startOf = function startOf(unit) {
        if (!this.isValid) return this;
        var o = {},
            normalizedUnit = Duration.normalizeUnit(unit);

        switch (normalizedUnit) {
          case "years":
            o.month = 1;
          // falls through

          case "quarters":
          case "months":
            o.day = 1;
          // falls through

          case "weeks":
          case "days":
            o.hour = 0;
          // falls through

          case "hours":
            o.minute = 0;
          // falls through

          case "minutes":
            o.second = 0;
          // falls through

          case "seconds":
            o.millisecond = 0;
            break;
          // no default, invalid units throw in normalizeUnit()
        }

        if (normalizedUnit === "weeks") {
          o.weekday = 1;
        }

        if (normalizedUnit === "quarters") {
          var q = Math.ceil(this.month / 3);
          o.month = (q - 1) * 3 + 1;
        }

        return this.set(o);
      }
      /**
       * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
       * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
       * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
       * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
       * @return {DateTime}
       */
      ;

      _proto.endOf = function endOf(unit) {
        var _this$plus;

        return this.isValid ? this.plus((_this$plus = {}, _this$plus[unit] = 1, _this$plus)).startOf(unit).minus(1) : this;
      } // OUTPUT

      /**
       * Returns a string representation of this DateTime formatted according to the specified format string.
       * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
       * Defaults to en-US if no locale has been specified, regardless of the system's locale.
       * @param {string} fmt - the format string
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
       * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
       * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
       * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
       * @return {string}
       */
      ;

      _proto.toFormat = function toFormat(fmt, opts) {
        if (opts === void 0) {
          opts = {};
        }

        return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
      }
      /**
       * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
       * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
       * of the DateTime in the assigned locale.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
       * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
       * @param {Object} opts - opts to override the configuration options on this DateTime
       * @example DateTime.now().toLocaleString(); //=> 4/20/2017
       * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString({ locale: 'en-gb' }); //=> '20/04/2017'
       * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
       * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
       * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
       * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
       * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
       * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
       * @return {string}
       */
      ;

      _proto.toLocaleString = function toLocaleString(formatOpts, opts) {
        if (formatOpts === void 0) {
          formatOpts = DATE_SHORT;
        }

        if (opts === void 0) {
          opts = {};
        }

        return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
      }
      /**
       * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
       * Defaults to the system's locale if no locale has been specified
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
       * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
       * @example DateTime.now().toLocaleParts(); //=> [
       *                                   //=>   { type: 'day', value: '25' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'month', value: '05' },
       *                                   //=>   { type: 'literal', value: '/' },
       *                                   //=>   { type: 'year', value: '1982' }
       *                                   //=> ]
       */
      ;

      _proto.toLocaleParts = function toLocaleParts(opts) {
        if (opts === void 0) {
          opts = {};
        }

        return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
       * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
       * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
       * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
       * @return {string}
       */
      ;

      _proto.toISO = function toISO(_temp3) {
        var _ref4 = _temp3 === void 0 ? {} : _temp3,
            _ref4$format = _ref4.format,
            format = _ref4$format === void 0 ? "extended" : _ref4$format,
            _ref4$suppressSeconds = _ref4.suppressSeconds,
            suppressSeconds = _ref4$suppressSeconds === void 0 ? false : _ref4$suppressSeconds,
            _ref4$suppressMillise = _ref4.suppressMilliseconds,
            suppressMilliseconds = _ref4$suppressMillise === void 0 ? false : _ref4$suppressMillise,
            _ref4$includeOffset = _ref4.includeOffset,
            includeOffset = _ref4$includeOffset === void 0 ? true : _ref4$includeOffset;

        if (!this.isValid) {
          return null;
        }

        var ext = format === "extended";

        var c = _toISODate(this, ext);

        c += "T";
        c += _toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset);
        return c;
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's date component
       * @param {Object} opts - options
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
       * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
       * @return {string}
       */
      ;

      _proto.toISODate = function toISODate(_temp4) {
        var _ref5 = _temp4 === void 0 ? {} : _temp4,
            _ref5$format = _ref5.format,
            format = _ref5$format === void 0 ? "extended" : _ref5$format;

        if (!this.isValid) {
          return null;
        }

        return _toISODate(this, format === "extended");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's week date
       * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
       * @return {string}
       */
      ;

      _proto.toISOWeekDate = function toISOWeekDate() {
        return toTechFormat(this, "kkkk-'W'WW-c");
      }
      /**
       * Returns an ISO 8601-compliant string representation of this DateTime's time component
       * @param {Object} opts - options
       * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
       * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
       * @param {string} [opts.format='extended'] - choose between the basic and extended format
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
       * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
       * @return {string}
       */
      ;

      _proto.toISOTime = function toISOTime(_temp5) {
        var _ref6 = _temp5 === void 0 ? {} : _temp5,
            _ref6$suppressMillise = _ref6.suppressMilliseconds,
            suppressMilliseconds = _ref6$suppressMillise === void 0 ? false : _ref6$suppressMillise,
            _ref6$suppressSeconds = _ref6.suppressSeconds,
            suppressSeconds = _ref6$suppressSeconds === void 0 ? false : _ref6$suppressSeconds,
            _ref6$includeOffset = _ref6.includeOffset,
            includeOffset = _ref6$includeOffset === void 0 ? true : _ref6$includeOffset,
            _ref6$includePrefix = _ref6.includePrefix,
            includePrefix = _ref6$includePrefix === void 0 ? false : _ref6$includePrefix,
            _ref6$format = _ref6.format,
            format = _ref6$format === void 0 ? "extended" : _ref6$format;

        if (!this.isValid) {
          return null;
        }

        var c = includePrefix ? "T" : "";
        return c + _toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset);
      }
      /**
       * Returns an RFC 2822-compatible string representation of this DateTime
       * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
       * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
       * @return {string}
       */
      ;

      _proto.toRFC2822 = function toRFC2822() {
        return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
       * Specifically, the string conforms to RFC 1123.
       * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
       * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
       * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
       * @return {string}
       */
      ;

      _proto.toHTTP = function toHTTP() {
        return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Date
       * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
       * @return {string}
       */
      ;

      _proto.toSQLDate = function toSQLDate() {
        if (!this.isValid) {
          return null;
        }

        return _toISODate(this, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL Time
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @example DateTime.utc().toSQL() //=> '05:15:16.345'
       * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
       * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
       * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
       * @return {string}
       */
      ;

      _proto.toSQLTime = function toSQLTime(_temp6) {
        var _ref7 = _temp6 === void 0 ? {} : _temp6,
            _ref7$includeOffset = _ref7.includeOffset,
            includeOffset = _ref7$includeOffset === void 0 ? true : _ref7$includeOffset,
            _ref7$includeZone = _ref7.includeZone,
            includeZone = _ref7$includeZone === void 0 ? false : _ref7$includeZone;

        var fmt = "HH:mm:ss.SSS";

        if (includeZone || includeOffset) {
          fmt += " ";

          if (includeZone) {
            fmt += "z";
          } else if (includeOffset) {
            fmt += "ZZ";
          }
        }

        return toTechFormat(this, fmt, true);
      }
      /**
       * Returns a string representation of this DateTime appropriate for use in SQL DateTime
       * @param {Object} opts - options
       * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
       * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
       * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
       * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
       * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
       * @return {string}
       */
      ;

      _proto.toSQL = function toSQL(opts) {
        if (opts === void 0) {
          opts = {};
        }

        if (!this.isValid) {
          return null;
        }

        return this.toSQLDate() + " " + this.toSQLTime(opts);
      }
      /**
       * Returns a string representation of this DateTime appropriate for debugging
       * @return {string}
       */
      ;

      _proto.toString = function toString() {
        return this.isValid ? this.toISO() : INVALID;
      }
      /**
       * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
       * @return {number}
       */
      ;

      _proto.valueOf = function valueOf() {
        return this.toMillis();
      }
      /**
       * Returns the epoch milliseconds of this DateTime.
       * @return {number}
       */
      ;

      _proto.toMillis = function toMillis() {
        return this.isValid ? this.ts : NaN;
      }
      /**
       * Returns the epoch seconds of this DateTime.
       * @return {number}
       */
      ;

      _proto.toSeconds = function toSeconds() {
        return this.isValid ? this.ts / 1000 : NaN;
      }
      /**
       * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
       * @return {string}
       */
      ;

      _proto.toJSON = function toJSON() {
        return this.toISO();
      }
      /**
       * Returns a BSON serializable equivalent to this DateTime.
       * @return {Date}
       */
      ;

      _proto.toBSON = function toBSON() {
        return this.toJSDate();
      }
      /**
       * Returns a JavaScript object with this DateTime's year, month, day, and so on.
       * @param opts - options for generating the object
       * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
       * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
       * @return {Object}
       */
      ;

      _proto.toObject = function toObject(opts) {
        if (opts === void 0) {
          opts = {};
        }

        if (!this.isValid) return {};

        var base = _extends$5({}, this.c);

        if (opts.includeConfig) {
          base.outputCalendar = this.outputCalendar;
          base.numberingSystem = this.loc.numberingSystem;
          base.locale = this.loc.locale;
        }

        return base;
      }
      /**
       * Returns a JavaScript Date equivalent to this DateTime.
       * @return {Date}
       */
      ;

      _proto.toJSDate = function toJSDate() {
        return new Date(this.isValid ? this.ts : NaN);
      } // COMPARE

      /**
       * Return the difference between two DateTimes as a Duration.
       * @param {DateTime} otherDateTime - the DateTime to compare this one to
       * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @example
       * var i1 = DateTime.fromISO('1982-05-25T09:45'),
       *     i2 = DateTime.fromISO('1983-10-14T10:30');
       * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
       * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
       * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
       * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
       * @return {Duration}
       */
      ;

      _proto.diff = function diff(otherDateTime, unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }

        if (opts === void 0) {
          opts = {};
        }

        if (!this.isValid || !otherDateTime.isValid) {
          return Duration.invalid("created by diffing an invalid DateTime");
        }

        var durOpts = _extends$5({
          locale: this.locale,
          numberingSystem: this.numberingSystem
        }, opts);

        var units = maybeArray(unit).map(Duration.normalizeUnit),
            otherIsLater = otherDateTime.valueOf() > this.valueOf(),
            earlier = otherIsLater ? this : otherDateTime,
            later = otherIsLater ? otherDateTime : this,
            diffed = _diff(earlier, later, units, durOpts);

        return otherIsLater ? diffed.negate() : diffed;
      }
      /**
       * Return the difference between this DateTime and right now.
       * See {@link DateTime#diff}
       * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
       * @param {Object} opts - options that affect the creation of the Duration
       * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
       * @return {Duration}
       */
      ;

      _proto.diffNow = function diffNow(unit, opts) {
        if (unit === void 0) {
          unit = "milliseconds";
        }

        if (opts === void 0) {
          opts = {};
        }

        return this.diff(DateTime.now(), unit, opts);
      }
      /**
       * Return an Interval spanning between this DateTime and another DateTime
       * @param {DateTime} otherDateTime - the other end point of the Interval
       * @return {Interval}
       */
      ;

      _proto.until = function until(otherDateTime) {
        return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
      }
      /**
       * Return whether this DateTime is in the same unit of time as another DateTime.
       * Higher-order units must also be identical for this function to return `true`.
       * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
       * @param {DateTime} otherDateTime - the other DateTime
       * @param {string} unit - the unit of time to check sameness on
       * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
       * @return {boolean}
       */
      ;

      _proto.hasSame = function hasSame(otherDateTime, unit) {
        if (!this.isValid) return false;
        var inputMs = otherDateTime.valueOf();
        var adjustedToZone = this.setZone(otherDateTime.zone, {
          keepLocalTime: true
        });
        return adjustedToZone.startOf(unit) <= inputMs && inputMs <= adjustedToZone.endOf(unit);
      }
      /**
       * Equality check
       * Two DateTimes are equal iff they represent the same millisecond, have the same zone and location, and are both valid.
       * To compare just the millisecond values, use `+dt1 === +dt2`.
       * @param {DateTime} other - the other DateTime
       * @return {boolean}
       */
      ;

      _proto.equals = function equals(other) {
        return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
      }
      /**
       * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
       * platform supports Intl.RelativeTimeFormat. Rounds down by default.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
       * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
       * @param {boolean} [options.round=true] - whether to round the numbers in the output.
       * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
       * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 da"
       * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
       * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
       * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
       * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
       */
      ;

      _proto.toRelative = function toRelative(options) {
        if (options === void 0) {
          options = {};
        }

        if (!this.isValid) return null;
        var base = options.base || DateTime.fromObject({}, {
          zone: this.zone
        }),
            padding = options.padding ? this < base ? -options.padding : options.padding : 0;
        var units = ["years", "months", "days", "hours", "minutes", "seconds"];
        var unit = options.unit;

        if (Array.isArray(options.unit)) {
          units = options.unit;
          unit = undefined;
        }

        return diffRelative(base, this.plus(padding), _extends$5({}, options, {
          numeric: "always",
          units: units,
          unit: unit
        }));
      }
      /**
       * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
       * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
       * @param {Object} options - options that affect the output
       * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
       * @param {string} options.locale - override the locale of this DateTime
       * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
       * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
       * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""maana"
       * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
       * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
       */
      ;

      _proto.toRelativeCalendar = function toRelativeCalendar(options) {
        if (options === void 0) {
          options = {};
        }

        if (!this.isValid) return null;
        return diffRelative(options.base || DateTime.fromObject({}, {
          zone: this.zone
        }), this, _extends$5({}, options, {
          numeric: "auto",
          units: ["years", "months", "days"],
          calendary: true
        }));
      }
      /**
       * Return the min of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
       * @return {DateTime} the min DateTime, or undefined if called with no argument
       */
      ;

      DateTime.min = function min() {
        for (var _len = arguments.length, dateTimes = new Array(_len), _key = 0; _key < _len; _key++) {
          dateTimes[_key] = arguments[_key];
        }

        if (!dateTimes.every(DateTime.isDateTime)) {
          throw new InvalidArgumentError("min requires all arguments be DateTimes");
        }

        return bestBy(dateTimes, function (i) {
          return i.valueOf();
        }, Math.min);
      }
      /**
       * Return the max of several date times
       * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
       * @return {DateTime} the max DateTime, or undefined if called with no argument
       */
      ;

      DateTime.max = function max() {
        for (var _len2 = arguments.length, dateTimes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          dateTimes[_key2] = arguments[_key2];
        }

        if (!dateTimes.every(DateTime.isDateTime)) {
          throw new InvalidArgumentError("max requires all arguments be DateTimes");
        }

        return bestBy(dateTimes, function (i) {
          return i.valueOf();
        }, Math.max);
      } // MISC

      /**
       * Explain how a string would be parsed by fromFormat()
       * @param {string} text - the string to parse
       * @param {string} fmt - the format the string is expected to be in (see description)
       * @param {Object} options - options taken by fromFormat()
       * @return {Object}
       */
      ;

      DateTime.fromFormatExplain = function fromFormatExplain(text, fmt, options) {
        if (options === void 0) {
          options = {};
        }

        var _options = options,
            _options$locale = _options.locale,
            locale = _options$locale === void 0 ? null : _options$locale,
            _options$numberingSys = _options.numberingSystem,
            numberingSystem = _options$numberingSys === void 0 ? null : _options$numberingSys,
            localeToUse = Locale.fromOpts({
          locale: locale,
          numberingSystem: numberingSystem,
          defaultToEN: true
        });
        return explainFromTokens(localeToUse, text, fmt);
      }
      /**
       * @deprecated use fromFormatExplain instead
       */
      ;

      DateTime.fromStringExplain = function fromStringExplain(text, fmt, options) {
        if (options === void 0) {
          options = {};
        }

        return DateTime.fromFormatExplain(text, fmt, options);
      } // FORMAT PRESETS

      /**
       * {@link DateTime#toLocaleString} format like 10/14/1983
       * @type {Object}
       */
      ;

      _createClass(DateTime, [{
        key: "isValid",
        get: function get() {
          return this.invalid === null;
        }
        /**
         * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
         * @type {string}
         */

      }, {
        key: "invalidReason",
        get: function get() {
          return this.invalid ? this.invalid.reason : null;
        }
        /**
         * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
         * @type {string}
         */

      }, {
        key: "invalidExplanation",
        get: function get() {
          return this.invalid ? this.invalid.explanation : null;
        }
        /**
         * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
         *
         * @type {string}
         */

      }, {
        key: "locale",
        get: function get() {
          return this.isValid ? this.loc.locale : null;
        }
        /**
         * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
         *
         * @type {string}
         */

      }, {
        key: "numberingSystem",
        get: function get() {
          return this.isValid ? this.loc.numberingSystem : null;
        }
        /**
         * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
         *
         * @type {string}
         */

      }, {
        key: "outputCalendar",
        get: function get() {
          return this.isValid ? this.loc.outputCalendar : null;
        }
        /**
         * Get the time zone associated with this DateTime.
         * @type {Zone}
         */

      }, {
        key: "zone",
        get: function get() {
          return this._zone;
        }
        /**
         * Get the name of the time zone.
         * @type {string}
         */

      }, {
        key: "zoneName",
        get: function get() {
          return this.isValid ? this.zone.name : null;
        }
        /**
         * Get the year
         * @example DateTime.local(2017, 5, 25).year //=> 2017
         * @type {number}
         */

      }, {
        key: "year",
        get: function get() {
          return this.isValid ? this.c.year : NaN;
        }
        /**
         * Get the quarter
         * @example DateTime.local(2017, 5, 25).quarter //=> 2
         * @type {number}
         */

      }, {
        key: "quarter",
        get: function get() {
          return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
        }
        /**
         * Get the month (1-12).
         * @example DateTime.local(2017, 5, 25).month //=> 5
         * @type {number}
         */

      }, {
        key: "month",
        get: function get() {
          return this.isValid ? this.c.month : NaN;
        }
        /**
         * Get the day of the month (1-30ish).
         * @example DateTime.local(2017, 5, 25).day //=> 25
         * @type {number}
         */

      }, {
        key: "day",
        get: function get() {
          return this.isValid ? this.c.day : NaN;
        }
        /**
         * Get the hour of the day (0-23).
         * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
         * @type {number}
         */

      }, {
        key: "hour",
        get: function get() {
          return this.isValid ? this.c.hour : NaN;
        }
        /**
         * Get the minute of the hour (0-59).
         * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
         * @type {number}
         */

      }, {
        key: "minute",
        get: function get() {
          return this.isValid ? this.c.minute : NaN;
        }
        /**
         * Get the second of the minute (0-59).
         * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
         * @type {number}
         */

      }, {
        key: "second",
        get: function get() {
          return this.isValid ? this.c.second : NaN;
        }
        /**
         * Get the millisecond of the second (0-999).
         * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
         * @type {number}
         */

      }, {
        key: "millisecond",
        get: function get() {
          return this.isValid ? this.c.millisecond : NaN;
        }
        /**
         * Get the week year
         * @see https://en.wikipedia.org/wiki/ISO_week_date
         * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
         * @type {number}
         */

      }, {
        key: "weekYear",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
        }
        /**
         * Get the week number of the week year (1-52ish).
         * @see https://en.wikipedia.org/wiki/ISO_week_date
         * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
         * @type {number}
         */

      }, {
        key: "weekNumber",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
        }
        /**
         * Get the day of the week.
         * 1 is Monday and 7 is Sunday
         * @see https://en.wikipedia.org/wiki/ISO_week_date
         * @example DateTime.local(2014, 11, 31).weekday //=> 4
         * @type {number}
         */

      }, {
        key: "weekday",
        get: function get() {
          return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
        }
        /**
         * Get the ordinal (meaning the day of the year)
         * @example DateTime.local(2017, 5, 25).ordinal //=> 145
         * @type {number|DateTime}
         */

      }, {
        key: "ordinal",
        get: function get() {
          return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
        }
        /**
         * Get the human readable short month name, such as 'Oct'.
         * Defaults to the system's locale if no locale has been specified
         * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
         * @type {string}
         */

      }, {
        key: "monthShort",
        get: function get() {
          return this.isValid ? Info.months("short", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
        /**
         * Get the human readable long month name, such as 'October'.
         * Defaults to the system's locale if no locale has been specified
         * @example DateTime.local(2017, 10, 30).monthLong //=> October
         * @type {string}
         */

      }, {
        key: "monthLong",
        get: function get() {
          return this.isValid ? Info.months("long", {
            locObj: this.loc
          })[this.month - 1] : null;
        }
        /**
         * Get the human readable short weekday, such as 'Mon'.
         * Defaults to the system's locale if no locale has been specified
         * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
         * @type {string}
         */

      }, {
        key: "weekdayShort",
        get: function get() {
          return this.isValid ? Info.weekdays("short", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
        /**
         * Get the human readable long weekday, such as 'Monday'.
         * Defaults to the system's locale if no locale has been specified
         * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
         * @type {string}
         */

      }, {
        key: "weekdayLong",
        get: function get() {
          return this.isValid ? Info.weekdays("long", {
            locObj: this.loc
          })[this.weekday - 1] : null;
        }
        /**
         * Get the UTC offset of this DateTime in minutes
         * @example DateTime.now().offset //=> -240
         * @example DateTime.utc().offset //=> 0
         * @type {number}
         */

      }, {
        key: "offset",
        get: function get() {
          return this.isValid ? +this.o : NaN;
        }
        /**
         * Get the short human name for the zone's current offset, for example "EST" or "EDT".
         * Defaults to the system's locale if no locale has been specified
         * @type {string}
         */

      }, {
        key: "offsetNameShort",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "short",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
        /**
         * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
         * Defaults to the system's locale if no locale has been specified
         * @type {string}
         */

      }, {
        key: "offsetNameLong",
        get: function get() {
          if (this.isValid) {
            return this.zone.offsetName(this.ts, {
              format: "long",
              locale: this.locale
            });
          } else {
            return null;
          }
        }
        /**
         * Get whether this zone's offset ever changes, as in a DST.
         * @type {boolean}
         */

      }, {
        key: "isOffsetFixed",
        get: function get() {
          return this.isValid ? this.zone.isUniversal : null;
        }
        /**
         * Get whether the DateTime is in a DST.
         * @type {boolean}
         */

      }, {
        key: "isInDST",
        get: function get() {
          if (this.isOffsetFixed) {
            return false;
          } else {
            return this.offset > this.set({
              month: 1
            }).offset || this.offset > this.set({
              month: 5
            }).offset;
          }
        }
        /**
         * Returns true if this DateTime is in a leap year, false otherwise
         * @example DateTime.local(2016).isInLeapYear //=> true
         * @example DateTime.local(2013).isInLeapYear //=> false
         * @type {boolean}
         */

      }, {
        key: "isInLeapYear",
        get: function get() {
          return isLeapYear(this.year);
        }
        /**
         * Returns the number of days in this DateTime's month
         * @example DateTime.local(2016, 2).daysInMonth //=> 29
         * @example DateTime.local(2016, 3).daysInMonth //=> 31
         * @type {number}
         */

      }, {
        key: "daysInMonth",
        get: function get() {
          return daysInMonth(this.year, this.month);
        }
        /**
         * Returns the number of days in this DateTime's year
         * @example DateTime.local(2016).daysInYear //=> 366
         * @example DateTime.local(2013).daysInYear //=> 365
         * @type {number}
         */

      }, {
        key: "daysInYear",
        get: function get() {
          return this.isValid ? daysInYear(this.year) : NaN;
        }
        /**
         * Returns the number of weeks in this DateTime's year
         * @see https://en.wikipedia.org/wiki/ISO_week_date
         * @example DateTime.local(2004).weeksInWeekYear //=> 53
         * @example DateTime.local(2013).weeksInWeekYear //=> 52
         * @type {number}
         */

      }, {
        key: "weeksInWeekYear",
        get: function get() {
          return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
        }
      }], [{
        key: "DATE_SHORT",
        get: function get() {
          return DATE_SHORT;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
         * @type {Object}
         */

      }, {
        key: "DATE_MED",
        get: function get() {
          return DATE_MED;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
         * @type {Object}
         */

      }, {
        key: "DATE_MED_WITH_WEEKDAY",
        get: function get() {
          return DATE_MED_WITH_WEEKDAY;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'October 14, 1983'
         * @type {Object}
         */

      }, {
        key: "DATE_FULL",
        get: function get() {
          return DATE_FULL;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
         * @type {Object}
         */

      }, {
        key: "DATE_HUGE",
        get: function get() {
          return DATE_HUGE;
        }
        /**
         * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "TIME_SIMPLE",
        get: function get() {
          return TIME_SIMPLE;
        }
        /**
         * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "TIME_WITH_SECONDS",
        get: function get() {
          return TIME_WITH_SECONDS;
        }
        /**
         * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "TIME_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_WITH_SHORT_OFFSET;
        }
        /**
         * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "TIME_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_WITH_LONG_OFFSET;
        }
        /**
         * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
         * @type {Object}
         */

      }, {
        key: "TIME_24_SIMPLE",
        get: function get() {
          return TIME_24_SIMPLE;
        }
        /**
         * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
         * @type {Object}
         */

      }, {
        key: "TIME_24_WITH_SECONDS",
        get: function get() {
          return TIME_24_WITH_SECONDS;
        }
        /**
         * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
         * @type {Object}
         */

      }, {
        key: "TIME_24_WITH_SHORT_OFFSET",
        get: function get() {
          return TIME_24_WITH_SHORT_OFFSET;
        }
        /**
         * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
         * @type {Object}
         */

      }, {
        key: "TIME_24_WITH_LONG_OFFSET",
        get: function get() {
          return TIME_24_WITH_LONG_OFFSET;
        }
        /**
         * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "DATETIME_SHORT",
        get: function get() {
          return DATETIME_SHORT;
        }
        /**
         * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "DATETIME_SHORT_WITH_SECONDS",
        get: function get() {
          return DATETIME_SHORT_WITH_SECONDS;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "DATETIME_MED",
        get: function get() {
          return DATETIME_MED;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "DATETIME_MED_WITH_SECONDS",
        get: function get() {
          return DATETIME_MED_WITH_SECONDS;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "DATETIME_MED_WITH_WEEKDAY",
        get: function get() {
          return DATETIME_MED_WITH_WEEKDAY;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "DATETIME_FULL",
        get: function get() {
          return DATETIME_FULL;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "DATETIME_FULL_WITH_SECONDS",
        get: function get() {
          return DATETIME_FULL_WITH_SECONDS;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "DATETIME_HUGE",
        get: function get() {
          return DATETIME_HUGE;
        }
        /**
         * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
         * @type {Object}
         */

      }, {
        key: "DATETIME_HUGE_WITH_SECONDS",
        get: function get() {
          return DATETIME_HUGE_WITH_SECONDS;
        }
      }]);

      return DateTime;
    }();
    function friendlyDateTime(dateTimeish) {
      if (DateTime.isDateTime(dateTimeish)) {
        return dateTimeish;
      } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
        return DateTime.fromJSDate(dateTimeish);
      } else if (dateTimeish && typeof dateTimeish === "object") {
        return DateTime.fromObject(dateTimeish);
      } else {
        throw new InvalidArgumentError("Unknown datetime argument: " + dateTimeish + ", of type " + typeof dateTimeish);
      }
    }

    var DateTime_1 = DateTime;
    var Duration_1 = Duration;
    var Interval_1 = Interval;

    var has$1 = Object.prototype.hasOwnProperty;

    function dequal(foo, bar) {
    	var ctor, len;
    	if (foo === bar) return true;

    	if (foo && bar && (ctor=foo.constructor) === bar.constructor) {
    		if (ctor === Date) return foo.getTime() === bar.getTime();
    		if (ctor === RegExp) return foo.toString() === bar.toString();

    		if (ctor === Array) {
    			if ((len=foo.length) === bar.length) {
    				while (len-- && dequal(foo[len], bar[len]));
    			}
    			return len === -1;
    		}

    		if (!ctor || typeof foo === 'object') {
    			len = 0;
    			for (ctor in foo) {
    				if (has$1.call(foo, ctor) && ++len && !has$1.call(bar, ctor)) return false;
    				if (!(ctor in bar) || !dequal(foo[ctor], bar[ctor])) return false;
    			}
    			return Object.keys(bar).length === len;
    		}
    	}

    	return foo !== foo && bar !== bar;
    }

    function subscribeOnce(observable) {
      return new Promise((resolve) => {
        observable.subscribe(resolve)(); // immediately invoke to unsubscribe
      });
    }

    function update(object, path, value) {
      object.update((o) => {
        set$4(o, path, value);
        return o;
      });
    }

    function cloneDeep(object) {
      return JSON.parse(JSON.stringify(object));
    }

    function isNullish(value) {
      return value === undefined || value === null;
    }

    function isEmpty(object) {
      return isNullish(object) || Object.keys(object).length <= 0;
    }

    function getValues(object) {
      let results = [];

      for (const [, value] of Object.entries(object)) {
        const values = typeof value === 'object' ? getValues(value) : [value];
        results = [...results, ...values];
      }

      return results;
    }

    // TODO: refactor this so as not to rely directly on yup's API
    // This should use dependency injection, with a default callback which may assume
    // yup as the validation schema
    function getErrorsFromSchema(initialValues, schema, errors = {}) {
      for (const key in schema) {
        switch (true) {
          case schema[key].type === 'object' && !isEmpty(schema[key].fields): {
            errors[key] = getErrorsFromSchema(
              initialValues[key],
              schema[key].fields,
              {...errors[key]},
            );
            break;
          }

          case schema[key].type === 'array': {
            const values =
              initialValues && initialValues[key] ? initialValues[key] : [];
            errors[key] = values.map((value) => {
              const innerError = getErrorsFromSchema(
                value,
                schema[key].innerType.fields,
                {...errors[key]},
              );

              return Object.keys(innerError).length > 0 ? innerError : '';
            });
            break;
          }

          default: {
            errors[key] = '';
          }
        }
      }

      return errors;
    }

    const deepEqual = dequal;

    function assignDeep(object, value) {
      if (Array.isArray(object)) {
        return object.map((o) => assignDeep(o, value));
      }
      const copy = {};
      for (const key in object) {
        copy[key] =
          typeof object[key] === 'object' && !isNullish(object[key]) ? assignDeep(object[key], value) : value;
      }
      return copy;
    }

    function set$4(object, path, value) {
      if (new Object(object) !== object) return object;

      if (!Array.isArray(path)) {
        path = path.toString().match(/[^.[\]]+/g) || [];
      }

      const result = path
        .slice(0, -1)
        // TODO: replace this reduce with something more readable
        // eslint-disable-next-line unicorn/no-array-reduce
        .reduce(
          (accumulator, key, index) =>
            new Object(accumulator[key]) === accumulator[key]
              ? accumulator[key]
              : (accumulator[key] =
                  Math.trunc(Math.abs(path[index + 1])) === +path[index + 1]
                    ? []
                    : {}),
          object,
        );

      result[path[path.length - 1]] = value;

      return object;
    }

    const util = {
      assignDeep,
      cloneDeep,
      deepEqual,
      getErrorsFromSchema,
      getValues,
      isEmpty,
      isNullish,
      set: set$4,
      subscribeOnce,
      update,
    };

    const NO_ERROR = '';
    const IS_TOUCHED = true;

    function isCheckbox(element) {
      return element.getAttribute && element.getAttribute('type') === 'checkbox';
    }

    function isFileInput(element) {
      return element.getAttribute && element.getAttribute('type') === 'file';
    }

    function resolveValue(element) {
      if (isFileInput(element)) {
        return element.files;
      } else if (isCheckbox(element)) {
        return element.checked;
      } else {
        return element.value;
      }
    }

    const createForm = (config) => {
      let initialValues = config.initialValues || {};

      const validationSchema = config.validationSchema;
      const validateFunction = config.validate;
      const onSubmit = config.onSubmit;

      const getInitial = {
        values: () => util.cloneDeep(initialValues),
        errors: () =>
          validationSchema
            ? util.getErrorsFromSchema(initialValues, validationSchema.fields)
            : util.assignDeep(initialValues, NO_ERROR),
        touched: () => util.assignDeep(initialValues, !IS_TOUCHED),
      };

      const form = writable(getInitial.values());
      const errors = writable(getInitial.errors());
      const touched = writable(getInitial.touched());

      const isSubmitting = writable(false);
      const isValidating = writable(false);

      const isValid = derived(errors, ($errors) => {
        const noErrors = util
          .getValues($errors)
          .every((field) => field === NO_ERROR);
        return noErrors;
      });

      const modified = derived(form, ($form) => {
        const object = util.assignDeep($form, false);

        for (let key in $form) {
          object[key] = !util.deepEqual($form[key], initialValues[key]);
        }

        return object;
      });

      const isModified = derived(modified, ($modified) => {
        return util.getValues($modified).includes(true);
      });

      function validateField(field) {
        return util
          .subscribeOnce(form)
          .then((values) => validateFieldValue(field, values[field]));
      }

      function validateFieldValue(field, value) {
        updateTouched(field, true);

        if (validationSchema) {
          isValidating.set(true);

          return validationSchema
            .validateAt(field, get_store_value(form))
            .then(() => util.update(errors, field, ''))
            .catch((error) => util.update(errors, field, error.message))
            .finally(() => {
              isValidating.set(false);
            });
        }

        if (validateFunction) {
          isValidating.set(true);
          return Promise.resolve()
            .then(() => validateFunction({[field]: value}))
            .then((errs) =>
              util.update(errors, field, !util.isNullish(errs) ? errs[field] : ''),
            )
            .finally(() => {
              isValidating.set(false);
            });
        }

        return Promise.resolve();
      }

      function updateValidateField(field, value) {
        updateField(field, value);
        return validateFieldValue(field, value);
      }

      function handleChange(event) {
        const element = event.target;
        const field = element.name || element.id;
        const value = resolveValue(element);

        return updateValidateField(field, value);
      }

      function handleSubmit(event) {
        if (event && event.preventDefault) {
          event.preventDefault();
        }

        isSubmitting.set(true);

        return util.subscribeOnce(form).then((values) => {
          if (typeof validateFunction === 'function') {
            isValidating.set(true);

            return Promise.resolve()
              .then(() => validateFunction(values))
              .then((error) => {
                if (util.isNullish(error) || util.getValues(error).length === 0) {
                  return clearErrorsAndSubmit(values);
                } else {
                  errors.set(error);
                  isSubmitting.set(false);
                }
              })
              .finally(() => isValidating.set(false));
          }

          if (validationSchema) {
            isValidating.set(true);

            return (
              validationSchema
                .validate(values, {abortEarly: false})
                .then(() => clearErrorsAndSubmit(values))
                // eslint-disable-next-line unicorn/catch-error-name
                .catch((yupErrors) => {
                  if (yupErrors && yupErrors.inner) {
                    const updatedErrors = getInitial.errors();

                    yupErrors.inner.map((error) =>
                      util.set(updatedErrors, error.path, error.message),
                    );

                    errors.set(updatedErrors);
                  }
                  isSubmitting.set(false);
                })
                .finally(() => isValidating.set(false))
            );
          }

          return clearErrorsAndSubmit(values);
        });
      }

      function handleReset() {
        form.set(getInitial.values());
        errors.set(getInitial.errors());
        touched.set(getInitial.touched());
      }

      function clearErrorsAndSubmit(values) {
        return Promise.resolve()
          .then(() => errors.set(getInitial.errors()))
          .then(() => onSubmit(values, form, errors))
          .finally(() => isSubmitting.set(false));
      }

      /**
       * Handler to imperatively update the value of a form field
       */
      function updateField(field, value) {
        util.update(form, field, value);
      }

      /**
       * Handler to imperatively update the touched value of a form field
       */
      function updateTouched(field, value) {
        util.update(touched, field, value);
      }

      /**
       * Update the initial values and reset form. Used to dynamically display new form values
       */
      function updateInitialValues(newValues) {
        initialValues = newValues;

        handleReset();
      }

      return {
        form,
        errors,
        touched,
        modified,
        isValid,
        isSubmitting,
        isValidating,
        isModified,
        handleChange,
        handleSubmit,
        handleReset,
        updateField,
        updateValidateField,
        updateTouched,
        validateField,
        updateInitialValues,
        state: derived(
          [
            form,
            errors,
            touched,
            modified,
            isValid,
            isValidating,
            isSubmitting,
            isModified,
          ],
          ([
            $form,
            $errors,
            $touched,
            $modified,
            $isValid,
            $isValidating,
            $isSubmitting,
            $isModified,
          ]) => ({
            form: $form,
            errors: $errors,
            touched: $touched,
            modified: $modified,
            isValid: $isValid,
            isSubmitting: $isSubmitting,
            isValidating: $isValidating,
            isModified: $isModified,
          }),
        ),
      };
    };

    // ES6 Map
    var map$2;
    try {
      map$2 = Map;
    } catch (_) { }
    var set$3;

    // ES6 Set
    try {
      set$3 = Set;
    } catch (_) { }

    function baseClone (src, circulars, clones) {
      // Null/undefined/functions/etc
      if (!src || typeof src !== 'object' || typeof src === 'function') {
        return src
      }

      // DOM Node
      if (src.nodeType && 'cloneNode' in src) {
        return src.cloneNode(true)
      }

      // Date
      if (src instanceof Date) {
        return new Date(src.getTime())
      }

      // RegExp
      if (src instanceof RegExp) {
        return new RegExp(src)
      }

      // Arrays
      if (Array.isArray(src)) {
        return src.map(clone)
      }

      // ES6 Maps
      if (map$2 && src instanceof map$2) {
        return new Map(Array.from(src.entries()))
      }

      // ES6 Sets
      if (set$3 && src instanceof set$3) {
        return new Set(Array.from(src.values()))
      }

      // Object
      if (src instanceof Object) {
        circulars.push(src);
        var obj = Object.create(src);
        clones.push(obj);
        for (var key in src) {
          var idx = circulars.findIndex(function (i) {
            return i === src[key]
          });
          obj[key] = idx > -1 ? clones[idx] : baseClone(src[key], circulars, clones);
        }
        return obj
      }

      // ???
      return src
    }

    function clone (src) {
      return baseClone(src, [], [])
    }

    const toString$1 = Object.prototype.toString;
    const errorToString = Error.prototype.toString;
    const regExpToString = RegExp.prototype.toString;
    const symbolToString$1 = typeof Symbol !== 'undefined' ? Symbol.prototype.toString : () => '';
    const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;

    function printNumber(val) {
      if (val != +val) return 'NaN';
      const isNegativeZero = val === 0 && 1 / val < 0;
      return isNegativeZero ? '-0' : '' + val;
    }

    function printSimpleValue(val, quoteStrings = false) {
      if (val == null || val === true || val === false) return '' + val;
      const typeOf = typeof val;
      if (typeOf === 'number') return printNumber(val);
      if (typeOf === 'string') return quoteStrings ? `"${val}"` : val;
      if (typeOf === 'function') return '[Function ' + (val.name || 'anonymous') + ']';
      if (typeOf === 'symbol') return symbolToString$1.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
      const tag = toString$1.call(val).slice(8, -1);
      if (tag === 'Date') return isNaN(val.getTime()) ? '' + val : val.toISOString(val);
      if (tag === 'Error' || val instanceof Error) return '[' + errorToString.call(val) + ']';
      if (tag === 'RegExp') return regExpToString.call(val);
      return null;
    }

    function printValue(value, quoteStrings) {
      let result = printSimpleValue(value, quoteStrings);
      if (result !== null) return result;
      return JSON.stringify(value, function (key, value) {
        let result = printSimpleValue(this[key], quoteStrings);
        if (result !== null) return result;
        return value;
      }, 2);
    }

    let mixed = {
      default: '${path} is invalid',
      required: '${path} is a required field',
      oneOf: '${path} must be one of the following values: ${values}',
      notOneOf: '${path} must not be one of the following values: ${values}',
      notType: ({
        path,
        type,
        value,
        originalValue
      }) => {
        let isCast = originalValue != null && originalValue !== value;
        let msg = `${path} must be a \`${type}\` type, ` + `but the final value was: \`${printValue(value, true)}\`` + (isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : '.');

        if (value === null) {
          msg += `\n If "null" is intended as an empty value be sure to mark the schema as \`.nullable()\``;
        }

        return msg;
      },
      defined: '${path} must be defined'
    };
    let string = {
      length: '${path} must be exactly ${length} characters',
      min: '${path} must be at least ${min} characters',
      max: '${path} must be at most ${max} characters',
      matches: '${path} must match the following: "${regex}"',
      email: '${path} must be a valid email',
      url: '${path} must be a valid URL',
      uuid: '${path} must be a valid UUID',
      trim: '${path} must be a trimmed string',
      lowercase: '${path} must be a lowercase string',
      uppercase: '${path} must be a upper case string'
    };
    let number$4 = {
      min: '${path} must be greater than or equal to ${min}',
      max: '${path} must be less than or equal to ${max}',
      lessThan: '${path} must be less than ${less}',
      moreThan: '${path} must be greater than ${more}',
      positive: '${path} must be a positive number',
      negative: '${path} must be a negative number',
      integer: '${path} must be an integer'
    };
    let date$2 = {
      min: '${path} field must be later than ${min}',
      max: '${path} field must be at earlier than ${max}'
    };
    let boolean = {
      isValue: '${path} field must be ${value}'
    };
    let object$2 = {
      noUnknown: '${path} field has unspecified keys: ${unknown}'
    };
    let array$7 = {
      min: '${path} field must have at least ${min} items',
      max: '${path} field must have less than or equal to ${max} items',
      length: '${path} must have ${length} items'
    };
    var locale$2 = Object.assign(Object.create(null), {
      mixed,
      string,
      number: number$4,
      date: date$2,
      object: object$2,
      array: array$7,
      boolean
    });

    /** Used for built-in method references. */
    var objectProto$c = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$9 = objectProto$c.hasOwnProperty;

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty$9.call(object, key);
    }

    var _baseHas = baseHas;

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    var isArray_1 = isArray;

    /** Detect free variable `global` from Node.js. */

    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

    var _freeGlobal = freeGlobal;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root$2 = _freeGlobal || freeSelf || Function('return this')();

    var _root = root$2;

    /** Built-in value references. */
    var Symbol$2 = _root.Symbol;

    var _Symbol = Symbol$2;

    /** Used for built-in method references. */
    var objectProto$b = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$b.toString;

    /** Built-in value references. */
    var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$8.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    var _getRawTag = getRawTag;

    /** Used for built-in method references. */
    var objectProto$a = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$a.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    var _objectToString = objectToString;

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? _getRawTag(value)
        : _objectToString(value);
    }

    var _baseGetTag = baseGetTag;

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    var isObjectLike_1 = isObjectLike;

    /** `Object#toString` result references. */
    var symbolTag$1 = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1);
    }

    var isSymbol_1 = isSymbol;

    /** Used to match property names within property paths. */
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/;

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray_1(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol_1(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    var _isKey = isKey;

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject$1(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    var isObject_1 = isObject$1;

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag$1 = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject_1(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = _baseGetTag(value);
      return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    var isFunction_1 = isFunction;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = _root['__core-js_shared__'];

    var _coreJsData = coreJsData;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    var _isMasked = isMasked;

    /** Used for built-in method references. */
    var funcProto$1 = Function.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString$1 = funcProto$1.toString;

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString$1.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    var _toSource = toSource;

    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

    /** Used to detect host constructors (Safari). */
    var reIsHostCtor = /^\[object .+?Constructor\]$/;

    /** Used for built-in method references. */
    var funcProto = Function.prototype,
        objectProto$9 = Object.prototype;

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty$7).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject_1(value) || _isMasked(value)) {
        return false;
      }
      var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
      return pattern.test(_toSource(value));
    }

    var _baseIsNative = baseIsNative;

    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }

    var _getValue = getValue;

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = _getValue(object, key);
      return _baseIsNative(value) ? value : undefined;
    }

    var _getNative = getNative;

    /* Built-in method references that are verified to be native. */
    var nativeCreate = _getNative(Object, 'create');

    var _nativeCreate = nativeCreate;

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
      this.size = 0;
    }

    var _hashClear = hashClear;

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    var _hashDelete = hashDelete;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

    /** Used for built-in method references. */
    var objectProto$8 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (_nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED$2 ? undefined : result;
      }
      return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
    }

    var _hashGet = hashGet;

    /** Used for built-in method references. */
    var objectProto$7 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$5.call(data, key);
    }

    var _hashHas = hashHas;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
      return this;
    }

    var _hashSet = hashSet;

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = _hashClear;
    Hash.prototype['delete'] = _hashDelete;
    Hash.prototype.get = _hashGet;
    Hash.prototype.has = _hashHas;
    Hash.prototype.set = _hashSet;

    var _Hash = Hash;

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    var _listCacheClear = listCacheClear;

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    var eq_1 = eq;

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq_1(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    var _assocIndexOf = assocIndexOf;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype;

    /** Built-in value references. */
    var splice = arrayProto.splice;

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    var _listCacheDelete = listCacheDelete;

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    var _listCacheGet = listCacheGet;

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return _assocIndexOf(this.__data__, key) > -1;
    }

    var _listCacheHas = listCacheHas;

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = _assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    var _listCacheSet = listCacheSet;

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = _listCacheClear;
    ListCache.prototype['delete'] = _listCacheDelete;
    ListCache.prototype.get = _listCacheGet;
    ListCache.prototype.has = _listCacheHas;
    ListCache.prototype.set = _listCacheSet;

    var _ListCache = ListCache;

    /* Built-in method references that are verified to be native. */
    var Map$1 = _getNative(_root, 'Map');

    var _Map = Map$1;

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new _Hash,
        'map': new (_Map || _ListCache),
        'string': new _Hash
      };
    }

    var _mapCacheClear = mapCacheClear;

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    var _isKeyable = isKeyable;

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return _isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    var _getMapData = getMapData;

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = _getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    var _mapCacheDelete = mapCacheDelete;

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return _getMapData(this, key).get(key);
    }

    var _mapCacheGet = mapCacheGet;

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return _getMapData(this, key).has(key);
    }

    var _mapCacheHas = mapCacheHas;

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = _getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    var _mapCacheSet = mapCacheSet;

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = _mapCacheClear;
    MapCache.prototype['delete'] = _mapCacheDelete;
    MapCache.prototype.get = _mapCacheGet;
    MapCache.prototype.has = _mapCacheHas;
    MapCache.prototype.set = _mapCacheSet;

    var _MapCache = MapCache;

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || _MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = _MapCache;

    var memoize_1 = memoize;

    /** Used as the maximum memoize cache size. */
    var MAX_MEMOIZE_SIZE = 500;

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize_1(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    var _memoizeCapped = memoizeCapped;

    /** Used to match property names within property paths. */
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

    /** Used to match backslashes in property paths. */
    var reEscapeChar = /\\(\\)?/g;

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = _memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    var _stringToPath = stringToPath;

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    var _arrayMap = arrayMap;

    /** Used as references for various `Number` constants. */
    var INFINITY$1 = 1 / 0;

    /** Used to convert symbols to primitives and strings. */
    var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
        symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray_1(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return _arrayMap(value, baseToString) + '';
      }
      if (isSymbol_1(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
    }

    var _baseToString = baseToString;

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : _baseToString(value);
    }

    var toString_1 = toString;

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray_1(value)) {
        return value;
      }
      return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
    }

    var _castPath = castPath;

    /** `Object#toString` result references. */
    var argsTag$2 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
    }

    var _baseIsArguments = baseIsArguments;

    /** Used for built-in method references. */
    var objectProto$6 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
      return isObjectLike_1(value) && hasOwnProperty$4.call(value, 'callee') &&
        !propertyIsEnumerable$1.call(value, 'callee');
    };

    var isArguments_1 = isArguments;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    var _isIndex = isIndex;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    var isLength_1 = isLength;

    /** Used as references for various `Number` constants. */
    var INFINITY = 1 / 0;

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol_1(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    var _toKey = toKey;

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = _castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = _toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength_1(length) && _isIndex(key, length) &&
        (isArray_1(object) || isArguments_1(object));
    }

    var _hasPath = hasPath;

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && _hasPath(object, path, _baseHas);
    }

    var has_1 = has;

    const isSchema = obj => obj && obj.__isYupSchema__;

    class Condition {
      constructor(refs, options) {
        this.fn = void 0;
        this.refs = refs;
        this.refs = refs;

        if (typeof options === 'function') {
          this.fn = options;
          return;
        }

        if (!has_1(options, 'is')) throw new TypeError('`is:` is required for `when()` conditions');
        if (!options.then && !options.otherwise) throw new TypeError('either `then:` or `otherwise:` is required for `when()` conditions');
        let {
          is,
          then,
          otherwise
        } = options;
        let check = typeof is === 'function' ? is : (...values) => values.every(value => value === is);

        this.fn = function (...args) {
          let options = args.pop();
          let schema = args.pop();
          let branch = check(...args) ? then : otherwise;
          if (!branch) return undefined;
          if (typeof branch === 'function') return branch(schema);
          return schema.concat(branch.resolve(options));
        };
      }

      resolve(base, options) {
        let values = this.refs.map(ref => ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
        let schema = this.fn.apply(base, values.concat(base, options));
        if (schema === undefined || schema === base) return base;
        if (!isSchema(schema)) throw new TypeError('conditions must return a schema object');
        return schema.resolve(options);
      }

    }

    function toArray(value) {
      return value == null ? [] : [].concat(value);
    }

    function _extends$4() { _extends$4 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$4.apply(this, arguments); }
    let strReg = /\$\{\s*(\w+)\s*\}/g;
    class ValidationError extends Error {
      static formatError(message, params) {
        const path = params.label || params.path || 'this';
        if (path !== params.path) params = _extends$4({}, params, {
          path
        });
        if (typeof message === 'string') return message.replace(strReg, (_, key) => printValue(params[key]));
        if (typeof message === 'function') return message(params);
        return message;
      }

      static isError(err) {
        return err && err.name === 'ValidationError';
      }

      constructor(errorOrErrors, value, field, type) {
        super();
        this.value = void 0;
        this.path = void 0;
        this.type = void 0;
        this.errors = void 0;
        this.params = void 0;
        this.inner = void 0;
        this.name = 'ValidationError';
        this.value = value;
        this.path = field;
        this.type = type;
        this.errors = [];
        this.inner = [];
        toArray(errorOrErrors).forEach(err => {
          if (ValidationError.isError(err)) {
            this.errors.push(...err.errors);
            this.inner = this.inner.concat(err.inner.length ? err.inner : err);
          } else {
            this.errors.push(err);
          }
        });
        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
        if (Error.captureStackTrace) Error.captureStackTrace(this, ValidationError);
      }

    }

    const once = cb => {
      let fired = false;
      return (...args) => {
        if (fired) return;
        fired = true;
        cb(...args);
      };
    };

    function runTests(options, cb) {
      let {
        endEarly,
        tests,
        args,
        value,
        errors,
        sort,
        path
      } = options;
      let callback = once(cb);
      let count = tests.length;
      const nestedErrors = [];
      errors = errors ? errors : [];
      if (!count) return errors.length ? callback(new ValidationError(errors, value, path)) : callback(null, value);

      for (let i = 0; i < tests.length; i++) {
        const test = tests[i];
        test(args, function finishTestRun(err) {
          if (err) {
            // always return early for non validation errors
            if (!ValidationError.isError(err)) {
              return callback(err, value);
            }

            if (endEarly) {
              err.value = value;
              return callback(err, value);
            }

            nestedErrors.push(err);
          }

          if (--count <= 0) {
            if (nestedErrors.length) {
              if (sort) nestedErrors.sort(sort); //show parent errors after the nested ones: name.first, name

              if (errors.length) nestedErrors.push(...errors);
              errors = nestedErrors;
            }

            if (errors.length) {
              callback(new ValidationError(errors, value, path), value);
              return;
            }

            callback(null, value);
          }
        });
      }
    }

    var defineProperty = (function() {
      try {
        var func = _getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    var _defineProperty = defineProperty;

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && _defineProperty) {
        _defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    var _baseAssignValue = baseAssignValue;

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    var _createBaseFor = createBaseFor;

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = _createBaseFor();

    var _baseFor = baseFor;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    var _baseTimes = baseTimes;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    var stubFalse_1 = stubFalse;

    var isBuffer_1 = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? _root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse_1;

    module.exports = isBuffer;
    });

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]',
        arrayTag$1 = '[object Array]',
        boolTag$1 = '[object Boolean]',
        dateTag$1 = '[object Date]',
        errorTag$1 = '[object Error]',
        funcTag = '[object Function]',
        mapTag$2 = '[object Map]',
        numberTag$1 = '[object Number]',
        objectTag$2 = '[object Object]',
        regexpTag$1 = '[object RegExp]',
        setTag$2 = '[object Set]',
        stringTag$1 = '[object String]',
        weakMapTag$1 = '[object WeakMap]';

    var arrayBufferTag$1 = '[object ArrayBuffer]',
        dataViewTag$2 = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
    typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
    typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] =
    typedArrayTags[errorTag$1] = typedArrayTags[funcTag] =
    typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] =
    typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] =
    typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] =
    typedArrayTags[weakMapTag$1] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike_1(value) &&
        isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
    }

    var _baseIsTypedArray = baseIsTypedArray;

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    var _baseUnary = baseUnary;

    var _nodeUtil = createCommonjsModule(function (module, exports) {
    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && _freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    module.exports = nodeUtil;
    });

    /* Node.js helper references. */
    var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

    var isTypedArray_1 = isTypedArray;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray_1(value),
          isArg = !isArr && isArguments_1(value),
          isBuff = !isArr && !isArg && isBuffer_1(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? _baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$3.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               _isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    var _arrayLikeKeys = arrayLikeKeys;

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

      return value === proto;
    }

    var _isPrototype = isPrototype;

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    var _overArg = overArg;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = _overArg(Object.keys, Object);

    var _nativeKeys = nativeKeys;

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!_isPrototype(object)) {
        return _nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    var _baseKeys = baseKeys;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength_1(value.length) && !isFunction_1(value);
    }

    var isArrayLike_1 = isArrayLike;

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
    }

    var keys_1 = keys;

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && _baseFor(object, iteratee, keys_1);
    }

    var _baseForOwn = baseForOwn;

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new _ListCache;
      this.size = 0;
    }

    var _stackClear = stackClear;

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    var _stackDelete = stackDelete;

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    var _stackGet = stackGet;

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    var _stackHas = stackHas;

    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof _ListCache) {
        var pairs = data.__data__;
        if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new _MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    var _stackSet = stackSet;

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new _ListCache(entries);
      this.size = data.size;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = _stackClear;
    Stack.prototype['delete'] = _stackDelete;
    Stack.prototype.get = _stackGet;
    Stack.prototype.has = _stackHas;
    Stack.prototype.set = _stackSet;

    var _Stack = Stack;

    /** Used to stand-in for `undefined` hash values. */
    var HASH_UNDEFINED = '__lodash_hash_undefined__';

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    var _setCacheAdd = setCacheAdd;

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    var _setCacheHas = setCacheHas;

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new _MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
    SetCache.prototype.has = _setCacheHas;

    var _SetCache = SetCache;

    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }

    var _arraySome = arraySome;

    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function cacheHas(cache, key) {
      return cache.has(key);
    }

    var _cacheHas = cacheHas;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$5 = 1,
        COMPARE_UNORDERED_FLAG$3 = 2;

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new _SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!_arraySome(other, function(othValue, othIndex) {
                if (!_cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    var _equalArrays = equalArrays;

    /** Built-in value references. */
    var Uint8Array = _root.Uint8Array;

    var _Uint8Array = Uint8Array;

    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */
    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);

      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }

    var _mapToArray = mapToArray;

    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */
    function setToArray(set) {
      var index = -1,
          result = Array(set.size);

      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }

    var _setToArray = setToArray;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$4 = 1,
        COMPARE_UNORDERED_FLAG$2 = 2;

    /** `Object#toString` result references. */
    var boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        mapTag$1 = '[object Map]',
        numberTag = '[object Number]',
        regexpTag = '[object RegExp]',
        setTag$1 = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag$1 = '[object DataView]';

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag$1:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq_1(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag$1:
          var convert = _mapToArray;

        case setTag$1:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
          convert || (convert = _setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG$2;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    var _equalByTag = equalByTag;

    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */
    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }

    var _arrayPush = arrayPush;

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
    }

    var _baseGetAllKeys = baseGetAllKeys;

    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    var _arrayFilter = arrayFilter;

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    var stubArray_1 = stubArray;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeGetSymbols = Object.getOwnPropertySymbols;

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return _arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    var _getSymbols = getSymbols;

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return _baseGetAllKeys(object, keys_1, _getSymbols);
    }

    var _getAllKeys = getAllKeys;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$3 = 1;

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
          objProps = _getAllKeys(object),
          objLength = objProps.length,
          othProps = _getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    var _equalObjects = equalObjects;

    /* Built-in method references that are verified to be native. */
    var DataView$1 = _getNative(_root, 'DataView');

    var _DataView = DataView$1;

    /* Built-in method references that are verified to be native. */
    var Promise$1 = _getNative(_root, 'Promise');

    var _Promise = Promise$1;

    /* Built-in method references that are verified to be native. */
    var Set$1 = _getNative(_root, 'Set');

    var _Set = Set$1;

    /* Built-in method references that are verified to be native. */
    var WeakMap = _getNative(_root, 'WeakMap');

    var _WeakMap = WeakMap;

    /** `Object#toString` result references. */
    var mapTag = '[object Map]',
        objectTag$1 = '[object Object]',
        promiseTag = '[object Promise]',
        setTag = '[object Set]',
        weakMapTag = '[object WeakMap]';

    var dataViewTag = '[object DataView]';

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = _toSource(_DataView),
        mapCtorString = _toSource(_Map),
        promiseCtorString = _toSource(_Promise),
        setCtorString = _toSource(_Set),
        weakMapCtorString = _toSource(_WeakMap);

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = _baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (_Map && getTag(new _Map) != mapTag) ||
        (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
        (_Set && getTag(new _Set) != setTag) ||
        (_WeakMap && getTag(new _WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = _baseGetTag(value),
            Ctor = result == objectTag$1 ? value.constructor : undefined,
            ctorString = Ctor ? _toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    var _getTag = getTag;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$2 = 1;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        objectTag = '[object Object]';

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray_1(object),
          othIsArr = isArray_1(other),
          objTag = objIsArr ? arrayTag : _getTag(object),
          othTag = othIsArr ? arrayTag : _getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer_1(object)) {
        if (!isBuffer_1(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new _Stack);
        return (objIsArr || isTypedArray_1(object))
          ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new _Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new _Stack);
      return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    var _baseIsEqualDeep = baseIsEqualDeep;

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
        return value !== value && other !== other;
      }
      return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    var _baseIsEqual = baseIsEqual;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG$1 = 1,
        COMPARE_UNORDERED_FLAG$1 = 2;

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new _Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    var _baseIsMatch = baseIsMatch;

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject_1(value);
    }

    var _isStrictComparable = isStrictComparable;

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys_1(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, _isStrictComparable(value)];
      }
      return result;
    }

    var _getMatchData = getMatchData;

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    var _matchesStrictComparable = matchesStrictComparable;

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = _getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || _baseIsMatch(object, source, matchData);
      };
    }

    var _baseMatches = baseMatches;

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = _castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[_toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    var _baseGet = baseGet;

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get$2(object, path, defaultValue) {
      var result = object == null ? undefined : _baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    var get_1 = get$2;

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    var _baseHasIn = baseHasIn;

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && _hasPath(object, path, _baseHasIn);
    }

    var hasIn_1 = hasIn;

    /** Used to compose bitmasks for value comparisons. */
    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (_isKey(path) && _isStrictComparable(srcValue)) {
        return _matchesStrictComparable(_toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get_1(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn_1(object, path)
          : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    var _baseMatchesProperty = baseMatchesProperty;

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity$a(value) {
      return value;
    }

    var identity_1 = identity$a;

    /**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined : object[key];
      };
    }

    var _baseProperty = baseProperty;

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return _baseGet(object, path);
      };
    }

    var _basePropertyDeep = basePropertyDeep;

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
    }

    var property_1 = property;

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity_1;
      }
      if (typeof value == 'object') {
        return isArray_1(value)
          ? _baseMatchesProperty(value[0], value[1])
          : _baseMatches(value);
      }
      return property_1(value);
    }

    var _baseIteratee = baseIteratee;

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = _baseIteratee(iteratee);

      _baseForOwn(object, function(value, key, object) {
        _baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    var mapValues_1 = mapValues;

    /**
     * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>
     */

    function Cache(maxSize) {
      this._maxSize = maxSize;
      this.clear();
    }
    Cache.prototype.clear = function () {
      this._size = 0;
      this._values = Object.create(null);
    };
    Cache.prototype.get = function (key) {
      return this._values[key]
    };
    Cache.prototype.set = function (key, value) {
      this._size >= this._maxSize && this.clear();
      if (!(key in this._values)) this._size++;

      return (this._values[key] = value)
    };

    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g,
      DIGIT_REGEX = /^\d+$/,
      LEAD_DIGIT_REGEX = /^\d/,
      SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g,
      CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/,
      MAX_CACHE_SIZE = 512;

    var pathCache = new Cache(MAX_CACHE_SIZE),
      setCache = new Cache(MAX_CACHE_SIZE),
      getCache = new Cache(MAX_CACHE_SIZE);

    var propertyExpr = {
      Cache: Cache,

      split: split,

      normalizePath: normalizePath,

      setter: function (path) {
        var parts = normalizePath(path);

        return (
          setCache.get(path) ||
          setCache.set(path, function setter(obj, value) {
            var index = 0;
            var len = parts.length;
            var data = obj;

            while (index < len - 1) {
              var part = parts[index];
              if (
                part === '__proto__' ||
                part === 'constructor' ||
                part === 'prototype'
              ) {
                return obj
              }

              data = data[parts[index++]];
            }
            data[parts[index]] = value;
          })
        )
      },

      getter: function (path, safe) {
        var parts = normalizePath(path);
        return (
          getCache.get(path) ||
          getCache.set(path, function getter(data) {
            var index = 0,
              len = parts.length;
            while (index < len) {
              if (data != null || !safe) data = data[parts[index++]];
              else return
            }
            return data
          })
        )
      },

      join: function (segments) {
        return segments.reduce(function (path, part) {
          return (
            path +
            (isQuoted(part) || DIGIT_REGEX.test(part)
              ? '[' + part + ']'
              : (path ? '.' : '') + part)
          )
        }, '')
      },

      forEach: function (path, cb, thisArg) {
        forEach(Array.isArray(path) ? path : split(path), cb, thisArg);
      },
    };

    function normalizePath(path) {
      return (
        pathCache.get(path) ||
        pathCache.set(
          path,
          split(path).map(function (part) {
            return part.replace(CLEAN_QUOTES_REGEX, '$2')
          })
        )
      )
    }

    function split(path) {
      return path.match(SPLIT_REGEX) || ['']
    }

    function forEach(parts, iter, thisArg) {
      var len = parts.length,
        part,
        idx,
        isArray,
        isBracket;

      for (idx = 0; idx < len; idx++) {
        part = parts[idx];

        if (part) {
          if (shouldBeQuoted(part)) {
            part = '"' + part + '"';
          }

          isBracket = isQuoted(part);
          isArray = !isBracket && /^\d+$/.test(part);

          iter.call(thisArg, part, isBracket, isArray, idx, parts);
        }
      }
    }

    function isQuoted(str) {
      return (
        typeof str === 'string' && str && ["'", '"'].indexOf(str.charAt(0)) !== -1
      )
    }

    function hasLeadingNumber(part) {
      return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX)
    }

    function hasSpecialChars(part) {
      return SPEC_CHAR_REGEX.test(part)
    }

    function shouldBeQuoted(part) {
      return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part))
    }

    const prefixes$1 = {
      context: '$',
      value: '.'
    };
    function create$a(key, options) {
      return new Reference(key, options);
    }
    class Reference {
      constructor(key, options = {}) {
        this.key = void 0;
        this.isContext = void 0;
        this.isValue = void 0;
        this.isSibling = void 0;
        this.path = void 0;
        this.getter = void 0;
        this.map = void 0;
        if (typeof key !== 'string') throw new TypeError('ref must be a string, got: ' + key);
        this.key = key.trim();
        if (key === '') throw new TypeError('ref must be a non-empty string');
        this.isContext = this.key[0] === prefixes$1.context;
        this.isValue = this.key[0] === prefixes$1.value;
        this.isSibling = !this.isContext && !this.isValue;
        let prefix = this.isContext ? prefixes$1.context : this.isValue ? prefixes$1.value : '';
        this.path = this.key.slice(prefix.length);
        this.getter = this.path && propertyExpr.getter(this.path, true);
        this.map = options.map;
      }

      getValue(value, parent, context) {
        let result = this.isContext ? context : this.isValue ? value : parent;
        if (this.getter) result = this.getter(result || {});
        if (this.map) result = this.map(result);
        return result;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {Object=} options.context
       * @param {Object=} options.parent
       */


      cast(value, options) {
        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
      }

      resolve() {
        return this;
      }

      describe() {
        return {
          type: 'ref',
          key: this.key
        };
      }

      toString() {
        return `Ref(${this.key})`;
      }

      static isRef(value) {
        return value && value.__isYupRef;
      }

    } // @ts-ignore

    Reference.prototype.__isYupRef = true;

    function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }

    function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
    function createValidation(config) {
      function validate(_ref, cb) {
        let {
          value,
          path = '',
          label,
          options,
          originalValue,
          sync
        } = _ref,
            rest = _objectWithoutPropertiesLoose(_ref, ["value", "path", "label", "options", "originalValue", "sync"]);

        const {
          name,
          test,
          params,
          message
        } = config;
        let {
          parent,
          context
        } = options;

        function resolve(item) {
          return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
        }

        function createError(overrides = {}) {
          const nextParams = mapValues_1(_extends$3({
            value,
            originalValue,
            label,
            path: overrides.path || path
          }, params, overrides.params), resolve);
          const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name);
          error.params = nextParams;
          return error;
        }

        let ctx = _extends$3({
          path,
          parent,
          type: name,
          createError,
          resolve,
          options,
          originalValue
        }, rest);

        if (!sync) {
          try {
            Promise.resolve(test.call(ctx, value, ctx)).then(validOrError => {
              if (ValidationError.isError(validOrError)) cb(validOrError);else if (!validOrError) cb(createError());else cb(null, validOrError);
            }).catch(cb);
          } catch (err) {
            cb(err);
          }

          return;
        }

        let result;

        try {
          var _ref2;

          result = test.call(ctx, value, ctx);

          if (typeof ((_ref2 = result) == null ? void 0 : _ref2.then) === 'function') {
            throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. ` + `This test will finish after the validate call has returned`);
          }
        } catch (err) {
          cb(err);
          return;
        }

        if (ValidationError.isError(result)) cb(result);else if (!result) cb(createError());else cb(null, result);
      }

      validate.OPTIONS = config;
      return validate;
    }

    let trim = part => part.substr(0, part.length - 1).substr(1);

    function getIn(schema, path, value, context = value) {
      let parent, lastPart, lastPartDebug; // root path: ''

      if (!path) return {
        parent,
        parentPath: path,
        schema
      };
      propertyExpr.forEach(path, (_part, isBracket, isArray) => {
        let part = isBracket ? trim(_part) : _part;
        schema = schema.resolve({
          context,
          parent,
          value
        });

        if (schema.innerType) {
          let idx = isArray ? parseInt(part, 10) : 0;

          if (value && idx >= value.length) {
            throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. ` + `because there is no value at that index. `);
          }

          parent = value;
          value = value && value[idx];
          schema = schema.innerType;
        } // sometimes the array index part of a path doesn't exist: "nested.arr.child"
        // in these cases the current part is the next schema and should be processed
        // in this iteration. For cases where the index signature is included this
        // check will fail and we'll handle the `child` part on the next iteration like normal


        if (!isArray) {
          if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. ` + `(failed at: ${lastPartDebug} which is a type: "${schema._type}")`);
          parent = value;
          value = value && value[part];
          schema = schema.fields[part];
        }

        lastPart = part;
        lastPartDebug = isBracket ? '[' + _part + ']' : '.' + _part;
      });
      return {
        schema,
        parent,
        parentPath: lastPart
      };
    }

    const reach = (obj, path, value, context) => getIn(obj, path, value, context).schema;

    class ReferenceSet {
      constructor() {
        this.list = void 0;
        this.refs = void 0;
        this.list = new Set();
        this.refs = new Map();
      }

      get size() {
        return this.list.size + this.refs.size;
      }

      describe() {
        const description = [];

        for (const item of this.list) description.push(item);

        for (const [, ref] of this.refs) description.push(ref.describe());

        return description;
      }

      toArray() {
        return Array.from(this.list).concat(Array.from(this.refs.values()));
      }

      resolveAll(resolve) {
        return this.toArray().reduce((acc, e) => acc.concat(Reference.isRef(e) ? resolve(e) : e), []);
      }

      add(value) {
        Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
      }

      delete(value) {
        Reference.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
      }

      clone() {
        const next = new ReferenceSet();
        next.list = new Set(this.list);
        next.refs = new Map(this.refs);
        return next;
      }

      merge(newItems, removeItems) {
        const next = this.clone();
        newItems.list.forEach(value => next.add(value));
        newItems.refs.forEach(value => next.add(value));
        removeItems.list.forEach(value => next.delete(value));
        removeItems.refs.forEach(value => next.delete(value));
        return next;
      }

    }

    function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }

    class BaseSchema {
      constructor(options) {
        this.deps = [];
        this.tests = void 0;
        this.transforms = void 0;
        this.conditions = [];
        this._mutate = void 0;
        this._typeError = void 0;
        this._whitelist = new ReferenceSet();
        this._blacklist = new ReferenceSet();
        this.exclusiveTests = Object.create(null);
        this.spec = void 0;
        this.tests = [];
        this.transforms = [];
        this.withMutation(() => {
          this.typeError(mixed.notType);
        });
        this.type = (options == null ? void 0 : options.type) || 'mixed';
        this.spec = _extends$2({
          strip: false,
          strict: false,
          abortEarly: true,
          recursive: true,
          nullable: false,
          presence: 'optional'
        }, options == null ? void 0 : options.spec);
      } // TODO: remove


      get _type() {
        return this.type;
      }

      _typeCheck(_value) {
        return true;
      }

      clone(spec) {
        if (this._mutate) {
          if (spec) Object.assign(this.spec, spec);
          return this;
        } // if the nested value is a schema we can skip cloning, since
        // they are already immutable


        const next = Object.create(Object.getPrototypeOf(this)); // @ts-expect-error this is readonly

        next.type = this.type;
        next._typeError = this._typeError;
        next._whitelistError = this._whitelistError;
        next._blacklistError = this._blacklistError;
        next._whitelist = this._whitelist.clone();
        next._blacklist = this._blacklist.clone();
        next.exclusiveTests = _extends$2({}, this.exclusiveTests); // @ts-expect-error this is readonly

        next.deps = [...this.deps];
        next.conditions = [...this.conditions];
        next.tests = [...this.tests];
        next.transforms = [...this.transforms];
        next.spec = clone(_extends$2({}, this.spec, spec));
        return next;
      }

      label(label) {
        let next = this.clone();
        next.spec.label = label;
        return next;
      }

      meta(...args) {
        if (args.length === 0) return this.spec.meta;
        let next = this.clone();
        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
        return next;
      } // withContext<TContext extends AnyObject>(): BaseSchema<
      //   TCast,
      //   TContext,
      //   TOutput
      // > {
      //   return this as any;
      // }


      withMutation(fn) {
        let before = this._mutate;
        this._mutate = true;
        let result = fn(this);
        this._mutate = before;
        return result;
      }

      concat(schema) {
        if (!schema || schema === this) return this;
        if (schema.type !== this.type && this.type !== 'mixed') throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
        let base = this;
        let combined = schema.clone();

        const mergedSpec = _extends$2({}, base.spec, combined.spec); // if (combined.spec.nullable === UNSET)
        //   mergedSpec.nullable = base.spec.nullable;
        // if (combined.spec.presence === UNSET)
        //   mergedSpec.presence = base.spec.presence;


        combined.spec = mergedSpec;
        combined._typeError || (combined._typeError = base._typeError);
        combined._whitelistError || (combined._whitelistError = base._whitelistError);
        combined._blacklistError || (combined._blacklistError = base._blacklistError); // manually merge the blacklist/whitelist (the other `schema` takes
        // precedence in case of conflicts)

        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist); // start with the current tests

        combined.tests = base.tests;
        combined.exclusiveTests = base.exclusiveTests; // manually add the new tests to ensure
        // the deduping logic is consistent

        combined.withMutation(next => {
          schema.tests.forEach(fn => {
            next.test(fn.OPTIONS);
          });
        });
        combined.transforms = [...base.transforms, ...combined.transforms];
        return combined;
      }

      isType(v) {
        if (this.spec.nullable && v === null) return true;
        return this._typeCheck(v);
      }

      resolve(options) {
        let schema = this;

        if (schema.conditions.length) {
          let conditions = schema.conditions;
          schema = schema.clone();
          schema.conditions = [];
          schema = conditions.reduce((schema, condition) => condition.resolve(schema, options), schema);
          schema = schema.resolve(options);
        }

        return schema;
      }
      /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {*=} options.parent
       * @param {*=} options.context
       */


      cast(value, options = {}) {
        let resolvedSchema = this.resolve(_extends$2({
          value
        }, options));

        let result = resolvedSchema._cast(value, options);

        if (value !== undefined && options.assert !== false && resolvedSchema.isType(result) !== true) {
          let formattedValue = printValue(value);
          let formattedResult = printValue(result);
          throw new TypeError(`The value of ${options.path || 'field'} could not be cast to a value ` + `that satisfies the schema type: "${resolvedSchema._type}". \n\n` + `attempted value: ${formattedValue} \n` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ''));
        }

        return result;
      }

      _cast(rawValue, _options) {
        let value = rawValue === undefined ? rawValue : this.transforms.reduce((value, fn) => fn.call(this, value, rawValue, this), rawValue);

        if (value === undefined) {
          value = this.getDefault();
        }

        return value;
      }

      _validate(_value, options = {}, cb) {
        let {
          sync,
          path,
          from = [],
          originalValue = _value,
          strict = this.spec.strict,
          abortEarly = this.spec.abortEarly
        } = options;
        let value = _value;

        if (!strict) {
          // this._validating = true;
          value = this._cast(value, _extends$2({
            assert: false
          }, options)); // this._validating = false;
        } // value is cast, we can check if it meets type requirements


        let args = {
          value,
          path,
          options,
          originalValue,
          schema: this,
          label: this.spec.label,
          sync,
          from
        };
        let initialTests = [];
        if (this._typeError) initialTests.push(this._typeError);
        let finalTests = [];
        if (this._whitelistError) finalTests.push(this._whitelistError);
        if (this._blacklistError) finalTests.push(this._blacklistError);
        runTests({
          args,
          value,
          path,
          sync,
          tests: initialTests,
          endEarly: abortEarly
        }, err => {
          if (err) return void cb(err, value);
          runTests({
            tests: this.tests.concat(finalTests),
            args,
            path,
            sync,
            value,
            endEarly: abortEarly
          }, cb);
        });
      }

      validate(value, options, maybeCb) {
        let schema = this.resolve(_extends$2({}, options, {
          value
        })); // callback case is for nested validations

        return typeof maybeCb === 'function' ? schema._validate(value, options, maybeCb) : new Promise((resolve, reject) => schema._validate(value, options, (err, value) => {
          if (err) reject(err);else resolve(value);
        }));
      }

      validateSync(value, options) {
        let schema = this.resolve(_extends$2({}, options, {
          value
        }));
        let result;

        schema._validate(value, _extends$2({}, options, {
          sync: true
        }), (err, value) => {
          if (err) throw err;
          result = value;
        });

        return result;
      }

      isValid(value, options) {
        return this.validate(value, options).then(() => true, err => {
          if (ValidationError.isError(err)) return false;
          throw err;
        });
      }

      isValidSync(value, options) {
        try {
          this.validateSync(value, options);
          return true;
        } catch (err) {
          if (ValidationError.isError(err)) return false;
          throw err;
        }
      }

      _getDefault() {
        let defaultValue = this.spec.default;

        if (defaultValue == null) {
          return defaultValue;
        }

        return typeof defaultValue === 'function' ? defaultValue.call(this) : clone(defaultValue);
      }

      getDefault(options) {
        let schema = this.resolve(options || {});
        return schema._getDefault();
      }

      default(def) {
        if (arguments.length === 0) {
          return this._getDefault();
        }

        let next = this.clone({
          default: def
        });
        return next;
      }

      strict(isStrict = true) {
        let next = this.clone();
        next.spec.strict = isStrict;
        return next;
      }

      _isPresent(value) {
        return value != null;
      }

      defined(message = mixed.defined) {
        return this.test({
          message,
          name: 'defined',
          exclusive: true,

          test(value) {
            return value !== undefined;
          }

        });
      }

      required(message = mixed.required) {
        return this.clone({
          presence: 'required'
        }).withMutation(s => s.test({
          message,
          name: 'required',
          exclusive: true,

          test(value) {
            return this.schema._isPresent(value);
          }

        }));
      }

      notRequired() {
        let next = this.clone({
          presence: 'optional'
        });
        next.tests = next.tests.filter(test => test.OPTIONS.name !== 'required');
        return next;
      }

      nullable(isNullable = true) {
        let next = this.clone({
          nullable: isNullable !== false
        });
        return next;
      }

      transform(fn) {
        let next = this.clone();
        next.transforms.push(fn);
        return next;
      }
      /**
       * Adds a test function to the schema's queue of tests.
       * tests can be exclusive or non-exclusive.
       *
       * - exclusive tests, will replace any existing tests of the same name.
       * - non-exclusive: can be stacked
       *
       * If a non-exclusive test is added to a schema with an exclusive test of the same name
       * the exclusive test is removed and further tests of the same name will be stacked.
       *
       * If an exclusive test is added to a schema with non-exclusive tests of the same name
       * the previous tests are removed and further tests of the same name will replace each other.
       */


      test(...args) {
        let opts;

        if (args.length === 1) {
          if (typeof args[0] === 'function') {
            opts = {
              test: args[0]
            };
          } else {
            opts = args[0];
          }
        } else if (args.length === 2) {
          opts = {
            name: args[0],
            test: args[1]
          };
        } else {
          opts = {
            name: args[0],
            message: args[1],
            test: args[2]
          };
        }

        if (opts.message === undefined) opts.message = mixed.default;
        if (typeof opts.test !== 'function') throw new TypeError('`test` is a required parameters');
        let next = this.clone();
        let validate = createValidation(opts);
        let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;

        if (opts.exclusive) {
          if (!opts.name) throw new TypeError('Exclusive tests must provide a unique `name` identifying the test');
        }

        if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
        next.tests = next.tests.filter(fn => {
          if (fn.OPTIONS.name === opts.name) {
            if (isExclusive) return false;
            if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
          }

          return true;
        });
        next.tests.push(validate);
        return next;
      }

      when(keys, options) {
        if (!Array.isArray(keys) && typeof keys !== 'string') {
          options = keys;
          keys = '.';
        }

        let next = this.clone();
        let deps = toArray(keys).map(key => new Reference(key));
        deps.forEach(dep => {
          // @ts-ignore
          if (dep.isSibling) next.deps.push(dep.key);
        });
        next.conditions.push(new Condition(deps, options));
        return next;
      }

      typeError(message) {
        let next = this.clone();
        next._typeError = createValidation({
          message,
          name: 'typeError',

          test(value) {
            if (value !== undefined && !this.schema.isType(value)) return this.createError({
              params: {
                type: this.schema._type
              }
            });
            return true;
          }

        });
        return next;
      }

      oneOf(enums, message = mixed.oneOf) {
        let next = this.clone();
        enums.forEach(val => {
          next._whitelist.add(val);

          next._blacklist.delete(val);
        });
        next._whitelistError = createValidation({
          message,
          name: 'oneOf',

          test(value) {
            if (value === undefined) return true;
            let valids = this.schema._whitelist;
            let resolved = valids.resolveAll(this.resolve);
            return resolved.includes(value) ? true : this.createError({
              params: {
                values: valids.toArray().join(', '),
                resolved
              }
            });
          }

        });
        return next;
      }

      notOneOf(enums, message = mixed.notOneOf) {
        let next = this.clone();
        enums.forEach(val => {
          next._blacklist.add(val);

          next._whitelist.delete(val);
        });
        next._blacklistError = createValidation({
          message,
          name: 'notOneOf',

          test(value) {
            let invalids = this.schema._blacklist;
            let resolved = invalids.resolveAll(this.resolve);
            if (resolved.includes(value)) return this.createError({
              params: {
                values: invalids.toArray().join(', '),
                resolved
              }
            });
            return true;
          }

        });
        return next;
      }

      strip(strip = true) {
        let next = this.clone();
        next.spec.strip = strip;
        return next;
      }

      describe() {
        const next = this.clone();
        const {
          label,
          meta
        } = next.spec;
        const description = {
          meta,
          label,
          type: next.type,
          oneOf: next._whitelist.describe(),
          notOneOf: next._blacklist.describe(),
          tests: next.tests.map(fn => ({
            name: fn.OPTIONS.name,
            params: fn.OPTIONS.params
          })).filter((n, idx, list) => list.findIndex(c => c.name === n.name) === idx)
        };
        return description;
      }

    } // eslint-disable-next-line @typescript-eslint/no-unused-vars

    // @ts-expect-error
    BaseSchema.prototype.__isYupSchema__ = true;

    for (const method of ['validate', 'validateSync']) BaseSchema.prototype[`${method}At`] = function (path, value, options = {}) {
      const {
        parent,
        parentPath,
        schema
      } = getIn(this, path, value, options.context);
      return schema[method](parent && parent[parentPath], _extends$2({}, options, {
        parent,
        path
      }));
    };

    for (const alias of ['equals', 'is']) BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;

    for (const alias of ['not', 'nope']) BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;

    BaseSchema.prototype.optional = BaseSchema.prototype.notRequired;

    const Mixed = BaseSchema;
    function create$9() {
      return new Mixed();
    } // XXX: this is using the Base schema so that `addMethod(mixed)` works as a base class

    create$9.prototype = Mixed.prototype;

    const isAbsent = value => value == null;

    function create$8() {
      return new BooleanSchema();
    }
    class BooleanSchema extends BaseSchema {
      constructor() {
        super({
          type: 'boolean'
        });
        this.withMutation(() => {
          this.transform(function (value) {
            if (!this.isType(value)) {
              if (/^(true|1)$/i.test(String(value))) return true;
              if (/^(false|0)$/i.test(String(value))) return false;
            }

            return value;
          });
        });
      }

      _typeCheck(v) {
        if (v instanceof Boolean) v = v.valueOf();
        return typeof v === 'boolean';
      }

      isTrue(message = boolean.isValue) {
        return this.test({
          message,
          name: 'is-value',
          exclusive: true,
          params: {
            value: 'true'
          },

          test(value) {
            return isAbsent(value) || value === true;
          }

        });
      }

      isFalse(message = boolean.isValue) {
        return this.test({
          message,
          name: 'is-value',
          exclusive: true,
          params: {
            value: 'false'
          },

          test(value) {
            return isAbsent(value) || value === false;
          }

        });
      }

    }
    create$8.prototype = BooleanSchema.prototype;

    let rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i; // eslint-disable-next-line

    let rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i; // eslint-disable-next-line

    let rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    let isTrimmed = value => isAbsent(value) || value === value.trim();

    let objStringTag = {}.toString();
    function create$7() {
      return new StringSchema();
    }
    class StringSchema extends BaseSchema {
      constructor() {
        super({
          type: 'string'
        });
        this.withMutation(() => {
          this.transform(function (value) {
            if (this.isType(value)) return value;
            if (Array.isArray(value)) return value;
            const strValue = value != null && value.toString ? value.toString() : value;
            if (strValue === objStringTag) return value;
            return strValue;
          });
        });
      }

      _typeCheck(value) {
        if (value instanceof String) value = value.valueOf();
        return typeof value === 'string';
      }

      _isPresent(value) {
        return super._isPresent(value) && !!value.length;
      }

      length(length, message = string.length) {
        return this.test({
          message,
          name: 'length',
          exclusive: true,
          params: {
            length
          },

          test(value) {
            return isAbsent(value) || value.length === this.resolve(length);
          }

        });
      }

      min(min, message = string.min) {
        return this.test({
          message,
          name: 'min',
          exclusive: true,
          params: {
            min
          },

          test(value) {
            return isAbsent(value) || value.length >= this.resolve(min);
          }

        });
      }

      max(max, message = string.max) {
        return this.test({
          name: 'max',
          exclusive: true,
          message,
          params: {
            max
          },

          test(value) {
            return isAbsent(value) || value.length <= this.resolve(max);
          }

        });
      }

      matches(regex, options) {
        let excludeEmptyString = false;
        let message;
        let name;

        if (options) {
          if (typeof options === 'object') {
            ({
              excludeEmptyString = false,
              message,
              name
            } = options);
          } else {
            message = options;
          }
        }

        return this.test({
          name: name || 'matches',
          message: message || string.matches,
          params: {
            regex
          },
          test: value => isAbsent(value) || value === '' && excludeEmptyString || value.search(regex) !== -1
        });
      }

      email(message = string.email) {
        return this.matches(rEmail, {
          name: 'email',
          message,
          excludeEmptyString: true
        });
      }

      url(message = string.url) {
        return this.matches(rUrl, {
          name: 'url',
          message,
          excludeEmptyString: true
        });
      }

      uuid(message = string.uuid) {
        return this.matches(rUUID, {
          name: 'uuid',
          message,
          excludeEmptyString: false
        });
      } //-- transforms --


      ensure() {
        return this.default('').transform(val => val === null ? '' : val);
      }

      trim(message = string.trim) {
        return this.transform(val => val != null ? val.trim() : val).test({
          message,
          name: 'trim',
          test: isTrimmed
        });
      }

      lowercase(message = string.lowercase) {
        return this.transform(value => !isAbsent(value) ? value.toLowerCase() : value).test({
          message,
          name: 'string_case',
          exclusive: true,
          test: value => isAbsent(value) || value === value.toLowerCase()
        });
      }

      uppercase(message = string.uppercase) {
        return this.transform(value => !isAbsent(value) ? value.toUpperCase() : value).test({
          message,
          name: 'string_case',
          exclusive: true,
          test: value => isAbsent(value) || value === value.toUpperCase()
        });
      }

    }
    create$7.prototype = StringSchema.prototype; //
    // String Interfaces
    //

    let isNaN$1 = value => value != +value;

    function create$6() {
      return new NumberSchema();
    }
    class NumberSchema extends BaseSchema {
      constructor() {
        super({
          type: 'number'
        });
        this.withMutation(() => {
          this.transform(function (value) {
            let parsed = value;

            if (typeof parsed === 'string') {
              parsed = parsed.replace(/\s/g, '');
              if (parsed === '') return NaN; // don't use parseFloat to avoid positives on alpha-numeric strings

              parsed = +parsed;
            }

            if (this.isType(parsed)) return parsed;
            return parseFloat(parsed);
          });
        });
      }

      _typeCheck(value) {
        if (value instanceof Number) value = value.valueOf();
        return typeof value === 'number' && !isNaN$1(value);
      }

      min(min, message = number$4.min) {
        return this.test({
          message,
          name: 'min',
          exclusive: true,
          params: {
            min
          },

          test(value) {
            return isAbsent(value) || value >= this.resolve(min);
          }

        });
      }

      max(max, message = number$4.max) {
        return this.test({
          message,
          name: 'max',
          exclusive: true,
          params: {
            max
          },

          test(value) {
            return isAbsent(value) || value <= this.resolve(max);
          }

        });
      }

      lessThan(less, message = number$4.lessThan) {
        return this.test({
          message,
          name: 'max',
          exclusive: true,
          params: {
            less
          },

          test(value) {
            return isAbsent(value) || value < this.resolve(less);
          }

        });
      }

      moreThan(more, message = number$4.moreThan) {
        return this.test({
          message,
          name: 'min',
          exclusive: true,
          params: {
            more
          },

          test(value) {
            return isAbsent(value) || value > this.resolve(more);
          }

        });
      }

      positive(msg = number$4.positive) {
        return this.moreThan(0, msg);
      }

      negative(msg = number$4.negative) {
        return this.lessThan(0, msg);
      }

      integer(message = number$4.integer) {
        return this.test({
          name: 'integer',
          message,
          test: val => isAbsent(val) || Number.isInteger(val)
        });
      }

      truncate() {
        return this.transform(value => !isAbsent(value) ? value | 0 : value);
      }

      round(method) {
        var _method;

        let avail = ['ceil', 'floor', 'round', 'trunc'];
        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || 'round'; // this exists for symemtry with the new Math.trunc

        if (method === 'trunc') return this.truncate();
        if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError('Only valid options for round() are: ' + avail.join(', '));
        return this.transform(value => !isAbsent(value) ? Math[method](value) : value);
      }

    }
    create$6.prototype = NumberSchema.prototype; //
    // Number Interfaces
    //

    /* eslint-disable */

    /**
     *
     * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>
     * NON-CONFORMANT EDITION.
     *  2011 Colin Snover <http://zetafleet.com>
     * Released under MIT license.
     */
    //              1 YYYY                 2 MM        3 DD              4 HH     5 mm        6 ss            7 msec         8 Z 9     10 tzHH    11 tzmm
    var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
    function parseIsoDate(date) {
      var numericKeys = [1, 4, 5, 6, 7, 10, 11],
          minutesOffset = 0,
          timestamp,
          struct;

      if (struct = isoReg.exec(date)) {
        // avoid NaN timestamps caused by undefined values being passed to Date.UTC
        for (var i = 0, k; k = numericKeys[i]; ++i) struct[k] = +struct[k] || 0; // allow undefined days and months


        struct[2] = (+struct[2] || 1) - 1;
        struct[3] = +struct[3] || 1; // allow arbitrary sub-second precision beyond milliseconds

        struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0; // timestamps without timezone identifiers should be considered local time

        if ((struct[8] === undefined || struct[8] === '') && (struct[9] === undefined || struct[9] === '')) timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);else {
          if (struct[8] !== 'Z' && struct[9] !== undefined) {
            minutesOffset = struct[10] * 60 + struct[11];
            if (struct[9] === '+') minutesOffset = 0 - minutesOffset;
          }

          timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
        }
      } else timestamp = Date.parse ? Date.parse(date) : NaN;

      return timestamp;
    }

    // @ts-ignore
    let invalidDate = new Date('');

    let isDate = obj => Object.prototype.toString.call(obj) === '[object Date]';

    function create$5() {
      return new DateSchema();
    }
    class DateSchema extends BaseSchema {
      constructor() {
        super({
          type: 'date'
        });
        this.withMutation(() => {
          this.transform(function (value) {
            if (this.isType(value)) return value;
            value = parseIsoDate(value); // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.

            return !isNaN(value) ? new Date(value) : invalidDate;
          });
        });
      }

      _typeCheck(v) {
        return isDate(v) && !isNaN(v.getTime());
      }

      prepareParam(ref, name) {
        let param;

        if (!Reference.isRef(ref)) {
          let cast = this.cast(ref);
          if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
          param = cast;
        } else {
          param = ref;
        }

        return param;
      }

      min(min, message = date$2.min) {
        let limit = this.prepareParam(min, 'min');
        return this.test({
          message,
          name: 'min',
          exclusive: true,
          params: {
            min
          },

          test(value) {
            return isAbsent(value) || value >= this.resolve(limit);
          }

        });
      }

      max(max, message = date$2.max) {
        let limit = this.prepareParam(max, 'max');
        return this.test({
          message,
          name: 'max',
          exclusive: true,
          params: {
            max
          },

          test(value) {
            return isAbsent(value) || value <= this.resolve(limit);
          }

        });
      }

    }
    DateSchema.INVALID_DATE = invalidDate;
    create$5.prototype = DateSchema.prototype;
    create$5.INVALID_DATE = invalidDate;

    /**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1,
          length = array == null ? 0 : array.length;

      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }

    var _arrayReduce = arrayReduce;

    /**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined : object[key];
      };
    }

    var _basePropertyOf = basePropertyOf;

    /** Used to map Latin Unicode letters to basic Latin letters. */
    var deburredLetters = {
      // Latin-1 Supplement block.
      '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
      '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
      '\xc7': 'C',  '\xe7': 'c',
      '\xd0': 'D',  '\xf0': 'd',
      '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
      '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
      '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
      '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
      '\xd1': 'N',  '\xf1': 'n',
      '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
      '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
      '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
      '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
      '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
      '\xc6': 'Ae', '\xe6': 'ae',
      '\xde': 'Th', '\xfe': 'th',
      '\xdf': 'ss',
      // Latin Extended-A block.
      '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
      '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
      '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
      '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
      '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
      '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
      '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
      '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
      '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
      '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
      '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
      '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
      '\u0134': 'J',  '\u0135': 'j',
      '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
      '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
      '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
      '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
      '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
      '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
      '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
      '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
      '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
      '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
      '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
      '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
      '\u0163': 't',  '\u0165': 't', '\u0167': 't',
      '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
      '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
      '\u0174': 'W',  '\u0175': 'w',
      '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
      '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
      '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
      '\u0132': 'IJ', '\u0133': 'ij',
      '\u0152': 'Oe', '\u0153': 'oe',
      '\u0149': "'n", '\u017f': 's'
    };

    /**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */
    var deburrLetter = _basePropertyOf(deburredLetters);

    var _deburrLetter = deburrLetter;

    /** Used to match Latin Unicode letters (excluding mathematical operators). */
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

    /** Used to compose unicode character classes. */
    var rsComboMarksRange$3 = '\\u0300-\\u036f',
        reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
        rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3;

    /** Used to compose unicode capture groups. */
    var rsCombo$2 = '[' + rsComboRange$3 + ']';

    /**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */
    var reComboMark = RegExp(rsCombo$2, 'g');

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString_1(string);
      return string && string.replace(reLatin, _deburrLetter).replace(reComboMark, '');
    }

    var deburr_1 = deburr;

    /** Used to match words composed of alphanumeric characters. */
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

    /**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }

    var _asciiWords = asciiWords;

    /** Used to detect strings that need a more robust regexp to match words. */
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

    /**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }

    var _hasUnicodeWord = hasUnicodeWord;

    /** Used to compose unicode character classes. */
    var rsAstralRange$2 = '\\ud800-\\udfff',
        rsComboMarksRange$2 = '\\u0300-\\u036f',
        reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
        rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange$2 = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

    /** Used to compose unicode capture groups. */
    var rsApos$1 = "['\u2019]",
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo$1 = '[' + rsComboRange$2 + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
        rsModifier$1 = '(?:' + rsCombo$1 + '|' + rsFitz$1 + ')',
        rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
        rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ$2 = '\\u200d';

    /** Used to compose unicode regexes. */
    var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod$1 = rsModifier$1 + '?',
        rsOptVar$1 = '[' + rsVarRange$2 + ']?',
        rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
        rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;

    /** Used to match complex or compound words. */
    var reUnicodeWord = RegExp([
      rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
      rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
      rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
      rsUpper + '+' + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join('|'), 'g');

    /**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }

    var _unicodeWords = unicodeWords;

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString_1(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return _hasUnicodeWord(string) ? _unicodeWords(string) : _asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    var words_1 = words;

    /** Used to compose unicode capture groups. */
    var rsApos = "['\u2019]";

    /** Used to match apostrophes. */
    var reApos = RegExp(rsApos, 'g');

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return _arrayReduce(words_1(deburr_1(string).replace(reApos, '')), callback, '');
      };
    }

    var _createCompounder = createCompounder;

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = _createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    var snakeCase_1 = snakeCase;

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    var _baseSlice = baseSlice;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : _baseSlice(array, start, end);
    }

    var _castSlice = castSlice;

    /** Used to compose unicode character classes. */
    var rsAstralRange$1 = '\\ud800-\\udfff',
        rsComboMarksRange$1 = '\\u0300-\\u036f',
        reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
        rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
        rsVarRange$1 = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsZWJ$1 = '\\u200d';

    /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
    var reHasUnicode = RegExp('[' + rsZWJ$1 + rsAstralRange$1  + rsComboRange$1 + rsVarRange$1 + ']');

    /**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }

    var _hasUnicode = hasUnicode;

    /**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function asciiToArray(string) {
      return string.split('');
    }

    var _asciiToArray = asciiToArray;

    /** Used to compose unicode character classes. */
    var rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsVarRange = '\\ufe0e\\ufe0f';

    /** Used to compose unicode capture groups. */
    var rsAstral = '[' + rsAstralRange + ']',
        rsCombo = '[' + rsComboRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsZWJ = '\\u200d';

    /** Used to compose unicode regexes. */
    var reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

    /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
    var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

    /**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }

    var _unicodeToArray = unicodeToArray;

    /**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */
    function stringToArray(string) {
      return _hasUnicode(string)
        ? _unicodeToArray(string)
        : _asciiToArray(string);
    }

    var _stringToArray = stringToArray;

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString_1(string);

        var strSymbols = _hasUnicode(string)
          ? _stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? _castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    var _createCaseFirst = createCaseFirst;

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = _createCaseFirst('toUpperCase');

    var upperFirst_1 = upperFirst;

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst_1(toString_1(string).toLowerCase());
    }

    var capitalize_1 = capitalize;

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = _createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize_1(word) : word);
    });

    var camelCase_1 = camelCase;

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = _baseIteratee(iteratee);

      _baseForOwn(object, function(value, key, object) {
        _baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    var mapKeys_1 = mapKeys;

    /**
     * Topological sorting function
     *
     * @param {Array} edges
     * @returns {Array}
     */

    var toposort_1 = function(edges) {
      return toposort(uniqueNodes(edges), edges)
    };

    var array$6 = toposort;

    function toposort(nodes, edges) {
      var cursor = nodes.length
        , sorted = new Array(cursor)
        , visited = {}
        , i = cursor
        // Better data structures make algorithm much faster.
        , outgoingEdges = makeOutgoingEdges(edges)
        , nodesHash = makeNodesHash(nodes);

      // check for unknown nodes
      edges.forEach(function(edge) {
        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
          throw new Error('Unknown node. There is an unknown node in the supplied edges.')
        }
      });

      while (i--) {
        if (!visited[i]) visit(nodes[i], i, new Set());
      }

      return sorted

      function visit(node, i, predecessors) {
        if(predecessors.has(node)) {
          var nodeRep;
          try {
            nodeRep = ", node was:" + JSON.stringify(node);
          } catch(e) {
            nodeRep = "";
          }
          throw new Error('Cyclic dependency' + nodeRep)
        }

        if (!nodesHash.has(node)) {
          throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: '+JSON.stringify(node))
        }

        if (visited[i]) return;
        visited[i] = true;

        var outgoing = outgoingEdges.get(node) || new Set();
        outgoing = Array.from(outgoing);

        if (i = outgoing.length) {
          predecessors.add(node);
          do {
            var child = outgoing[--i];
            visit(child, nodesHash.get(child), predecessors);
          } while (i)
          predecessors.delete(node);
        }

        sorted[--cursor] = node;
      }
    }

    function uniqueNodes(arr){
      var res = new Set();
      for (var i = 0, len = arr.length; i < len; i++) {
        var edge = arr[i];
        res.add(edge[0]);
        res.add(edge[1]);
      }
      return Array.from(res)
    }

    function makeOutgoingEdges(arr){
      var edges = new Map();
      for (var i = 0, len = arr.length; i < len; i++) {
        var edge = arr[i];
        if (!edges.has(edge[0])) edges.set(edge[0], new Set());
        if (!edges.has(edge[1])) edges.set(edge[1], new Set());
        edges.get(edge[0]).add(edge[1]);
      }
      return edges
    }

    function makeNodesHash(arr){
      var res = new Map();
      for (var i = 0, len = arr.length; i < len; i++) {
        res.set(arr[i], i);
      }
      return res
    }
    toposort_1.array = array$6;

    function sortFields(fields, excludedEdges = []) {
      let edges = [];
      let nodes = new Set();
      let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));

      function addNode(depPath, key) {
        let node = propertyExpr.split(depPath)[0];
        nodes.add(node);
        if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);
      }

      for (const key in fields) if (has_1(fields, key)) {
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && 'deps' in value) value.deps.forEach(path => addNode(path, key));
      }

      return toposort_1.array(Array.from(nodes), edges).reverse();
    }

    function findIndex(arr, err) {
      let idx = Infinity;
      arr.some((key, ii) => {
        var _err$path;

        if (((_err$path = err.path) == null ? void 0 : _err$path.indexOf(key)) !== -1) {
          idx = ii;
          return true;
        }
      });
      return idx;
    }

    function sortByKeyOrder(keys) {
      return (a, b) => {
        return findIndex(keys, a) - findIndex(keys, b);
      };
    }

    function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }

    let isObject = obj => Object.prototype.toString.call(obj) === '[object Object]';

    function unknown(ctx, value) {
      let known = Object.keys(ctx.fields);
      return Object.keys(value).filter(key => known.indexOf(key) === -1);
    }

    const defaultSort = sortByKeyOrder([]);
    class ObjectSchema extends BaseSchema {
      constructor(spec) {
        super({
          type: 'object'
        });
        this.fields = Object.create(null);
        this._sortErrors = defaultSort;
        this._nodes = [];
        this._excludedEdges = [];
        this.withMutation(() => {
          this.transform(function coerce(value) {
            if (typeof value === 'string') {
              try {
                value = JSON.parse(value);
              } catch (err) {
                value = null;
              }
            }

            if (this.isType(value)) return value;
            return null;
          });

          if (spec) {
            this.shape(spec);
          }
        });
      }

      _typeCheck(value) {
        return isObject(value) || typeof value === 'function';
      }

      _cast(_value, options = {}) {
        var _options$stripUnknown;

        let value = super._cast(_value, options); //should ignore nulls here


        if (value === undefined) return this.getDefault();
        if (!this._typeCheck(value)) return value;
        let fields = this.fields;
        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;

        let props = this._nodes.concat(Object.keys(value).filter(v => this._nodes.indexOf(v) === -1));

        let intermediateValue = {}; // is filled during the transform below

        let innerOptions = _extends$1({}, options, {
          parent: intermediateValue,
          __validating: options.__validating || false
        });

        let isChanged = false;

        for (const prop of props) {
          let field = fields[prop];
          let exists = has_1(value, prop);

          if (field) {
            let fieldValue;
            let inputValue = value[prop]; // safe to mutate since this is fired in sequence

            innerOptions.path = (options.path ? `${options.path}.` : '') + prop; // innerOptions.value = value[prop];

            field = field.resolve({
              value: inputValue,
              context: options.context,
              parent: intermediateValue
            });
            let fieldSpec = 'spec' in field ? field.spec : undefined;
            let strict = fieldSpec == null ? void 0 : fieldSpec.strict;

            if (fieldSpec == null ? void 0 : fieldSpec.strip) {
              isChanged = isChanged || prop in value;
              continue;
            }

            fieldValue = !options.__validating || !strict ? // TODO: use _cast, this is double resolving
            field.cast(value[prop], innerOptions) : value[prop];

            if (fieldValue !== undefined) {
              intermediateValue[prop] = fieldValue;
            }
          } else if (exists && !strip) {
            intermediateValue[prop] = value[prop];
          }

          if (intermediateValue[prop] !== value[prop]) {
            isChanged = true;
          }
        }

        return isChanged ? intermediateValue : value;
      }

      _validate(_value, opts = {}, callback) {
        let errors = [];
        let {
          sync,
          from = [],
          originalValue = _value,
          abortEarly = this.spec.abortEarly,
          recursive = this.spec.recursive
        } = opts;
        from = [{
          schema: this,
          value: originalValue
        }, ...from]; // this flag is needed for handling `strict` correctly in the context of
        // validation vs just casting. e.g strict() on a field is only used when validating

        opts.__validating = true;
        opts.originalValue = originalValue;
        opts.from = from;

        super._validate(_value, opts, (err, value) => {
          if (err) {
            if (!ValidationError.isError(err) || abortEarly) {
              return void callback(err, value);
            }

            errors.push(err);
          }

          if (!recursive || !isObject(value)) {
            callback(errors[0] || null, value);
            return;
          }

          originalValue = originalValue || value;

          let tests = this._nodes.map(key => (_, cb) => {
            let path = key.indexOf('.') === -1 ? (opts.path ? `${opts.path}.` : '') + key : `${opts.path || ''}["${key}"]`;
            let field = this.fields[key];

            if (field && 'validate' in field) {
              field.validate(value[key], _extends$1({}, opts, {
                // @ts-ignore
                path,
                from,
                // inner fields are always strict:
                // 1. this isn't strict so the casting will also have cast inner values
                // 2. this is strict in which case the nested values weren't cast either
                strict: true,
                parent: value,
                originalValue: originalValue[key]
              }), cb);
              return;
            }

            cb(null);
          });

          runTests({
            sync,
            tests,
            value,
            errors,
            endEarly: abortEarly,
            sort: this._sortErrors,
            path: opts.path
          }, callback);
        });
      }

      clone(spec) {
        const next = super.clone(spec);
        next.fields = _extends$1({}, this.fields);
        next._nodes = this._nodes;
        next._excludedEdges = this._excludedEdges;
        next._sortErrors = this._sortErrors;
        return next;
      }

      concat(schema) {
        let next = super.concat(schema);
        let nextFields = next.fields;

        for (let [field, schemaOrRef] of Object.entries(this.fields)) {
          const target = nextFields[field];

          if (target === undefined) {
            nextFields[field] = schemaOrRef;
          } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {
            nextFields[field] = schemaOrRef.concat(target);
          }
        }

        return next.withMutation(() => next.shape(nextFields, this._excludedEdges));
      }

      getDefaultFromShape() {
        let dft = {};

        this._nodes.forEach(key => {
          const field = this.fields[key];
          dft[key] = 'default' in field ? field.getDefault() : undefined;
        });

        return dft;
      }

      _getDefault() {
        if ('default' in this.spec) {
          return super._getDefault();
        } // if there is no default set invent one


        if (!this._nodes.length) {
          return undefined;
        }

        return this.getDefaultFromShape();
      }

      shape(additions, excludes = []) {
        let next = this.clone();
        let fields = Object.assign(next.fields, additions);
        next.fields = fields;
        next._sortErrors = sortByKeyOrder(Object.keys(fields));

        if (excludes.length) {
          // this is a convenience for when users only supply a single pair
          if (!Array.isArray(excludes[0])) excludes = [excludes];
          next._excludedEdges = [...next._excludedEdges, ...excludes];
        }

        next._nodes = sortFields(fields, next._excludedEdges);
        return next;
      }

      pick(keys) {
        const picked = {};

        for (const key of keys) {
          if (this.fields[key]) picked[key] = this.fields[key];
        }

        return this.clone().withMutation(next => {
          next.fields = {};
          return next.shape(picked);
        });
      }

      omit(keys) {
        const next = this.clone();
        const fields = next.fields;
        next.fields = {};

        for (const key of keys) {
          delete fields[key];
        }

        return next.withMutation(() => next.shape(fields));
      }

      from(from, to, alias) {
        let fromGetter = propertyExpr.getter(from, true);
        return this.transform(obj => {
          if (obj == null) return obj;
          let newObj = obj;

          if (has_1(obj, from)) {
            newObj = _extends$1({}, obj);
            if (!alias) delete newObj[from];
            newObj[to] = fromGetter(obj);
          }

          return newObj;
        });
      }

      noUnknown(noAllow = true, message = object$2.noUnknown) {
        if (typeof noAllow === 'string') {
          message = noAllow;
          noAllow = true;
        }

        let next = this.test({
          name: 'noUnknown',
          exclusive: true,
          message: message,

          test(value) {
            if (value == null) return true;
            const unknownKeys = unknown(this.schema, value);
            return !noAllow || unknownKeys.length === 0 || this.createError({
              params: {
                unknown: unknownKeys.join(', ')
              }
            });
          }

        });
        next.spec.noUnknown = noAllow;
        return next;
      }

      unknown(allow = true, message = object$2.noUnknown) {
        return this.noUnknown(!allow, message);
      }

      transformKeys(fn) {
        return this.transform(obj => obj && mapKeys_1(obj, (_, key) => fn(key)));
      }

      camelCase() {
        return this.transformKeys(camelCase_1);
      }

      snakeCase() {
        return this.transformKeys(snakeCase_1);
      }

      constantCase() {
        return this.transformKeys(key => snakeCase_1(key).toUpperCase());
      }

      describe() {
        let base = super.describe();
        base.fields = mapValues_1(this.fields, value => value.describe());
        return base;
      }

    }
    function create$4(spec) {
      return new ObjectSchema(spec);
    }
    create$4.prototype = ObjectSchema.prototype;

    function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
    function create$3(type) {
      return new ArraySchema(type);
    }
    class ArraySchema extends BaseSchema {
      constructor(type) {
        super({
          type: 'array'
        }); // `undefined` specifically means uninitialized, as opposed to
        // "no subtype"

        this.innerType = void 0;
        this.innerType = type;
        this.withMutation(() => {
          this.transform(function (values) {
            if (typeof values === 'string') try {
              values = JSON.parse(values);
            } catch (err) {
              values = null;
            }
            return this.isType(values) ? values : null;
          });
        });
      }

      _typeCheck(v) {
        return Array.isArray(v);
      }

      get _subType() {
        return this.innerType;
      }

      _cast(_value, _opts) {
        const value = super._cast(_value, _opts); //should ignore nulls here


        if (!this._typeCheck(value) || !this.innerType) return value;
        let isChanged = false;
        const castArray = value.map((v, idx) => {
          const castElement = this.innerType.cast(v, _extends({}, _opts, {
            path: `${_opts.path || ''}[${idx}]`
          }));

          if (castElement !== v) {
            isChanged = true;
          }

          return castElement;
        });
        return isChanged ? castArray : value;
      }

      _validate(_value, options = {}, callback) {
        var _options$abortEarly, _options$recursive;

        let errors = [];
        let sync = options.sync;
        let path = options.path;
        let innerType = this.innerType;
        let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
        let originalValue = options.originalValue != null ? options.originalValue : _value;

        super._validate(_value, options, (err, value) => {
          if (err) {
            if (!ValidationError.isError(err) || endEarly) {
              return void callback(err, value);
            }

            errors.push(err);
          }

          if (!recursive || !innerType || !this._typeCheck(value)) {
            callback(errors[0] || null, value);
            return;
          }

          originalValue = originalValue || value; // #950 Ensure that sparse array empty slots are validated

          let tests = new Array(value.length);

          for (let idx = 0; idx < value.length; idx++) {
            let item = value[idx];
            let path = `${options.path || ''}[${idx}]`; // object._validate note for isStrict explanation

            let innerOptions = _extends({}, options, {
              path,
              strict: true,
              parent: value,
              index: idx,
              originalValue: originalValue[idx]
            });

            tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);
          }

          runTests({
            sync,
            path,
            value,
            errors,
            endEarly,
            tests
          }, callback);
        });
      }

      clone(spec) {
        const next = super.clone(spec);
        next.innerType = this.innerType;
        return next;
      }

      concat(schema) {
        let next = super.concat(schema);
        next.innerType = this.innerType;
        if (schema.innerType) next.innerType = next.innerType ? // @ts-expect-error Lazy doesn't have concat()
        next.innerType.concat(schema.innerType) : schema.innerType;
        return next;
      }

      of(schema) {
        // FIXME: this should return a new instance of array without the default to be
        let next = this.clone();
        if (!isSchema(schema)) throw new TypeError('`array.of()` sub-schema must be a valid yup schema not: ' + printValue(schema)); // FIXME(ts):

        next.innerType = schema;
        return next;
      }

      length(length, message = array$7.length) {
        return this.test({
          message,
          name: 'length',
          exclusive: true,
          params: {
            length
          },

          test(value) {
            return isAbsent(value) || value.length === this.resolve(length);
          }

        });
      }

      min(min, message) {
        message = message || array$7.min;
        return this.test({
          message,
          name: 'min',
          exclusive: true,
          params: {
            min
          },

          // FIXME(ts): Array<typeof T>
          test(value) {
            return isAbsent(value) || value.length >= this.resolve(min);
          }

        });
      }

      max(max, message) {
        message = message || array$7.max;
        return this.test({
          message,
          name: 'max',
          exclusive: true,
          params: {
            max
          },

          test(value) {
            return isAbsent(value) || value.length <= this.resolve(max);
          }

        });
      }

      ensure() {
        return this.default(() => []).transform((val, original) => {
          // We don't want to return `null` for nullable schema
          if (this._typeCheck(val)) return val;
          return original == null ? [] : [].concat(original);
        });
      }

      compact(rejector) {
        let reject = !rejector ? v => !!v : (v, i, a) => !rejector(v, i, a);
        return this.transform(values => values != null ? values.filter(reject) : values);
      }

      describe() {
        let base = super.describe();
        if (this.innerType) base.innerType = this.innerType.describe();
        return base;
      }

      nullable(isNullable = true) {
        return super.nullable(isNullable);
      }

      defined() {
        return super.defined();
      }

      required(msg) {
        return super.required(msg);
      }

    }
    create$3.prototype = ArraySchema.prototype; //
    // Interfaces
    //

    function create$2(builder) {
      return new Lazy(builder);
    }

    class Lazy {
      constructor(builder) {
        this.type = 'lazy';
        this.__isYupSchema__ = true;
        this.__inputType = void 0;
        this.__outputType = void 0;

        this._resolve = (value, options = {}) => {
          let schema = this.builder(value, options);
          if (!isSchema(schema)) throw new TypeError('lazy() functions must return a valid schema');
          return schema.resolve(options);
        };

        this.builder = builder;
      }

      resolve(options) {
        return this._resolve(options.value, options);
      }

      cast(value, options) {
        return this._resolve(value, options).cast(value, options);
      }

      validate(value, options, maybeCb) {
        // @ts-expect-error missing public callback on type
        return this._resolve(value, options).validate(value, options, maybeCb);
      }

      validateSync(value, options) {
        return this._resolve(value, options).validateSync(value, options);
      }

      validateAt(path, value, options) {
        return this._resolve(value, options).validateAt(path, value, options);
      }

      validateSyncAt(path, value, options) {
        return this._resolve(value, options).validateSyncAt(path, value, options);
      }

      describe() {
        return null;
      }

      isValid(value, options) {
        return this._resolve(value, options).isValid(value, options);
      }

      isValidSync(value, options) {
        return this._resolve(value, options).isValidSync(value, options);
      }

    }

    function setLocale(custom) {
      Object.keys(custom).forEach(type => {
        // @ts-ignore
        Object.keys(custom[type]).forEach(method => {
          // @ts-ignore
          locale$2[type][method] = custom[type][method];
        });
      });
    }

    function addMethod(schemaType, name, fn) {
      if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError('You must provide a yup schema constructor function');
      if (typeof name !== 'string') throw new TypeError('A Method name must be provided');
      if (typeof fn !== 'function') throw new TypeError('Method function must be provided');
      schemaType.prototype[name] = fn;
    }

    var yup = /*#__PURE__*/Object.freeze({
        __proto__: null,
        mixed: create$9,
        bool: create$8,
        boolean: create$8,
        string: create$7,
        number: create$6,
        date: create$5,
        object: create$4,
        array: create$3,
        ref: create$a,
        lazy: create$2,
        reach: reach,
        isSchema: isSchema,
        addMethod: addMethod,
        setLocale: setLocale,
        ValidationError: ValidationError,
        BaseSchema: BaseSchema,
        MixedSchema: Mixed,
        BooleanSchema: BooleanSchema,
        StringSchema: StringSchema,
        NumberSchema: NumberSchema,
        DateSchema: DateSchema,
        ObjectSchema: ObjectSchema,
        ArraySchema: ArraySchema
    });

    const HOOKS = [
        "onChange",
        "onClose",
        "onDayCreate",
        "onDestroy",
        "onKeyDown",
        "onMonthChange",
        "onOpen",
        "onParseConfig",
        "onReady",
        "onValueUpdate",
        "onYearChange",
        "onPreCalendarPosition",
    ];
    const defaults = {
        _disable: [],
        allowInput: false,
        allowInvalidPreload: false,
        altFormat: "F j, Y",
        altInput: false,
        altInputClass: "form-control input",
        animate: typeof window === "object" &&
            window.navigator.userAgent.indexOf("MSIE") === -1,
        ariaDateFormat: "F j, Y",
        autoFillDefaultTime: true,
        clickOpens: true,
        closeOnSelect: true,
        conjunction: ", ",
        dateFormat: "Y-m-d",
        defaultHour: 12,
        defaultMinute: 0,
        defaultSeconds: 0,
        disable: [],
        disableMobile: false,
        enableSeconds: false,
        enableTime: false,
        errorHandler: (err) => typeof console !== "undefined" && console.warn(err),
        getWeek: (givenDate) => {
            const date = new Date(givenDate.getTime());
            date.setHours(0, 0, 0, 0);
            date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
            var week1 = new Date(date.getFullYear(), 0, 4);
            return (1 +
                Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                    3 +
                    ((week1.getDay() + 6) % 7)) /
                    7));
        },
        hourIncrement: 1,
        ignoredFocusElements: [],
        inline: false,
        locale: "default",
        minuteIncrement: 5,
        mode: "single",
        monthSelectorType: "dropdown",
        nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
        noCalendar: false,
        now: new Date(),
        onChange: [],
        onClose: [],
        onDayCreate: [],
        onDestroy: [],
        onKeyDown: [],
        onMonthChange: [],
        onOpen: [],
        onParseConfig: [],
        onReady: [],
        onValueUpdate: [],
        onYearChange: [],
        onPreCalendarPosition: [],
        plugins: [],
        position: "auto",
        positionElement: undefined,
        prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
        shorthandCurrentMonth: false,
        showMonths: 1,
        static: false,
        time_24hr: false,
        weekNumbers: false,
        wrap: false,
    };

    const english = {
        weekdays: {
            shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
            longhand: [
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
            ],
        },
        months: {
            shorthand: [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
            ],
            longhand: [
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
            ],
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: (nth) => {
            const s = nth % 100;
            if (s > 3 && s < 21)
                return "th";
            switch (s % 10) {
                case 1:
                    return "st";
                case 2:
                    return "nd";
                case 3:
                    return "rd";
                default:
                    return "th";
            }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        monthAriaLabel: "Month",
        hourAriaLabel: "Hour",
        minuteAriaLabel: "Minute",
        time_24hr: false,
    };

    const pad$2 = (number, length = 2) => `000${number}`.slice(length * -1);
    const int$1 = (bool) => (bool === true ? 1 : 0);
    function debounce(fn, wait) {
        let t;
        return function () {
            clearTimeout(t);
            t = setTimeout(() => fn.apply(this, arguments), wait);
        };
    }
    const arrayify$1 = (obj) => obj instanceof Array ? obj : [obj];

    function toggleClass(elem, className, bool) {
        if (bool === true)
            return elem.classList.add(className);
        elem.classList.remove(className);
    }
    function createElement(tag, className, content) {
        const e = window.document.createElement(tag);
        className = className || "";
        content = content || "";
        e.className = className;
        if (content !== undefined)
            e.textContent = content;
        return e;
    }
    function clearNode(node) {
        while (node.firstChild)
            node.removeChild(node.firstChild);
    }
    function findParent(node, condition) {
        if (condition(node))
            return node;
        else if (node.parentNode)
            return findParent(node.parentNode, condition);
        return undefined;
    }
    function createNumberInput(inputClassName, opts) {
        const wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
        if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
            numInput.type = "number";
        }
        else {
            numInput.type = "text";
            numInput.pattern = "\\d*";
        }
        if (opts !== undefined)
            for (const key in opts)
                numInput.setAttribute(key, opts[key]);
        wrapper.appendChild(numInput);
        wrapper.appendChild(arrowUp);
        wrapper.appendChild(arrowDown);
        return wrapper;
    }
    function getEventTarget(event) {
        try {
            if (typeof event.composedPath === "function") {
                const path = event.composedPath();
                return path[0];
            }
            return event.target;
        }
        catch (error) {
            return event.target;
        }
    }

    const doNothing = () => undefined;
    const monthToStr = (monthNumber, shorthand, locale) => locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
    const revFormat = {
        D: doNothing,
        F: function (dateObj, monthName, locale) {
            dateObj.setMonth(locale.months.longhand.indexOf(monthName));
        },
        G: (dateObj, hour) => {
            dateObj.setHours(parseFloat(hour));
        },
        H: (dateObj, hour) => {
            dateObj.setHours(parseFloat(hour));
        },
        J: (dateObj, day) => {
            dateObj.setDate(parseFloat(day));
        },
        K: (dateObj, amPM, locale) => {
            dateObj.setHours((dateObj.getHours() % 12) +
                12 * int$1(new RegExp(locale.amPM[1], "i").test(amPM)));
        },
        M: function (dateObj, shortMonth, locale) {
            dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
        },
        S: (dateObj, seconds) => {
            dateObj.setSeconds(parseFloat(seconds));
        },
        U: (_, unixSeconds) => new Date(parseFloat(unixSeconds) * 1000),
        W: function (dateObj, weekNum, locale) {
            const weekNumber = parseInt(weekNum);
            const date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
            date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
            return date;
        },
        Y: (dateObj, year) => {
            dateObj.setFullYear(parseFloat(year));
        },
        Z: (_, ISODate) => new Date(ISODate),
        d: (dateObj, day) => {
            dateObj.setDate(parseFloat(day));
        },
        h: (dateObj, hour) => {
            dateObj.setHours(parseFloat(hour));
        },
        i: (dateObj, minutes) => {
            dateObj.setMinutes(parseFloat(minutes));
        },
        j: (dateObj, day) => {
            dateObj.setDate(parseFloat(day));
        },
        l: doNothing,
        m: (dateObj, month) => {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        n: (dateObj, month) => {
            dateObj.setMonth(parseFloat(month) - 1);
        },
        s: (dateObj, seconds) => {
            dateObj.setSeconds(parseFloat(seconds));
        },
        u: (_, unixMillSeconds) => new Date(parseFloat(unixMillSeconds)),
        w: doNothing,
        y: (dateObj, year) => {
            dateObj.setFullYear(2000 + parseFloat(year));
        },
    };
    const tokenRegex = {
        D: "(\\w+)",
        F: "(\\w+)",
        G: "(\\d\\d|\\d)",
        H: "(\\d\\d|\\d)",
        J: "(\\d\\d|\\d)\\w+",
        K: "",
        M: "(\\w+)",
        S: "(\\d\\d|\\d)",
        U: "(.+)",
        W: "(\\d\\d|\\d)",
        Y: "(\\d{4})",
        Z: "(.+)",
        d: "(\\d\\d|\\d)",
        h: "(\\d\\d|\\d)",
        i: "(\\d\\d|\\d)",
        j: "(\\d\\d|\\d)",
        l: "(\\w+)",
        m: "(\\d\\d|\\d)",
        n: "(\\d\\d|\\d)",
        s: "(\\d\\d|\\d)",
        u: "(.+)",
        w: "(\\d\\d|\\d)",
        y: "(\\d{2})",
    };
    const formats = {
        Z: (date) => date.toISOString(),
        D: function (date, locale, options) {
            return locale.weekdays.shorthand[formats.w(date, locale, options)];
        },
        F: function (date, locale, options) {
            return monthToStr(formats.n(date, locale, options) - 1, false, locale);
        },
        G: function (date, locale, options) {
            return pad$2(formats.h(date, locale, options));
        },
        H: (date) => pad$2(date.getHours()),
        J: function (date, locale) {
            return locale.ordinal !== undefined
                ? date.getDate() + locale.ordinal(date.getDate())
                : date.getDate();
        },
        K: (date, locale) => locale.amPM[int$1(date.getHours() > 11)],
        M: function (date, locale) {
            return monthToStr(date.getMonth(), true, locale);
        },
        S: (date) => pad$2(date.getSeconds()),
        U: (date) => date.getTime() / 1000,
        W: function (date, _, options) {
            return options.getWeek(date);
        },
        Y: (date) => pad$2(date.getFullYear(), 4),
        d: (date) => pad$2(date.getDate()),
        h: (date) => (date.getHours() % 12 ? date.getHours() % 12 : 12),
        i: (date) => pad$2(date.getMinutes()),
        j: (date) => date.getDate(),
        l: function (date, locale) {
            return locale.weekdays.longhand[date.getDay()];
        },
        m: (date) => pad$2(date.getMonth() + 1),
        n: (date) => date.getMonth() + 1,
        s: (date) => date.getSeconds(),
        u: (date) => date.getTime(),
        w: (date) => date.getDay(),
        y: (date) => String(date.getFullYear()).substring(2),
    };

    const createDateFormatter = ({ config = defaults, l10n = english, isMobile = false, }) => (dateObj, frmt, overrideLocale) => {
        const locale = overrideLocale || l10n;
        if (config.formatDate !== undefined && !isMobile) {
            return config.formatDate(dateObj, frmt, locale);
        }
        return frmt
            .split("")
            .map((c, i, arr) => formats[c] && arr[i - 1] !== "\\"
            ? formats[c](dateObj, locale, config)
            : c !== "\\"
                ? c
                : "")
            .join("");
    };
    const createDateParser = ({ config = defaults, l10n = english }) => (date, givenFormat, timeless, customLocale) => {
        if (date !== 0 && !date)
            return undefined;
        const locale = customLocale || l10n;
        let parsedDate;
        const dateOrig = date;
        if (date instanceof Date)
            parsedDate = new Date(date.getTime());
        else if (typeof date !== "string" &&
            date.toFixed !== undefined)
            parsedDate = new Date(date);
        else if (typeof date === "string") {
            const format = givenFormat || (config || defaults).dateFormat;
            const datestr = String(date).trim();
            if (datestr === "today") {
                parsedDate = new Date();
                timeless = true;
            }
            else if (/Z$/.test(datestr) ||
                /GMT$/.test(datestr))
                parsedDate = new Date(date);
            else if (config && config.parseDate)
                parsedDate = config.parseDate(date, format);
            else {
                parsedDate =
                    !config || !config.noCalendar
                        ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                        : new Date(new Date().setHours(0, 0, 0, 0));
                let matched, ops = [];
                for (let i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                    const token = format[i];
                    const isBackSlash = token === "\\";
                    const escaped = format[i - 1] === "\\" || isBackSlash;
                    if (tokenRegex[token] && !escaped) {
                        regexStr += tokenRegex[token];
                        const match = new RegExp(regexStr).exec(date);
                        if (match && (matched = true)) {
                            ops[token !== "Y" ? "push" : "unshift"]({
                                fn: revFormat[token],
                                val: match[++matchIndex],
                            });
                        }
                    }
                    else if (!isBackSlash)
                        regexStr += ".";
                    ops.forEach(({ fn, val }) => (parsedDate = fn(parsedDate, val, locale) || parsedDate));
                }
                parsedDate = matched ? parsedDate : undefined;
            }
        }
        if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
            config.errorHandler(new Error(`Invalid date provided: ${dateOrig}`));
            return undefined;
        }
        if (timeless === true)
            parsedDate.setHours(0, 0, 0, 0);
        return parsedDate;
    };
    function compareDates(date1, date2, timeless = true) {
        if (timeless !== false) {
            return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
                new Date(date2.getTime()).setHours(0, 0, 0, 0));
        }
        return date1.getTime() - date2.getTime();
    }
    const isBetween = (ts, ts1, ts2) => {
        return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
    };
    const duration = {
        DAY: 86400000,
    };
    function getDefaultHours(config) {
        let hours = config.defaultHour;
        let minutes = config.defaultMinute;
        let seconds = config.defaultSeconds;
        if (config.minDate !== undefined) {
            const minHour = config.minDate.getHours();
            const minMinutes = config.minDate.getMinutes();
            const minSeconds = config.minDate.getSeconds();
            if (hours < minHour) {
                hours = minHour;
            }
            if (hours === minHour && minutes < minMinutes) {
                minutes = minMinutes;
            }
            if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
                seconds = config.minDate.getSeconds();
        }
        if (config.maxDate !== undefined) {
            const maxHr = config.maxDate.getHours();
            const maxMinutes = config.maxDate.getMinutes();
            hours = Math.min(hours, maxHr);
            if (hours === maxHr)
                minutes = Math.min(maxMinutes, minutes);
            if (hours === maxHr && minutes === maxMinutes)
                seconds = config.maxDate.getSeconds();
        }
        return { hours, minutes, seconds };
    }

    if (typeof Object.assign !== "function") {
        Object.assign = function (target, ...args) {
            if (!target) {
                throw TypeError("Cannot convert undefined or null to object");
            }
            for (const source of args) {
                if (source) {
                    Object.keys(source).forEach((key) => (target[key] = source[key]));
                }
            }
            return target;
        };
    }

    const DEBOUNCED_CHANGE_MS = 300;
    function FlatpickrInstance(element, instanceConfig) {
        const self = {
            config: Object.assign(Object.assign({}, defaults), flatpickr.defaultConfig),
            l10n: english,
        };
        self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        self._handlers = [];
        self.pluginElements = [];
        self.loadedPlugins = [];
        self._bind = bind;
        self._setHoursFromDate = setHoursFromDate;
        self._positionCalendar = positionCalendar;
        self.changeMonth = changeMonth;
        self.changeYear = changeYear;
        self.clear = clear;
        self.close = close;
        self._createElement = createElement;
        self.destroy = destroy;
        self.isEnabled = isEnabled;
        self.jumpToDate = jumpToDate;
        self.open = open;
        self.redraw = redraw;
        self.set = set;
        self.setDate = setDate;
        self.toggle = toggle;
        function setupHelperFunctions() {
            self.utils = {
                getDaysInMonth(month = self.currentMonth, yr = self.currentYear) {
                    if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                        return 29;
                    return self.l10n.daysInMonth[month];
                },
            };
        }
        function init() {
            self.element = self.input = element;
            self.isOpen = false;
            parseConfig();
            setupLocale();
            setupInputs();
            setupDates();
            setupHelperFunctions();
            if (!self.isMobile)
                build();
            bindEvents();
            if (self.selectedDates.length || self.config.noCalendar) {
                if (self.config.enableTime) {
                    setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : undefined);
                }
                updateValue(false);
            }
            setCalendarWidth();
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            if (!self.isMobile && isSafari) {
                positionCalendar();
            }
            triggerEvent("onReady");
        }
        function bindToInstance(fn) {
            return fn.bind(self);
        }
        function setCalendarWidth() {
            const config = self.config;
            if (config.weekNumbers === false && config.showMonths === 1) {
                return;
            }
            else if (config.noCalendar !== true) {
                window.requestAnimationFrame(function () {
                    if (self.calendarContainer !== undefined) {
                        self.calendarContainer.style.visibility = "hidden";
                        self.calendarContainer.style.display = "block";
                    }
                    if (self.daysContainer !== undefined) {
                        const daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                        self.daysContainer.style.width = daysWidth + "px";
                        self.calendarContainer.style.width =
                            daysWidth +
                                (self.weekWrapper !== undefined
                                    ? self.weekWrapper.offsetWidth
                                    : 0) +
                                "px";
                        self.calendarContainer.style.removeProperty("visibility");
                        self.calendarContainer.style.removeProperty("display");
                    }
                });
            }
        }
        function updateTime(e) {
            if (self.selectedDates.length === 0) {
                const defaultDate = self.config.minDate === undefined ||
                    compareDates(new Date(), self.config.minDate) >= 0
                    ? new Date()
                    : new Date(self.config.minDate.getTime());
                const defaults = getDefaultHours(self.config);
                defaultDate.setHours(defaults.hours, defaults.minutes, defaults.seconds, defaultDate.getMilliseconds());
                self.selectedDates = [defaultDate];
                self.latestSelectedDateObj = defaultDate;
            }
            if (e !== undefined && e.type !== "blur") {
                timeWrapper(e);
            }
            const prevValue = self._input.value;
            setHoursFromInputs();
            updateValue();
            if (self._input.value !== prevValue) {
                self._debouncedChange();
            }
        }
        function ampm2military(hour, amPM) {
            return (hour % 12) + 12 * int$1(amPM === self.l10n.amPM[1]);
        }
        function military2ampm(hour) {
            switch (hour % 24) {
                case 0:
                case 12:
                    return 12;
                default:
                    return hour % 12;
            }
        }
        function setHoursFromInputs() {
            if (self.hourElement === undefined || self.minuteElement === undefined)
                return;
            let hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
                ? (parseInt(self.secondElement.value, 10) || 0) % 60
                : 0;
            if (self.amPM !== undefined) {
                hours = ampm2military(hours, self.amPM.textContent);
            }
            const limitMinHours = self.config.minTime !== undefined ||
                (self.config.minDate &&
                    self.minDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                        0);
            const limitMaxHours = self.config.maxTime !== undefined ||
                (self.config.maxDate &&
                    self.maxDateHasTime &&
                    self.latestSelectedDateObj &&
                    compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                        0);
            if (limitMaxHours) {
                const maxTime = self.config.maxTime !== undefined
                    ? self.config.maxTime
                    : self.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours())
                    minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes())
                    seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
                const minTime = self.config.minTime !== undefined
                    ? self.config.minTime
                    : self.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours() && minutes < minTime.getMinutes())
                    minutes = minTime.getMinutes();
                if (minutes === minTime.getMinutes())
                    seconds = Math.max(seconds, minTime.getSeconds());
            }
            setHours(hours, minutes, seconds);
        }
        function setHoursFromDate(dateObj) {
            const date = dateObj || self.latestSelectedDateObj;
            if (date) {
                setHours(date.getHours(), date.getMinutes(), date.getSeconds());
            }
        }
        function setHours(hours, minutes, seconds) {
            if (self.latestSelectedDateObj !== undefined) {
                self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
            }
            if (!self.hourElement || !self.minuteElement || self.isMobile)
                return;
            self.hourElement.value = pad$2(!self.config.time_24hr
                ? ((12 + hours) % 12) + 12 * int$1(hours % 12 === 0)
                : hours);
            self.minuteElement.value = pad$2(minutes);
            if (self.amPM !== undefined)
                self.amPM.textContent = self.l10n.amPM[int$1(hours >= 12)];
            if (self.secondElement !== undefined)
                self.secondElement.value = pad$2(seconds);
        }
        function onYearInput(event) {
            const eventTarget = getEventTarget(event);
            const year = parseInt(eventTarget.value) + (event.delta || 0);
            if (year / 1000 > 1 ||
                (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
                changeYear(year);
            }
        }
        function bind(element, event, handler, options) {
            if (event instanceof Array)
                return event.forEach((ev) => bind(element, ev, handler, options));
            if (element instanceof Array)
                return element.forEach((el) => bind(el, event, handler, options));
            element.addEventListener(event, handler, options);
            self._handlers.push({
                remove: () => element.removeEventListener(event, handler),
            });
        }
        function triggerChange() {
            triggerEvent("onChange");
        }
        function bindEvents() {
            if (self.config.wrap) {
                ["open", "close", "toggle", "clear"].forEach((evt) => {
                    Array.prototype.forEach.call(self.element.querySelectorAll(`[data-${evt}]`), (el) => bind(el, "click", self[evt]));
                });
            }
            if (self.isMobile) {
                setupMobile();
                return;
            }
            const debouncedResize = debounce(onResize, 50);
            self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
            if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
                bind(self.daysContainer, "mouseover", (e) => {
                    if (self.config.mode === "range")
                        onMouseOver(getEventTarget(e));
                });
            bind(window.document.body, "keydown", onKeyDown);
            if (!self.config.inline && !self.config.static)
                bind(window, "resize", debouncedResize);
            if (window.ontouchstart !== undefined)
                bind(window.document, "touchstart", documentClick);
            else
                bind(window.document, "mousedown", documentClick);
            bind(window.document, "focus", documentClick, { capture: true });
            if (self.config.clickOpens === true) {
                bind(self._input, "focus", self.open);
                bind(self._input, "click", self.open);
            }
            if (self.daysContainer !== undefined) {
                bind(self.monthNav, "click", onMonthNavClick);
                bind(self.monthNav, ["keyup", "increment"], onYearInput);
                bind(self.daysContainer, "click", selectDate);
            }
            if (self.timeContainer !== undefined &&
                self.minuteElement !== undefined &&
                self.hourElement !== undefined) {
                const selText = (e) => getEventTarget(e).select();
                bind(self.timeContainer, ["increment"], updateTime);
                bind(self.timeContainer, "blur", updateTime, { capture: true });
                bind(self.timeContainer, "click", timeIncrement);
                bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
                if (self.secondElement !== undefined)
                    bind(self.secondElement, "focus", () => self.secondElement && self.secondElement.select());
                if (self.amPM !== undefined) {
                    bind(self.amPM, "click", (e) => {
                        updateTime(e);
                        triggerChange();
                    });
                }
            }
            if (self.config.allowInput) {
                bind(self._input, "blur", onBlur);
            }
        }
        function jumpToDate(jumpDate, triggerChange) {
            const jumpTo = jumpDate !== undefined
                ? self.parseDate(jumpDate)
                : self.latestSelectedDateObj ||
                    (self.config.minDate && self.config.minDate > self.now
                        ? self.config.minDate
                        : self.config.maxDate && self.config.maxDate < self.now
                            ? self.config.maxDate
                            : self.now);
            const oldYear = self.currentYear;
            const oldMonth = self.currentMonth;
            try {
                if (jumpTo !== undefined) {
                    self.currentYear = jumpTo.getFullYear();
                    self.currentMonth = jumpTo.getMonth();
                }
            }
            catch (e) {
                e.message = "Invalid date supplied: " + jumpTo;
                self.config.errorHandler(e);
            }
            if (triggerChange && self.currentYear !== oldYear) {
                triggerEvent("onYearChange");
                buildMonthSwitch();
            }
            if (triggerChange &&
                (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
                triggerEvent("onMonthChange");
            }
            self.redraw();
        }
        function timeIncrement(e) {
            const eventTarget = getEventTarget(e);
            if (~eventTarget.className.indexOf("arrow"))
                incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
        }
        function incrementNumInput(e, delta, inputElem) {
            const target = e && getEventTarget(e);
            const input = inputElem ||
                (target && target.parentNode && target.parentNode.firstChild);
            const event = createEvent("increment");
            event.delta = delta;
            input && input.dispatchEvent(event);
        }
        function build() {
            const fragment = window.document.createDocumentFragment();
            self.calendarContainer = createElement("div", "flatpickr-calendar");
            self.calendarContainer.tabIndex = -1;
            if (!self.config.noCalendar) {
                fragment.appendChild(buildMonthNav());
                self.innerContainer = createElement("div", "flatpickr-innerContainer");
                if (self.config.weekNumbers) {
                    const { weekWrapper, weekNumbers } = buildWeeks();
                    self.innerContainer.appendChild(weekWrapper);
                    self.weekNumbers = weekNumbers;
                    self.weekWrapper = weekWrapper;
                }
                self.rContainer = createElement("div", "flatpickr-rContainer");
                self.rContainer.appendChild(buildWeekdays());
                if (!self.daysContainer) {
                    self.daysContainer = createElement("div", "flatpickr-days");
                    self.daysContainer.tabIndex = -1;
                }
                buildDays();
                self.rContainer.appendChild(self.daysContainer);
                self.innerContainer.appendChild(self.rContainer);
                fragment.appendChild(self.innerContainer);
            }
            if (self.config.enableTime) {
                fragment.appendChild(buildTime());
            }
            toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
            toggleClass(self.calendarContainer, "animate", self.config.animate === true);
            toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
            self.calendarContainer.appendChild(fragment);
            const customAppend = self.config.appendTo !== undefined &&
                self.config.appendTo.nodeType !== undefined;
            if (self.config.inline || self.config.static) {
                self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                if (self.config.inline) {
                    if (!customAppend && self.element.parentNode)
                        self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                    else if (self.config.appendTo !== undefined)
                        self.config.appendTo.appendChild(self.calendarContainer);
                }
                if (self.config.static) {
                    const wrapper = createElement("div", "flatpickr-wrapper");
                    if (self.element.parentNode)
                        self.element.parentNode.insertBefore(wrapper, self.element);
                    wrapper.appendChild(self.element);
                    if (self.altInput)
                        wrapper.appendChild(self.altInput);
                    wrapper.appendChild(self.calendarContainer);
                }
            }
            if (!self.config.static && !self.config.inline)
                (self.config.appendTo !== undefined
                    ? self.config.appendTo
                    : window.document.body).appendChild(self.calendarContainer);
        }
        function createDay(className, date, dayNumber, i) {
            const dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
            dayElement.dateObj = date;
            dayElement.$i = i;
            dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
            if (className.indexOf("hidden") === -1 &&
                compareDates(date, self.now) === 0) {
                self.todayDateElem = dayElement;
                dayElement.classList.add("today");
                dayElement.setAttribute("aria-current", "date");
            }
            if (dateIsEnabled) {
                dayElement.tabIndex = -1;
                if (isDateSelected(date)) {
                    dayElement.classList.add("selected");
                    self.selectedDateElem = dayElement;
                    if (self.config.mode === "range") {
                        toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                            compareDates(date, self.selectedDates[0], true) === 0);
                        toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                            compareDates(date, self.selectedDates[1], true) === 0);
                        if (className === "nextMonthDay")
                            dayElement.classList.add("inRange");
                    }
                }
            }
            else {
                dayElement.classList.add("flatpickr-disabled");
            }
            if (self.config.mode === "range") {
                if (isDateInRange(date) && !isDateSelected(date))
                    dayElement.classList.add("inRange");
            }
            if (self.weekNumbers &&
                self.config.showMonths === 1 &&
                className !== "prevMonthDay" &&
                dayNumber % 7 === 1) {
                self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
            }
            triggerEvent("onDayCreate", dayElement);
            return dayElement;
        }
        function focusOnDayElem(targetNode) {
            targetNode.focus();
            if (self.config.mode === "range")
                onMouseOver(targetNode);
        }
        function getFirstAvailableDay(delta) {
            const startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
            const endMonth = delta > 0 ? self.config.showMonths : -1;
            for (let m = startMonth; m != endMonth; m += delta) {
                const month = self.daysContainer.children[m];
                const startIndex = delta > 0 ? 0 : month.children.length - 1;
                const endIndex = delta > 0 ? month.children.length : -1;
                for (let i = startIndex; i != endIndex; i += delta) {
                    const c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                        return c;
                }
            }
            return undefined;
        }
        function getNextAvailableDay(current, delta) {
            const givenMonth = current.className.indexOf("Month") === -1
                ? current.dateObj.getMonth()
                : self.currentMonth;
            const endMonth = delta > 0 ? self.config.showMonths : -1;
            const loopDelta = delta > 0 ? 1 : -1;
            for (let m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                const month = self.daysContainer.children[m];
                const startIndex = givenMonth - self.currentMonth === m
                    ? current.$i + delta
                    : delta < 0
                        ? month.children.length - 1
                        : 0;
                const numMonthDays = month.children.length;
                for (let i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                    const c = month.children[i];
                    if (c.className.indexOf("hidden") === -1 &&
                        isEnabled(c.dateObj) &&
                        Math.abs(current.$i - i) >= Math.abs(delta))
                        return focusOnDayElem(c);
                }
            }
            self.changeMonth(loopDelta);
            focusOnDay(getFirstAvailableDay(loopDelta), 0);
            return undefined;
        }
        function focusOnDay(current, offset) {
            const dayFocused = isInView(document.activeElement || document.body);
            const startElem = current !== undefined
                ? current
                : dayFocused
                    ? document.activeElement
                    : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                        ? self.selectedDateElem
                        : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                            ? self.todayDateElem
                            : getFirstAvailableDay(offset > 0 ? 1 : -1);
            if (startElem === undefined) {
                self._input.focus();
            }
            else if (!dayFocused) {
                focusOnDayElem(startElem);
            }
            else {
                getNextAvailableDay(startElem, offset);
            }
        }
        function buildMonthDays(year, month) {
            const firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
            const prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
            const daysInMonth = self.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
            let dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
            for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
                days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
            }
            for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
                days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
            }
            for (let dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
                (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
                days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
            }
            const dayContainer = createElement("div", "dayContainer");
            dayContainer.appendChild(days);
            return dayContainer;
        }
        function buildDays() {
            if (self.daysContainer === undefined) {
                return;
            }
            clearNode(self.daysContainer);
            if (self.weekNumbers)
                clearNode(self.weekNumbers);
            const frag = document.createDocumentFragment();
            for (let i = 0; i < self.config.showMonths; i++) {
                const d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
            }
            self.daysContainer.appendChild(frag);
            self.days = self.daysContainer.firstChild;
            if (self.config.mode === "range" && self.selectedDates.length === 1) {
                onMouseOver();
            }
        }
        function buildMonthSwitch() {
            if (self.config.showMonths > 1 ||
                self.config.monthSelectorType !== "dropdown")
                return;
            const shouldBuildMonth = function (month) {
                if (self.config.minDate !== undefined &&
                    self.currentYear === self.config.minDate.getFullYear() &&
                    month < self.config.minDate.getMonth()) {
                    return false;
                }
                return !(self.config.maxDate !== undefined &&
                    self.currentYear === self.config.maxDate.getFullYear() &&
                    month > self.config.maxDate.getMonth());
            };
            self.monthsDropdownContainer.tabIndex = -1;
            self.monthsDropdownContainer.innerHTML = "";
            for (let i = 0; i < 12; i++) {
                if (!shouldBuildMonth(i))
                    continue;
                const month = createElement("option", "flatpickr-monthDropdown-month");
                month.value = new Date(self.currentYear, i).getMonth().toString();
                month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
                month.tabIndex = -1;
                if (self.currentMonth === i) {
                    month.selected = true;
                }
                self.monthsDropdownContainer.appendChild(month);
            }
        }
        function buildMonth() {
            const container = createElement("div", "flatpickr-month");
            const monthNavFragment = window.document.createDocumentFragment();
            let monthElement;
            if (self.config.showMonths > 1 ||
                self.config.monthSelectorType === "static") {
                monthElement = createElement("span", "cur-month");
            }
            else {
                self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
                self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
                bind(self.monthsDropdownContainer, "change", (e) => {
                    const target = getEventTarget(e);
                    const selectedMonth = parseInt(target.value, 10);
                    self.changeMonth(selectedMonth - self.currentMonth);
                    triggerEvent("onMonthChange");
                });
                buildMonthSwitch();
                monthElement = self.monthsDropdownContainer;
            }
            const yearInput = createNumberInput("cur-year", { tabindex: "-1" });
            const yearElement = yearInput.getElementsByTagName("input")[0];
            yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
            if (self.config.minDate) {
                yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
            }
            if (self.config.maxDate) {
                yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                yearElement.disabled =
                    !!self.config.minDate &&
                        self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
            }
            const currentMonth = createElement("div", "flatpickr-current-month");
            currentMonth.appendChild(monthElement);
            currentMonth.appendChild(yearInput);
            monthNavFragment.appendChild(currentMonth);
            container.appendChild(monthNavFragment);
            return {
                container,
                yearElement,
                monthElement,
            };
        }
        function buildMonths() {
            clearNode(self.monthNav);
            self.monthNav.appendChild(self.prevMonthNav);
            if (self.config.showMonths) {
                self.yearElements = [];
                self.monthElements = [];
            }
            for (let m = self.config.showMonths; m--;) {
                const month = buildMonth();
                self.yearElements.push(month.yearElement);
                self.monthElements.push(month.monthElement);
                self.monthNav.appendChild(month.container);
            }
            self.monthNav.appendChild(self.nextMonthNav);
        }
        function buildMonthNav() {
            self.monthNav = createElement("div", "flatpickr-months");
            self.yearElements = [];
            self.monthElements = [];
            self.prevMonthNav = createElement("span", "flatpickr-prev-month");
            self.prevMonthNav.innerHTML = self.config.prevArrow;
            self.nextMonthNav = createElement("span", "flatpickr-next-month");
            self.nextMonthNav.innerHTML = self.config.nextArrow;
            buildMonths();
            Object.defineProperty(self, "_hidePrevMonthArrow", {
                get: () => self.__hidePrevMonthArrow,
                set(bool) {
                    if (self.__hidePrevMonthArrow !== bool) {
                        toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
                        self.__hidePrevMonthArrow = bool;
                    }
                },
            });
            Object.defineProperty(self, "_hideNextMonthArrow", {
                get: () => self.__hideNextMonthArrow,
                set(bool) {
                    if (self.__hideNextMonthArrow !== bool) {
                        toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
                        self.__hideNextMonthArrow = bool;
                    }
                },
            });
            self.currentYearElement = self.yearElements[0];
            updateNavigationCurrentMonth();
            return self.monthNav;
        }
        function buildTime() {
            self.calendarContainer.classList.add("hasTime");
            if (self.config.noCalendar)
                self.calendarContainer.classList.add("noCalendar");
            const defaults = getDefaultHours(self.config);
            self.timeContainer = createElement("div", "flatpickr-time");
            self.timeContainer.tabIndex = -1;
            const separator = createElement("span", "flatpickr-time-separator", ":");
            const hourInput = createNumberInput("flatpickr-hour", {
                "aria-label": self.l10n.hourAriaLabel,
            });
            self.hourElement = hourInput.getElementsByTagName("input")[0];
            const minuteInput = createNumberInput("flatpickr-minute", {
                "aria-label": self.l10n.minuteAriaLabel,
            });
            self.minuteElement = minuteInput.getElementsByTagName("input")[0];
            self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
            self.hourElement.value = pad$2(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getHours()
                : self.config.time_24hr
                    ? defaults.hours
                    : military2ampm(defaults.hours));
            self.minuteElement.value = pad$2(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getMinutes()
                : defaults.minutes);
            self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
            self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
            self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
            self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
            self.hourElement.setAttribute("maxlength", "2");
            self.minuteElement.setAttribute("min", "0");
            self.minuteElement.setAttribute("max", "59");
            self.minuteElement.setAttribute("maxlength", "2");
            self.timeContainer.appendChild(hourInput);
            self.timeContainer.appendChild(separator);
            self.timeContainer.appendChild(minuteInput);
            if (self.config.time_24hr)
                self.timeContainer.classList.add("time24hr");
            if (self.config.enableSeconds) {
                self.timeContainer.classList.add("hasSeconds");
                const secondInput = createNumberInput("flatpickr-second");
                self.secondElement = secondInput.getElementsByTagName("input")[0];
                self.secondElement.value = pad$2(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getSeconds()
                    : defaults.seconds);
                self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                self.secondElement.setAttribute("min", "0");
                self.secondElement.setAttribute("max", "59");
                self.secondElement.setAttribute("maxlength", "2");
                self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                self.timeContainer.appendChild(secondInput);
            }
            if (!self.config.time_24hr) {
                self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int$1((self.latestSelectedDateObj
                    ? self.hourElement.value
                    : self.config.defaultHour) > 11)]);
                self.amPM.title = self.l10n.toggleTitle;
                self.amPM.tabIndex = -1;
                self.timeContainer.appendChild(self.amPM);
            }
            return self.timeContainer;
        }
        function buildWeekdays() {
            if (!self.weekdayContainer)
                self.weekdayContainer = createElement("div", "flatpickr-weekdays");
            else
                clearNode(self.weekdayContainer);
            for (let i = self.config.showMonths; i--;) {
                const container = createElement("div", "flatpickr-weekdaycontainer");
                self.weekdayContainer.appendChild(container);
            }
            updateWeekdays();
            return self.weekdayContainer;
        }
        function updateWeekdays() {
            if (!self.weekdayContainer) {
                return;
            }
            const firstDayOfWeek = self.l10n.firstDayOfWeek;
            let weekdays = [...self.l10n.weekdays.shorthand];
            if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
                weekdays = [
                    ...weekdays.splice(firstDayOfWeek, weekdays.length),
                    ...weekdays.splice(0, firstDayOfWeek),
                ];
            }
            for (let i = self.config.showMonths; i--;) {
                self.weekdayContainer.children[i].innerHTML = `
      <span class='flatpickr-weekday'>
        ${weekdays.join("</span><span class='flatpickr-weekday'>")}
      </span>
      `;
            }
        }
        function buildWeeks() {
            self.calendarContainer.classList.add("hasWeeks");
            const weekWrapper = createElement("div", "flatpickr-weekwrapper");
            weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
            const weekNumbers = createElement("div", "flatpickr-weeks");
            weekWrapper.appendChild(weekNumbers);
            return {
                weekWrapper,
                weekNumbers,
            };
        }
        function changeMonth(value, isOffset = true) {
            const delta = isOffset ? value : value - self.currentMonth;
            if ((delta < 0 && self._hidePrevMonthArrow === true) ||
                (delta > 0 && self._hideNextMonthArrow === true))
                return;
            self.currentMonth += delta;
            if (self.currentMonth < 0 || self.currentMonth > 11) {
                self.currentYear += self.currentMonth > 11 ? 1 : -1;
                self.currentMonth = (self.currentMonth + 12) % 12;
                triggerEvent("onYearChange");
                buildMonthSwitch();
            }
            buildDays();
            triggerEvent("onMonthChange");
            updateNavigationCurrentMonth();
        }
        function clear(triggerChangeEvent = true, toInitial = true) {
            self.input.value = "";
            if (self.altInput !== undefined)
                self.altInput.value = "";
            if (self.mobileInput !== undefined)
                self.mobileInput.value = "";
            self.selectedDates = [];
            self.latestSelectedDateObj = undefined;
            if (toInitial === true) {
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
            }
            if (self.config.enableTime === true) {
                const { hours, minutes, seconds } = getDefaultHours(self.config);
                setHours(hours, minutes, seconds);
            }
            self.redraw();
            if (triggerChangeEvent)
                triggerEvent("onChange");
        }
        function close() {
            self.isOpen = false;
            if (!self.isMobile) {
                if (self.calendarContainer !== undefined) {
                    self.calendarContainer.classList.remove("open");
                }
                if (self._input !== undefined) {
                    self._input.classList.remove("active");
                }
            }
            triggerEvent("onClose");
        }
        function destroy() {
            if (self.config !== undefined)
                triggerEvent("onDestroy");
            for (let i = self._handlers.length; i--;) {
                self._handlers[i].remove();
            }
            self._handlers = [];
            if (self.mobileInput) {
                if (self.mobileInput.parentNode)
                    self.mobileInput.parentNode.removeChild(self.mobileInput);
                self.mobileInput = undefined;
            }
            else if (self.calendarContainer && self.calendarContainer.parentNode) {
                if (self.config.static && self.calendarContainer.parentNode) {
                    const wrapper = self.calendarContainer.parentNode;
                    wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                    if (wrapper.parentNode) {
                        while (wrapper.firstChild)
                            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                        wrapper.parentNode.removeChild(wrapper);
                    }
                }
                else
                    self.calendarContainer.parentNode.removeChild(self.calendarContainer);
            }
            if (self.altInput) {
                self.input.type = "text";
                if (self.altInput.parentNode)
                    self.altInput.parentNode.removeChild(self.altInput);
                delete self.altInput;
            }
            if (self.input) {
                self.input.type = self.input._type;
                self.input.classList.remove("flatpickr-input");
                self.input.removeAttribute("readonly");
            }
            [
                "_showTimeInput",
                "latestSelectedDateObj",
                "_hideNextMonthArrow",
                "_hidePrevMonthArrow",
                "__hideNextMonthArrow",
                "__hidePrevMonthArrow",
                "isMobile",
                "isOpen",
                "selectedDateElem",
                "minDateHasTime",
                "maxDateHasTime",
                "days",
                "daysContainer",
                "_input",
                "_positionElement",
                "innerContainer",
                "rContainer",
                "monthNav",
                "todayDateElem",
                "calendarContainer",
                "weekdayContainer",
                "prevMonthNav",
                "nextMonthNav",
                "monthsDropdownContainer",
                "currentMonthElement",
                "currentYearElement",
                "navigationCurrentMonth",
                "selectedDateElem",
                "config",
            ].forEach((k) => {
                try {
                    delete self[k];
                }
                catch (_) { }
            });
        }
        function isCalendarElem(elem) {
            if (self.config.appendTo && self.config.appendTo.contains(elem))
                return true;
            return self.calendarContainer.contains(elem);
        }
        function documentClick(e) {
            if (self.isOpen && !self.config.inline) {
                const eventTarget = getEventTarget(e);
                const isCalendarElement = isCalendarElem(eventTarget);
                const isInput = eventTarget === self.input ||
                    eventTarget === self.altInput ||
                    self.element.contains(eventTarget) ||
                    (e.path &&
                        e.path.indexOf &&
                        (~e.path.indexOf(self.input) ||
                            ~e.path.indexOf(self.altInput)));
                const lostFocus = e.type === "blur"
                    ? isInput &&
                        e.relatedTarget &&
                        !isCalendarElem(e.relatedTarget)
                    : !isInput &&
                        !isCalendarElement &&
                        !isCalendarElem(e.relatedTarget);
                const isIgnored = !self.config.ignoredFocusElements.some((elem) => elem.contains(eventTarget));
                if (lostFocus && isIgnored) {
                    if (self.timeContainer !== undefined &&
                        self.minuteElement !== undefined &&
                        self.hourElement !== undefined &&
                        self.input.value !== "" &&
                        self.input.value !== undefined) {
                        updateTime();
                    }
                    self.close();
                    if (self.config &&
                        self.config.mode === "range" &&
                        self.selectedDates.length === 1) {
                        self.clear(false);
                        self.redraw();
                    }
                }
            }
        }
        function changeYear(newYear) {
            if (!newYear ||
                (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
                (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
                return;
            const newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
            self.currentYear = newYearNum || self.currentYear;
            if (self.config.maxDate &&
                self.currentYear === self.config.maxDate.getFullYear()) {
                self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
            }
            else if (self.config.minDate &&
                self.currentYear === self.config.minDate.getFullYear()) {
                self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
            }
            if (isNewYear) {
                self.redraw();
                triggerEvent("onYearChange");
                buildMonthSwitch();
            }
        }
        function isEnabled(date, timeless = true) {
            var _a;
            const dateToCheck = self.parseDate(date, undefined, timeless);
            if ((self.config.minDate &&
                dateToCheck &&
                compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
                (self.config.maxDate &&
                    dateToCheck &&
                    compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
                return false;
            if (!self.config.enable && self.config.disable.length === 0)
                return true;
            if (dateToCheck === undefined)
                return false;
            const bool = !!self.config.enable, array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
            for (let i = 0, d; i < array.length; i++) {
                d = array[i];
                if (typeof d === "function" &&
                    d(dateToCheck))
                    return bool;
                else if (d instanceof Date &&
                    dateToCheck !== undefined &&
                    d.getTime() === dateToCheck.getTime())
                    return bool;
                else if (typeof d === "string") {
                    const parsed = self.parseDate(d, undefined, true);
                    return parsed && parsed.getTime() === dateToCheck.getTime()
                        ? bool
                        : !bool;
                }
                else if (typeof d === "object" &&
                    dateToCheck !== undefined &&
                    d.from &&
                    d.to &&
                    dateToCheck.getTime() >= d.from.getTime() &&
                    dateToCheck.getTime() <= d.to.getTime())
                    return bool;
            }
            return !bool;
        }
        function isInView(elem) {
            if (self.daysContainer !== undefined)
                return (elem.className.indexOf("hidden") === -1 &&
                    elem.className.indexOf("flatpickr-disabled") === -1 &&
                    self.daysContainer.contains(elem));
            return false;
        }
        function onBlur(e) {
            const isInput = e.target === self._input;
            if (isInput &&
                (self.selectedDates.length > 0 || self._input.value.length > 0) &&
                !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
                self.setDate(self._input.value, true, e.target === self.altInput
                    ? self.config.altFormat
                    : self.config.dateFormat);
            }
        }
        function onKeyDown(e) {
            const eventTarget = getEventTarget(e);
            const isInput = self.config.wrap
                ? element.contains(eventTarget)
                : eventTarget === self._input;
            const allowInput = self.config.allowInput;
            const allowKeydown = self.isOpen && (!allowInput || !isInput);
            const allowInlineKeydown = self.config.inline && isInput && !allowInput;
            if (e.keyCode === 13 && isInput) {
                if (allowInput) {
                    self.setDate(self._input.value, true, eventTarget === self.altInput
                        ? self.config.altFormat
                        : self.config.dateFormat);
                    return eventTarget.blur();
                }
                else {
                    self.open();
                }
            }
            else if (isCalendarElem(eventTarget) ||
                allowKeydown ||
                allowInlineKeydown) {
                const isTimeObj = !!self.timeContainer &&
                    self.timeContainer.contains(eventTarget);
                switch (e.keyCode) {
                    case 13:
                        if (isTimeObj) {
                            e.preventDefault();
                            updateTime();
                            focusAndClose();
                        }
                        else
                            selectDate(e);
                        break;
                    case 27:
                        e.preventDefault();
                        focusAndClose();
                        break;
                    case 8:
                    case 46:
                        if (isInput && !self.config.allowInput) {
                            e.preventDefault();
                            self.clear();
                        }
                        break;
                    case 37:
                    case 39:
                        if (!isTimeObj && !isInput) {
                            e.preventDefault();
                            if (self.daysContainer !== undefined &&
                                (allowInput === false ||
                                    (document.activeElement && isInView(document.activeElement)))) {
                                const delta = e.keyCode === 39 ? 1 : -1;
                                if (!e.ctrlKey)
                                    focusOnDay(undefined, delta);
                                else {
                                    e.stopPropagation();
                                    changeMonth(delta);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                            }
                        }
                        else if (self.hourElement)
                            self.hourElement.focus();
                        break;
                    case 38:
                    case 40:
                        e.preventDefault();
                        const delta = e.keyCode === 40 ? 1 : -1;
                        if ((self.daysContainer &&
                            eventTarget.$i !== undefined) ||
                            eventTarget === self.input ||
                            eventTarget === self.altInput) {
                            if (e.ctrlKey) {
                                e.stopPropagation();
                                changeYear(self.currentYear - delta);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                            else if (!isTimeObj)
                                focusOnDay(undefined, delta * 7);
                        }
                        else if (eventTarget === self.currentYearElement) {
                            changeYear(self.currentYear - delta);
                        }
                        else if (self.config.enableTime) {
                            if (!isTimeObj && self.hourElement)
                                self.hourElement.focus();
                            updateTime(e);
                            self._debouncedChange();
                        }
                        break;
                    case 9:
                        if (isTimeObj) {
                            const elems = [
                                self.hourElement,
                                self.minuteElement,
                                self.secondElement,
                                self.amPM,
                            ]
                                .concat(self.pluginElements)
                                .filter((x) => x);
                            const i = elems.indexOf(eventTarget);
                            if (i !== -1) {
                                const target = elems[i + (e.shiftKey ? -1 : 1)];
                                e.preventDefault();
                                (target || self._input).focus();
                            }
                        }
                        else if (!self.config.noCalendar &&
                            self.daysContainer &&
                            self.daysContainer.contains(eventTarget) &&
                            e.shiftKey) {
                            e.preventDefault();
                            self._input.focus();
                        }
                        break;
                }
            }
            if (self.amPM !== undefined && eventTarget === self.amPM) {
                switch (e.key) {
                    case self.l10n.amPM[0].charAt(0):
                    case self.l10n.amPM[0].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[0];
                        setHoursFromInputs();
                        updateValue();
                        break;
                    case self.l10n.amPM[1].charAt(0):
                    case self.l10n.amPM[1].charAt(0).toLowerCase():
                        self.amPM.textContent = self.l10n.amPM[1];
                        setHoursFromInputs();
                        updateValue();
                        break;
                }
            }
            if (isInput || isCalendarElem(eventTarget)) {
                triggerEvent("onKeyDown", e);
            }
        }
        function onMouseOver(elem) {
            if (self.selectedDates.length !== 1 ||
                (elem &&
                    (!elem.classList.contains("flatpickr-day") ||
                        elem.classList.contains("flatpickr-disabled"))))
                return;
            const hoverDate = elem
                ? elem.dateObj.getTime()
                : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
            let containsDisabled = false;
            let minRange = 0, maxRange = 0;
            for (let t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
                if (!isEnabled(new Date(t), true)) {
                    containsDisabled =
                        containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                    if (t < initialDate && (!minRange || t > minRange))
                        minRange = t;
                    else if (t > initialDate && (!maxRange || t < maxRange))
                        maxRange = t;
                }
            }
            for (let m = 0; m < self.config.showMonths; m++) {
                const month = self.daysContainer.children[m];
                for (let i = 0, l = month.children.length; i < l; i++) {
                    const dayElem = month.children[i], date = dayElem.dateObj;
                    const timestamp = date.getTime();
                    const outOfRange = (minRange > 0 && timestamp < minRange) ||
                        (maxRange > 0 && timestamp > maxRange);
                    if (outOfRange) {
                        dayElem.classList.add("notAllowed");
                        ["inRange", "startRange", "endRange"].forEach((c) => {
                            dayElem.classList.remove(c);
                        });
                        continue;
                    }
                    else if (containsDisabled && !outOfRange)
                        continue;
                    ["startRange", "inRange", "endRange", "notAllowed"].forEach((c) => {
                        dayElem.classList.remove(c);
                    });
                    if (elem !== undefined) {
                        elem.classList.add(hoverDate <= self.selectedDates[0].getTime()
                            ? "startRange"
                            : "endRange");
                        if (initialDate < hoverDate && timestamp === initialDate)
                            dayElem.classList.add("startRange");
                        else if (initialDate > hoverDate && timestamp === initialDate)
                            dayElem.classList.add("endRange");
                        if (timestamp >= minRange &&
                            (maxRange === 0 || timestamp <= maxRange) &&
                            isBetween(timestamp, initialDate, hoverDate))
                            dayElem.classList.add("inRange");
                    }
                }
            }
        }
        function onResize() {
            if (self.isOpen && !self.config.static && !self.config.inline)
                positionCalendar();
        }
        function open(e, positionElement = self._positionElement) {
            if (self.isMobile === true) {
                if (e) {
                    e.preventDefault();
                    const eventTarget = getEventTarget(e);
                    if (eventTarget) {
                        eventTarget.blur();
                    }
                }
                if (self.mobileInput !== undefined) {
                    self.mobileInput.focus();
                    self.mobileInput.click();
                }
                triggerEvent("onOpen");
                return;
            }
            else if (self._input.disabled || self.config.inline) {
                return;
            }
            const wasOpen = self.isOpen;
            self.isOpen = true;
            if (!wasOpen) {
                self.calendarContainer.classList.add("open");
                self._input.classList.add("active");
                triggerEvent("onOpen");
                positionCalendar(positionElement);
            }
            if (self.config.enableTime === true && self.config.noCalendar === true) {
                if (self.config.allowInput === false &&
                    (e === undefined ||
                        !self.timeContainer.contains(e.relatedTarget))) {
                    setTimeout(() => self.hourElement.select(), 50);
                }
            }
        }
        function minMaxDateSetter(type) {
            return (date) => {
                const dateObj = (self.config[`_${type}Date`] = self.parseDate(date, self.config.dateFormat));
                const inverseDateObj = self.config[`_${type === "min" ? "max" : "min"}Date`];
                if (dateObj !== undefined) {
                    self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                        dateObj.getHours() > 0 ||
                            dateObj.getMinutes() > 0 ||
                            dateObj.getSeconds() > 0;
                }
                if (self.selectedDates) {
                    self.selectedDates = self.selectedDates.filter((d) => isEnabled(d));
                    if (!self.selectedDates.length && type === "min")
                        setHoursFromDate(dateObj);
                    updateValue();
                }
                if (self.daysContainer) {
                    redraw();
                    if (dateObj !== undefined)
                        self.currentYearElement[type] = dateObj.getFullYear().toString();
                    else
                        self.currentYearElement.removeAttribute(type);
                    self.currentYearElement.disabled =
                        !!inverseDateObj &&
                            dateObj !== undefined &&
                            inverseDateObj.getFullYear() === dateObj.getFullYear();
                }
            };
        }
        function parseConfig() {
            const boolOpts = [
                "wrap",
                "weekNumbers",
                "allowInput",
                "allowInvalidPreload",
                "clickOpens",
                "time_24hr",
                "enableTime",
                "noCalendar",
                "altInput",
                "shorthandCurrentMonth",
                "inline",
                "static",
                "enableSeconds",
                "disableMobile",
            ];
            const userConfig = Object.assign(Object.assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
            const formats = {};
            self.config.parseDate = userConfig.parseDate;
            self.config.formatDate = userConfig.formatDate;
            Object.defineProperty(self.config, "enable", {
                get: () => self.config._enable,
                set: (dates) => {
                    self.config._enable = parseDateRules(dates);
                },
            });
            Object.defineProperty(self.config, "disable", {
                get: () => self.config._disable,
                set: (dates) => {
                    self.config._disable = parseDateRules(dates);
                },
            });
            const timeMode = userConfig.mode === "time";
            if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                const defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
                formats.dateFormat =
                    userConfig.noCalendar || timeMode
                        ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                        : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
            }
            if (userConfig.altInput &&
                (userConfig.enableTime || timeMode) &&
                !userConfig.altFormat) {
                const defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
                formats.altFormat =
                    userConfig.noCalendar || timeMode
                        ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                        : defaultAltFormat + ` h:i${userConfig.enableSeconds ? ":S" : ""} K`;
            }
            Object.defineProperty(self.config, "minDate", {
                get: () => self.config._minDate,
                set: minMaxDateSetter("min"),
            });
            Object.defineProperty(self.config, "maxDate", {
                get: () => self.config._maxDate,
                set: minMaxDateSetter("max"),
            });
            const minMaxTimeSetter = (type) => (val) => {
                self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
            };
            Object.defineProperty(self.config, "minTime", {
                get: () => self.config._minTime,
                set: minMaxTimeSetter("min"),
            });
            Object.defineProperty(self.config, "maxTime", {
                get: () => self.config._maxTime,
                set: minMaxTimeSetter("max"),
            });
            if (userConfig.mode === "time") {
                self.config.noCalendar = true;
                self.config.enableTime = true;
            }
            Object.assign(self.config, formats, userConfig);
            for (let i = 0; i < boolOpts.length; i++)
                self.config[boolOpts[i]] =
                    self.config[boolOpts[i]] === true ||
                        self.config[boolOpts[i]] === "true";
            HOOKS.filter((hook) => self.config[hook] !== undefined).forEach((hook) => {
                self.config[hook] = arrayify$1(self.config[hook] || []).map(bindToInstance);
            });
            self.isMobile =
                !self.config.disableMobile &&
                    !self.config.inline &&
                    self.config.mode === "single" &&
                    !self.config.disable.length &&
                    !self.config.enable &&
                    !self.config.weekNumbers &&
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            for (let i = 0; i < self.config.plugins.length; i++) {
                const pluginConf = self.config.plugins[i](self) || {};
                for (const key in pluginConf) {
                    if (HOOKS.indexOf(key) > -1) {
                        self.config[key] = arrayify$1(pluginConf[key])
                            .map(bindToInstance)
                            .concat(self.config[key]);
                    }
                    else if (typeof userConfig[key] === "undefined")
                        self.config[key] = pluginConf[key];
                }
            }
            if (!userConfig.altInputClass) {
                self.config.altInputClass =
                    getInputElem().className + " " + self.config.altInputClass;
            }
            triggerEvent("onParseConfig");
        }
        function getInputElem() {
            return self.config.wrap
                ? element.querySelector("[data-input]")
                : element;
        }
        function setupLocale() {
            if (typeof self.config.locale !== "object" &&
                typeof flatpickr.l10ns[self.config.locale] === "undefined")
                self.config.errorHandler(new Error(`flatpickr: invalid locale ${self.config.locale}`));
            self.l10n = Object.assign(Object.assign({}, flatpickr.l10ns.default), (typeof self.config.locale === "object"
                ? self.config.locale
                : self.config.locale !== "default"
                    ? flatpickr.l10ns[self.config.locale]
                    : undefined));
            tokenRegex.K = `(${self.l10n.amPM[0]}|${self.l10n.amPM[1]}|${self.l10n.amPM[0].toLowerCase()}|${self.l10n.amPM[1].toLowerCase()})`;
            const userConfig = Object.assign(Object.assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
            if (userConfig.time_24hr === undefined &&
                flatpickr.defaultConfig.time_24hr === undefined) {
                self.config.time_24hr = self.l10n.time_24hr;
            }
            self.formatDate = createDateFormatter(self);
            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
        }
        function positionCalendar(customPositionElement) {
            if (typeof self.config.position === "function") {
                return void self.config.position(self, customPositionElement);
            }
            if (self.calendarContainer === undefined)
                return;
            triggerEvent("onPreCalendarPosition");
            const positionElement = customPositionElement || self._positionElement;
            const calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, ((acc, child) => acc + child.offsetHeight), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
                (configPosVertical !== "below" &&
                    distanceFromBottom < calendarHeight &&
                    inputBounds.top > calendarHeight);
            const top = window.pageYOffset +
                inputBounds.top +
                (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
            toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
            toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
            if (self.config.inline)
                return;
            let left = window.pageXOffset + inputBounds.left;
            let isCenter = false;
            let isRight = false;
            if (configPosHorizontal === "center") {
                left -= (calendarWidth - inputBounds.width) / 2;
                isCenter = true;
            }
            else if (configPosHorizontal === "right") {
                left -= calendarWidth - inputBounds.width;
                isRight = true;
            }
            toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
            toggleClass(self.calendarContainer, "arrowCenter", isCenter);
            toggleClass(self.calendarContainer, "arrowRight", isRight);
            const right = window.document.body.offsetWidth -
                (window.pageXOffset + inputBounds.right);
            const rightMost = left + calendarWidth > window.document.body.offsetWidth;
            const centerMost = right + calendarWidth > window.document.body.offsetWidth;
            toggleClass(self.calendarContainer, "rightMost", rightMost);
            if (self.config.static)
                return;
            self.calendarContainer.style.top = `${top}px`;
            if (!rightMost) {
                self.calendarContainer.style.left = `${left}px`;
                self.calendarContainer.style.right = "auto";
            }
            else if (!centerMost) {
                self.calendarContainer.style.left = "auto";
                self.calendarContainer.style.right = `${right}px`;
            }
            else {
                const doc = getDocumentStyleSheet();
                if (doc === undefined)
                    return;
                const bodyWidth = window.document.body.offsetWidth;
                const centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                const centerBefore = ".flatpickr-calendar.centerMost:before";
                const centerAfter = ".flatpickr-calendar.centerMost:after";
                const centerIndex = doc.cssRules.length;
                const centerStyle = `{left:${inputBounds.left}px;right:auto;}`;
                toggleClass(self.calendarContainer, "rightMost", false);
                toggleClass(self.calendarContainer, "centerMost", true);
                doc.insertRule(`${centerBefore},${centerAfter}${centerStyle}`, centerIndex);
                self.calendarContainer.style.left = `${centerLeft}px`;
                self.calendarContainer.style.right = "auto";
            }
        }
        function getDocumentStyleSheet() {
            let editableSheet = null;
            for (let i = 0; i < document.styleSheets.length; i++) {
                const sheet = document.styleSheets[i];
                try {
                    sheet.cssRules;
                }
                catch (err) {
                    continue;
                }
                editableSheet = sheet;
                break;
            }
            return editableSheet != null ? editableSheet : createStyleSheet();
        }
        function createStyleSheet() {
            const style = document.createElement("style");
            document.head.appendChild(style);
            return style.sheet;
        }
        function redraw() {
            if (self.config.noCalendar || self.isMobile)
                return;
            buildMonthSwitch();
            updateNavigationCurrentMonth();
            buildDays();
        }
        function focusAndClose() {
            self._input.focus();
            if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
                navigator.msMaxTouchPoints !== undefined) {
                setTimeout(self.close, 0);
            }
            else {
                self.close();
            }
        }
        function selectDate(e) {
            e.preventDefault();
            e.stopPropagation();
            const isSelectable = (day) => day.classList &&
                day.classList.contains("flatpickr-day") &&
                !day.classList.contains("flatpickr-disabled") &&
                !day.classList.contains("notAllowed");
            const t = findParent(getEventTarget(e), isSelectable);
            if (t === undefined)
                return;
            const target = t;
            const selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
            const shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
                selectedDate.getMonth() >
                    self.currentMonth + self.config.showMonths - 1) &&
                self.config.mode !== "range";
            self.selectedDateElem = target;
            if (self.config.mode === "single")
                self.selectedDates = [selectedDate];
            else if (self.config.mode === "multiple") {
                const selectedIndex = isDateSelected(selectedDate);
                if (selectedIndex)
                    self.selectedDates.splice(parseInt(selectedIndex), 1);
                else
                    self.selectedDates.push(selectedDate);
            }
            else if (self.config.mode === "range") {
                if (self.selectedDates.length === 2) {
                    self.clear(false, false);
                }
                self.latestSelectedDateObj = selectedDate;
                self.selectedDates.push(selectedDate);
                if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                    self.selectedDates.sort((a, b) => a.getTime() - b.getTime());
            }
            setHoursFromInputs();
            if (shouldChangeMonth) {
                const isNewYear = self.currentYear !== selectedDate.getFullYear();
                self.currentYear = selectedDate.getFullYear();
                self.currentMonth = selectedDate.getMonth();
                if (isNewYear) {
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
                triggerEvent("onMonthChange");
            }
            updateNavigationCurrentMonth();
            buildDays();
            updateValue();
            if (!shouldChangeMonth &&
                self.config.mode !== "range" &&
                self.config.showMonths === 1)
                focusOnDayElem(target);
            else if (self.selectedDateElem !== undefined &&
                self.hourElement === undefined) {
                self.selectedDateElem && self.selectedDateElem.focus();
            }
            if (self.hourElement !== undefined)
                self.hourElement !== undefined && self.hourElement.focus();
            if (self.config.closeOnSelect) {
                const single = self.config.mode === "single" && !self.config.enableTime;
                const range = self.config.mode === "range" &&
                    self.selectedDates.length === 2 &&
                    !self.config.enableTime;
                if (single || range) {
                    focusAndClose();
                }
            }
            triggerChange();
        }
        const CALLBACKS = {
            locale: [setupLocale, updateWeekdays],
            showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
            minDate: [jumpToDate],
            maxDate: [jumpToDate],
            clickOpens: [
                () => {
                    if (self.config.clickOpens === true) {
                        bind(self._input, "focus", self.open);
                        bind(self._input, "click", self.open);
                    }
                    else {
                        self._input.removeEventListener("focus", self.open);
                        self._input.removeEventListener("click", self.open);
                    }
                },
            ],
        };
        function set(option, value) {
            if (option !== null && typeof option === "object") {
                Object.assign(self.config, option);
                for (const key in option) {
                    if (CALLBACKS[key] !== undefined)
                        CALLBACKS[key].forEach((x) => x());
                }
            }
            else {
                self.config[option] = value;
                if (CALLBACKS[option] !== undefined)
                    CALLBACKS[option].forEach((x) => x());
                else if (HOOKS.indexOf(option) > -1)
                    self.config[option] = arrayify$1(value);
            }
            self.redraw();
            updateValue(true);
        }
        function setSelectedDate(inputDate, format) {
            let dates = [];
            if (inputDate instanceof Array)
                dates = inputDate.map((d) => self.parseDate(d, format));
            else if (inputDate instanceof Date || typeof inputDate === "number")
                dates = [self.parseDate(inputDate, format)];
            else if (typeof inputDate === "string") {
                switch (self.config.mode) {
                    case "single":
                    case "time":
                        dates = [self.parseDate(inputDate, format)];
                        break;
                    case "multiple":
                        dates = inputDate
                            .split(self.config.conjunction)
                            .map((date) => self.parseDate(date, format));
                        break;
                    case "range":
                        dates = inputDate
                            .split(self.l10n.rangeSeparator)
                            .map((date) => self.parseDate(date, format));
                        break;
                }
            }
            else
                self.config.errorHandler(new Error(`Invalid date supplied: ${JSON.stringify(inputDate)}`));
            self.selectedDates = (self.config.allowInvalidPreload
                ? dates
                : dates.filter((d) => d instanceof Date && isEnabled(d, false)));
            if (self.config.mode === "range")
                self.selectedDates.sort((a, b) => a.getTime() - b.getTime());
        }
        function setDate(date, triggerChange = false, format = self.config.dateFormat) {
            if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
                return self.clear(triggerChange);
            setSelectedDate(date, format);
            self.latestSelectedDateObj =
                self.selectedDates[self.selectedDates.length - 1];
            self.redraw();
            jumpToDate(undefined, triggerChange);
            setHoursFromDate();
            if (self.selectedDates.length === 0) {
                self.clear(false);
            }
            updateValue(triggerChange);
            if (triggerChange)
                triggerEvent("onChange");
        }
        function parseDateRules(arr) {
            return arr
                .slice()
                .map((rule) => {
                if (typeof rule === "string" ||
                    typeof rule === "number" ||
                    rule instanceof Date) {
                    return self.parseDate(rule, undefined, true);
                }
                else if (rule &&
                    typeof rule === "object" &&
                    rule.from &&
                    rule.to)
                    return {
                        from: self.parseDate(rule.from, undefined),
                        to: self.parseDate(rule.to, undefined),
                    };
                return rule;
            })
                .filter((x) => x);
        }
        function setupDates() {
            self.selectedDates = [];
            self.now = self.parseDate(self.config.now) || new Date();
            const preloadedDate = self.config.defaultDate ||
                ((self.input.nodeName === "INPUT" ||
                    self.input.nodeName === "TEXTAREA") &&
                    self.input.placeholder &&
                    self.input.value === self.input.placeholder
                    ? null
                    : self.input.value);
            if (preloadedDate)
                setSelectedDate(preloadedDate, self.config.dateFormat);
            self._initialDate =
                self.selectedDates.length > 0
                    ? self.selectedDates[0]
                    : self.config.minDate &&
                        self.config.minDate.getTime() > self.now.getTime()
                        ? self.config.minDate
                        : self.config.maxDate &&
                            self.config.maxDate.getTime() < self.now.getTime()
                            ? self.config.maxDate
                            : self.now;
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
            if (self.selectedDates.length > 0)
                self.latestSelectedDateObj = self.selectedDates[0];
            if (self.config.minTime !== undefined)
                self.config.minTime = self.parseDate(self.config.minTime, "H:i");
            if (self.config.maxTime !== undefined)
                self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
            self.minDateHasTime =
                !!self.config.minDate &&
                    (self.config.minDate.getHours() > 0 ||
                        self.config.minDate.getMinutes() > 0 ||
                        self.config.minDate.getSeconds() > 0);
            self.maxDateHasTime =
                !!self.config.maxDate &&
                    (self.config.maxDate.getHours() > 0 ||
                        self.config.maxDate.getMinutes() > 0 ||
                        self.config.maxDate.getSeconds() > 0);
        }
        function setupInputs() {
            self.input = getInputElem();
            if (!self.input) {
                self.config.errorHandler(new Error("Invalid input element specified"));
                return;
            }
            self.input._type = self.input.type;
            self.input.type = "text";
            self.input.classList.add("flatpickr-input");
            self._input = self.input;
            if (self.config.altInput) {
                self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
                self._input = self.altInput;
                self.altInput.placeholder = self.input.placeholder;
                self.altInput.disabled = self.input.disabled;
                self.altInput.required = self.input.required;
                self.altInput.tabIndex = self.input.tabIndex;
                self.altInput.type = "text";
                self.input.setAttribute("type", "hidden");
                if (!self.config.static && self.input.parentNode)
                    self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
            }
            if (!self.config.allowInput)
                self._input.setAttribute("readonly", "readonly");
            self._positionElement = self.config.positionElement || self._input;
        }
        function setupMobile() {
            const inputType = self.config.enableTime
                ? self.config.noCalendar
                    ? "time"
                    : "datetime-local"
                : "date";
            self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
            self.mobileInput.tabIndex = 1;
            self.mobileInput.type = inputType;
            self.mobileInput.disabled = self.input.disabled;
            self.mobileInput.required = self.input.required;
            self.mobileInput.placeholder = self.input.placeholder;
            self.mobileFormatStr =
                inputType === "datetime-local"
                    ? "Y-m-d\\TH:i:S"
                    : inputType === "date"
                        ? "Y-m-d"
                        : "H:i:S";
            if (self.selectedDates.length > 0) {
                self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
            }
            if (self.config.minDate)
                self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
            if (self.config.maxDate)
                self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
            if (self.input.getAttribute("step"))
                self.mobileInput.step = String(self.input.getAttribute("step"));
            self.input.type = "hidden";
            if (self.altInput !== undefined)
                self.altInput.type = "hidden";
            try {
                if (self.input.parentNode)
                    self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
            }
            catch (_a) { }
            bind(self.mobileInput, "change", (e) => {
                self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
                triggerEvent("onChange");
                triggerEvent("onClose");
            });
        }
        function toggle(e) {
            if (self.isOpen === true)
                return self.close();
            self.open(e);
        }
        function triggerEvent(event, data) {
            if (self.config === undefined)
                return;
            const hooks = self.config[event];
            if (hooks !== undefined && hooks.length > 0) {
                for (let i = 0; hooks[i] && i < hooks.length; i++)
                    hooks[i](self.selectedDates, self.input.value, self, data);
            }
            if (event === "onChange") {
                self.input.dispatchEvent(createEvent("change"));
                self.input.dispatchEvent(createEvent("input"));
            }
        }
        function createEvent(name) {
            const e = document.createEvent("Event");
            e.initEvent(name, true, true);
            return e;
        }
        function isDateSelected(date) {
            for (let i = 0; i < self.selectedDates.length; i++) {
                if (compareDates(self.selectedDates[i], date) === 0)
                    return "" + i;
            }
            return false;
        }
        function isDateInRange(date) {
            if (self.config.mode !== "range" || self.selectedDates.length < 2)
                return false;
            return (compareDates(date, self.selectedDates[0]) >= 0 &&
                compareDates(date, self.selectedDates[1]) <= 0);
        }
        function updateNavigationCurrentMonth() {
            if (self.config.noCalendar || self.isMobile || !self.monthNav)
                return;
            self.yearElements.forEach((yearElement, i) => {
                const d = new Date(self.currentYear, self.currentMonth, 1);
                d.setMonth(self.currentMonth + i);
                if (self.config.showMonths > 1 ||
                    self.config.monthSelectorType === "static") {
                    self.monthElements[i].textContent =
                        monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
                }
                else {
                    self.monthsDropdownContainer.value = d.getMonth().toString();
                }
                yearElement.value = d.getFullYear().toString();
            });
            self._hidePrevMonthArrow =
                self.config.minDate !== undefined &&
                    (self.currentYear === self.config.minDate.getFullYear()
                        ? self.currentMonth <= self.config.minDate.getMonth()
                        : self.currentYear < self.config.minDate.getFullYear());
            self._hideNextMonthArrow =
                self.config.maxDate !== undefined &&
                    (self.currentYear === self.config.maxDate.getFullYear()
                        ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                        : self.currentYear > self.config.maxDate.getFullYear());
        }
        function getDateStr(format) {
            return self.selectedDates
                .map((dObj) => self.formatDate(dObj, format))
                .filter((d, i, arr) => self.config.mode !== "range" ||
                self.config.enableTime ||
                arr.indexOf(d) === i)
                .join(self.config.mode !== "range"
                ? self.config.conjunction
                : self.l10n.rangeSeparator);
        }
        function updateValue(triggerChange = true) {
            if (self.mobileInput !== undefined && self.mobileFormatStr) {
                self.mobileInput.value =
                    self.latestSelectedDateObj !== undefined
                        ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                        : "";
            }
            self.input.value = getDateStr(self.config.dateFormat);
            if (self.altInput !== undefined) {
                self.altInput.value = getDateStr(self.config.altFormat);
            }
            if (triggerChange !== false)
                triggerEvent("onValueUpdate");
        }
        function onMonthNavClick(e) {
            const eventTarget = getEventTarget(e);
            const isPrevMonth = self.prevMonthNav.contains(eventTarget);
            const isNextMonth = self.nextMonthNav.contains(eventTarget);
            if (isPrevMonth || isNextMonth) {
                changeMonth(isPrevMonth ? -1 : 1);
            }
            else if (self.yearElements.indexOf(eventTarget) >= 0) {
                eventTarget.select();
            }
            else if (eventTarget.classList.contains("arrowUp")) {
                self.changeYear(self.currentYear + 1);
            }
            else if (eventTarget.classList.contains("arrowDown")) {
                self.changeYear(self.currentYear - 1);
            }
        }
        function timeWrapper(e) {
            e.preventDefault();
            const isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
            if (self.amPM !== undefined && eventTarget === self.amPM) {
                self.amPM.textContent =
                    self.l10n.amPM[int$1(self.amPM.textContent === self.l10n.amPM[0])];
            }
            const min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
                (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
            let newValue = curValue + step * delta;
            if (typeof input.value !== "undefined" && input.value.length === 2) {
                const isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                if (newValue < min) {
                    newValue =
                        max +
                            newValue +
                            int$1(!isHourElem) +
                            (int$1(isHourElem) && int$1(!self.amPM));
                    if (isMinuteElem)
                        incrementNumInput(undefined, -1, self.hourElement);
                }
                else if (newValue > max) {
                    newValue =
                        input === self.hourElement ? newValue - max - int$1(!self.amPM) : min;
                    if (isMinuteElem)
                        incrementNumInput(undefined, 1, self.hourElement);
                }
                if (self.amPM &&
                    isHourElem &&
                    (step === 1
                        ? newValue + curValue === 23
                        : Math.abs(newValue - curValue) > step)) {
                    self.amPM.textContent =
                        self.l10n.amPM[int$1(self.amPM.textContent === self.l10n.amPM[0])];
                }
                input.value = pad$2(newValue);
            }
        }
        init();
        return self;
    }
    function _flatpickr(nodeList, config) {
        const nodes = Array.prototype.slice
            .call(nodeList)
            .filter((x) => x instanceof HTMLElement);
        const instances = [];
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            try {
                if (node.getAttribute("data-fp-omit") !== null)
                    continue;
                if (node._flatpickr !== undefined) {
                    node._flatpickr.destroy();
                    node._flatpickr = undefined;
                }
                node._flatpickr = FlatpickrInstance(node, config || {});
                instances.push(node._flatpickr);
            }
            catch (e) {
                console.error(e);
            }
        }
        return instances.length === 1 ? instances[0] : instances;
    }
    if (typeof HTMLElement !== "undefined" &&
        typeof HTMLCollection !== "undefined" &&
        typeof NodeList !== "undefined") {
        HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
        HTMLElement.prototype.flatpickr = function (config) {
            return _flatpickr([this], config);
        };
    }
    var flatpickr = function (selector, config) {
        if (typeof selector === "string") {
            return _flatpickr(window.document.querySelectorAll(selector), config);
        }
        else if (selector instanceof Node) {
            return _flatpickr([selector], config);
        }
        else {
            return _flatpickr(selector, config);
        }
    };
    flatpickr.defaultConfig = {};
    flatpickr.l10ns = {
        en: Object.assign({}, english),
        default: Object.assign({}, english),
    };
    flatpickr.localize = (l10n) => {
        flatpickr.l10ns.default = Object.assign(Object.assign({}, flatpickr.l10ns.default), l10n);
    };
    flatpickr.setDefaults = (config) => {
        flatpickr.defaultConfig = Object.assign(Object.assign({}, flatpickr.defaultConfig), config);
    };
    flatpickr.parseDate = createDateParser({});
    flatpickr.formatDate = createDateFormatter({});
    flatpickr.compareDates = compareDates;
    if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
        jQuery.fn.flatpickr = function (config) {
            return _flatpickr(this, config);
        };
    }
    Date.prototype.fp_incr = function (days) {
        return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
    };
    if (typeof window !== "undefined") {
        window.flatpickr = flatpickr;
    }

    /* src/components/MemberForm.svelte generated by Svelte v3.45.0 */

    const { Object: Object_1$5 } = globals;
    const file$u = "src/components/MemberForm.svelte";

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[28] = list[i];
    	return child_ctx;
    }

    // (97:4) {:else}
    function create_else_block_1$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Edit member");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$g.name,
    		type: "else",
    		source: "(97:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (95:43) 
    function create_if_block_8$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Renew Member");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$6.name,
    		type: "if",
    		source: "(95:43) ",
    		ctx
    	});

    	return block;
    }

    // (93:4) {#if member === null}
    function create_if_block_7$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("New Member");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$8.name,
    		type: "if",
    		source: "(93:4) {#if member === null}",
    		ctx
    	});

    	return block;
    }

    // (104:4) {#if member === null}
    function create_if_block_6$9(ctx) {
    	let div;
    	let p;
    	let t1;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			p.textContent = "PAF Membership Terms";
    			t1 = text$1("\n            PAF is a non-profit organization. The Act of 1st July 1901 applies to this organization. PAF is intended to the professionals and not-yet-professionals in the field of performing arts, visual art, music, film, literature, new media, theory and cultural production, who want to research and determine their own conditions of work. It is a platform for anyone who wishes to expand possibilities and interests in their own working practice. Initiated and run by artists, theoreticians, practitioners and activists themselves, PAF is an user-created informal institution. The organization disclaims all liability as long as the necessary restorations of the building are not made. Therefore PAF is not liable in case of any loss, material damage or personal injury occurred to current members and to non-members even in case of gross negligence. You hereby declare to have inspected the site and building. You declare awareness that the aforementioned site and building are not within accordance of the necessary safety codes. To ensure that every resident becomes a member of the organization PAF, they must sign this disclaimer.");
    			attr_dev(p, "class", "uk-text-lead");
    			toggle_class(p, "uk-text-small", /*$screenWidthS*/ ctx[5]);
    			toggle_class(p, "uk-text-bold", /*$screenWidthS*/ ctx[5]);
    			add_location(p, file$u, 105, 12, 3729);
    			attr_dev(div, "class", "uk-margin-medium uk-padding uk-text-justify uk-background-muted uk-text-emphasis");
    			toggle_class(div, "uk-text-small", /*$screenWidthS*/ ctx[5]);
    			add_location(div, file$u, 104, 8, 3586);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$screenWidthS*/ 32) {
    				toggle_class(p, "uk-text-small", /*$screenWidthS*/ ctx[5]);
    			}

    			if (dirty & /*$screenWidthS*/ 32) {
    				toggle_class(p, "uk-text-bold", /*$screenWidthS*/ ctx[5]);
    			}

    			if (dirty & /*$screenWidthS*/ 32) {
    				toggle_class(div, "uk-text-small", /*$screenWidthS*/ ctx[5]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$9.name,
    		type: "if",
    		source: "(104:4) {#if member === null}",
    		ctx
    	});

    	return block;
    }

    // (119:16) {#if !okEmail}
    function create_if_block_5$b(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "class", "uk-form-icon uk-form-icon-flip");
    			attr_dev(a, "href", "#");
    			attr_dev(a, "uk-icon", "icon: file-edit");
    			attr_dev(a, "uk-tooltip", "title: Edit member with this email");
    			add_location(a, file$u, 119, 20, 5736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*jumpEdit*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$b.name,
    		type: "if",
    		source: "(119:16) {#if !okEmail}",
    		ctx
    	});

    	return block;
    }

    // (126:12) {#if !okEmail}
    function create_if_block_3$g(ctx) {
    	let t0;
    	let div;
    	let if_block = !/*$screenWidthS*/ ctx[5] && create_if_block_4$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			div = element("div");
    			div.textContent = "Email already in use";
    			attr_dev(div, "class", "uk-width-1-2@s uk-text-danger");
    			add_location(div, file$u, 131, 16, 6483);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*$screenWidthS*/ ctx[5]) {
    				if (if_block) ; else {
    					if_block = create_if_block_4$c(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$g.name,
    		type: "if",
    		source: "(126:12) {#if !okEmail}",
    		ctx
    	});

    	return block;
    }

    // (127:16) {#if !$screenWidthS}
    function create_if_block_4$c(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "";
    			attr_dev(div, "class", "uk-width-1-2@s");
    			add_location(div, file$u, 127, 20, 6358);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$c.name,
    		type: "if",
    		source: "(127:16) {#if !$screenWidthS}",
    		ctx
    	});

    	return block;
    }

    // (160:20) {#if member === undefined || member === null || member.country === null || member.country === ''}
    function create_if_block_2$j(ctx) {
    	let option;

    	const block = {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Please select country";
    			option.__value = "";
    			option.value = option.__value;
    			option.selected = true;
    			add_location(option, file$u, 160, 24, 8348);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$j.name,
    		type: "if",
    		source: "(160:20) {#if member === undefined || member === null || member.country === null || member.country === ''}",
    		ctx
    	});

    	return block;
    }

    // (166:24) {:else}
    function create_else_block$s(ctx) {
    	let option;
    	let t_value = /*country*/ ctx[28].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = /*country*/ ctx[28].title;
    			option.value = option.__value;
    			add_location(option, file$u, 166, 28, 8743);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$s.name,
    		type: "else",
    		source: "(166:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (164:24) {#if member !== undefined && member !== null && member.country === country.title}
    function create_if_block_1$k(ctx) {
    	let option;
    	let t_value = /*country*/ ctx[28].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = /*country*/ ctx[28].title;
    			option.value = option.__value;
    			option.selected = true;
    			add_location(option, file$u, 164, 28, 8617);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(164:24) {#if member !== undefined && member !== null && member.country === country.title}",
    		ctx
    	});

    	return block;
    }

    // (163:20) {#each countryArray as country}
    function create_each_block$k(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*member*/ ctx[0] !== undefined && /*member*/ ctx[0] !== null && /*member*/ ctx[0].country === /*country*/ ctx[28].title) return create_if_block_1$k;
    		return create_else_block$s;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$k.name,
    		type: "each",
    		source: "(163:20) {#each countryArray as country}",
    		ctx
    	});

    	return block;
    }

    // (174:4) {#if member === null}
    function create_if_block$t(ctx) {
    	let div1;
    	let label0;
    	let t1;
    	let div0;
    	let input0;
    	let t2;
    	let div4;
    	let label1;
    	let t3;
    	let div2;
    	let input1;
    	let t4;
    	let span;
    	let t5;
    	let a;
    	let t7;
    	let label2;
    	let t8;
    	let div3;
    	let input2;
    	let t9;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Start date";
    			t1 = space();
    			div0 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div4 = element("div");
    			label1 = element("label");
    			t3 = space();
    			div2 = element("div");
    			input1 = element("input");
    			t4 = space();
    			span = element("span");
    			t5 = text$1("I hereby agree to ");
    			a = element("a");
    			a.textContent = "PAF's membership terms";
    			t7 = space();
    			label2 = element("label");
    			t8 = space();
    			div3 = element("div");
    			input2 = element("input");
    			t9 = text$1(" I would like to receive occasional updates from PAF via email");
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-start_date");
    			add_location(label0, file$u, 175, 12, 9006);
    			attr_dev(input0, "class", "uk-input");
    			attr_dev(input0, "id", "form-start_date");
    			attr_dev(input0, "name", "start_date");
    			attr_dev(input0, "type", "text");
    			input0.readOnly = true;
    			set_style(input0, "color", "black");
    			toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[6].start_date && /*$touched*/ ctx[7].start_date);
    			add_location(input0, file$u, 177, 16, 9135);
    			attr_dev(div0, "class", "uk-form-controls");
    			add_location(div0, file$u, 176, 12, 9088);
    			attr_dev(div1, "class", "uk-margin-medium");
    			add_location(div1, file$u, 174, 8, 8963);
    			attr_dev(label1, "for", "form-agree");
    			add_location(label1, file$u, 183, 12, 9515);
    			attr_dev(input1, "class", "uk-checkbox");
    			attr_dev(input1, "id", "form-agree");
    			attr_dev(input1, "name", "agree");
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$u, 185, 16, 9607);
    			attr_dev(a, "class", "uk-link-muted");
    			attr_dev(a, "href", "#terms");
    			attr_dev(a, "uk-scroll", "");
    			add_location(a, file$u, 187, 112, 9862);
    			toggle_class(span, ":uk-text-danger", /*$errors*/ ctx[6].agree);
    			add_location(span, file$u, 187, 49, 9799);
    			attr_dev(div2, "class", "uk-form-controls");
    			add_location(div2, file$u, 184, 12, 9560);
    			attr_dev(label2, "for", "form-newsletter");
    			add_location(label2, file$u, 189, 12, 9976);
    			attr_dev(input2, "class", "uk-checkbox");
    			attr_dev(input2, "id", "form-newsletter");
    			attr_dev(input2, "name", "newsletter");
    			attr_dev(input2, "type", "checkbox");
    			input2.checked = true;
    			add_location(input2, file$u, 191, 16, 10073);
    			attr_dev(div3, "class", "uk-form-controls");
    			add_location(div3, file$u, 190, 12, 10026);
    			attr_dev(div4, "class", "uk-margin-medium");
    			add_location(div4, file$u, 182, 8, 9472);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$form*/ ctx[2].start_date);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, label1);
    			append_dev(div4, t3);
    			append_dev(div4, div2);
    			append_dev(div2, input1);
    			set_input_value(input1, /*$form*/ ctx[2].agree);
    			append_dev(div2, t4);
    			append_dev(div2, span);
    			append_dev(span, t5);
    			append_dev(span, a);
    			append_dev(div4, t7);
    			append_dev(div4, label2);
    			append_dev(div4, t8);
    			append_dev(div4, div3);
    			append_dev(div3, input2);
    			set_input_value(input2, /*$form*/ ctx[2].newsletter);
    			append_dev(div3, t9);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input0, "blur", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler_1*/ ctx[23]),
    					listen_dev(input1, "change", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input1, "blur", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[24]),
    					listen_dev(input2, "change", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input2, "blur", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[25])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$form*/ 4 && input0.value !== /*$form*/ ctx[2].start_date) {
    				set_input_value(input0, /*$form*/ ctx[2].start_date);
    			}

    			if (dirty & /*$errors, $touched*/ 192) {
    				toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[6].start_date && /*$touched*/ ctx[7].start_date);
    			}

    			if (dirty & /*$form*/ 4) {
    				set_input_value(input1, /*$form*/ ctx[2].agree);
    			}

    			if (dirty & /*$errors*/ 64) {
    				toggle_class(span, ":uk-text-danger", /*$errors*/ ctx[6].agree);
    			}

    			if (dirty & /*$form*/ 4) {
    				set_input_value(input2, /*$form*/ ctx[2].newsletter);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(174:4) {#if member === null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let h4;
    	let t0;
    	let a;
    	let t1;
    	let form_1;
    	let t2;
    	let div3;
    	let label0;
    	let t4;
    	let div2;
    	let div0;
    	let input0;
    	let t5;
    	let div1;
    	let t6;
    	let input1;
    	let t7;
    	let t8;
    	let div9;
    	let label1;
    	let t10;
    	let div8;
    	let div4;
    	let input2;
    	let t11;
    	let div5;
    	let input3;
    	let t12;
    	let div6;
    	let input4;
    	let t13;
    	let div7;
    	let select;
    	let if_block4_anchor;
    	let t14;
    	let t15;
    	let div10;
    	let button0;
    	let t17;
    	let button1;

    	let t18_value = (/*member*/ ctx[0] !== null && /*renew*/ ctx[1] !== undefined && /*renew*/ ctx[1] === false
    	? 'Save'
    	: 'Continue') + "";

    	let t18;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*member*/ ctx[0] === null) return create_if_block_7$8;
    		if (/*renew*/ ctx[1] !== undefined && /*renew*/ ctx[1]) return create_if_block_8$6;
    		return create_else_block_1$g;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*member*/ ctx[0] === null && create_if_block_6$9(ctx);
    	let if_block2 = !/*okEmail*/ ctx[3] && create_if_block_5$b(ctx);
    	let if_block3 = !/*okEmail*/ ctx[3] && create_if_block_3$g(ctx);
    	let if_block4 = (/*member*/ ctx[0] === undefined || /*member*/ ctx[0] === null || /*member*/ ctx[0].country === null || /*member*/ ctx[0].country === '') && create_if_block_2$j(ctx);
    	let each_value = countryArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
    	}

    	let if_block5 = /*member*/ ctx[0] === null && create_if_block$t(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			if_block0.c();
    			t0 = space();
    			a = element("a");
    			t1 = space();
    			form_1 = element("form");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Name, Email";
    			t4 = space();
    			div2 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t5 = space();
    			div1 = element("div");
    			if (if_block2) if_block2.c();
    			t6 = space();
    			input1 = element("input");
    			t7 = space();
    			if (if_block3) if_block3.c();
    			t8 = space();
    			div9 = element("div");
    			label1 = element("label");
    			label1.textContent = "Address";
    			t10 = space();
    			div8 = element("div");
    			div4 = element("div");
    			input2 = element("input");
    			t11 = space();
    			div5 = element("div");
    			input3 = element("input");
    			t12 = space();
    			div6 = element("div");
    			input4 = element("input");
    			t13 = space();
    			div7 = element("div");
    			select = element("select");
    			if (if_block4) if_block4.c();
    			if_block4_anchor = empty$3();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t14 = space();
    			if (if_block5) if_block5.c();
    			t15 = space();
    			div10 = element("div");
    			button0 = element("button");
    			button0.textContent = "Cancel";
    			t17 = space();
    			button1 = element("button");
    			t18 = text$1(t18_value);
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom");
    			add_location(h4, file$u, 91, 0, 3196);
    			attr_dev(a, "id", "terms");
    			add_location(a, file$u, 100, 0, 3441);
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-personals");
    			add_location(label0, file$u, 110, 8, 5056);
    			attr_dev(input0, "class", "uk-input uk-form-width-large");
    			attr_dev(input0, "id", "form-name-no1pw-search");
    			attr_dev(input0, "name", "name");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Name");
    			attr_dev(input0, "autocomplete", "'off");
    			set_style(input0, "color", "black");
    			toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[6].name && /*$touched*/ ctx[7].name);
    			add_location(input0, file$u, 113, 16, 5288);
    			attr_dev(div0, "class", "uk-width-1-2@s");
    			add_location(div0, file$u, 112, 12, 5243);
    			attr_dev(input1, "class", "uk-input");
    			attr_dev(input1, "id", "form-email-no1pw-search");
    			attr_dev(input1, "name", "email");
    			attr_dev(input1, "type", "email");
    			attr_dev(input1, "placeholder", "Email");
    			attr_dev(input1, "autocomplete", "'off");
    			set_style(input1, "color", "black");
    			toggle_class(input1, "uk-form-danger", !/*okEmail*/ ctx[3] || /*$errors*/ ctx[6].email && /*$touched*/ ctx[7].email);
    			add_location(input1, file$u, 121, 16, 5927);
    			attr_dev(div1, "class", "uk-width-1-2@s uk-inline");
    			add_location(div1, file$u, 117, 12, 5646);
    			attr_dev(div2, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div2, "id", "form-personals");
    			attr_dev(div2, "uk-grid", "");
    			add_location(div2, file$u, 111, 8, 5134);
    			attr_dev(div3, "class", "uk-margin-medium");
    			add_location(div3, file$u, 109, 4, 5017);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "form-addr");
    			add_location(label1, file$u, 138, 8, 6678);
    			attr_dev(input2, "class", "uk-input");
    			attr_dev(input2, "id", "form-address");
    			attr_dev(input2, "name", "address");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", "Address");
    			set_style(input2, "color", "black");
    			toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[6].address && /*$touched*/ ctx[7].address);
    			add_location(input2, file$u, 141, 16, 6896);
    			attr_dev(div4, "class", "uk-width-1-2@s");
    			add_location(div4, file$u, 140, 12, 6851);
    			attr_dev(input3, "class", "uk-input");
    			attr_dev(input3, "id", "form-zip");
    			attr_dev(input3, "name", "zip");
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "placeholder", "ZIP");
    			set_style(input3, "color", "black");
    			toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[6].zip && /*$touched*/ ctx[7].zip);
    			add_location(input3, file$u, 146, 16, 7264);
    			attr_dev(div5, "class", "uk-width-1-2@s");
    			add_location(div5, file$u, 145, 12, 7219);
    			attr_dev(input4, "class", "uk-input");
    			attr_dev(input4, "id", "form-city");
    			attr_dev(input4, "name", "city");
    			attr_dev(input4, "type", "text");
    			attr_dev(input4, "placeholder", "City");
    			set_style(input4, "color", "black");
    			toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[6].city && /*$touched*/ ctx[7].city);
    			add_location(input4, file$u, 151, 16, 7608);
    			attr_dev(div6, "class", "uk-width-1-2@s");
    			add_location(div6, file$u, 150, 12, 7563);
    			attr_dev(select, "class", "uk-select");
    			attr_dev(select, "id", "form-country");
    			attr_dev(select, "name", "country");
    			attr_dev(select, "type", "text");
    			set_style(select, "color", "black");
    			toggle_class(select, "uk-form-danger", /*$errors*/ ctx[6].country && /*$touched*/ ctx[7].country);
    			add_location(select, file$u, 156, 16, 7958);
    			attr_dev(div7, "class", "uk-width-1-2@s");
    			add_location(div7, file$u, 155, 12, 7913);
    			attr_dev(div8, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div8, "id", "form-addr");
    			attr_dev(div8, "uk-grid", "");
    			add_location(div8, file$u, 139, 8, 6747);
    			attr_dev(div9, "class", "uk-margin-medium");
    			add_location(div9, file$u, 137, 4, 6639);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$u, 198, 8, 10458);
    			attr_dev(button1, "class", "uk-button uk-margin-large-left");
    			attr_dev(button1, "id", "submit");
    			attr_dev(button1, "type", "submit");
    			button1.disabled = button1_disabled_value = !/*$isValid*/ ctx[8] || !/*okEmail*/ ctx[3];
    			toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[8] && /*okEmail*/ ctx[3]);
    			add_location(button1, file$u, 199, 8, 10558);
    			attr_dev(div10, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div10, file$u, 197, 4, 10376);
    			attr_dev(form_1, "class", "uk-form");
    			toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[4]);
    			add_location(form_1, file$u, 101, 0, 3461);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			if_block0.m(h4, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, a, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, form_1, anchor);
    			if (if_block1) if_block1.m(form_1, null);
    			append_dev(form_1, t2);
    			append_dev(form_1, div3);
    			append_dev(div3, label0);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$form*/ ctx[2].name);
    			append_dev(div2, t5);
    			append_dev(div2, div1);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t6);
    			append_dev(div1, input1);
    			set_input_value(input1, /*$form*/ ctx[2].email);
    			append_dev(div2, t7);
    			if (if_block3) if_block3.m(div2, null);
    			append_dev(form_1, t8);
    			append_dev(form_1, div9);
    			append_dev(div9, label1);
    			append_dev(div9, t10);
    			append_dev(div9, div8);
    			append_dev(div8, div4);
    			append_dev(div4, input2);
    			set_input_value(input2, /*$form*/ ctx[2].address);
    			append_dev(div8, t11);
    			append_dev(div8, div5);
    			append_dev(div5, input3);
    			set_input_value(input3, /*$form*/ ctx[2].zip);
    			append_dev(div8, t12);
    			append_dev(div8, div6);
    			append_dev(div6, input4);
    			set_input_value(input4, /*$form*/ ctx[2].city);
    			append_dev(div8, t13);
    			append_dev(div8, div7);
    			append_dev(div7, select);
    			if (if_block4) if_block4.m(select, null);
    			append_dev(select, if_block4_anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			append_dev(form_1, t14);
    			if (if_block5) if_block5.m(form_1, null);
    			append_dev(form_1, t15);
    			append_dev(form_1, div10);
    			append_dev(div10, button0);
    			append_dev(div10, t17);
    			append_dev(div10, button1);
    			append_dev(button1, t18);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keyup", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input0, "blur", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[18]),
    					listen_dev(input1, "keyup", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input1, "blur", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[19]),
    					listen_dev(input2, "keyup", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input2, "blur", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[20]),
    					listen_dev(input3, "keyup", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input3, "blur", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[21]),
    					listen_dev(input4, "keyup", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input4, "blur", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[22]),
    					listen_dev(select, "change", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(select, "blur", /*handleChange*/ ctx[13], false, false, false),
    					listen_dev(button0, "click", /*cancel*/ ctx[15], false, false, false),
    					listen_dev(form_1, "submit", /*handleSubmit*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h4, null);
    				}
    			}

    			if (/*member*/ ctx[0] === null) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_6$9(ctx);
    					if_block1.c();
    					if_block1.m(form_1, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*$form*/ 4 && input0.value !== /*$form*/ ctx[2].name) {
    				set_input_value(input0, /*$form*/ ctx[2].name);
    			}

    			if (dirty & /*$errors, $touched*/ 192) {
    				toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[6].name && /*$touched*/ ctx[7].name);
    			}

    			if (!/*okEmail*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_5$b(ctx);
    					if_block2.c();
    					if_block2.m(div1, t6);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*$form*/ 4 && input1.value !== /*$form*/ ctx[2].email) {
    				set_input_value(input1, /*$form*/ ctx[2].email);
    			}

    			if (dirty & /*okEmail, $errors, $touched*/ 200) {
    				toggle_class(input1, "uk-form-danger", !/*okEmail*/ ctx[3] || /*$errors*/ ctx[6].email && /*$touched*/ ctx[7].email);
    			}

    			if (!/*okEmail*/ ctx[3]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_3$g(ctx);
    					if_block3.c();
    					if_block3.m(div2, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (dirty & /*$form*/ 4 && input2.value !== /*$form*/ ctx[2].address) {
    				set_input_value(input2, /*$form*/ ctx[2].address);
    			}

    			if (dirty & /*$errors, $touched*/ 192) {
    				toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[6].address && /*$touched*/ ctx[7].address);
    			}

    			if (dirty & /*$form*/ 4 && input3.value !== /*$form*/ ctx[2].zip) {
    				set_input_value(input3, /*$form*/ ctx[2].zip);
    			}

    			if (dirty & /*$errors, $touched*/ 192) {
    				toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[6].zip && /*$touched*/ ctx[7].zip);
    			}

    			if (dirty & /*$form*/ 4 && input4.value !== /*$form*/ ctx[2].city) {
    				set_input_value(input4, /*$form*/ ctx[2].city);
    			}

    			if (dirty & /*$errors, $touched*/ 192) {
    				toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[6].city && /*$touched*/ ctx[7].city);
    			}

    			if (/*member*/ ctx[0] === undefined || /*member*/ ctx[0] === null || /*member*/ ctx[0].country === null || /*member*/ ctx[0].country === '') {
    				if (if_block4) ; else {
    					if_block4 = create_if_block_2$j(ctx);
    					if_block4.c();
    					if_block4.m(select, if_block4_anchor);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (dirty & /*countryArray, member, undefined*/ 1) {
    				each_value = countryArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$k(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$k(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*$errors, $touched*/ 192) {
    				toggle_class(select, "uk-form-danger", /*$errors*/ ctx[6].country && /*$touched*/ ctx[7].country);
    			}

    			if (/*member*/ ctx[0] === null) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block$t(ctx);
    					if_block5.c();
    					if_block5.m(form_1, t15);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (dirty & /*member, renew*/ 3 && t18_value !== (t18_value = (/*member*/ ctx[0] !== null && /*renew*/ ctx[1] !== undefined && /*renew*/ ctx[1] === false
    			? 'Save'
    			: 'Continue') + "")) set_data_dev(t18, t18_value);

    			if (dirty & /*$isValid, okEmail*/ 264 && button1_disabled_value !== (button1_disabled_value = !/*$isValid*/ ctx[8] || !/*okEmail*/ ctx[3])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*$isValid, okEmail*/ 264) {
    				toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[8] && /*okEmail*/ ctx[3]);
    			}

    			if (dirty & /*$screenWidthL*/ 16) {
    				toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[4]);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if_block0.d();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(form_1);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block5) if_block5.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let $form;
    	let $memberEmails;
    	let $screenWidthL;
    	let $screenWidthS;
    	let $errors;
    	let $touched;
    	let $isValid;
    	validate_store(memberEmails, 'memberEmails');
    	component_subscribe($$self, memberEmails, $$value => $$invalidate(17, $memberEmails = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(4, $screenWidthL = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(5, $screenWidthS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MemberForm', slots, []);
    	let { member = undefined } = $$props;
    	let { renew } = $$props;
    	let okEmail;
    	const dispatch = createEventDispatcher();

    	const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    		initialValues: {
    			name: '',
    			email: '',
    			address: '',
    			zip: '',
    			city: '',
    			country: '',
    			start_date: DateTime_1.now().toSQLDate(),
    			agree: false,
    			newsletter: true
    		},
    		onSubmit: values => {
    			if (member === null) $$invalidate(0, member = {});
    			Object.entries(values).forEach(e => $$invalidate(0, member[e[0]] = e[1], member));
    			if (renew) $$invalidate(0, member.renew_date = DateTime_1.now().plus({ years: 1 }).toSQLDate(), member);
    			dispatch('message', { goto: 'signature' });
    		},
    		validationSchema: create$4().shape({
    			name: create$7().min(4).required(),
    			email: create$7().email().required(),
    			address: create$7().min(4).required(),
    			zip: create$7().min(4).required(),
    			city: create$7().min(2).required(),
    			country: create$7().min(4).required(),
    			start_date: create$5().min(DateTime_1.now().minus({ years: 30 }).toJSDate()).max(DateTime_1.now().plus({ years: 1 }).toJSDate()).transform((date, string) => DateTime_1.fromSQL(string).toJSDate()).required(),
    			agree: create$8().oneOf([true]),
    			newsletter: create$8()
    		})
    	});

    	validate_store(form, 'form');
    	component_subscribe($$self, form, value => $$invalidate(2, $form = value));
    	validate_store(errors, 'errors');
    	component_subscribe($$self, errors, value => $$invalidate(6, $errors = value));
    	validate_store(touched, 'touched');
    	component_subscribe($$self, touched, value => $$invalidate(7, $touched = value));
    	validate_store(isValid, 'isValid');
    	component_subscribe($$self, isValid, value => $$invalidate(8, $isValid = value));

    	onMount(() => {
    		if (member !== undefined) {
    			set_store_value(
    				form,
    				$form.name = member !== null && member.name !== null
    				? member.name
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.email = member !== null && member.email !== null
    				? member.email
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.address = member !== null && member.address !== null
    				? member.address
    				: '',
    				$form
    			);

    			set_store_value(form, $form.zip = member !== null && member.zip !== null ? member.zip : '', $form);

    			set_store_value(
    				form,
    				$form.city = member !== null && member.city !== null
    				? member.city
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.country = member !== null && member.country !== null
    				? member.country
    				: '',
    				$form
    			);

    			set_store_value(form, $form.agree = member !== null, $form);

    			set_store_value(
    				form,
    				$form.newsletter = member !== null && member.newsletter !== null
    				? member.newsletter
    				: true,
    				$form
    			);

    			// ugly hack to get force evaluate isValid
    			if (member === null) handleSubmit(null);
    		}

    		flatpickr('#form-start_date', { monthSelectorType: 'static' });
    	});

    	function cancel() {
    		dispatch('message', { goto: 'cancel' });
    	}

    	function jumpEdit() {
    		dispatch('message', { goto: 'jumpEdit', email: $form.email });
    	}

    	const writable_props = ['member', 'renew'];

    	Object_1$5.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MemberForm> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		$form.name = this.value;
    		form.set($form);
    	}

    	function input1_input_handler() {
    		$form.email = this.value;
    		form.set($form);
    	}

    	function input2_input_handler() {
    		$form.address = this.value;
    		form.set($form);
    	}

    	function input3_input_handler() {
    		$form.zip = this.value;
    		form.set($form);
    	}

    	function input4_input_handler() {
    		$form.city = this.value;
    		form.set($form);
    	}

    	function input0_input_handler_1() {
    		$form.start_date = this.value;
    		form.set($form);
    	}

    	function input1_change_handler() {
    		$form.agree = this.value;
    		form.set($form);
    	}

    	function input2_change_handler() {
    		$form.newsletter = this.value;
    		form.set($form);
    	}

    	$$self.$$set = $$props => {
    		if ('member' in $$props) $$invalidate(0, member = $$props.member);
    		if ('renew' in $$props) $$invalidate(1, renew = $$props.renew);
    	};

    	$$self.$capture_state = () => ({
    		DateTime: DateTime_1,
    		createEventDispatcher,
    		onMount,
    		createForm,
    		yup,
    		flatpickr,
    		screenWidthL,
    		screenWidthS,
    		countryArray,
    		memberEmails,
    		member,
    		renew,
    		okEmail,
    		dispatch,
    		form,
    		errors,
    		touched,
    		state,
    		isValid,
    		handleChange,
    		handleSubmit,
    		cancel,
    		jumpEdit,
    		$form,
    		$memberEmails,
    		$screenWidthL,
    		$screenWidthS,
    		$errors,
    		$touched,
    		$isValid
    	});

    	$$self.$inject_state = $$props => {
    		if ('member' in $$props) $$invalidate(0, member = $$props.member);
    		if ('renew' in $$props) $$invalidate(1, renew = $$props.renew);
    		if ('okEmail' in $$props) $$invalidate(3, okEmail = $$props.okEmail);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*member, $memberEmails, $form*/ 131077) {
    			$$invalidate(3, okEmail = member !== null || !$memberEmails.includes($form.email));
    		}
    	};

    	return [
    		member,
    		renew,
    		$form,
    		okEmail,
    		$screenWidthL,
    		$screenWidthS,
    		$errors,
    		$touched,
    		$isValid,
    		form,
    		errors,
    		touched,
    		isValid,
    		handleChange,
    		handleSubmit,
    		cancel,
    		jumpEdit,
    		$memberEmails,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input0_input_handler_1,
    		input1_change_handler,
    		input2_change_handler
    	];
    }

    class MemberForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$u, create_fragment$u, safe_not_equal, { member: 0, renew: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MemberForm",
    			options,
    			id: create_fragment$u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*renew*/ ctx[1] === undefined && !('renew' in props)) {
    			console.warn("<MemberForm> was created without expected prop 'renew'");
    		}
    	}

    	get member() {
    		throw new Error("<MemberForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set member(value) {
    		throw new Error("<MemberForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get renew() {
    		throw new Error("<MemberForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set renew(value) {
    		throw new Error("<MemberForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*!
     * Signature Pad v4.0.2 | https://github.com/szimek/signature_pad
     * (c) 2022 Szymon Nowak | Released under the MIT license
     */

    class Point {
        constructor(x, y, pressure, time) {
            if (isNaN(x) || isNaN(y)) {
                throw new Error(`Point is invalid: (${x}, ${y})`);
            }
            this.x = +x;
            this.y = +y;
            this.pressure = pressure || 0;
            this.time = time || Date.now();
        }
        distanceTo(start) {
            return Math.sqrt(Math.pow(this.x - start.x, 2) + Math.pow(this.y - start.y, 2));
        }
        equals(other) {
            return (this.x === other.x &&
                this.y === other.y &&
                this.pressure === other.pressure &&
                this.time === other.time);
        }
        velocityFrom(start) {
            return this.time !== start.time
                ? this.distanceTo(start) / (this.time - start.time)
                : 0;
        }
    }

    class Bezier {
        constructor(startPoint, control2, control1, endPoint, startWidth, endWidth) {
            this.startPoint = startPoint;
            this.control2 = control2;
            this.control1 = control1;
            this.endPoint = endPoint;
            this.startWidth = startWidth;
            this.endWidth = endWidth;
        }
        static fromPoints(points, widths) {
            const c2 = this.calculateControlPoints(points[0], points[1], points[2]).c2;
            const c3 = this.calculateControlPoints(points[1], points[2], points[3]).c1;
            return new Bezier(points[1], c2, c3, points[2], widths.start, widths.end);
        }
        static calculateControlPoints(s1, s2, s3) {
            const dx1 = s1.x - s2.x;
            const dy1 = s1.y - s2.y;
            const dx2 = s2.x - s3.x;
            const dy2 = s2.y - s3.y;
            const m1 = { x: (s1.x + s2.x) / 2.0, y: (s1.y + s2.y) / 2.0 };
            const m2 = { x: (s2.x + s3.x) / 2.0, y: (s2.y + s3.y) / 2.0 };
            const l1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            const l2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
            const dxm = m1.x - m2.x;
            const dym = m1.y - m2.y;
            const k = l2 / (l1 + l2);
            const cm = { x: m2.x + dxm * k, y: m2.y + dym * k };
            const tx = s2.x - cm.x;
            const ty = s2.y - cm.y;
            return {
                c1: new Point(m1.x + tx, m1.y + ty),
                c2: new Point(m2.x + tx, m2.y + ty),
            };
        }
        length() {
            const steps = 10;
            let length = 0;
            let px;
            let py;
            for (let i = 0; i <= steps; i += 1) {
                const t = i / steps;
                const cx = this.point(t, this.startPoint.x, this.control1.x, this.control2.x, this.endPoint.x);
                const cy = this.point(t, this.startPoint.y, this.control1.y, this.control2.y, this.endPoint.y);
                if (i > 0) {
                    const xdiff = cx - px;
                    const ydiff = cy - py;
                    length += Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                }
                px = cx;
                py = cy;
            }
            return length;
        }
        point(t, start, c1, c2, end) {
            return (start * (1.0 - t) * (1.0 - t) * (1.0 - t))
                + (3.0 * c1 * (1.0 - t) * (1.0 - t) * t)
                + (3.0 * c2 * (1.0 - t) * t * t)
                + (end * t * t * t);
        }
    }

    class SignatureEventTarget {
        constructor() {
            try {
                this._et = new EventTarget();
            }
            catch (error) {
                this._et = document;
            }
        }
        addEventListener(type, listener, options) {
            this._et.addEventListener(type, listener, options);
        }
        dispatchEvent(event) {
            return this._et.dispatchEvent(event);
        }
        removeEventListener(type, callback, options) {
            this._et.removeEventListener(type, callback, options);
        }
    }

    function throttle(fn, wait = 250) {
        let previous = 0;
        let timeout = null;
        let result;
        let storedContext;
        let storedArgs;
        const later = () => {
            previous = Date.now();
            timeout = null;
            result = fn.apply(storedContext, storedArgs);
            if (!timeout) {
                storedContext = null;
                storedArgs = [];
            }
        };
        return function wrapper(...args) {
            const now = Date.now();
            const remaining = wait - (now - previous);
            storedContext = this;
            storedArgs = args;
            if (remaining <= 0 || remaining > wait) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                previous = now;
                result = fn.apply(storedContext, storedArgs);
                if (!timeout) {
                    storedContext = null;
                    storedArgs = [];
                }
            }
            else if (!timeout) {
                timeout = window.setTimeout(later, remaining);
            }
            return result;
        };
    }

    class SignaturePad extends SignatureEventTarget {
        constructor(canvas, options = {}) {
            super();
            this.canvas = canvas;
            this._handleMouseDown = (event) => {
                if (event.buttons === 1) {
                    this._drawningStroke = true;
                    this._strokeBegin(event);
                }
            };
            this._handleMouseMove = (event) => {
                if (this._drawningStroke) {
                    this._strokeMoveUpdate(event);
                }
            };
            this._handleMouseUp = (event) => {
                if (event.buttons === 1 && this._drawningStroke) {
                    this._drawningStroke = false;
                    this._strokeEnd(event);
                }
            };
            this._handleTouchStart = (event) => {
                event.preventDefault();
                if (event.targetTouches.length === 1) {
                    const touch = event.changedTouches[0];
                    this._strokeBegin(touch);
                }
            };
            this._handleTouchMove = (event) => {
                event.preventDefault();
                const touch = event.targetTouches[0];
                this._strokeMoveUpdate(touch);
            };
            this._handleTouchEnd = (event) => {
                const wasCanvasTouched = event.target === this.canvas;
                if (wasCanvasTouched) {
                    event.preventDefault();
                    const touch = event.changedTouches[0];
                    this._strokeEnd(touch);
                }
            };
            this._handlePointerStart = (event) => {
                this._drawningStroke = true;
                event.preventDefault();
                this._strokeBegin(event);
            };
            this._handlePointerMove = (event) => {
                if (this._drawningStroke) {
                    event.preventDefault();
                    this._strokeMoveUpdate(event);
                }
            };
            this._handlePointerEnd = (event) => {
                this._drawningStroke = false;
                const wasCanvasTouched = event.target === this.canvas;
                if (wasCanvasTouched) {
                    event.preventDefault();
                    this._strokeEnd(event);
                }
            };
            this.velocityFilterWeight = options.velocityFilterWeight || 0.7;
            this.minWidth = options.minWidth || 0.5;
            this.maxWidth = options.maxWidth || 2.5;
            this.throttle = ('throttle' in options ? options.throttle : 16);
            this.minDistance = ('minDistance' in options ? options.minDistance : 5);
            this.dotSize = options.dotSize || 0;
            this.penColor = options.penColor || 'black';
            this.backgroundColor = options.backgroundColor || 'rgba(0,0,0,0)';
            this._strokeMoveUpdate = this.throttle
                ? throttle(SignaturePad.prototype._strokeUpdate, this.throttle)
                : SignaturePad.prototype._strokeUpdate;
            this._ctx = canvas.getContext('2d');
            this.clear();
            this.on();
        }
        clear() {
            const { _ctx: ctx, canvas } = this;
            ctx.fillStyle = this.backgroundColor;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            this._data = [];
            this._reset();
            this._isEmpty = true;
        }
        fromDataURL(dataUrl, options = {}) {
            return new Promise((resolve, reject) => {
                const image = new Image();
                const ratio = options.ratio || window.devicePixelRatio || 1;
                const width = options.width || this.canvas.width / ratio;
                const height = options.height || this.canvas.height / ratio;
                const xOffset = options.xOffset || 0;
                const yOffset = options.yOffset || 0;
                this._reset();
                image.onload = () => {
                    this._ctx.drawImage(image, xOffset, yOffset, width, height);
                    resolve();
                };
                image.onerror = (error) => {
                    reject(error);
                };
                image.crossOrigin = 'anonymous';
                image.src = dataUrl;
                this._isEmpty = false;
            });
        }
        toDataURL(type = 'image/png', encoderOptions) {
            switch (type) {
                case 'image/svg+xml':
                    return this._toSVG();
                default:
                    return this.canvas.toDataURL(type, encoderOptions);
            }
        }
        on() {
            this.canvas.style.touchAction = 'none';
            this.canvas.style.msTouchAction = 'none';
            this.canvas.style.userSelect = 'none';
            const isIOS = /Macintosh/.test(navigator.userAgent) && 'ontouchstart' in document;
            if (window.PointerEvent && !isIOS) {
                this._handlePointerEvents();
            }
            else {
                this._handleMouseEvents();
                if ('ontouchstart' in window) {
                    this._handleTouchEvents();
                }
            }
        }
        off() {
            this.canvas.style.touchAction = 'auto';
            this.canvas.style.msTouchAction = 'auto';
            this.canvas.style.userSelect = 'auto';
            this.canvas.removeEventListener('pointerdown', this._handlePointerStart);
            this.canvas.removeEventListener('pointermove', this._handlePointerMove);
            document.removeEventListener('pointerup', this._handlePointerEnd);
            this.canvas.removeEventListener('mousedown', this._handleMouseDown);
            this.canvas.removeEventListener('mousemove', this._handleMouseMove);
            document.removeEventListener('mouseup', this._handleMouseUp);
            this.canvas.removeEventListener('touchstart', this._handleTouchStart);
            this.canvas.removeEventListener('touchmove', this._handleTouchMove);
            this.canvas.removeEventListener('touchend', this._handleTouchEnd);
        }
        isEmpty() {
            return this._isEmpty;
        }
        fromData(pointGroups, { clear = true } = {}) {
            if (clear) {
                this.clear();
            }
            this._fromData(pointGroups, this._drawCurve.bind(this), this._drawDot.bind(this));
            this._data = clear ? pointGroups : this._data.concat(pointGroups);
        }
        toData() {
            return this._data;
        }
        _strokeBegin(event) {
            this.dispatchEvent(new CustomEvent('beginStroke', { detail: event }));
            const newPointGroup = {
                dotSize: this.dotSize,
                minWidth: this.minWidth,
                maxWidth: this.maxWidth,
                penColor: this.penColor,
                points: [],
            };
            this._data.push(newPointGroup);
            this._reset();
            this._strokeUpdate(event);
        }
        _strokeUpdate(event) {
            if (this._data.length === 0) {
                this._strokeBegin(event);
                return;
            }
            this.dispatchEvent(new CustomEvent('beforeUpdateStroke', { detail: event }));
            const x = event.clientX;
            const y = event.clientY;
            const pressure = event.pressure !== undefined
                ? event.pressure
                : event.force !== undefined
                    ? event.force
                    : 0;
            const point = this._createPoint(x, y, pressure);
            const lastPointGroup = this._data[this._data.length - 1];
            const lastPoints = lastPointGroup.points;
            const lastPoint = lastPoints.length > 0 && lastPoints[lastPoints.length - 1];
            const isLastPointTooClose = lastPoint
                ? point.distanceTo(lastPoint) <= this.minDistance
                : false;
            const { penColor, dotSize, minWidth, maxWidth } = lastPointGroup;
            if (!lastPoint || !(lastPoint && isLastPointTooClose)) {
                const curve = this._addPoint(point);
                if (!lastPoint) {
                    this._drawDot(point, {
                        penColor,
                        dotSize,
                        minWidth,
                        maxWidth,
                    });
                }
                else if (curve) {
                    this._drawCurve(curve, {
                        penColor,
                        dotSize,
                        minWidth,
                        maxWidth,
                    });
                }
                lastPoints.push({
                    time: point.time,
                    x: point.x,
                    y: point.y,
                    pressure: point.pressure,
                });
            }
            this.dispatchEvent(new CustomEvent('afterUpdateStroke', { detail: event }));
        }
        _strokeEnd(event) {
            this._strokeUpdate(event);
            this.dispatchEvent(new CustomEvent('endStroke', { detail: event }));
        }
        _handlePointerEvents() {
            this._drawningStroke = false;
            this.canvas.addEventListener('pointerdown', this._handlePointerStart);
            this.canvas.addEventListener('pointermove', this._handlePointerMove);
            document.addEventListener('pointerup', this._handlePointerEnd);
        }
        _handleMouseEvents() {
            this._drawningStroke = false;
            this.canvas.addEventListener('mousedown', this._handleMouseDown);
            this.canvas.addEventListener('mousemove', this._handleMouseMove);
            document.addEventListener('mouseup', this._handleMouseUp);
        }
        _handleTouchEvents() {
            this.canvas.addEventListener('touchstart', this._handleTouchStart);
            this.canvas.addEventListener('touchmove', this._handleTouchMove);
            this.canvas.addEventListener('touchend', this._handleTouchEnd);
        }
        _reset() {
            this._lastPoints = [];
            this._lastVelocity = 0;
            this._lastWidth = (this.minWidth + this.maxWidth) / 2;
            this._ctx.fillStyle = this.penColor;
        }
        _createPoint(x, y, pressure) {
            const rect = this.canvas.getBoundingClientRect();
            return new Point(x - rect.left, y - rect.top, pressure, new Date().getTime());
        }
        _addPoint(point) {
            const { _lastPoints } = this;
            _lastPoints.push(point);
            if (_lastPoints.length > 2) {
                if (_lastPoints.length === 3) {
                    _lastPoints.unshift(_lastPoints[0]);
                }
                const widths = this._calculateCurveWidths(_lastPoints[1], _lastPoints[2]);
                const curve = Bezier.fromPoints(_lastPoints, widths);
                _lastPoints.shift();
                return curve;
            }
            return null;
        }
        _calculateCurveWidths(startPoint, endPoint) {
            const velocity = this.velocityFilterWeight * endPoint.velocityFrom(startPoint) +
                (1 - this.velocityFilterWeight) * this._lastVelocity;
            const newWidth = this._strokeWidth(velocity);
            const widths = {
                end: newWidth,
                start: this._lastWidth,
            };
            this._lastVelocity = velocity;
            this._lastWidth = newWidth;
            return widths;
        }
        _strokeWidth(velocity) {
            return Math.max(this.maxWidth / (velocity + 1), this.minWidth);
        }
        _drawCurveSegment(x, y, width) {
            const ctx = this._ctx;
            ctx.moveTo(x, y);
            ctx.arc(x, y, width, 0, 2 * Math.PI, false);
            this._isEmpty = false;
        }
        _drawCurve(curve, options) {
            const ctx = this._ctx;
            const widthDelta = curve.endWidth - curve.startWidth;
            const drawSteps = Math.ceil(curve.length()) * 2;
            ctx.beginPath();
            ctx.fillStyle = options.penColor;
            for (let i = 0; i < drawSteps; i += 1) {
                const t = i / drawSteps;
                const tt = t * t;
                const ttt = tt * t;
                const u = 1 - t;
                const uu = u * u;
                const uuu = uu * u;
                let x = uuu * curve.startPoint.x;
                x += 3 * uu * t * curve.control1.x;
                x += 3 * u * tt * curve.control2.x;
                x += ttt * curve.endPoint.x;
                let y = uuu * curve.startPoint.y;
                y += 3 * uu * t * curve.control1.y;
                y += 3 * u * tt * curve.control2.y;
                y += ttt * curve.endPoint.y;
                const width = Math.min(curve.startWidth + ttt * widthDelta, options.maxWidth);
                this._drawCurveSegment(x, y, width);
            }
            ctx.closePath();
            ctx.fill();
        }
        _drawDot(point, options) {
            const ctx = this._ctx;
            const width = options.dotSize > 0
                ? options.dotSize
                : (options.minWidth + options.maxWidth) / 2;
            ctx.beginPath();
            this._drawCurveSegment(point.x, point.y, width);
            ctx.closePath();
            ctx.fillStyle = options.penColor;
            ctx.fill();
        }
        _fromData(pointGroups, drawCurve, drawDot) {
            for (const group of pointGroups) {
                const { penColor, dotSize, minWidth, maxWidth, points } = group;
                if (points.length > 1) {
                    for (let j = 0; j < points.length; j += 1) {
                        const basicPoint = points[j];
                        const point = new Point(basicPoint.x, basicPoint.y, basicPoint.pressure, basicPoint.time);
                        this.penColor = penColor;
                        if (j === 0) {
                            this._reset();
                        }
                        const curve = this._addPoint(point);
                        if (curve) {
                            drawCurve(curve, {
                                penColor,
                                dotSize,
                                minWidth,
                                maxWidth,
                            });
                        }
                    }
                }
                else {
                    this._reset();
                    drawDot(points[0], {
                        penColor,
                        dotSize,
                        minWidth,
                        maxWidth,
                    });
                }
            }
        }
        _toSVG() {
            const pointGroups = this._data;
            const ratio = Math.max(window.devicePixelRatio || 1, 1);
            const minX = 0;
            const minY = 0;
            const maxX = this.canvas.width / ratio;
            const maxY = this.canvas.height / ratio;
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', this.canvas.width.toString());
            svg.setAttribute('height', this.canvas.height.toString());
            this._fromData(pointGroups, (curve, { penColor }) => {
                const path = document.createElement('path');
                if (!isNaN(curve.control1.x) &&
                    !isNaN(curve.control1.y) &&
                    !isNaN(curve.control2.x) &&
                    !isNaN(curve.control2.y)) {
                    const attr = `M ${curve.startPoint.x.toFixed(3)},${curve.startPoint.y.toFixed(3)} ` +
                        `C ${curve.control1.x.toFixed(3)},${curve.control1.y.toFixed(3)} ` +
                        `${curve.control2.x.toFixed(3)},${curve.control2.y.toFixed(3)} ` +
                        `${curve.endPoint.x.toFixed(3)},${curve.endPoint.y.toFixed(3)}`;
                    path.setAttribute('d', attr);
                    path.setAttribute('stroke-width', (curve.endWidth * 2.25).toFixed(3));
                    path.setAttribute('stroke', penColor);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-linecap', 'round');
                    svg.appendChild(path);
                }
            }, (point, { penColor, dotSize, minWidth, maxWidth }) => {
                const circle = document.createElement('circle');
                const size = dotSize > 0 ? dotSize : (minWidth + maxWidth) / 2;
                circle.setAttribute('r', size.toString());
                circle.setAttribute('cx', point.x.toString());
                circle.setAttribute('cy', point.y.toString());
                circle.setAttribute('fill', penColor);
                svg.appendChild(circle);
            });
            const prefix = 'data:image/svg+xml;base64,';
            const header = '<svg' +
                ' xmlns="http://www.w3.org/2000/svg"' +
                ' xmlns:xlink="http://www.w3.org/1999/xlink"' +
                ` viewBox="${minX} ${minY} ${this.canvas.width} ${this.canvas.height}"` +
                ` width="${maxX}"` +
                ` height="${maxY}"` +
                '>';
            let body = svg.innerHTML;
            if (body === undefined) {
                const dummy = document.createElement('dummy');
                const nodes = svg.childNodes;
                dummy.innerHTML = '';
                for (let i = 0; i < nodes.length; i += 1) {
                    dummy.appendChild(nodes[i].cloneNode(true));
                }
                body = dummy.innerHTML;
            }
            const footer = '</svg>';
            const data = header + body + footer;
            return prefix + btoa(data);
        }
    }

    /* src/components/MemberSignature.svelte generated by Svelte v3.45.0 */
    const file$t = "src/components/MemberSignature.svelte";

    // (56:4) {:else}
    function create_else_block_1$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Creating member");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$f.name,
    		type: "else",
    		source: "(56:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (54:28) 
    function create_if_block_2$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Updating member");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$i.name,
    		type: "if",
    		source: "(54:28) ",
    		ctx
    	});

    	return block;
    }

    // (52:4) {#if !dispatched}
    function create_if_block_1$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Please sign");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(52:4) {#if !dispatched}",
    		ctx
    	});

    	return block;
    }

    // (64:0) {:else}
    function create_else_block$r(ctx) {
    	let div2;
    	let div0;
    	let canvas;
    	let canvas_width_value;
    	let canvas_height_value;
    	let t0;
    	let div1;
    	let a;
    	let t2;
    	let div3;
    	let button0;
    	let t4;
    	let button1;
    	let t5;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			canvas = element("canvas");
    			t0 = space();
    			div1 = element("div");
    			a = element("a");
    			a.textContent = "Erase canvas";
    			t2 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Back";
    			t4 = space();
    			button1 = element("button");
    			t5 = text$1("Save");
    			attr_dev(canvas, "id", "signature-pad");
    			attr_dev(canvas, "width", canvas_width_value = /*$screenWidthM*/ ctx[5] ? 500 : 700);
    			attr_dev(canvas, "height", canvas_height_value = /*$screenWidthM*/ ctx[5] ? 300 : 450);
    			add_location(canvas, file$t, 66, 12, 1667);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$t, 65, 8, 1618);
    			attr_dev(a, "class", "uk-link-text uk-text-meta uk-margin");
    			attr_dev(a, "href", '#');
    			add_location(a, file$t, 69, 12, 1849);
    			attr_dev(div1, "class", "uk-flex uk-flex-center");
    			add_location(div1, file$t, 68, 8, 1800);
    			attr_dev(div2, "class", "uk-card uk-card-default");
    			add_location(div2, file$t, 64, 4, 1572);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$t, 73, 8, 2055);
    			attr_dev(button1, "class", "uk-button uk-margin-large-left");
    			button1.disabled = button1_disabled_value = !/*validated*/ ctx[4];
    			attr_dev(button1, "type", "button");
    			toggle_class(button1, "uk-button-primary", /*validated*/ ctx[4]);
    			add_location(button1, file$t, 75, 8, 2167);
    			attr_dev(div3, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div3, file$t, 72, 4, 1973);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, canvas);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, a);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, button0);
    			append_dev(div3, t4);
    			append_dev(div3, button1);
    			append_dev(button1, t5);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*clear*/ ctx[6], false, false, false),
    					listen_dev(button0, "click", /*back*/ ctx[7], false, false, false),
    					listen_dev(button1, "click", /*dispatchSignature*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$screenWidthM*/ 32 && canvas_width_value !== (canvas_width_value = /*$screenWidthM*/ ctx[5] ? 500 : 700)) {
    				attr_dev(canvas, "width", canvas_width_value);
    			}

    			if (dirty & /*$screenWidthM*/ 32 && canvas_height_value !== (canvas_height_value = /*$screenWidthM*/ ctx[5] ? 300 : 450)) {
    				attr_dev(canvas, "height", canvas_height_value);
    			}

    			if (dirty & /*validated*/ 16 && button1_disabled_value !== (button1_disabled_value = !/*validated*/ ctx[4])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*validated*/ 16) {
    				toggle_class(button1, "uk-button-primary", /*validated*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$r.name,
    		type: "else",
    		source: "(64:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:0) {#if dispatched}
    function create_if_block$s(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$t, 61, 8, 1515);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-xlarge-top");
    			add_location(div1, file$t, 60, 4, 1449);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(60:0) {#if dispatched}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let h4;
    	let t;
    	let if_block1_anchor;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[9]);

    	function select_block_type(ctx, dirty) {
    		if (!/*dispatched*/ ctx[3]) return create_if_block_1$j;
    		if (/*edit*/ ctx[0] || /*renew*/ ctx[1]) return create_if_block_2$i;
    		return create_else_block_1$f;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*dispatched*/ ctx[3]) return create_if_block$s;
    		return create_else_block$r;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			if_block0.c();
    			t = space();
    			if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom");
    			add_location(h4, file$t, 50, 0, 1194);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			if_block0.m(h4, null);
    			insert_dev(target, t, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(window, "resize", /*onwindowresize*/ ctx[9]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h4, null);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if_block0.d();
    			if (detaching) detach_dev(t);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $screenWidthM;
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(5, $screenWidthM = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MemberSignature', slots, []);
    	let { edit } = $$props;
    	let { renew } = $$props;
    	let innerWidth = 0;
    	let signaturePad;
    	let dispatched = false;
    	let validated = false;
    	const dispatch = createEventDispatcher();

    	onMount(() => {
    		if (!edit) {
    			signaturePad = new SignaturePad(document.querySelector("canvas"));

    			signaturePad.addEventListener(
    				"endStroke",
    				() => {
    					$$invalidate(4, validated = true);
    				},
    				{ once: false }
    			);
    		} else dispatchSignature();
    	});

    	function clear() {
    		signaturePad?.clear();
    		$$invalidate(4, validated = false);
    	}

    	function back() {
    		dispatch('message', { goto: 'form' });
    	}

    	function dispatchSignature() {
    		$$invalidate(3, dispatched = true);
    		if (signaturePad !== undefined && !signaturePad.isEmpty()) dispatch('message', { signature: signaturePad.toDataURL() }); else dispatch('message', {});
    	}

    	const writable_props = ['edit', 'renew'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MemberSignature> was created with unknown prop '${key}'`);
    	});

    	function onwindowresize() {
    		$$invalidate(2, innerWidth = window.innerWidth);
    	}

    	$$self.$$set = $$props => {
    		if ('edit' in $$props) $$invalidate(0, edit = $$props.edit);
    		if ('renew' in $$props) $$invalidate(1, renew = $$props.renew);
    	};

    	$$self.$capture_state = () => ({
    		SignaturePad,
    		createEventDispatcher,
    		onMount,
    		screenWidthM,
    		edit,
    		renew,
    		innerWidth,
    		signaturePad,
    		dispatched,
    		validated,
    		dispatch,
    		clear,
    		back,
    		dispatchSignature,
    		$screenWidthM
    	});

    	$$self.$inject_state = $$props => {
    		if ('edit' in $$props) $$invalidate(0, edit = $$props.edit);
    		if ('renew' in $$props) $$invalidate(1, renew = $$props.renew);
    		if ('innerWidth' in $$props) $$invalidate(2, innerWidth = $$props.innerWidth);
    		if ('signaturePad' in $$props) signaturePad = $$props.signaturePad;
    		if ('dispatched' in $$props) $$invalidate(3, dispatched = $$props.dispatched);
    		if ('validated' in $$props) $$invalidate(4, validated = $$props.validated);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*innerWidth*/ 4) {
    			innerWidth && clear();
    		}
    	};

    	return [
    		edit,
    		renew,
    		innerWidth,
    		dispatched,
    		validated,
    		$screenWidthM,
    		clear,
    		back,
    		dispatchSignature,
    		onwindowresize
    	];
    }

    class MemberSignature extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$t, create_fragment$t, safe_not_equal, { edit: 0, renew: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MemberSignature",
    			options,
    			id: create_fragment$t.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*edit*/ ctx[0] === undefined && !('edit' in props)) {
    			console.warn("<MemberSignature> was created without expected prop 'edit'");
    		}

    		if (/*renew*/ ctx[1] === undefined && !('renew' in props)) {
    			console.warn("<MemberSignature> was created without expected prop 'renew'");
    		}
    	}

    	get edit() {
    		throw new Error("<MemberSignature>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set edit(value) {
    		throw new Error("<MemberSignature>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get renew() {
    		throw new Error("<MemberSignature>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set renew(value) {
    		throw new Error("<MemberSignature>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Member.svelte generated by Svelte v3.45.0 */
    const file$s = "src/components/Member.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	return child_ctx;
    }

    // (167:8) {:else }
    function create_else_block_1$e(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let tbody;
    	let each_value = /*data*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Email";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "City";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Valid until ";
    			t7 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$s, 170, 20, 6195);
    			attr_dev(th1, "class", "uk-visible@s");
    			add_location(th1, file$s, 171, 20, 6229);
    			attr_dev(th2, "class", "uk-visible@l");
    			add_location(th2, file$s, 172, 20, 6285);
    			attr_dev(th3, "class", "uk-text-nowrap");
    			add_location(th3, file$s, 173, 20, 6340);
    			add_location(tr, file$s, 169, 16, 6170);
    			add_location(thead, file$s, 168, 16, 6146);
    			add_location(tbody, file$s, 176, 16, 6454);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$s, 167, 12, 6044);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(table, t7);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*openForm, data, DateTime*/ 8193) {
    				each_value = /*data*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$e.name,
    		type: "else",
    		source: "(167:8) {:else }",
    		ctx
    	});

    	return block;
    }

    // (165:8) {#if data.length === 0}
    function create_if_block_1$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading members...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(165:8) {#if data.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (186:20) {:else}
    function create_else_block_2$a(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*member*/ ctx[24].name + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*member*/ ctx[24].email + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*member*/ ctx[24].city + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = DateTime_1.fromSQL(/*member*/ ctx[24].renew_date).toFormat('dd LLL yyyy') + "";
    	let t6;
    	let t7;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[16](/*member*/ ctx[24]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			add_location(td0, file$s, 187, 28, 7124);
    			attr_dev(td1, "class", "uk-visible@s");
    			add_location(td1, file$s, 188, 28, 7175);
    			attr_dev(td2, "class", "uk-visible@l");
    			add_location(td2, file$s, 189, 28, 7248);
    			attr_dev(td3, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td3, file$s, 190, 28, 7320);
    			attr_dev(tr, "class", "uk-table-link");
    			add_location(tr, file$s, 186, 24, 7028);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);

    			if (!mounted) {
    				dispose = listen_dev(tr, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*member*/ ctx[24].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*data*/ 1 && t2_value !== (t2_value = /*member*/ ctx[24].email + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*data*/ 1 && t4_value !== (t4_value = /*member*/ ctx[24].city + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*data*/ 1 && t6_value !== (t6_value = DateTime_1.fromSQL(/*member*/ ctx[24].renew_date).toFormat('dd LLL yyyy') + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$a.name,
    		type: "else",
    		source: "(186:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (179:20) {#if DateTime.fromSQL(member.renew_date) < DateTime.now()}
    function create_if_block_2$h(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*member*/ ctx[24].name + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*member*/ ctx[24].email + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*member*/ ctx[24].city + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*member*/ ctx[24].renew_date + "";
    	let t6;
    	let t7;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[15](/*member*/ ctx[24]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			add_location(td0, file$s, 180, 28, 6700);
    			attr_dev(td1, "class", "uk-visible@s");
    			add_location(td1, file$s, 181, 28, 6751);
    			attr_dev(td2, "class", "uk-visible@l");
    			add_location(td2, file$s, 182, 28, 6824);
    			attr_dev(td3, "class", "uk-text-bold");
    			add_location(td3, file$s, 183, 28, 6896);
    			attr_dev(tr, "class", "uk-text-danger");
    			add_location(tr, file$s, 179, 24, 6604);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);

    			if (!mounted) {
    				dispose = listen_dev(tr, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*member*/ ctx[24].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*data*/ 1 && t2_value !== (t2_value = /*member*/ ctx[24].email + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*data*/ 1 && t4_value !== (t4_value = /*member*/ ctx[24].city + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*data*/ 1 && t6_value !== (t6_value = /*member*/ ctx[24].renew_date + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$h.name,
    		type: "if",
    		source: "(179:20) {#if DateTime.fromSQL(member.renew_date) < DateTime.now()}",
    		ctx
    	});

    	return block;
    }

    // (178:16) {#each data as member}
    function create_each_block$j(ctx) {
    	let show_if;
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (dirty & /*data*/ 1) show_if = null;
    		if (show_if == null) show_if = !!(DateTime_1.fromSQL(/*member*/ ctx[24].renew_date) < DateTime_1.now());
    		if (show_if) return create_if_block_2$h;
    		return create_else_block_2$a;
    	}

    	let current_block_type = select_block_type_1(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$j.name,
    		type: "each",
    		source: "(178:16) {#each data as member}",
    		ctx
    	});

    	return block;
    }

    // (222:16) {:else}
    function create_else_block$q(ctx) {
    	let previous_key = /*recreateForm*/ ctx[8];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*recreateForm*/ 256 && safe_not_equal(previous_key, previous_key = /*recreateForm*/ ctx[8])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_1$4(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$q.name,
    		type: "else",
    		source: "(222:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (218:16) {#if !showSignPad}
    function create_if_block$r(ctx) {
    	let previous_key = /*recreateForm*/ ctx[8];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$b(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*recreateForm*/ 256 && safe_not_equal(previous_key, previous_key = /*recreateForm*/ ctx[8])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block$b(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(218:16) {#if !showSignPad}",
    		ctx
    	});

    	return block;
    }

    // (223:20) {#key recreateForm}
    function create_key_block_1$4(ctx) {
    	let membersignature;
    	let current;

    	membersignature = new MemberSignature({
    			props: {
    				edit: /*editMember*/ ctx[5],
    				renew: /*renewMember*/ ctx[6]
    			},
    			$$inline: true
    		});

    	membersignature.$on("message", /*processSignup*/ ctx[14]);

    	const block = {
    		c: function create() {
    			create_component(membersignature.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(membersignature, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const membersignature_changes = {};
    			if (dirty & /*editMember*/ 32) membersignature_changes.edit = /*editMember*/ ctx[5];
    			if (dirty & /*renewMember*/ 64) membersignature_changes.renew = /*renewMember*/ ctx[6];
    			membersignature.$set(membersignature_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(membersignature.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(membersignature.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(membersignature, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_1$4.name,
    		type: "key",
    		source: "(223:20) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    // (219:20) {#key recreateForm}
    function create_key_block$b(ctx) {
    	let memberform;
    	let updating_member;
    	let current;

    	function memberform_member_binding(value) {
    		/*memberform_member_binding*/ ctx[18](value);
    	}

    	let memberform_props = { renew: /*renewMember*/ ctx[6] };

    	if (/*selectedMember*/ ctx[4] !== void 0) {
    		memberform_props.member = /*selectedMember*/ ctx[4];
    	}

    	memberform = new MemberForm({ props: memberform_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(memberform, 'member', memberform_member_binding));
    	memberform.$on("message", /*processSignup*/ ctx[14]);

    	const block = {
    		c: function create() {
    			create_component(memberform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(memberform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const memberform_changes = {};
    			if (dirty & /*renewMember*/ 64) memberform_changes.renew = /*renewMember*/ ctx[6];

    			if (!updating_member && dirty & /*selectedMember*/ 16) {
    				updating_member = true;
    				memberform_changes.member = /*selectedMember*/ ctx[4];
    				add_flush_callback(() => updating_member = false);
    			}

    			memberform.$set(memberform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(memberform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(memberform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(memberform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$b.name,
    		type: "key",
    		source: "(219:20) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let input;
    	let input_class_value;
    	let t0;
    	let button0;
    	let span;

    	let t1_value = (/*$screenWidthS*/ ctx[9]
    	? ''
    	: /*$screenWidthM*/ ctx[10]
    		? '\xa0member'
    		: '\xa0New member') + "";

    	let t1;
    	let t2;
    	let div4;
    	let div3;
    	let t3;
    	let infinitescroll;
    	let t4;
    	let div8;
    	let div7;
    	let button1;
    	let t5;
    	let div6;
    	let div5;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0) return create_if_block_1$i;
    		return create_else_block_1$e;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	infinitescroll = new InfiniteScroll({
    			props: {
    				hasMore: /*newBatch*/ ctx[1].length,
    				threshold: 80
    			},
    			$$inline: true
    		});

    	infinitescroll.$on("loadMore", /*loadMore_handler*/ ctx[17]);
    	const if_block_creators = [create_if_block$r, create_else_block$q];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (!/*showSignPad*/ ctx[7]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			button0 = element("button");
    			span = element("span");
    			t1 = text$1(t1_value);
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			if_block0.c();
    			t3 = space();
    			create_component(infinitescroll.$$.fragment);
    			t4 = space();
    			div8 = element("div");
    			div7 = element("div");
    			button1 = element("button");
    			t5 = space();
    			div6 = element("div");
    			div5 = element("div");
    			if_block1.c();

    			attr_dev(input, "class", input_class_value = "uk-input " + (/*$screenWidthS*/ ctx[9]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[10] || /*$screenWidthL*/ ctx[11]
    				? 'uk-width-medium'
    				: 'uk-width-large'));

    			attr_dev(input, "id", "autocomplete");
    			attr_dev(input, "type", "search");
    			attr_dev(input, "spellcheck", "false");
    			attr_dev(input, "autocorrect", "off");
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "autocapitalize", "off");
    			attr_dev(input, "maxlength", "256");
    			add_location(input, file$s, 156, 12, 5266);
    			attr_dev(span, "uk-icon", "icon: plus; ratio: 0.6");
    			add_location(span, file$s, 157, 113, 5636);
    			attr_dev(button0, "class", "uk-button uk-button-small uk-button-primary uk-margin-large-left");
    			add_location(button0, file$s, 157, 12, 5535);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$s, 155, 8, 5217);
    			attr_dev(div1, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6 paf-top-section-bg");
    			add_location(div1, file$s, 154, 4, 5119);
    			attr_dev(div2, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div2, file$s, 153, 0, 5041);
    			attr_dev(div3, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6");
    			add_location(div3, file$s, 163, 4, 5881);
    			attr_dev(div4, "class", "uk-flex uk-flex-center");
    			set_style(div4, "max-height", "75%");
    			set_style(div4, "overflow-x", "scroll");
    			add_location(div4, file$s, 162, 0, 5795);
    			attr_dev(button1, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "uk-close", "");
    			add_location(button1, file$s, 213, 8, 8013);
    			attr_dev(div5, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div5, "uk-height-viewport", "");
    			add_location(div5, file$s, 215, 12, 8154);
    			attr_dev(div6, "class", "uk-flex uk-flex-center");
    			add_location(div6, file$s, 214, 8, 8105);
    			attr_dev(div7, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div7, file$s, 212, 4, 7943);
    			attr_dev(div8, "id", "modal-full");
    			attr_dev(div8, "class", "uk-modal-full");
    			attr_dev(div8, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div8, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[10]);
    			add_location(div8, file$s, 208, 0, 7792);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			append_dev(div0, t0);
    			append_dev(div0, button0);
    			append_dev(button0, span);
    			append_dev(button0, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			if_block0.m(div3, null);
    			append_dev(div4, t3);
    			mount_component(infinitescroll, div4, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, button1);
    			append_dev(div7, t5);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			if_blocks[current_block_type_index].m(div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*openForm*/ ctx[13], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$screenWidthS, $screenWidthM, $screenWidthL*/ 3584 && input_class_value !== (input_class_value = "uk-input " + (/*$screenWidthS*/ ctx[9]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[10] || /*$screenWidthL*/ ctx[11]
    				? 'uk-width-medium'
    				: 'uk-width-large'))) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if ((!current || dirty & /*$screenWidthS, $screenWidthM*/ 1536) && t1_value !== (t1_value = (/*$screenWidthS*/ ctx[9]
    			? ''
    			: /*$screenWidthM*/ ctx[10]
    				? '\xa0member'
    				: '\xa0New member') + "")) set_data_dev(t1, t1_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div3, null);
    				}
    			}

    			const infinitescroll_changes = {};
    			if (dirty & /*newBatch*/ 2) infinitescroll_changes.hasMore = /*newBatch*/ ctx[1].length;
    			infinitescroll.$set(infinitescroll_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div5, null);
    			}

    			if (dirty & /*$screenWidthM*/ 1024) {
    				toggle_class(div8, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[10]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(infinitescroll.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(infinitescroll.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div4);
    			if_block0.d();
    			destroy_component(infinitescroll);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div8);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $memberNames;
    	let $screenWidthS;
    	let $screenWidthM;
    	let $screenWidthL;
    	validate_store(memberNames, 'memberNames');
    	component_subscribe($$self, memberNames, $$value => $$invalidate(19, $memberNames = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(9, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(10, $screenWidthM = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(11, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Member', slots, []);
    	let page = 1;
    	let maxPage = 2;
    	let data = [];
    	let newBatch = [];
    	let selectedMember;
    	let editMember = false;
    	let renewMember = false;
    	let showSignPad = false;
    	let signatureBase64;
    	let recreateForm = false;
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		await fetchData();

    		const autoCompleteJS = new autoComplete_min({
    				selector: "#autocomplete",
    				placeHolder: "Search members...",
    				diacritics: true,
    				searchEngine: 'strict',
    				data: { src: $memberNames, cache: true },
    				resultsList: {
    					element: (list, data) => {
    						if (!data.results.length) {
    							const message = document.createElement("div");
    							message.setAttribute("class", "no_result");
    							message.innerHTML = `<span>No Member for "${data.query}"</span>`;
    							list.prepend(message);
    						}
    					},
    					maxResults: 50,
    					noResults: true
    				},
    				resultItem: { highlight: true },
    				events: {
    					input: {
    						selection: event => {
    							autoCompleteJS.input.value = event.detail.selection.value;
    							fetchMember(event.detail.selection.value);
    						},
    						keyup: () => {
    							if (autoCompleteJS.input.value === '') fetchMember(null);
    						}
    					}
    				}
    			});
    	});

    	async function fetchData() {
    		const response = await getMembers(page);
    		$$invalidate(3, maxPage = response.meta.last_page);
    		$$invalidate(1, newBatch = await response.data);
    	}

    	async function fetchMember(memberName) {
    		if (memberName !== undefined && memberName !== null) {
    			$$invalidate(1, newBatch = []);
    			$$invalidate(0, data = [...await getMemberByName(memberName)]);
    		} else if (data.length === 1) {
    			$$invalidate(0, data = []);
    			$$invalidate(2, page = 1);
    			await fetchData();
    		}
    	}

    	function dispatchReload() {
    		dispatch('message', { reload: 'member' });
    	}

    	function openForm(member, renew) {
    		$$invalidate(4, selectedMember = member instanceof MouseEvent
    		? null
    		: JSON.parse(JSON.stringify(member)));

    		$$invalidate(6, renewMember = selectedMember !== null && renew);
    		$$invalidate(5, editMember = selectedMember !== null && !renew);
    		$$invalidate(7, showSignPad = false);
    		$$invalidate(8, recreateForm = !recreateForm);
    		uikit.modal("#modal-full").show();
    	}

    	async function processSignup(event) {
    		if (event.detail.goto !== undefined) {
    			switch (event.detail.goto) {
    				case 'signature':
    					$$invalidate(7, showSignPad = true);
    					$$invalidate(8, recreateForm = !recreateForm);
    					break;
    				case 'form':
    					$$invalidate(7, showSignPad = false);
    					$$invalidate(8, recreateForm = !recreateForm);
    					break;
    				case 'jumpEdit':
    					let membemail = await getMemberByEmail(event.detail.email);
    					uikit.modal("#modal-full").hide();
    					openForm(membemail, DateTime_1.fromSQL(membemail.renew_date) < DateTime_1.now());
    					break;
    				case 'cancel':
    					uikit.modal("#modal-full").hide();
    			}

    			return;
    		}

    		let member = selectedMember;
    		let success = false;

    		if (event.detail.signature !== undefined) {
    			member.signature = event.detail.signature;
    		}

    		if (!editMember && !renewMember) success = await createMember(member); else if (member.id !== undefined && member.id !== null) success = await updateMember(member);

    		if (success) {
    			uikit.modal("#modal-full").hide();

    			uikit.notification(
    				'<span uk-icon="icon: check"></span> Successfully ' + (event.detail.signature !== undefined && !renewMember
    				? 'created!'
    				: renewMember ? 'renewed!' : 'updated!'),
    				{ status: 'success', pos: 'bottom-center' }
    			);
    		} else {
    			uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    		}

    		dispatchReload();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Member> was created with unknown prop '${key}'`);
    	});

    	const click_handler = member => openForm(member, true);
    	const click_handler_1 = member => openForm(member, false);

    	const loadMore_handler = () => {
    		if (page < maxPage) {
    			$$invalidate(2, page++, page);
    			fetchData();
    		}
    	};

    	function memberform_member_binding(value) {
    		selectedMember = value;
    		$$invalidate(4, selectedMember);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		createMember,
    		getMemberByEmail,
    		getMemberByName,
    		getMembers,
    		memberNames,
    		updateMember,
    		InfiniteScroll,
    		autoComplete: autoComplete_min,
    		DateTime: DateTime_1,
    		MemberForm,
    		UIkit: uikit,
    		MemberSignature,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		page,
    		maxPage,
    		data,
    		newBatch,
    		selectedMember,
    		editMember,
    		renewMember,
    		showSignPad,
    		signatureBase64,
    		recreateForm,
    		dispatch,
    		fetchData,
    		fetchMember,
    		dispatchReload,
    		openForm,
    		processSignup,
    		$memberNames,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL
    	});

    	$$self.$inject_state = $$props => {
    		if ('page' in $$props) $$invalidate(2, page = $$props.page);
    		if ('maxPage' in $$props) $$invalidate(3, maxPage = $$props.maxPage);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('newBatch' in $$props) $$invalidate(1, newBatch = $$props.newBatch);
    		if ('selectedMember' in $$props) $$invalidate(4, selectedMember = $$props.selectedMember);
    		if ('editMember' in $$props) $$invalidate(5, editMember = $$props.editMember);
    		if ('renewMember' in $$props) $$invalidate(6, renewMember = $$props.renewMember);
    		if ('showSignPad' in $$props) $$invalidate(7, showSignPad = $$props.showSignPad);
    		if ('signatureBase64' in $$props) signatureBase64 = $$props.signatureBase64;
    		if ('recreateForm' in $$props) $$invalidate(8, recreateForm = $$props.recreateForm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, newBatch*/ 3) {
    			$$invalidate(0, data = [...data, ...newBatch]);
    		}
    	};

    	return [
    		data,
    		newBatch,
    		page,
    		maxPage,
    		selectedMember,
    		editMember,
    		renewMember,
    		showSignPad,
    		recreateForm,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		fetchData,
    		openForm,
    		processSignup,
    		click_handler,
    		click_handler_1,
    		loadMore_handler,
    		memberform_member_binding
    	];
    }

    class Member extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Member",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    const events = writable([]);


    async function fetchEvents() {
        try {
            const result = await api.get('/events/');
            result.data.forEach(e => {
                e.selected = false;
                e.show = true;
            });
            events.set(result.data);
        } catch (error) {}
    }

    async function createEvent(event) {
        try {
            const result = await api.post('/event/', event);
            return result.data
        } catch (error) {}
    }

    async function updateEvent(event) {
        try {
            const result = await api.put('/event/'+event.id, event);
            return result.data
        } catch (error) {}
    }

    async function deleteEvent(id) {
        try {
            const result = await api.delete('/event/'+id);
            return result.status === 200
        } catch (error) {}
    }

    function getEvents() {
        return get_store_value(events)
    }

    const bookingNames = writable([]);

    async function getBookings(query) {
        try {
            const result = await api.post('/bookings/', query);
            return result.data
        } catch (error) {}
    }

    async function getPaymentBookings(query) {
        try {
            const result = await api.post('/payments/', query);
            return result.data
        } catch (error) {}
    }

    async function getBookingNames() {
        try {
            const result = await api.get('/bookings/');
            bookingNames.set(result.data);
        } catch (error) {}
    }

    async function getGroupNames() {
        try {
            const result = await api.get('/bookings/groups');
            return(result.data.filter(g => g.length > 0))
        } catch (error) {}
    }

    async function getBookingsByIds(ids) {
        try {
            ids = {ids: ids};
            const result = await api.post('/bookings/byIds', ids);
            return result.data
        } catch (error) {}
    }

    async function getReservationList(year) {
        try {
            const result = await api.get('/bookings/reservations/' + year);
            return result.data
        } catch (error) {}
    }

    async function updateBookingPaid(invoiceId, date) {
        try {
            const result = await api.post('/bookingPaid/', {invoice_id: invoiceId, date_paid: date});
            return result.status === 200
        } catch (error) {}
    }

    async function createBooking(booking) {
        try {
            const result = await api.post('/booking/', booking);
            return result.data
        } catch (error) {}
    }

    async function updateBooking(booking) {
        try {
            const result = await api.put('/booking/'+booking.id, booking);
            return result.status === 200
        } catch (error) {}
    }

    async function deleteBooking(id) {
        try {
            const result = await api.delete('/booking/'+id);
            return result.status === 200
        } catch (error) {}
    }

    function calculateBookingAmounts(booking) {
        if (!booking.paid || booking.mattress_booking) {
            
            let settings = getSettings();

            if (booking.stay_rate === null || booking.stay_rate === 0)
                booking.stay_rate = booking.stay_days <= settings.short_stay_duration ? settings.price_stay_short : booking.stay_days < 30 ? settings.price_stay : settings.price_stay_month;

            if (booking.sci_member && booking.member_id !== null) {
                // let sciMember = $sciMembers.find(m => m.id === booking.member_id)
                let sciMember = getSciMember(booking.member_id);
                if (DateTime_1.fromSQL(booking.arrival).year < DateTime_1.now().year) {
                    if (booking.no_stay_pay)
                        booking.sci_days_used = 0;
                    else {
                        let prevYearDays = Math.round(DateTime_1.fromSQL(booking.arrival).until(DateTime_1.fromSQL(booking.departure).year < DateTime_1.now().year ? DateTime_1.fromSQL(booking.departure) : DateTime_1.fromSQL(booking.arrival).endOf('year')).length('days'));
                        let currYearDays = Math.round(DateTime_1.fromSQL(booking.departure).year < DateTime_1.now().year ? 0 : DateTime_1.now().startOf('year').until(DateTime_1.fromSQL(booking.departure)).length('days'));
                        let prevYearSciDaysLeft = settings.sci_days - sciMember.sci_days_used_prev_year;
                        let currYearSciDaysLeft = settings.sci_days - sciMember.sci_days_used;
                        let prevYearSciDaysUsed = prevYearDays > prevYearSciDaysLeft ? prevYearSciDaysLeft : prevYearDays;
                        let currYearSciDaysUsed = currYearDays > currYearSciDaysLeft ? currYearSciDaysLeft : currYearDays;
                        booking.sci_days_used = prevYearSciDaysUsed + currYearSciDaysUsed;
                    }
                } else
                    booking.sci_days_used = !booking.no_stay_pay ? booking.stay_days <= settings.sci_days - sciMember?.sci_days_used ? booking.stay_days : settings.sci_days - sciMember?.sci_days_used : 0;
            }

            booking.stay_amount = booking.no_stay_pay ? 0 : (booking.stay_days - booking.sci_days_used) * booking.stay_rate;

            // if booking is for more than one person, add amount for full period for the rest of
            booking.stay_amount += booking.people_count === 1 ? 0 : (booking.people_count - 1) * booking.stay_days * booking.stay_rate;

            let mealsDays = 0;
            let mealsAmount = 0;
            let stayInterval = Interval_1.fromDateTimes(DateTime_1.fromSQL(booking.arrival), DateTime_1.fromSQL(booking.departure));
            booking.paf_events.forEach(pafEvent => {
                let event = getEvents().find(e => e.id === pafEvent.id);
                let intersection = stayInterval.intersection(Interval_1.fromDateTimes(DateTime_1.fromSQL(event.start_date), DateTime_1.fromSQL(event.end_date)));
                if (intersection !== null && event.meal_price_day > 0) {
                    mealsDays += intersection.length('days');
                    mealsAmount += intersection.length('days') * event.meal_price_day;
                }
            });
            booking.meals_days = mealsDays;
            booking.meals_amount = booking.no_meal_pay ? 0 : mealsAmount * booking.people_count;
            booking.membership_amount = booking.membership_count * settings.price_membership;
            booking.total_amount = booking.stay_amount + booking.membership_amount + booking.meals_amount;
            booking.meals_amount_orig = booking.meals_amount;
            booking.membership_amount_orig = booking.membership_amount;
            booking.stay_amount_orig = booking.stay_amount;
        }

        return booking
    }

    var autoComplete = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
      module.exports = factory() ;
    }(commonjsGlobal, (function () {
      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
          var symbols = Object.getOwnPropertySymbols(object);

          if (enumerableOnly) {
            symbols = symbols.filter(function (sym) {
              return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
          }

          keys.push.apply(keys, symbols);
        }

        return keys;
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};

          if (i % 2) {
            ownKeys(Object(source), true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(Object(source)).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }

        return target;
      }

      function _typeof(obj) {
        "@babel/helpers - typeof";

        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function (obj) {
            return typeof obj;
          };
        } else {
          _typeof = function (obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
          };
        }

        return _typeof(obj);
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function _toConsumableArray(arr) {
        return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
      }

      function _arrayWithoutHoles(arr) {
        if (Array.isArray(arr)) return _arrayLikeToArray(arr);
      }

      function _iterableToArray(iter) {
        if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
      }

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

        return arr2;
      }

      function _nonIterableSpread() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      function _createForOfIteratorHelper(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

        if (!it) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
            if (it) o = it;
            var i = 0;

            var F = function () {};

            return {
              s: F,
              n: function () {
                if (i >= o.length) return {
                  done: true
                };
                return {
                  done: false,
                  value: o[i++]
                };
              },
              e: function (e) {
                throw e;
              },
              f: F
            };
          }

          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }

        var normalCompletion = true,
            didErr = false,
            err;
        return {
          s: function () {
            it = it.call(o);
          },
          n: function () {
            var step = it.next();
            normalCompletion = step.done;
            return step;
          },
          e: function (e) {
            didErr = true;
            err = e;
          },
          f: function () {
            try {
              if (!normalCompletion && it.return != null) it.return();
            } finally {
              if (didErr) throw err;
            }
          }
        };
      }

      var select$1 = function select(element) {
        return typeof element === "string" ? document.querySelector(element) : element();
      };
      var create = function create(tag, options) {
        var el = typeof tag === "string" ? document.createElement(tag) : tag;
        for (var key in options) {
          var val = options[key];
          if (key === "inside") {
            val.append(el);
          } else if (key === "dest") {
            select$1(val[0]).insertAdjacentElement(val[1], el);
          } else if (key === "around") {
            var ref = val;
            ref.parentNode.insertBefore(el, ref);
            el.append(ref);
            if (ref.getAttribute("autofocus") != null) ref.focus();
          } else if (key in el) {
            el[key] = val;
          } else {
            el.setAttribute(key, val);
          }
        }
        return el;
      };
      var getQuery = function getQuery(field) {
        return field instanceof HTMLInputElement || field instanceof HTMLTextAreaElement ? field.value : field.innerHTML;
      };
      var format = function format(value, diacritics) {
        value = value.toString().toLowerCase();
        return diacritics ? value.normalize("NFD").replace(/[\u0300-\u036f]/g, "").normalize("NFC") : value;
      };
      var debounce = function debounce(callback, duration) {
        var timer;
        return function () {
          clearTimeout(timer);
          timer = setTimeout(function () {
            return callback();
          }, duration);
        };
      };
      var checkTrigger = function checkTrigger(query, condition, threshold) {
        return condition ? condition(query) : query.length >= threshold;
      };
      var mark = function mark(value, cls) {
        return create("mark", _objectSpread2({
          innerHTML: value
        }, typeof cls === "string" && {
          "class": cls
        })).outerHTML;
      };

      var configure = (function (ctx) {
        var name = ctx.name,
            options = ctx.options,
            resultsList = ctx.resultsList,
            resultItem = ctx.resultItem;
        for (var option in options) {
          if (_typeof(options[option]) === "object") {
            if (!ctx[option]) ctx[option] = {};
            for (var subOption in options[option]) {
              ctx[option][subOption] = options[option][subOption];
            }
          } else {
            ctx[option] = options[option];
          }
        }
        ctx.selector = ctx.selector || "#" + name;
        resultsList.destination = resultsList.destination || ctx.selector;
        resultsList.id = resultsList.id || name + "_list_" + ctx.id;
        resultItem.id = resultItem.id || name + "_result";
        ctx.input = select$1(ctx.selector);
      });

      var eventEmitter = (function (name, ctx) {
        ctx.input.dispatchEvent(new CustomEvent(name, {
          bubbles: true,
          detail: ctx.feedback,
          cancelable: true
        }));
      });

      var search = (function (query, record, options) {
        var _ref = options || {},
            mode = _ref.mode,
            diacritics = _ref.diacritics,
            highlight = _ref.highlight;
        var nRecord = format(record, diacritics);
        record = record.toString();
        query = format(query, diacritics);
        if (mode === "loose") {
          query = query.replace(/ /g, "");
          var qLength = query.length;
          var cursor = 0;
          var match = Array.from(record).map(function (character, index) {
            if (cursor < qLength && nRecord[index] === query[cursor]) {
              character = highlight ? mark(character, highlight) : character;
              cursor++;
            }
            return character;
          }).join("");
          if (cursor === qLength) return match;
        } else {
          var _match = nRecord.indexOf(query);
          if (~_match) {
            query = record.substring(_match, _match + query.length);
            _match = highlight ? record.replace(query, mark(query, highlight)) : record;
            return _match;
          }
        }
      });

      var getData = function getData(ctx, query) {
        return new Promise(function ($return, $error) {
          var data;
          data = ctx.data;
          if (data.cache && data.store) return $return();
          return new Promise(function ($return, $error) {
            if (typeof data.src === "function") {
              return data.src(query).then($return, $error);
            }
            return $return(data.src);
          }).then(function ($await_4) {
            try {
              ctx.feedback = data.store = $await_4;
              eventEmitter("response", ctx);
              return $return();
            } catch ($boundEx) {
              return $error($boundEx);
            }
          }, $error);
        });
      };
      var findMatches = function findMatches(query, ctx) {
        var data = ctx.data,
            searchEngine = ctx.searchEngine;
        var matches = [];
        data.store.forEach(function (value, index) {
          var find = function find(key) {
            var record = key ? value[key] : value;
            var match = typeof searchEngine === "function" ? searchEngine(query, record) : search(query, record, {
              mode: searchEngine,
              diacritics: ctx.diacritics,
              highlight: ctx.resultItem.highlight
            });
            if (!match) return;
            var result = {
              match: match,
              value: value
            };
            if (key) result.key = key;
            matches.push(result);
          };
          if (data.keys) {
            var _iterator = _createForOfIteratorHelper(data.keys),
                _step;
            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var key = _step.value;
                find(key);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }
          } else {
            find();
          }
        });
        if (data.filter) matches = data.filter(matches);
        var results = matches.slice(0, ctx.resultsList.maxResults);
        ctx.feedback = {
          query: query,
          matches: matches,
          results: results
        };
        eventEmitter("results", ctx);
      };

      var Expand = "aria-expanded";
      var Active = "aria-activedescendant";
      var Selected = "aria-selected";
      var feedback = function feedback(ctx, index) {
        ctx.feedback.selection = _objectSpread2({
          index: index
        }, ctx.feedback.results[index]);
      };
      var render = function render(ctx) {
        var resultsList = ctx.resultsList,
            list = ctx.list,
            resultItem = ctx.resultItem,
            feedback = ctx.feedback;
        var matches = feedback.matches,
            results = feedback.results;
        ctx.cursor = -1;
        list.innerHTML = "";
        if (matches.length || resultsList.noResults) {
          var fragment = new DocumentFragment();
          results.forEach(function (result, index) {
            var element = create(resultItem.tag, _objectSpread2({
              id: "".concat(resultItem.id, "_").concat(index),
              role: "option",
              innerHTML: result.match,
              inside: fragment
            }, resultItem["class"] && {
              "class": resultItem["class"]
            }));
            if (resultItem.element) resultItem.element(element, result);
          });
          list.append(fragment);
          if (resultsList.element) resultsList.element(list, feedback);
          open(ctx);
        } else {
          close(ctx);
        }
      };
      var open = function open(ctx) {
        if (ctx.isOpen) return;
        (ctx.wrapper || ctx.input).setAttribute(Expand, true);
        ctx.list.removeAttribute("hidden");
        ctx.isOpen = true;
        eventEmitter("open", ctx);
      };
      var close = function close(ctx) {
        if (!ctx.isOpen) return;
        (ctx.wrapper || ctx.input).setAttribute(Expand, false);
        ctx.input.setAttribute(Active, "");
        ctx.list.setAttribute("hidden", "");
        ctx.isOpen = false;
        eventEmitter("close", ctx);
      };
      var goTo = function goTo(index, ctx) {
        var resultItem = ctx.resultItem;
        var results = ctx.list.getElementsByTagName(resultItem.tag);
        var cls = resultItem.selected ? resultItem.selected.split(" ") : false;
        if (ctx.isOpen && results.length) {
          var _results$index$classL;
          var state = ctx.cursor;
          if (index >= results.length) index = 0;
          if (index < 0) index = results.length - 1;
          ctx.cursor = index;
          if (state > -1) {
            var _results$state$classL;
            results[state].removeAttribute(Selected);
            if (cls) (_results$state$classL = results[state].classList).remove.apply(_results$state$classL, _toConsumableArray(cls));
          }
          results[index].setAttribute(Selected, true);
          if (cls) (_results$index$classL = results[index].classList).add.apply(_results$index$classL, _toConsumableArray(cls));
          ctx.input.setAttribute(Active, results[ctx.cursor].id);
          ctx.list.scrollTop = results[index].offsetTop - ctx.list.clientHeight + results[index].clientHeight + 5;
          ctx.feedback.cursor = ctx.cursor;
          feedback(ctx, index);
          eventEmitter("navigate", ctx);
        }
      };
      var next = function next(ctx) {
        goTo(ctx.cursor + 1, ctx);
      };
      var previous = function previous(ctx) {
        goTo(ctx.cursor - 1, ctx);
      };
      var select = function select(ctx, event, index) {
        index = index >= 0 ? index : ctx.cursor;
        if (index < 0) return;
        ctx.feedback.event = event;
        feedback(ctx, index);
        eventEmitter("selection", ctx);
        close(ctx);
      };
      var click = function click(event, ctx) {
        var itemTag = ctx.resultItem.tag.toUpperCase();
        var items = Array.from(ctx.list.querySelectorAll(itemTag));
        var item = event.target.closest(itemTag);
        if (item && item.nodeName === itemTag) {
          select(ctx, event, items.indexOf(item));
        }
      };
      var navigate = function navigate(event, ctx) {
        switch (event.keyCode) {
          case 40:
          case 38:
            event.preventDefault();
            event.keyCode === 40 ? next(ctx) : previous(ctx);
            break;
          case 13:
            if (!ctx.submit) event.preventDefault();
            if (ctx.cursor >= 0) select(ctx, event);
            break;
          case 9:
            if (ctx.resultsList.tabSelect && ctx.cursor >= 0) select(ctx, event);
            break;
          case 27:
            ctx.input.value = "";
            close(ctx);
            break;
        }
      };

      function start (ctx, q) {
        var _this = this;
        return new Promise(function ($return, $error) {
          var queryVal, condition;
          queryVal = q || getQuery(ctx.input);
          queryVal = ctx.query ? ctx.query(queryVal) : queryVal;
          condition = checkTrigger(queryVal, ctx.trigger, ctx.threshold);
          if (condition) {
            return getData(ctx, queryVal).then(function ($await_2) {
              try {
                if (ctx.feedback instanceof Error) return $return();
                findMatches(queryVal, ctx);
                if (ctx.resultsList) render(ctx);
                return $If_1.call(_this);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }, $error);
          } else {
            close(ctx);
            return $If_1.call(_this);
          }
          function $If_1() {
            return $return();
          }
        });
      }

      var eventsManager = function eventsManager(events, callback) {
        for (var element in events) {
          for (var event in events[element]) {
            callback(element, event);
          }
        }
      };
      var addEvents = function addEvents(ctx) {
        var events = ctx.events;
        var run = debounce(function () {
          return start(ctx);
        }, ctx.debounce);
        var publicEvents = ctx.events = _objectSpread2({
          input: _objectSpread2({}, events && events.input)
        }, ctx.resultsList && {
          list: events ? _objectSpread2({}, events.list) : {}
        });
        var privateEvents = {
          input: {
            input: function input() {
              run();
            },
            keydown: function keydown(event) {
              navigate(event, ctx);
            },
            blur: function blur() {
              close(ctx);
            }
          },
          list: {
            mousedown: function mousedown(event) {
              event.preventDefault();
            },
            click: function click$1(event) {
              click(event, ctx);
            }
          }
        };
        eventsManager(privateEvents, function (element, event) {
          if (!ctx.resultsList && event !== "input") return;
          if (publicEvents[element][event]) return;
          publicEvents[element][event] = privateEvents[element][event];
        });
        eventsManager(publicEvents, function (element, event) {
          ctx[element].addEventListener(event, publicEvents[element][event]);
        });
      };
      var removeEvents = function removeEvents(ctx) {
        eventsManager(ctx.events, function (element, event) {
          ctx[element].removeEventListener(event, ctx.events[element][event]);
        });
      };

      function init (ctx) {
        var _this = this;
        return new Promise(function ($return, $error) {
          var placeHolder, resultsList, parentAttrs;
          placeHolder = ctx.placeHolder;
          resultsList = ctx.resultsList;
          parentAttrs = {
            role: "combobox",
            "aria-owns": resultsList.id,
            "aria-haspopup": true,
            "aria-expanded": false
          };
          create(ctx.input, _objectSpread2(_objectSpread2({
            "aria-controls": resultsList.id,
            "aria-autocomplete": "both"
          }, placeHolder && {
            placeholder: placeHolder
          }), !ctx.wrapper && _objectSpread2({}, parentAttrs)));
          if (ctx.wrapper) ctx.wrapper = create("div", _objectSpread2({
            around: ctx.input,
            "class": ctx.name + "_wrapper"
          }, parentAttrs));
          if (resultsList) ctx.list = create(resultsList.tag, _objectSpread2({
            dest: [resultsList.destination, resultsList.position],
            id: resultsList.id,
            role: "listbox",
            hidden: "hidden"
          }, resultsList["class"] && {
            "class": resultsList["class"]
          }));
          addEvents(ctx);
          if (ctx.data.cache) {
            return getData(ctx).then(function ($await_2) {
              try {
                return $If_1.call(_this);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }, $error);
          }
          function $If_1() {
            eventEmitter("init", ctx);
            return $return();
          }
          return $If_1.call(_this);
        });
      }

      function extend (autoComplete) {
        var prototype = autoComplete.prototype;
        prototype.init = function () {
          init(this);
        };
        prototype.start = function (query) {
          start(this, query);
        };
        prototype.unInit = function () {
          if (this.wrapper) {
            var parentNode = this.wrapper.parentNode;
            parentNode.insertBefore(this.input, this.wrapper);
            parentNode.removeChild(this.wrapper);
          }
          removeEvents(this);
        };
        prototype.open = function () {
          open(this);
        };
        prototype.close = function () {
          close(this);
        };
        prototype.goTo = function (index) {
          goTo(index, this);
        };
        prototype.next = function () {
          next(this);
        };
        prototype.previous = function () {
          previous(this);
        };
        prototype.select = function (index) {
          select(this, null, index);
        };
        prototype.search = function (query, record, options) {
          return search(query, record, options);
        };
      }

      function autoComplete(config) {
        this.options = config;
        this.id = autoComplete.instances = (autoComplete.instances || 0) + 1;
        this.name = "autoComplete";
        this.wrapper = 1;
        this.threshold = 1;
        this.debounce = 0;
        this.resultsList = {
          position: "afterend",
          tag: "ul",
          maxResults: 5
        };
        this.resultItem = {
          tag: "li"
        };
        configure(this);
        extend.call(this, autoComplete);
        init(this);
      }

      return autoComplete;

    })));
    });

    /* src/components/BookingFormComponent.svelte generated by Svelte v3.45.0 */

    const { Object: Object_1$4 } = globals;
    const file$r = "src/components/BookingFormComponent.svelte";

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[54] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[54] = list[i];
    	return child_ctx;
    }

    // (303:16) {#if $form.sci_member || (booking !== undefined && booking !== null && booking.sci_member)}
    function create_if_block_8$5(ctx) {
    	let span;
    	let t0;
    	let t1_value = (/*$screenWidthS*/ ctx[9] ? '' : ' member') + "";
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text$1("SCI");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-label uk-label-warning uk-position-center-right uk-margin-small-right");
    			add_location(span, file$r, 303, 20, 15270);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$screenWidthS*/ 512 && t1_value !== (t1_value = (/*$screenWidthS*/ ctx[9] ? '' : ' member') + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$5.name,
    		type: "if",
    		source: "(303:16) {#if $form.sci_member || (booking !== undefined && booking !== null && booking.sci_member)}",
    		ctx
    	});

    	return block;
    }

    // (306:16) {#if booking?.mattress_booking}
    function create_if_block_7$7(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Mattress";
    			attr_dev(span, "class", "uk-label uk-label-warning uk-position-center-right uk-margin-small-right");
    			add_location(span, file$r, 306, 20, 15490);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$7.name,
    		type: "if",
    		source: "(306:16) {#if booking?.mattress_booking}",
    		ctx
    	});

    	return block;
    }

    // (397:12) {:else}
    function create_else_block_3$5(ctx) {
    	let div1;
    	let div0;
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t = text$1(" Membership/s needed");
    			attr_dev(input, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input, "name", "membership_needed");
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$r, 399, 24, 21806);
    			add_location(div0, file$r, 398, 20, 21776);
    			attr_dev(div1, "class", "uk-width-1-2@s");
    			add_location(div1, file$r, 397, 16, 21727);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			input.checked = /*$form*/ ctx[2].membership_needed;
    			append_dev(div0, t);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input, "change", /*input_change_handler_3*/ ctx[34])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 4) {
    				input.checked = /*$form*/ ctx[2].membership_needed;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$5.name,
    		type: "else",
    		source: "(397:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (345:12) {#if !isMattressBooking}
    function create_if_block_4$b(ctx) {
    	let div0;
    	let t0;
    	let div1;
    	let input0;
    	let t1;
    	let t2;
    	let div2;
    	let input1;
    	let t3;
    	let span;
    	let t4;
    	let div5;
    	let div3;
    	let input2;
    	let t5;
    	let t6;
    	let t7;
    	let div4;
    	let input3;
    	let t8;
    	let t9;
    	let div9;
    	let div6;
    	let input4;
    	let t10;
    	let t11;
    	let div7;
    	let input5;
    	let t12;
    	let t13;
    	let div8;
    	let input6;
    	let t14;
    	let mounted;
    	let dispose;
    	let if_block = /*booking*/ ctx[0] !== null && create_if_block_5$a(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			input0 = element("input");
    			t1 = text$1(" Stay rate");
    			t2 = space();
    			div2 = element("div");
    			input1 = element("input");
    			t3 = text$1(" Institutional rate\n                    ");
    			span = element("span");
    			t4 = space();
    			div5 = element("div");
    			div3 = element("div");
    			input2 = element("input");
    			t5 = text$1("\n                        Pays early (before stay)");
    			t6 = space();
    			if (if_block) if_block.c();
    			t7 = space();
    			div4 = element("div");
    			input3 = element("input");
    			t8 = text$1(" Membership/s needed");
    			t9 = space();
    			div9 = element("div");
    			div6 = element("div");
    			input4 = element("input");
    			t10 = text$1(" Longstayer");
    			t11 = space();
    			div7 = element("div");
    			input5 = element("input");
    			t12 = text$1(" Doesn't pay for stay");
    			t13 = space();
    			div8 = element("div");
    			input6 = element("input");
    			t14 = text$1(" Doesn't pay for meals");
    			attr_dev(div0, "class", "uk-width-1-2@s uk-text-nowrap");
    			add_location(div0, file$r, 345, 16, 18071);
    			attr_dev(input0, "class", "uk-input uk-margin-small-right uk-form-width-small");
    			attr_dev(input0, "name", "stay_rate");
    			attr_dev(input0, "type", "number");
    			set_style(input0, "color", "black");
    			toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[6].stay_rate && /*$touched*/ ctx[8].stay_rate);
    			add_location(input0, file$r, 347, 20, 18201);
    			attr_dev(div1, "class", "uk-width-1-2@s uk-text-nowrap");
    			add_location(div1, file$r, 346, 16, 18137);
    			attr_dev(input1, "class", "uk-checkbox");
    			attr_dev(input1, "id", "form-institutional");
    			attr_dev(input1, "name", "institutional");
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$r, 352, 20, 18623);
    			attr_dev(span, "uk-icon", "icon: info");
    			attr_dev(span, "uk-tooltip", "title: Applies to groups with whom a higher price has been negotiated.");
    			add_location(span, file$r, 354, 25, 18868);
    			attr_dev(div2, "class", "uk-width-1-2@s uk-text-nowrap");
    			add_location(div2, file$r, 351, 16, 18559);
    			attr_dev(input2, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input2, "name", "early_pay");
    			attr_dev(input2, "type", "checkbox");
    			add_location(input2, file$r, 358, 24, 19106);
    			add_location(div3, file$r, 357, 20, 19076);
    			attr_dev(input3, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input3, "name", "membership_needed");
    			attr_dev(input3, "type", "checkbox");
    			add_location(input3, file$r, 378, 24, 20421);
    			add_location(div4, file$r, 377, 20, 20391);
    			attr_dev(div5, "class", "uk-width-1-2@s");
    			add_location(div5, file$r, 356, 16, 19027);
    			attr_dev(input4, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input4, "id", "form-longstayer");
    			attr_dev(input4, "name", "longstayer");
    			attr_dev(input4, "type", "checkbox");
    			add_location(input4, file$r, 384, 24, 20791);
    			add_location(div6, file$r, 383, 20, 20761);
    			attr_dev(input5, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input5, "id", "form-no_stay_pay");
    			attr_dev(input5, "name", "no_stay_pay");
    			attr_dev(input5, "type", "checkbox");
    			add_location(input5, file$r, 388, 24, 21091);
    			add_location(div7, file$r, 387, 20, 21061);
    			attr_dev(input6, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input6, "id", "form-no_meal_pay");
    			attr_dev(input6, "name", "no_meal_pay");
    			attr_dev(input6, "type", "checkbox");
    			add_location(input6, file$r, 392, 24, 21404);
    			add_location(div8, file$r, 391, 20, 21374);
    			attr_dev(div9, "class", "uk-width-1-2@s");
    			add_location(div9, file$r, 382, 16, 20712);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, input0);
    			set_input_value(input0, /*$form*/ ctx[2].stay_rate);
    			append_dev(div1, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, input1);
    			input1.checked = /*$form*/ ctx[2].institutional;
    			append_dev(div2, t3);
    			append_dev(div2, span);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div3);
    			append_dev(div3, input2);
    			input2.checked = /*$form*/ ctx[2].early_pay;
    			append_dev(div3, t5);
    			append_dev(div5, t6);
    			if (if_block) if_block.m(div5, null);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div4, input3);
    			input3.checked = /*$form*/ ctx[2].membership_needed;
    			append_dev(div4, t8);
    			insert_dev(target, t9, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div6);
    			append_dev(div6, input4);
    			input4.checked = /*$form*/ ctx[2].longstayer;
    			append_dev(div6, t10);
    			append_dev(div9, t11);
    			append_dev(div9, div7);
    			append_dev(div7, input5);
    			input5.checked = /*$form*/ ctx[2].no_stay_pay;
    			append_dev(div7, t12);
    			append_dev(div9, t13);
    			append_dev(div9, div8);
    			append_dev(div8, input6);
    			input6.checked = /*$form*/ ctx[2].no_meal_pay;
    			append_dev(div8, t14);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input0, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler_1*/ ctx[24]),
    					listen_dev(input1, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input1, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[25]),
    					listen_dev(input2, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input2, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input2, "change", /*input2_change_handler*/ ctx[26]),
    					listen_dev(input3, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input3, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input3, "change", /*input3_change_handler*/ ctx[30]),
    					listen_dev(input4, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input4, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input4, "change", /*input4_change_handler*/ ctx[31]),
    					listen_dev(input5, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input5, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input5, "change", /*input5_change_handler*/ ctx[32]),
    					listen_dev(input6, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input6, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input6, "change", /*input6_change_handler*/ ctx[33])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 4 && to_number(input0.value) !== /*$form*/ ctx[2].stay_rate) {
    				set_input_value(input0, /*$form*/ ctx[2].stay_rate);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 320) {
    				toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[6].stay_rate && /*$touched*/ ctx[8].stay_rate);
    			}

    			if (dirty[0] & /*$form*/ 4) {
    				input1.checked = /*$form*/ ctx[2].institutional;
    			}

    			if (dirty[0] & /*$form*/ 4) {
    				input2.checked = /*$form*/ ctx[2].early_pay;
    			}

    			if (/*booking*/ ctx[0] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_5$a(ctx);
    					if_block.c();
    					if_block.m(div5, t7);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty[0] & /*$form*/ 4) {
    				input3.checked = /*$form*/ ctx[2].membership_needed;
    			}

    			if (dirty[0] & /*$form*/ 4) {
    				input4.checked = /*$form*/ ctx[2].longstayer;
    			}

    			if (dirty[0] & /*$form*/ 4) {
    				input5.checked = /*$form*/ ctx[2].no_stay_pay;
    			}

    			if (dirty[0] & /*$form*/ 4) {
    				input6.checked = /*$form*/ ctx[2].no_meal_pay;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div5);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(div9);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$b.name,
    		type: "if",
    		source: "(345:12) {#if !isMattressBooking}",
    		ctx
    	});

    	return block;
    }

    // (363:20) {#if booking !== null}
    function create_if_block_5$a(ctx) {
    	let div0;
    	let t0;
    	let div1;
    	let input;
    	let t1;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*booking*/ ctx[0]?.paid) return create_if_block_6$8;
    		return create_else_block_2$9;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if_block.c();
    			t0 = space();
    			div1 = element("div");
    			input = element("input");
    			t1 = text$1(" Cancelled");
    			add_location(div0, file$r, 363, 24, 19438);
    			attr_dev(input, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input, "name", "cancelled");
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$r, 373, 28, 20111);
    			add_location(div1, file$r, 372, 24, 20077);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			if_block.m(div0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, input);
    			input.checked = /*$form*/ ctx[2].cancelled;
    			append_dev(div1, t1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input, "change", /*input_change_handler_2*/ ctx[29])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}

    			if (dirty[0] & /*$form*/ 4) {
    				input.checked = /*$form*/ ctx[2].cancelled;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if_block.d();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$a.name,
    		type: "if",
    		source: "(363:20) {#if booking !== null}",
    		ctx
    	});

    	return block;
    }

    // (368:28) {:else}
    function create_else_block_2$9(ctx) {
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			t = text$1(" Paid");
    			attr_dev(input, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input, "type", "checkbox");
    			input.disabled = true;
    			add_location(input, file$r, 368, 32, 19799);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = /*$form*/ ctx[2].paid;
    			insert_dev(target, t, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input, "change", /*input_change_handler_1*/ ctx[28])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 4) {
    				input.checked = /*$form*/ ctx[2].paid;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$9.name,
    		type: "else",
    		source: "(368:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (365:28) {#if booking?.paid}
    function create_if_block_6$8(ctx) {
    	let input;
    	let t;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			t = text$1(" Paid");
    			attr_dev(input, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input, "id", "form-paid");
    			attr_dev(input, "name", "paid");
    			attr_dev(input, "type", "checkbox");
    			add_location(input, file$r, 365, 32, 19524);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = /*$form*/ ctx[2].paid;
    			insert_dev(target, t, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input, "change", /*input_change_handler*/ ctx[27])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 4) {
    				input.checked = /*$form*/ ctx[2].paid;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$8.name,
    		type: "if",
    		source: "(365:28) {#if booking?.paid}",
    		ctx
    	});

    	return block;
    }

    // (424:20) {:else}
    function create_else_block_1$d(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*pafEvents*/ ctx[3];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form, pafEvents, eventSelection*/ 65548) {
    				each_value_1 = /*pafEvents*/ ctx[3];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$d.name,
    		type: "else",
    		source: "(424:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (422:20) {#if !pafEvents.find(e => e.selected)}
    function create_if_block_2$g(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Add events from dropdown";
    			attr_dev(span, "class", "uk-text-muted");
    			add_location(span, file$r, 422, 24, 23094);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$g.name,
    		type: "if",
    		source: "(422:20) {#if !pafEvents.find(e => e.selected)}",
    		ctx
    	});

    	return block;
    }

    // (426:28) {#if event.selected}
    function create_if_block_3$f(ctx) {
    	let span;
    	let t0_value = /*event*/ ctx[54].abbreviation + "";
    	let t0;
    	let t1;
    	let a;
    	let t3;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[36](/*event*/ ctx[54]);
    	}

    	function func_1(...args) {
    		return /*func_1*/ ctx[37](/*event*/ ctx[54], ...args);
    	}

    	function func_2(...args) {
    		return /*func_2*/ ctx[38](/*event*/ ctx[54], ...args);
    	}

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text$1(t0_value);
    			t1 = text$1("");
    			a = element("a");
    			a.textContent = "X";
    			t3 = text$1("");
    			attr_dev(a, "class", "uk-link-reset");
    			attr_dev(a, "href", '#');
    			add_location(a, file$r, 428, 78, 23645);
    			attr_dev(span, "class", "uk-label uk-label-success");
    			toggle_class(span, "uk-label-danger", /*$form*/ ctx[2].paf_events.find(func_1) !== undefined && !/*$form*/ ctx[2].paf_events.find(func_2).confirmed);
    			add_location(span, file$r, 426, 36, 23318);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, a);
    			insert_dev(target, t3, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*pafEvents*/ 8 && t0_value !== (t0_value = /*event*/ ctx[54].abbreviation + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*$form, pafEvents*/ 12) {
    				toggle_class(span, "uk-label-danger", /*$form*/ ctx[2].paf_events.find(func_1) !== undefined && !/*$form*/ ctx[2].paf_events.find(func_2).confirmed);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$f.name,
    		type: "if",
    		source: "(426:28) {#if event.selected}",
    		ctx
    	});

    	return block;
    }

    // (425:24) {#each pafEvents as event}
    function create_each_block_1$6(ctx) {
    	let if_block_anchor;
    	let if_block = /*event*/ ctx[54].selected && create_if_block_3$f(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*event*/ ctx[54].selected) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$f(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(425:24) {#each pafEvents as event}",
    		ctx
    	});

    	return block;
    }

    // (420:12) {#key pafEventsReload}
    function create_key_block_1$3(ctx) {
    	let div;
    	let show_if;

    	function select_block_type_2(ctx, dirty) {
    		if (dirty[0] & /*pafEvents*/ 8) show_if = null;
    		if (show_if == null) show_if = !!!/*pafEvents*/ ctx[3].find(func$1);
    		if (show_if) return create_if_block_2$g;
    		return create_else_block_1$d;
    	}

    	let current_block_type = select_block_type_2(ctx, [-1, -1]);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "uk-width-1-2@s uk-flex uk-flex-middle");
    			attr_dev(div, "uk-margin", "");
    			add_location(div, file$r, 420, 16, 22949);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_1$3.name,
    		type: "key",
    		source: "(420:12) {#key pafEventsReload}",
    		ctx
    	});

    	return block;
    }

    // (440:28) {#if event.show && !event.selected}
    function create_if_block$q(ctx) {
    	let if_block_anchor;

    	function select_block_type_3(ctx, dirty) {
    		if (/*event*/ ctx[54].max_participants !== null && /*event*/ ctx[54].participant_count >= /*event*/ ctx[54].max_participants) return create_if_block_1$h;
    		return create_else_block$p;
    	}

    	let current_block_type = select_block_type_3(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(440:28) {#if event.show && !event.selected}",
    		ctx
    	});

    	return block;
    }

    // (443:32) {:else}
    function create_else_block$p(ctx) {
    	let option;
    	let t_value = /*event*/ ctx[54].name + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = option_value_value = /*event*/ ctx[54].id;
    			option.value = option.__value;
    			add_location(option, file$r, 443, 36, 24591);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pafEvents*/ 8 && t_value !== (t_value = /*event*/ ctx[54].name + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*pafEvents*/ 8 && option_value_value !== (option_value_value = /*event*/ ctx[54].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$p.name,
    		type: "else",
    		source: "(443:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (441:32) {#if event.max_participants !== null && event.participant_count >= event.max_participants}
    function create_if_block_1$h(ctx) {
    	let option;
    	let t0_value = /*event*/ ctx[54].name + "";
    	let t0;
    	let t1;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t0 = text$1(t0_value);
    			t1 = text$1(" (WAITING LIST)");
    			option.__value = option_value_value = /*event*/ ctx[54].id;
    			option.value = option.__value;
    			add_location(option, file$r, 441, 36, 24453);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t0);
    			append_dev(option, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pafEvents*/ 8 && t0_value !== (t0_value = /*event*/ ctx[54].name + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*pafEvents*/ 8 && option_value_value !== (option_value_value = /*event*/ ctx[54].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(441:32) {#if event.max_participants !== null && event.participant_count >= event.max_participants}",
    		ctx
    	});

    	return block;
    }

    // (439:24) {#each pafEvents as event}
    function create_each_block$i(ctx) {
    	let if_block_anchor;
    	let if_block = /*event*/ ctx[54].show && !/*event*/ ctx[54].selected && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*event*/ ctx[54].show && !/*event*/ ctx[54].selected) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$i.name,
    		type: "each",
    		source: "(439:24) {#each pafEvents as event}",
    		ctx
    	});

    	return block;
    }

    // (436:16) {#key pafEventsSelectReload}
    function create_key_block$a(ctx) {
    	let select;
    	let option;
    	let mounted;
    	let dispose;
    	let each_value = /*pafEvents*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			select = element("select");
    			option = element("option");
    			option.textContent = "Select event/s";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			option.__value = "0";
    			option.value = option.__value;
    			option.selected = true;
    			add_location(option, file$r, 437, 24, 24128);
    			attr_dev(select, "class", "uk-select");
    			attr_dev(select, "id", "form-paf_event_select");
    			attr_dev(select, "name", "paf_event_select");
    			attr_dev(select, "type", "text");
    			add_location(select, file$r, 436, 20, 23991);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			if (!mounted) {
    				dispose = listen_dev(select, "change", /*selection*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*pafEvents*/ 8) {
    				each_value = /*pafEvents*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$i(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$i(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$a.name,
    		type: "key",
    		source: "(436:16) {#key pafEventsSelectReload}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let form_1;
    	let div4;
    	let label0;
    	let t1;
    	let div3;
    	let div0;
    	let input0;
    	let t2;
    	let t3;
    	let t4;
    	let div1;
    	let input1;
    	let t5;
    	let div2;
    	let input2;
    	let t6;
    	let div8;
    	let label1;
    	let t8;
    	let div7;
    	let div5;
    	let input3;
    	let t9;
    	let div6;
    	let input4;
    	let t10;
    	let div11;
    	let label2;
    	let t12;
    	let div10;
    	let div9;
    	let input5;
    	let t13;
    	let t14;
    	let t15;
    	let div14;
    	let label3;
    	let t17;
    	let div13;
    	let div12;
    	let textarea;
    	let t18;
    	let div17;
    	let label4;
    	let t20;
    	let div16;
    	let previous_key = /*pafEventsReload*/ ctx[4];
    	let t21;
    	let div15;
    	let previous_key_1 = /*pafEventsSelectReload*/ ctx[5];
    	let t22;
    	let div20;
    	let label5;
    	let t24;
    	let div19;
    	let div18;
    	let input6;
    	let t25;
    	let div23;
    	let label6;
    	let t27;
    	let div22;
    	let div21;
    	let input7;
    	let t28;
    	let mounted;
    	let dispose;
    	let if_block0 = (/*$form*/ ctx[2].sci_member || /*booking*/ ctx[0] !== undefined && /*booking*/ ctx[0] !== null && /*booking*/ ctx[0].sci_member) && create_if_block_8$5(ctx);
    	let if_block1 = /*booking*/ ctx[0]?.mattress_booking && create_if_block_7$7(ctx);

    	function select_block_type(ctx, dirty) {
    		if (!/*isMattressBooking*/ ctx[1]) return create_if_block_4$b;
    		return create_else_block_3$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type(ctx);
    	let key_block0 = create_key_block_1$3(ctx);
    	let key_block1 = create_key_block$a(ctx);

    	const block = {
    		c: function create() {
    			form_1 = element("form");
    			div4 = element("div");
    			label0 = element("label");
    			label0.textContent = "Personals";
    			t1 = space();
    			div3 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div1 = element("div");
    			input1 = element("input");
    			t5 = space();
    			div2 = element("div");
    			input2 = element("input");
    			t6 = space();
    			div8 = element("div");
    			label1 = element("label");
    			label1.textContent = "Dates";
    			t8 = space();
    			div7 = element("div");
    			div5 = element("div");
    			input3 = element("input");
    			t9 = space();
    			div6 = element("div");
    			input4 = element("input");
    			t10 = space();
    			div11 = element("div");
    			label2 = element("label");
    			label2.textContent = "Accounting";
    			t12 = space();
    			div10 = element("div");
    			div9 = element("div");
    			input5 = element("input");
    			t13 = text$1(" People count");
    			t14 = space();
    			if_block2.c();
    			t15 = space();
    			div14 = element("div");
    			label3 = element("label");
    			label3.textContent = "Notes";
    			t17 = space();
    			div13 = element("div");
    			div12 = element("div");
    			textarea = element("textarea");
    			t18 = space();
    			div17 = element("div");
    			label4 = element("label");
    			label4.textContent = "PAF Event";
    			t20 = space();
    			div16 = element("div");
    			key_block0.c();
    			t21 = space();
    			div15 = element("div");
    			key_block1.c();
    			t22 = space();
    			div20 = element("div");
    			label5 = element("label");
    			label5.textContent = "Group";
    			t24 = space();
    			div19 = element("div");
    			div18 = element("div");
    			input6 = element("input");
    			t25 = space();
    			div23 = element("div");
    			label6 = element("label");
    			label6.textContent = "Website";
    			t27 = space();
    			div22 = element("div");
    			div21 = element("div");
    			input7 = element("input");
    			t28 = text$1(" Show on website");
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-personals");
    			add_location(label0, file$r, 296, 8, 14634);
    			attr_dev(input0, "class", "uk-input");
    			attr_dev(input0, "id", "form-name");
    			attr_dev(input0, "name", "name");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Name");
    			set_style(input0, "color", "black");
    			toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[6].name && /*$touched*/ ctx[8].name);
    			add_location(input0, file$r, 299, 16, 14872);
    			attr_dev(div0, "class", "uk-width-1-1 uk-inline");
    			add_location(div0, file$r, 298, 12, 14819);
    			attr_dev(input1, "class", "uk-input");
    			attr_dev(input1, "id", "form-email-no1pw-search");
    			attr_dev(input1, "name", "email");
    			attr_dev(input1, "type", "email");
    			attr_dev(input1, "placeholder", "Email");
    			attr_dev(input1, "autocomplete", "'off");
    			set_style(input1, "color", "black");
    			toggle_class(input1, "uk-form-danger", /*$errors*/ ctx[6].email && /*$touched*/ ctx[8].email);
    			add_location(input1, file$r, 310, 16, 15691);
    			attr_dev(div1, "class", "uk-width-1-2@s");
    			add_location(div1, file$r, 309, 12, 15646);
    			attr_dev(input2, "class", "uk-input");
    			attr_dev(input2, "id", "form-city");
    			attr_dev(input2, "name", "city");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", "City");
    			set_style(input2, "color", "black");
    			toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[6].city && /*$touched*/ ctx[8].city);
    			add_location(input2, file$r, 315, 16, 16077);
    			attr_dev(div2, "class", "uk-width-1-2@s");
    			add_location(div2, file$r, 314, 12, 16032);
    			attr_dev(div3, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div3, "id", "form-personals");
    			attr_dev(div3, "uk-grid", "");
    			add_location(div3, file$r, 297, 8, 14710);
    			attr_dev(div4, "class", "uk-margin-medium");
    			add_location(div4, file$r, 295, 4, 14595);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "form-dates");
    			add_location(label1, file$r, 322, 8, 16435);
    			attr_dev(input3, "class", "uk-input");
    			attr_dev(input3, "id", "form-arrival");
    			attr_dev(input3, "name", "arrival");
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "placeholder", "Arrival");
    			input3.readOnly = true;
    			set_style(input3, "color", "black");
    			toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[6].arrival && /*$touched*/ ctx[8].arrival);
    			add_location(input3, file$r, 325, 16, 16653);
    			attr_dev(div5, "class", "uk-width-1-2@s");
    			add_location(div5, file$r, 324, 12, 16608);
    			attr_dev(input4, "class", "uk-input");
    			attr_dev(input4, "id", "form-departure");
    			attr_dev(input4, "name", "departure");
    			attr_dev(input4, "type", "text");
    			attr_dev(input4, "placeholder", "Departure");
    			input4.readOnly = true;
    			set_style(input4, "color", "black");
    			toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[6].departure && /*$touched*/ ctx[8].departure);
    			add_location(input4, file$r, 330, 16, 17027);
    			attr_dev(div6, "class", "uk-width-1-2@s");
    			add_location(div6, file$r, 329, 12, 16982);
    			attr_dev(div7, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div7, "id", "form-dates");
    			attr_dev(div7, "uk-grid", "");
    			add_location(div7, file$r, 323, 8, 16503);
    			attr_dev(div8, "class", "uk-margin-medium");
    			add_location(div8, file$r, 321, 4, 16396);
    			attr_dev(label2, "class", "uk-form-label");
    			attr_dev(label2, "for", "form-accounting");
    			add_location(label2, file$r, 337, 8, 17425);
    			attr_dev(input5, "class", "uk-input uk-margin-small-right uk-form-width-small");
    			attr_dev(input5, "name", "people_count");
    			attr_dev(input5, "type", "number");
    			set_style(input5, "color", "black");
    			toggle_class(input5, "uk-form-danger", /*$errors*/ ctx[6].people_count && /*$touched*/ ctx[8].people_count);
    			add_location(input5, file$r, 340, 16, 17673);
    			attr_dev(div9, "class", "uk-width-1-2@s uk-text-nowrap");
    			add_location(div9, file$r, 339, 12, 17613);
    			attr_dev(div10, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div10, "id", "form-accounting");
    			attr_dev(div10, "uk-grid", "");
    			add_location(div10, file$r, 338, 8, 17503);
    			attr_dev(div11, "class", "uk-margin-medium");
    			add_location(div11, file$r, 336, 4, 17386);
    			attr_dev(label3, "class", "uk-form-label");
    			attr_dev(label3, "for", "form-info");
    			add_location(label3, file$r, 407, 8, 22168);
    			attr_dev(textarea, "class", "uk-textarea");
    			attr_dev(textarea, "name", "info");
    			set_style(textarea, "color", "black");
    			toggle_class(textarea, "uk-form-danger", /*$errors*/ ctx[6].info && /*$touched*/ ctx[8].info);
    			add_location(textarea, file$r, 410, 16, 22382);
    			attr_dev(div12, "class", "uk-width-1-1");
    			add_location(div12, file$r, 409, 12, 22339);
    			attr_dev(div13, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div13, "id", "form-info");
    			attr_dev(div13, "uk-grid", "");
    			add_location(div13, file$r, 408, 8, 22235);
    			attr_dev(div14, "class", "uk-margin-medium");
    			add_location(div14, file$r, 406, 4, 22129);
    			attr_dev(label4, "class", "uk-form-label");
    			attr_dev(label4, "for", "form-paf_event_ids");
    			add_location(label4, file$r, 417, 8, 22717);
    			attr_dev(div15, "class", "uk-width-1-2@s");
    			add_location(div15, file$r, 434, 12, 23897);
    			attr_dev(div16, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div16, "id", "form-paf_event_ids");
    			attr_dev(div16, "uk-grid", "");
    			add_location(div16, file$r, 418, 8, 22797);
    			attr_dev(div17, "class", "uk-margin-medium");
    			add_location(div17, file$r, 416, 4, 22678);
    			attr_dev(label5, "class", "uk-form-label");
    			attr_dev(label5, "for", "form-group_name");
    			add_location(label5, file$r, 453, 8, 24883);
    			attr_dev(input6, "class", "uk-input");
    			attr_dev(input6, "name", "group_name");
    			attr_dev(input6, "type", "text");
    			attr_dev(input6, "placeholder", "Group name");
    			set_style(input6, "color", "black");
    			toggle_class(input6, "uk-form-danger", /*$errors*/ ctx[6].group_name && /*$touched*/ ctx[8].group_name);
    			add_location(input6, file$r, 456, 16, 25111);
    			attr_dev(div18, "class", "uk-width-1-2@s");
    			add_location(div18, file$r, 455, 12, 25066);
    			attr_dev(div19, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div19, "id", "form-group_name");
    			attr_dev(div19, "uk-grid", "");
    			add_location(div19, file$r, 454, 8, 24956);
    			attr_dev(div20, "class", "uk-margin-medium");
    			add_location(div20, file$r, 452, 4, 24844);
    			attr_dev(label6, "class", "uk-form-label");
    			attr_dev(label6, "for", "form-website");
    			add_location(label6, file$r, 463, 8, 25484);
    			attr_dev(input7, "class", "uk-checkbox");
    			attr_dev(input7, "id", "form-show_on_website");
    			attr_dev(input7, "name", "show_on_website");
    			attr_dev(input7, "type", "checkbox");
    			add_location(input7, file$r, 466, 16, 25706);
    			attr_dev(div21, "class", "uk-width-1-1");
    			add_location(div21, file$r, 465, 12, 25663);
    			attr_dev(div22, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div22, "id", "form-website");
    			attr_dev(div22, "uk-grid", "");
    			add_location(div22, file$r, 464, 8, 25556);
    			attr_dev(div23, "class", "uk-margin-medium");
    			add_location(div23, file$r, 462, 4, 25445);
    			attr_dev(form_1, "id", "bookingForm");
    			attr_dev(form_1, "class", "uk-form");
    			toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[7]);
    			add_location(form_1, file$r, 293, 0, 14508);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form_1, anchor);
    			append_dev(form_1, div4);
    			append_dev(div4, label0);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$form*/ ctx[2].name);
    			append_dev(div0, t2);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t3);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div3, t4);
    			append_dev(div3, div1);
    			append_dev(div1, input1);
    			set_input_value(input1, /*$form*/ ctx[2].email);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, input2);
    			set_input_value(input2, /*$form*/ ctx[2].city);
    			append_dev(form_1, t6);
    			append_dev(form_1, div8);
    			append_dev(div8, label1);
    			append_dev(div8, t8);
    			append_dev(div8, div7);
    			append_dev(div7, div5);
    			append_dev(div5, input3);
    			set_input_value(input3, /*$form*/ ctx[2].arrival);
    			append_dev(div7, t9);
    			append_dev(div7, div6);
    			append_dev(div6, input4);
    			set_input_value(input4, /*$form*/ ctx[2].departure);
    			append_dev(form_1, t10);
    			append_dev(form_1, div11);
    			append_dev(div11, label2);
    			append_dev(div11, t12);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, input5);
    			set_input_value(input5, /*$form*/ ctx[2].people_count);
    			append_dev(div9, t13);
    			append_dev(div10, t14);
    			if_block2.m(div10, null);
    			append_dev(form_1, t15);
    			append_dev(form_1, div14);
    			append_dev(div14, label3);
    			append_dev(div14, t17);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, textarea);
    			set_input_value(textarea, /*$form*/ ctx[2].info);
    			append_dev(form_1, t18);
    			append_dev(form_1, div17);
    			append_dev(div17, label4);
    			append_dev(div17, t20);
    			append_dev(div17, div16);
    			key_block0.m(div16, null);
    			append_dev(div16, t21);
    			append_dev(div16, div15);
    			key_block1.m(div15, null);
    			append_dev(form_1, t22);
    			append_dev(form_1, div20);
    			append_dev(div20, label5);
    			append_dev(div20, t24);
    			append_dev(div20, div19);
    			append_dev(div19, div18);
    			append_dev(div18, input6);
    			set_input_value(input6, /*$form*/ ctx[2].group_name);
    			append_dev(form_1, t25);
    			append_dev(form_1, div23);
    			append_dev(div23, label6);
    			append_dev(div23, t27);
    			append_dev(div23, div22);
    			append_dev(div22, div21);
    			append_dev(div21, input7);
    			input7.checked = /*$form*/ ctx[2].show_on_website;
    			append_dev(div21, t28);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keyup", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input0, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[18]),
    					listen_dev(input1, "keyup", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input1, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[19]),
    					listen_dev(input2, "keyup", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input2, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[20]),
    					listen_dev(input3, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input3, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[21]),
    					listen_dev(input4, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input4, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[22]),
    					listen_dev(input5, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input5, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[23]),
    					listen_dev(textarea, "keyup", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(textarea, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[35]),
    					listen_dev(input6, "keyup", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input6, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[39]),
    					listen_dev(input7, "change", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input7, "blur", /*formUpdate*/ ctx[14], false, false, false),
    					listen_dev(input7, "change", /*input7_change_handler*/ ctx[40])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 4 && input0.value !== /*$form*/ ctx[2].name) {
    				set_input_value(input0, /*$form*/ ctx[2].name);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 320) {
    				toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[6].name && /*$touched*/ ctx[8].name);
    			}

    			if (/*$form*/ ctx[2].sci_member || /*booking*/ ctx[0] !== undefined && /*booking*/ ctx[0] !== null && /*booking*/ ctx[0].sci_member) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_8$5(ctx);
    					if_block0.c();
    					if_block0.m(div0, t3);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*booking*/ ctx[0]?.mattress_booking) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_7$7(ctx);
    					if_block1.c();
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*$form*/ 4 && input1.value !== /*$form*/ ctx[2].email) {
    				set_input_value(input1, /*$form*/ ctx[2].email);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 320) {
    				toggle_class(input1, "uk-form-danger", /*$errors*/ ctx[6].email && /*$touched*/ ctx[8].email);
    			}

    			if (dirty[0] & /*$form*/ 4 && input2.value !== /*$form*/ ctx[2].city) {
    				set_input_value(input2, /*$form*/ ctx[2].city);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 320) {
    				toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[6].city && /*$touched*/ ctx[8].city);
    			}

    			if (dirty[0] & /*$form*/ 4 && input3.value !== /*$form*/ ctx[2].arrival) {
    				set_input_value(input3, /*$form*/ ctx[2].arrival);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 320) {
    				toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[6].arrival && /*$touched*/ ctx[8].arrival);
    			}

    			if (dirty[0] & /*$form*/ 4 && input4.value !== /*$form*/ ctx[2].departure) {
    				set_input_value(input4, /*$form*/ ctx[2].departure);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 320) {
    				toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[6].departure && /*$touched*/ ctx[8].departure);
    			}

    			if (dirty[0] & /*$form*/ 4 && to_number(input5.value) !== /*$form*/ ctx[2].people_count) {
    				set_input_value(input5, /*$form*/ ctx[2].people_count);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 320) {
    				toggle_class(input5, "uk-form-danger", /*$errors*/ ctx[6].people_count && /*$touched*/ ctx[8].people_count);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div10, null);
    				}
    			}

    			if (dirty[0] & /*$form*/ 4) {
    				set_input_value(textarea, /*$form*/ ctx[2].info);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 320) {
    				toggle_class(textarea, "uk-form-danger", /*$errors*/ ctx[6].info && /*$touched*/ ctx[8].info);
    			}

    			if (dirty[0] & /*pafEventsReload*/ 16 && safe_not_equal(previous_key, previous_key = /*pafEventsReload*/ ctx[4])) {
    				key_block0.d(1);
    				key_block0 = create_key_block_1$3(ctx);
    				key_block0.c();
    				key_block0.m(div16, t21);
    			} else {
    				key_block0.p(ctx, dirty);
    			}

    			if (dirty[0] & /*pafEventsSelectReload*/ 32 && safe_not_equal(previous_key_1, previous_key_1 = /*pafEventsSelectReload*/ ctx[5])) {
    				key_block1.d(1);
    				key_block1 = create_key_block$a(ctx);
    				key_block1.c();
    				key_block1.m(div15, null);
    			} else {
    				key_block1.p(ctx, dirty);
    			}

    			if (dirty[0] & /*$form*/ 4 && input6.value !== /*$form*/ ctx[2].group_name) {
    				set_input_value(input6, /*$form*/ ctx[2].group_name);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 320) {
    				toggle_class(input6, "uk-form-danger", /*$errors*/ ctx[6].group_name && /*$touched*/ ctx[8].group_name);
    			}

    			if (dirty[0] & /*$form*/ 4) {
    				input7.checked = /*$form*/ ctx[2].show_on_website;
    			}

    			if (dirty[0] & /*$screenWidthL*/ 128) {
    				toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[7]);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form_1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_block2.d();
    			key_block0.d(detaching);
    			key_block1.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$1 = e => e.selected;

    function instance$r($$self, $$props, $$invalidate) {
    	let $form;
    	let $settings;
    	let $isValid;
    	let $errors;
    	let $memberNames;
    	let $events;
    	let $screenWidthL;
    	let $touched;
    	let $screenWidthS;
    	validate_store(settings, 'settings');
    	component_subscribe($$self, settings, $$value => $$invalidate(42, $settings = $$value));
    	validate_store(memberNames, 'memberNames');
    	component_subscribe($$self, memberNames, $$value => $$invalidate(44, $memberNames = $$value));
    	validate_store(events, 'events');
    	component_subscribe($$self, events, $$value => $$invalidate(45, $events = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(7, $screenWidthL = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(9, $screenWidthS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BookingFormComponent', slots, []);
    	let { booking = undefined } = $$props;
    	let { isMattressBooking = false } = $$props;
    	let { formValid = false } = $$props;
    	let pafEvents = [];
    	let pafEventsReload = false;
    	let pafEventsSelectReload = false;
    	let stayDays = 0;

    	const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    		initialValues: {
    			name: '',
    			member_id: 0,
    			sci_member: false,
    			sci_days_used: 0,
    			membership_needed: true,
    			membership_count: 1,
    			email: '',
    			city: '',
    			arrival: '',
    			departure: '',
    			people_count: 1,
    			info: '',
    			cancelled: false,
    			show_on_website: true,
    			paid: false,
    			date_paid: '',
    			invoice_id: 0,
    			invoice_nr: '',
    			institutional: false,
    			no_stay_pay: true,
    			no_meal_pay: false,
    			longstayer: false,
    			group_name: '',
    			paf_event_select: 0,
    			stay_rate: 0,
    			stay_amount: 0,
    			membership_amount: 0,
    			meals_amount: 0,
    			total_amount: 0,
    			early_pay: false
    		},
    		validationSchema: create$4().shape({
    			name: create$7().min(4).required(),
    			email: create$7().email().required(),
    			city: create$7().optional(),
    			arrival: create$5().required(),
    			departure: create$5().required(),
    			membership_count: create$6().required(),
    			membership_needed: create$8().required(),
    			people_count: create$6().min(1).required(),
    			info: create$7().optional(),
    			cancelled: create$8().required(),
    			show_on_website: create$8().required(),
    			paid: create$8().required(),
    			invoice_nr: create$7().optional(),
    			institutional: create$8().required(),
    			no_stay_pay: create$8().required(),
    			no_meal_pay: create$8().required(),
    			longstayer: create$8().required(),
    			group_name: create$7().optional(),
    			paf_event_select: create$6().optional(),
    			sci_days_used: create$6().min(0).transform((number, string) => string === '' ? 0 : Number(string)),
    			stay_rate: create$6().min(0).transform((number, string) => string === '' ? 0 : Number(string)),
    			stay_amount: create$6().min(0).transform((number, string) => string === '' ? 0 : Number(string)),
    			membership_amount: create$6().min(0).transform((number, string) => string === '' ? 0 : Number(string)),
    			meals_amount: create$6().min(0).transform((number, string) => string === '' ? 0 : Number(string)),
    			total_amount: create$6(),
    			early_pay: create$8().required()
    		})
    	});

    	validate_store(form, 'form');
    	component_subscribe($$self, form, value => $$invalidate(2, $form = value));
    	validate_store(errors, 'errors');
    	component_subscribe($$self, errors, value => $$invalidate(6, $errors = value));
    	validate_store(touched, 'touched');
    	component_subscribe($$self, touched, value => $$invalidate(8, $touched = value));
    	validate_store(isValid, 'isValid');
    	component_subscribe($$self, isValid, value => $$invalidate(43, $isValid = value));

    	onMount(async () => {
    		$$invalidate(3, pafEvents = JSON.parse(JSON.stringify($events)));

    		if (booking !== undefined) {
    			set_store_value(
    				form,
    				$form.name = booking !== null && booking.name !== null
    				? booking.name
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.member_id = booking !== null && booking.member_id !== null
    				? booking.member_id
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.sci_member = booking !== null && booking.sci_member !== null
    				? booking.sci_member
    				: false,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.sci_days_used = booking !== null && booking.sci_days_used !== null
    				? booking.sci_days_used
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.membership_count = booking !== null && booking.membership_count !== null
    				? booking.membership_count
    				: 1,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.membership_needed = booking !== null && booking.membership_count !== null
    				? booking.membership_count > 0
    				: true,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.email = booking !== null && booking.email !== null
    				? booking.email
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.city = booking !== null && booking.city !== null
    				? booking.city
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.arrival = booking !== null && booking.arrival !== null
    				? booking.arrival
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.departure = booking !== null && booking.departure !== null
    				? booking.departure
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.people_count = booking !== null && booking.people_count !== null
    				? booking.people_count
    				: 1,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.info = booking !== null && booking.info !== null
    				? booking.info
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.cancelled = booking !== null && booking.cancelled !== null
    				? booking.cancelled
    				: false,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.show_on_website = booking !== null && booking.show_on_website !== null
    				? booking.show_on_website
    				: true,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.paid = booking !== null && booking.paid !== null
    				? booking.paid
    				: false,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.date_paid = booking !== null && booking.date_paid !== null
    				? booking.date_paid
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.invoice_id = booking !== null && booking.invoice_id !== null
    				? booking.invoice_id
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.invoice_nr = booking !== null && booking.invoice_nr !== null
    				? booking.invoice_nr
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.institutional = booking !== null && booking.institutional !== null
    				? booking.institutional
    				: false,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.no_stay_pay = booking !== null && booking.no_stay_pay !== null
    				? booking.no_stay_pay
    				: false,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.no_meal_pay = booking !== null && booking.no_meal_pay !== null
    				? booking.no_meal_pay
    				: false,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.longstayer = booking !== null && booking.longstayer !== null
    				? booking.longstayer
    				: false,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.group_name = booking !== null && booking.group_name !== null
    				? booking.group_name
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.paf_events = booking !== null && booking.paf_events !== null
    				? booking.paf_events
    				: [],
    				$form
    			);

    			pafEvents.forEach(e => e.selected = $form.paf_events.find(dbEvent => dbEvent.id === e.id) !== undefined);
    			set_store_value(form, $form.paf_event_select = 0, $form);

    			set_store_value(
    				form,
    				$form.stay_rate = booking !== null && booking.stay_rate !== null
    				? booking.stay_rate
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.stay_amount = booking !== null && booking.stay_amount !== null
    				? booking.stay_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.membership_amount = booking !== null && booking.membership_amount !== null
    				? booking.membership_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.meals_amount = booking !== null && booking.meals_amount !== null
    				? booking.meals_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.total_amount = booking !== null && booking.total_amount !== null
    				? booking.total_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.early_pay = booking !== null && booking.early_pay !== null
    				? booking.early_pay
    				: false,
    				$form
    			);

    			stayDays = Interval_1.fromDateTimes(DateTime_1.fromSQL($form.arrival), DateTime_1.fromSQL($form.departure)).length('days');
    			if ($form.stay_rate === 0) updateStayRate();

    			// ugly hack to get force evaluate isValid
    			if (booking === null) handleSubmit(null);

    			// formValid = $isValid
    			setTimeout(() => $$invalidate(17, formValid = $isValid), 0);

    			if (booking !== null && !isMattressBooking) $$invalidate(1, isMattressBooking = booking?.mattress_booking);
    		}

    		if (booking !== undefined && booking === null) {
    			const autoCompleteJS = new autoComplete({
    					selector: "#form-name",
    					placeHolder: "Search for member... (or enter new name)",
    					diacritics: true,
    					searchEngine: 'strict',
    					data: { src: $memberNames, cache: true },
    					resultsList: {
    						element: (list, data) => {
    							if (!data.results.length) {
    								const message = document.createElement("div");
    								message.setAttribute("class", "no_result");
    								message.innerHTML = `<span>No Member for "${data.query}"</span>`;
    								list.prepend(message);
    							}
    						},
    						maxResults: 50,
    						noResults: true
    					},
    					resultItem: { highlight: true },
    					events: {
    						input: {
    							selection: event => {
    								autoCompleteJS.input.value = event.detail.selection.value;
    								fillMemberData(event.detail.selection.value);
    							},
    							keyup: () => {
    								if (autoCompleteJS.input.value === '') fillMemberData(null);
    							}
    						}
    					}
    				});
    		}

    		flatpickr('#form-dates', {
    			monthSelectorType: 'static',
    			mode: 'range',
    			defaultDate: [$form.arrival, $form.departure],
    			onChange(selectedDates, dateStr) {
    				set_store_value(form, $form.arrival = dateStr.substring(0, 10), $form);
    				set_store_value(form, $form.departure = dateStr.substring(14), $form);
    				if ($form.arrival !== '') document.getElementById('form-arrival').focus();

    				if ($form.departure !== '') {
    					document.getElementById('form-departure').focus();
    					setTimeout(() => document.getElementById('form-departure').blur(), 0);
    				} else set_store_value(errors, $errors.departure = 'Departure date needed!', $errors);
    			}
    		});
    	});

    	function formUpdate(event) {
    		handleChange(event);
    		updateBooking();
    		setTimeout(() => $$invalidate(17, formValid = $isValid), 0);
    	}

    	async function fillMemberData(name) {
    		let memberData = null;

    		if (name !== null) {
    			memberData = await getMemberByName(name);
    			if (memberData !== undefined && memberData !== null) memberData = memberData[0];
    		}

    		set_store_value(
    			form,
    			$form.name = memberData !== null && memberData.name !== null
    			? memberData.name
    			: '',
    			$form
    		);

    		set_store_value(
    			form,
    			$form.member_id = memberData !== null && memberData.id !== null
    			? memberData.id
    			: 0,
    			$form
    		);

    		set_store_value(form, $form.sci_member = Boolean(memberData !== null && memberData.sci_member !== null && memberData.sci_member), $form);

    		set_store_value(
    			form,
    			$form.sci_days_used = memberData !== null && memberData.sci_days_used !== null
    			? memberData.sci_days_used
    			: 0,
    			$form
    		);

    		set_store_value(
    			form,
    			$form.membership_needed = memberData !== null && memberData.renew_date !== null
    			? DateTime_1.fromSQL(memberData.renew_date) < DateTime_1.now()
    			: true,
    			$form
    		);

    		set_store_value(
    			form,
    			$form.email = memberData !== null && memberData.email !== null
    			? memberData.email
    			: '',
    			$form
    		);

    		set_store_value(
    			form,
    			$form.city = memberData !== null && memberData.city !== null
    			? memberData.city
    			: '',
    			$form
    		);

    		set_store_value(form, $form.people_count = 1, $form);
    		document.getElementById('form-email-no1pw-search').focus();
    		setTimeout(() => document.getElementById('form-email-no1pw-search').blur(), 0);
    	}

    	function updateBooking() {
    		if (booking === null) $$invalidate(0, booking = {});
    		Object.entries($form).forEach(e => $$invalidate(0, booking[e[0]] = e[1], booking));
    		if (booking.paid && booking.date_paid === '') $$invalidate(0, booking.date_paid = DateTime_1.now().toSQLDate(), booking);

    		$$invalidate(
    			0,
    			booking.membership_count = isMattressBooking
    			? 0
    			: booking.membership_needed ? booking.people_count : 0,
    			booking
    		);

    		$$invalidate(0, booking.paf_events = updateEventConfirmation(), booking);
    		$$invalidate(0, booking.stay_days = Interval_1.fromDateTimes(DateTime_1.fromSQL(booking.arrival), DateTime_1.fromSQL(booking.departure)).length('days'), booking);
    	}

    	function updateEventConfirmation() {
    		let events = pafEvents.filter(e => e.selected && e.show);

    		if (events.length > 0) {
    			events = events.map(e => {
    				const existingBookingIndex = e.bookings !== null && booking !== null
    				? e.bookings.findIndex(b => b.id === booking.id)
    				: -1;

    				const existingBookingCount = existingBookingIndex > -1
    				? e.bookings[existingBookingIndex].count
    				: 0;

    				const existingBookingConfirmed = existingBookingIndex > -1 && e.bookings[existingBookingIndex].confirmed;

    				return {
    					id: e.id,
    					name: e.name,
    					abbreviation: e.abbreviation,
    					confirmed: existingBookingIndex > -1
    					? existingBookingConfirmed
    					: e.max_participants === null || (e.bookings === null || e.bookings.length === 0) && Number($form.people_count) <= e.max_participants || e.bookings !== null && e.bookings.reduce((pVal, cVal) => pVal + cVal['count'], 0) + Number($form.people_count) - existingBookingCount <= e.max_participants
    				};
    			});
    		}

    		return events;
    	}

    	function updateStayRate() {
    		let updatedStayDays = Interval_1.fromDateTimes(DateTime_1.fromSQL($form.arrival), DateTime_1.fromSQL($form.departure)).length('days');

    		if (stayDays !== updatedStayDays && $form.arrival !== '' && $form.departure !== '') {
    			stayDays = Interval_1.fromDateTimes(DateTime_1.fromSQL($form.arrival), DateTime_1.fromSQL($form.departure)).length('days');

    			set_store_value(
    				form,
    				$form.stay_rate = stayDays <= $settings.short_stay_duration
    				? $settings.price_stay_short
    				: stayDays >= 30
    					? $settings.price_stay_month
    					: $settings.price_stay,
    				$form
    			);
    		}
    	}

    	function filterEvents() {
    		if ($form.arrival !== '' && $form.departure !== '') {
    			pafEvents.forEach(e => e.show = Interval_1.fromDateTimes(DateTime_1.fromSQL(e.start_date), DateTime_1.fromSQL(e.end_date)).overlaps(Interval_1.fromDateTimes(DateTime_1.fromSQL($form.arrival), DateTime_1.fromSQL($form.departure))));
    			$$invalidate(5, pafEventsSelectReload = !pafEventsSelectReload);
    		}
    	}

    	function selection(event) {
    		handleChange(event);
    		eventSelection(Number($form.paf_event_select), true);
    	}

    	function eventSelection(id, select) {
    		if (id > 0) {
    			pafEvents.find(e => e.id === id).selected = select;
    			set_store_value(form, $form.paf_events = updateEventConfirmation(), $form);

    			setTimeout(
    				() => {
    					$$invalidate(4, pafEventsReload = !pafEventsReload);
    					$$invalidate(5, pafEventsSelectReload = !pafEventsSelectReload);
    				},
    				0
    			);

    			updateBooking();
    		}
    	}

    	const writable_props = ['booking', 'isMattressBooking', 'formValid'];

    	Object_1$4.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BookingFormComponent> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		$form.name = this.value;
    		form.set($form);
    	}

    	function input1_input_handler() {
    		$form.email = this.value;
    		form.set($form);
    	}

    	function input2_input_handler() {
    		$form.city = this.value;
    		form.set($form);
    	}

    	function input3_input_handler() {
    		$form.arrival = this.value;
    		form.set($form);
    	}

    	function input4_input_handler() {
    		$form.departure = this.value;
    		form.set($form);
    	}

    	function input5_input_handler() {
    		$form.people_count = to_number(this.value);
    		form.set($form);
    	}

    	function input0_input_handler_1() {
    		$form.stay_rate = to_number(this.value);
    		form.set($form);
    	}

    	function input1_change_handler() {
    		$form.institutional = this.checked;
    		form.set($form);
    	}

    	function input2_change_handler() {
    		$form.early_pay = this.checked;
    		form.set($form);
    	}

    	function input_change_handler() {
    		$form.paid = this.checked;
    		form.set($form);
    	}

    	function input_change_handler_1() {
    		$form.paid = this.checked;
    		form.set($form);
    	}

    	function input_change_handler_2() {
    		$form.cancelled = this.checked;
    		form.set($form);
    	}

    	function input3_change_handler() {
    		$form.membership_needed = this.checked;
    		form.set($form);
    	}

    	function input4_change_handler() {
    		$form.longstayer = this.checked;
    		form.set($form);
    	}

    	function input5_change_handler() {
    		$form.no_stay_pay = this.checked;
    		form.set($form);
    	}

    	function input6_change_handler() {
    		$form.no_meal_pay = this.checked;
    		form.set($form);
    	}

    	function input_change_handler_3() {
    		$form.membership_needed = this.checked;
    		form.set($form);
    	}

    	function textarea_input_handler() {
    		$form.info = this.value;
    		form.set($form);
    	}

    	const click_handler = event => eventSelection(event.id, false);
    	const func_1 = (event, dbEvent) => dbEvent.id === event.id;
    	const func_2 = (event, dbEvent) => dbEvent.id === event.id;

    	function input6_input_handler() {
    		$form.group_name = this.value;
    		form.set($form);
    	}

    	function input7_change_handler() {
    		$form.show_on_website = this.checked;
    		form.set($form);
    	}

    	$$self.$$set = $$props => {
    		if ('booking' in $$props) $$invalidate(0, booking = $$props.booking);
    		if ('isMattressBooking' in $$props) $$invalidate(1, isMattressBooking = $$props.isMattressBooking);
    		if ('formValid' in $$props) $$invalidate(17, formValid = $$props.formValid);
    	};

    	$$self.$capture_state = () => ({
    		DateTime: DateTime_1,
    		Interval: Interval_1,
    		onMount,
    		createForm,
    		yup,
    		flatpickr,
    		screenWidthL,
    		screenWidthS,
    		getMemberByName,
    		memberNames,
    		autoComplete,
    		events,
    		settings,
    		booking,
    		isMattressBooking,
    		formValid,
    		pafEvents,
    		pafEventsReload,
    		pafEventsSelectReload,
    		stayDays,
    		form,
    		errors,
    		touched,
    		state,
    		isValid,
    		handleChange,
    		handleSubmit,
    		formUpdate,
    		fillMemberData,
    		updateBooking,
    		updateEventConfirmation,
    		updateStayRate,
    		filterEvents,
    		selection,
    		eventSelection,
    		$form,
    		$settings,
    		$isValid,
    		$errors,
    		$memberNames,
    		$events,
    		$screenWidthL,
    		$touched,
    		$screenWidthS
    	});

    	$$self.$inject_state = $$props => {
    		if ('booking' in $$props) $$invalidate(0, booking = $$props.booking);
    		if ('isMattressBooking' in $$props) $$invalidate(1, isMattressBooking = $$props.isMattressBooking);
    		if ('formValid' in $$props) $$invalidate(17, formValid = $$props.formValid);
    		if ('pafEvents' in $$props) $$invalidate(3, pafEvents = $$props.pafEvents);
    		if ('pafEventsReload' in $$props) $$invalidate(4, pafEventsReload = $$props.pafEventsReload);
    		if ('pafEventsSelectReload' in $$props) $$invalidate(5, pafEventsSelectReload = $$props.pafEventsSelectReload);
    		if ('stayDays' in $$props) stayDays = $$props.stayDays;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$form*/ 4) {
    			$form.departure && filterEvents();
    		}

    		if ($$self.$$.dirty[0] & /*$form*/ 4) {
    			$form.departure && updateStayRate();
    		}
    	};

    	return [
    		booking,
    		isMattressBooking,
    		$form,
    		pafEvents,
    		pafEventsReload,
    		pafEventsSelectReload,
    		$errors,
    		$screenWidthL,
    		$touched,
    		$screenWidthS,
    		form,
    		errors,
    		touched,
    		isValid,
    		formUpdate,
    		selection,
    		eventSelection,
    		formValid,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input0_input_handler_1,
    		input1_change_handler,
    		input2_change_handler,
    		input_change_handler,
    		input_change_handler_1,
    		input_change_handler_2,
    		input3_change_handler,
    		input4_change_handler,
    		input5_change_handler,
    		input6_change_handler,
    		input_change_handler_3,
    		textarea_input_handler,
    		click_handler,
    		func_1,
    		func_2,
    		input6_input_handler,
    		input7_change_handler
    	];
    }

    class BookingFormComponent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init$2(
    			this,
    			options,
    			instance$r,
    			create_fragment$r,
    			safe_not_equal,
    			{
    				booking: 0,
    				isMattressBooking: 1,
    				formValid: 17
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BookingFormComponent",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get booking() {
    		throw new Error("<BookingFormComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set booking(value) {
    		throw new Error("<BookingFormComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMattressBooking() {
    		throw new Error("<BookingFormComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMattressBooking(value) {
    		throw new Error("<BookingFormComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get formValid() {
    		throw new Error("<BookingFormComponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set formValid(value) {
    		throw new Error("<BookingFormComponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/BookingForm.svelte generated by Svelte v3.45.0 */
    const file$q = "src/components/BookingForm.svelte";

    // (48:4) {:else }
    function create_else_block_2$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Creating booking");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$8.name,
    		type: "else",
    		source: "(48:4) {:else }",
    		ctx
    	});

    	return block;
    }

    // (46:19) 
    function create_if_block_5$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Updating booking");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$9.name,
    		type: "if",
    		source: "(46:19) ",
    		ctx
    	});

    	return block;
    }

    // (41:26) 
    function create_if_block_3$e(ctx) {
    	let t0;
    	let t1_value = (/*$screenWidthS*/ ctx[4] ? '' : 'booking') + "";
    	let t1;
    	let t2;
    	let if_block_anchor;
    	let if_block = /*booking*/ ctx[0]?.cancelled && create_if_block_4$a(ctx);

    	const block = {
    		c: function create() {
    			t0 = text$1("Edit ");
    			t1 = text$1(t1_value);
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$screenWidthS*/ 16 && t1_value !== (t1_value = (/*$screenWidthS*/ ctx[4] ? '' : 'booking') + "")) set_data_dev(t1, t1_value);

    			if (/*booking*/ ctx[0]?.cancelled) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$a(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$e.name,
    		type: "if",
    		source: "(41:26) ",
    		ctx
    	});

    	return block;
    }

    // (39:4) {#if !edit && !dispatched}
    function create_if_block_2$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("New booking");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$f.name,
    		type: "if",
    		source: "(39:4) {#if !edit && !dispatched}",
    		ctx
    	});

    	return block;
    }

    // (43:8) {#if booking?.cancelled}
    function create_if_block_4$a(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Delete";
    			attr_dev(button, "class", "uk-button uk-text-normal uk-margin uk-button-secondary uk-position-bottom-right uk-button-danger");
    			attr_dev(button, "type", "button");
    			add_location(button, file$q, 43, 12, 1095);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*deleteMe*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$a.name,
    		type: "if",
    		source: "(43:8) {#if booking?.cancelled}",
    		ctx
    	});

    	return block;
    }

    // (56:0) {:else}
    function create_else_block$o(ctx) {
    	let bookingformcomponent;
    	let updating_booking;
    	let updating_formValid;
    	let t0;
    	let div;
    	let button;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;

    	function bookingformcomponent_booking_binding(value) {
    		/*bookingformcomponent_booking_binding*/ ctx[8](value);
    	}

    	function bookingformcomponent_formValid_binding(value) {
    		/*bookingformcomponent_formValid_binding*/ ctx[9](value);
    	}

    	let bookingformcomponent_props = { isMattressBooking: false };

    	if (/*booking*/ ctx[0] !== void 0) {
    		bookingformcomponent_props.booking = /*booking*/ ctx[0];
    	}

    	if (/*formValid*/ ctx[3] !== void 0) {
    		bookingformcomponent_props.formValid = /*formValid*/ ctx[3];
    	}

    	bookingformcomponent = new BookingFormComponent({
    			props: bookingformcomponent_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$1(bookingformcomponent, 'booking', bookingformcomponent_booking_binding));
    	binding_callbacks.push(() => bind$1(bookingformcomponent, 'formValid', bookingformcomponent_formValid_binding));

    	function select_block_type_2(ctx, dirty) {
    		if (/*booking*/ ctx[0]?.paid) return create_if_block_1$g;
    		return create_else_block_1$c;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			create_component(bookingformcomponent.$$.fragment);
    			t0 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Cancel";
    			t2 = space();
    			if_block.c();
    			attr_dev(button, "class", "uk-button uk-button-default");
    			attr_dev(button, "type", "button");
    			add_location(button, file$q, 58, 8, 1702);
    			attr_dev(div, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div, file$q, 57, 4, 1620);
    		},
    		m: function mount(target, anchor) {
    			mount_component(bookingformcomponent, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(div, t2);
    			if_block.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*cancel*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const bookingformcomponent_changes = {};

    			if (!updating_booking && dirty & /*booking*/ 1) {
    				updating_booking = true;
    				bookingformcomponent_changes.booking = /*booking*/ ctx[0];
    				add_flush_callback(() => updating_booking = false);
    			}

    			if (!updating_formValid && dirty & /*formValid*/ 8) {
    				updating_formValid = true;
    				bookingformcomponent_changes.formValid = /*formValid*/ ctx[3];
    				add_flush_callback(() => updating_formValid = false);
    			}

    			bookingformcomponent.$set(bookingformcomponent_changes);

    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bookingformcomponent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bookingformcomponent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(bookingformcomponent, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$o.name,
    		type: "else",
    		source: "(56:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (52:0) {#if dispatched}
    function create_if_block$p(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$q, 53, 8, 1458);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-xlarge-top");
    			add_location(div1, file$q, 52, 4, 1392);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(52:0) {#if dispatched}",
    		ctx
    	});

    	return block;
    }

    // (62:8) {:else}
    function create_else_block_1$c(ctx) {
    	let button;
    	let t;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text$1("Save");
    			attr_dev(button, "class", "uk-button uk-margin-large-left");
    			attr_dev(button, "id", "submitBooking");
    			attr_dev(button, "type", "submit");
    			button.disabled = button_disabled_value = !/*formValid*/ ctx[3];
    			toggle_class(button, "uk-button-primary", /*formValid*/ ctx[3]);
    			add_location(button, file$q, 62, 12, 1979);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*submit*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*formValid*/ 8 && button_disabled_value !== (button_disabled_value = !/*formValid*/ ctx[3])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (dirty & /*formValid*/ 8) {
    				toggle_class(button, "uk-button-primary", /*formValid*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$c.name,
    		type: "else",
    		source: "(62:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (60:8) {#if booking?.paid}
    function create_if_block_1$g(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Can't alter (paid)";
    			attr_dev(button, "class", "uk-button uk-margin-large-left");
    			attr_dev(button, "id", "submitBooking");
    			attr_dev(button, "type", "submit");
    			button.disabled = true;
    			add_location(button, file$q, 60, 12, 1834);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(60:8) {#if booking?.paid}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let h4;
    	let t;
    	let current_block_type_index;
    	let if_block1;
    	let if_block1_anchor;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (!/*edit*/ ctx[1] && !/*dispatched*/ ctx[2]) return create_if_block_2$f;
    		if (!/*dispatched*/ ctx[2]) return create_if_block_3$e;
    		if (/*edit*/ ctx[1]) return create_if_block_5$9;
    		return create_else_block_2$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	const if_block_creators = [create_if_block$p, create_else_block$o];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*dispatched*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			if_block0.c();
    			t = space();
    			if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-inline uk-width-1-1");
    			add_location(h4, file$q, 37, 0, 815);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			if_block0.m(h4, null);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h4, null);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if_block0.d();
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $screenWidthS;
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(4, $screenWidthS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BookingForm', slots, []);
    	let { booking = undefined } = $$props;
    	let { edit = false } = $$props;
    	let dispatched = false;
    	let formValid = false;
    	const dispatch = createEventDispatcher();

    	async function deleteMe() {
    		if (booking !== null && booking.id !== null && confirm("Are you sure to delete this booking?")) {
    			dispatch('message', { goto: 'delete' });
    		}
    	}

    	function submit() {
    		$$invalidate(2, dispatched = true);
    		dispatch('message', { goto: 'save' });
    	}

    	function cancel() {
    		dispatch('message', { goto: 'cancel' });
    	}

    	const writable_props = ['booking', 'edit'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BookingForm> was created with unknown prop '${key}'`);
    	});

    	function bookingformcomponent_booking_binding(value) {
    		booking = value;
    		$$invalidate(0, booking);
    	}

    	function bookingformcomponent_formValid_binding(value) {
    		formValid = value;
    		$$invalidate(3, formValid);
    	}

    	$$self.$$set = $$props => {
    		if ('booking' in $$props) $$invalidate(0, booking = $$props.booking);
    		if ('edit' in $$props) $$invalidate(1, edit = $$props.edit);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		screenWidthS,
    		BookingFormComponent,
    		booking,
    		edit,
    		dispatched,
    		formValid,
    		dispatch,
    		deleteMe,
    		submit,
    		cancel,
    		$screenWidthS
    	});

    	$$self.$inject_state = $$props => {
    		if ('booking' in $$props) $$invalidate(0, booking = $$props.booking);
    		if ('edit' in $$props) $$invalidate(1, edit = $$props.edit);
    		if ('dispatched' in $$props) $$invalidate(2, dispatched = $$props.dispatched);
    		if ('formValid' in $$props) $$invalidate(3, formValid = $$props.formValid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		booking,
    		edit,
    		dispatched,
    		formValid,
    		$screenWidthS,
    		deleteMe,
    		submit,
    		cancel,
    		bookingformcomponent_booking_binding,
    		bookingformcomponent_formValid_binding
    	];
    }

    class BookingForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$q, create_fragment$q, safe_not_equal, { booking: 0, edit: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BookingForm",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get booking() {
    		throw new Error("<BookingForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set booking(value) {
    		throw new Error("<BookingForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get edit() {
    		throw new Error("<BookingForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set edit(value) {
    		throw new Error("<BookingForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const accounts = writable([]);
    const allocatedNights = writable([]);
    const income = writable([]);
    const mattressNames = writable([]);

    async function getAccounts() {
        try {
            const result = await api.get('/mattress/account/');
            accounts.set(result.data);
        } catch (error) {}
    }

    async function getAllocatedNights() {
        try {
            const result = await api.get('/mattress/allocated/');
            allocatedNights.set(result.data);
        } catch (error) {}
    }

    async function getIncome() {
        try {
            const result = await api.get('/mattress/income/');
            income.set(result.data);
        } catch (error) {}
    }

    async function getTransactions(query) {
        try {
            const result = await api.post('/mattress/list/', query);
            return result.data
        } catch (error) {}
    }

    async function getTransactionsByBookingId(id) {
        try {
            const result = await api.get('/mattress/booking/'+id);
            return result.data[0]
        } catch (error) {}
    }

    async function getMattressNames() {
        try {
            const result = await api.get('/mattress/names/');
            mattressNames.set(result.data);
        } catch (error) {}
    }

    async function createTransaction(transaction) {
        try {
            const result = await api.post('/mattress/', transaction);
            return result.status === 200
        } catch (error) {}
    }

    async function updateTransaction(transaction) {
        try {
            const result = await api.put('/mattress/'+transaction.id, transaction);
            return result.status === 200
        } catch (error) {}
    }

    async function deleteTransaction(id) {
        try {
            const result = await api.delete('/mattress/'+id);
            return result.status === 200
        } catch (error) {}
    }

    /* src/components/Booking.svelte generated by Svelte v3.45.0 */

    const { Object: Object_1$3 } = globals;
    const file$p = "src/components/Booking.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[45] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[48] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[51] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[48] = list[i];
    	return child_ctx;
    }

    // (305:24) {#each $events as event}
    function create_each_block_3(ctx) {
    	let option;
    	let t_value = /*event*/ ctx[48].name + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = option_value_value = /*event*/ ctx[48].id;
    			option.value = option.__value;
    			add_location(option, file$p, 305, 28, 14030);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$events*/ 4096 && t_value !== (t_value = /*event*/ ctx[48].name + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$events*/ 4096 && option_value_value !== (option_value_value = /*event*/ ctx[48].id)) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(305:24) {#each $events as event}",
    		ctx
    	});

    	return block;
    }

    // (312:24) {#each groupNames as group}
    function create_each_block_2$1(ctx) {
    	let option;
    	let t_value = /*group*/ ctx[51] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = option_value_value = /*group*/ ctx[51];
    			option.value = option.__value;
    			add_location(option, file$p, 312, 28, 14476);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*groupNames*/ 8 && t_value !== (t_value = /*group*/ ctx[51] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*groupNames*/ 8 && option_value_value !== (option_value_value = /*group*/ ctx[51])) {
    				prop_dev(option, "__value", option_value_value);
    				option.value = option.__value;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(312:24) {#each groupNames as group}",
    		ctx
    	});

    	return block;
    }

    // (333:8) {:else }
    function create_else_block$n(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let span0;
    	let t6;
    	let a0;
    	let a0_uk_icon_value;
    	let t7;
    	let t8;
    	let th4;
    	let span1;
    	let t9_value = (/*$screenWidthS*/ ctx[9] ? 'Depart' : 'Departure') + "";
    	let t9;
    	let t10;
    	let a1;
    	let a1_uk_icon_value;
    	let t11;
    	let t12;
    	let th5;
    	let t14;
    	let th6;
    	let t15_value = (/*$screenWidthL*/ ctx[11] ? '' : 'PAF ') + "";
    	let t15;
    	let t16;
    	let t17;
    	let th7;
    	let t19;
    	let th8;
    	let t21;
    	let tbody;
    	let mounted;
    	let dispose;
    	let if_block0 = /*orderStates*/ ctx[5].arrival !== /*State*/ ctx[13].none && create_if_block_11$2(ctx);
    	let if_block1 = /*orderStates*/ ctx[5].departure !== /*State*/ ctx[13].none && create_if_block_10$4(ctx);
    	let each_value = /*data*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Name";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "People";
    			t5 = space();
    			th3 = element("th");
    			span0 = element("span");
    			t6 = text$1("Arrival\n                            ");
    			a0 = element("a");
    			t7 = space();
    			if (if_block0) if_block0.c();
    			t8 = space();
    			th4 = element("th");
    			span1 = element("span");
    			t9 = text$1(t9_value);
    			t10 = space();
    			a1 = element("a");
    			t11 = space();
    			if (if_block1) if_block1.c();
    			t12 = space();
    			th5 = element("th");
    			th5.textContent = "Notes";
    			t14 = space();
    			th6 = element("th");
    			t15 = text$1(t15_value);
    			t16 = text$1("Event");
    			t17 = space();
    			th7 = element("th");
    			th7.textContent = "Group";
    			t19 = space();
    			th8 = element("th");
    			th8.textContent = "Paid";
    			t21 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(th0, "class", "uk-table-shrink");
    			add_location(th0, file$p, 336, 20, 16041);
    			add_location(th1, file$p, 337, 20, 16125);
    			attr_dev(th2, "class", "uk-visible@s uk-table-shrink");
    			add_location(th2, file$p, 338, 20, 16159);

    			attr_dev(a0, "uk-icon", a0_uk_icon_value = /*orderStates*/ ctx[5].arrival === /*State*/ ctx[13].none
    			? "triangle-left"
    			: /*orderStates*/ ctx[5].arrival === /*State*/ ctx[13].asc
    				? "triangle-up"
    				: "triangle-down");

    			attr_dev(a0, "href", '#');
    			toggle_class(a0, "uk-text-secondary", /*orderStates*/ ctx[5].arrival !== /*State*/ ctx[13].none);
    			add_location(a0, file$p, 341, 28, 16368);
    			add_location(span0, file$p, 340, 24, 16284);
    			attr_dev(th3, "class", "uk-text-nowrap");
    			add_location(th3, file$p, 339, 20, 16232);

    			attr_dev(a1, "uk-icon", a1_uk_icon_value = /*orderStates*/ ctx[5].departure === /*State*/ ctx[13].none
    			? "triangle-left"
    			: /*orderStates*/ ctx[5].departure === /*State*/ ctx[13].asc
    				? "triangle-up"
    				: "triangle-down");

    			attr_dev(a1, "href", '#');
    			toggle_class(a1, "uk-text-secondary", /*orderStates*/ ctx[5].departure !== /*State*/ ctx[13].none);
    			add_location(a1, file$p, 349, 28, 17043);
    			add_location(span1, file$p, 348, 24, 16924);
    			attr_dev(th4, "class", "uk-text-nowrap");
    			add_location(th4, file$p, 347, 20, 16872);
    			attr_dev(th5, "class", "uk-visible@m uk-table-shrink");
    			add_location(th5, file$p, 355, 20, 17555);
    			attr_dev(th6, "class", "uk-visible@m");
    			add_location(th6, file$p, 356, 20, 17627);
    			attr_dev(th7, "class", "uk-visible@l");
    			add_location(th7, file$p, 357, 20, 17712);
    			attr_dev(th8, "class", "uk-visible@s uk-table-shrink");
    			add_location(th8, file$p, 358, 20, 17768);
    			add_location(tr, file$p, 335, 16, 16016);
    			add_location(thead, file$p, 334, 16, 15992);
    			add_location(tbody, file$p, 361, 16, 17882);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$p, 333, 12, 15890);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, span0);
    			append_dev(span0, t6);
    			append_dev(span0, a0);
    			append_dev(th3, t7);
    			if (if_block0) if_block0.m(th3, null);
    			append_dev(tr, t8);
    			append_dev(tr, th4);
    			append_dev(th4, span1);
    			append_dev(span1, t9);
    			append_dev(span1, t10);
    			append_dev(span1, a1);
    			append_dev(th4, t11);
    			if (if_block1) if_block1.m(th4, null);
    			append_dev(tr, t12);
    			append_dev(tr, th5);
    			append_dev(tr, t14);
    			append_dev(tr, th6);
    			append_dev(th6, t15);
    			append_dev(th6, t16);
    			append_dev(tr, t17);
    			append_dev(tr, th7);
    			append_dev(tr, t19);
    			append_dev(tr, th8);
    			append_dev(table, t21);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			if (!mounted) {
    				dispose = [
    					listen_dev(span0, "click", /*click_handler*/ ctx[28], false, false, false),
    					listen_dev(span1, "click", /*click_handler_2*/ ctx[30], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*orderStates*/ 32 && a0_uk_icon_value !== (a0_uk_icon_value = /*orderStates*/ ctx[5].arrival === /*State*/ ctx[13].none
    			? "triangle-left"
    			: /*orderStates*/ ctx[5].arrival === /*State*/ ctx[13].asc
    				? "triangle-up"
    				: "triangle-down")) {
    				attr_dev(a0, "uk-icon", a0_uk_icon_value);
    			}

    			if (dirty[0] & /*orderStates, State*/ 8224) {
    				toggle_class(a0, "uk-text-secondary", /*orderStates*/ ctx[5].arrival !== /*State*/ ctx[13].none);
    			}

    			if (/*orderStates*/ ctx[5].arrival !== /*State*/ ctx[13].none) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_11$2(ctx);
    					if_block0.c();
    					if_block0.m(th3, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*$screenWidthS*/ 512 && t9_value !== (t9_value = (/*$screenWidthS*/ ctx[9] ? 'Depart' : 'Departure') + "")) set_data_dev(t9, t9_value);

    			if (dirty[0] & /*orderStates*/ 32 && a1_uk_icon_value !== (a1_uk_icon_value = /*orderStates*/ ctx[5].departure === /*State*/ ctx[13].none
    			? "triangle-left"
    			: /*orderStates*/ ctx[5].departure === /*State*/ ctx[13].asc
    				? "triangle-up"
    				: "triangle-down")) {
    				attr_dev(a1, "uk-icon", a1_uk_icon_value);
    			}

    			if (dirty[0] & /*orderStates, State*/ 8224) {
    				toggle_class(a1, "uk-text-secondary", /*orderStates*/ ctx[5].departure !== /*State*/ ctx[13].none);
    			}

    			if (/*orderStates*/ ctx[5].departure !== /*State*/ ctx[13].none) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_10$4(ctx);
    					if_block1.c();
    					if_block1.m(th4, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*$screenWidthL*/ 2048 && t15_value !== (t15_value = (/*$screenWidthL*/ ctx[11] ? '' : 'PAF ') + "")) set_data_dev(t15, t15_value);

    			if (dirty[0] & /*data, openForm*/ 65537) {
    				each_value = /*data*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$n.name,
    		type: "else",
    		source: "(333:8) {:else }",
    		ctx
    	});

    	return block;
    }

    // (331:36) 
    function create_if_block_1$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading bookings...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(331:36) ",
    		ctx
    	});

    	return block;
    }

    // (329:8) {#if data.length === 0 && (bookingQuery.filter || bookingQuery.name)}
    function create_if_block$o(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("No filter results...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(329:8) {#if data.length === 0 && (bookingQuery.filter || bookingQuery.name)}",
    		ctx
    	});

    	return block;
    }

    // (344:24) {#if orderStates.arrival !== State.none}
    function create_if_block_11$2(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "";
    			attr_dev(a, "class", "uk-link-reset");
    			attr_dev(a, "href", '#');
    			add_location(a, file$p, 344, 28, 16715);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_1*/ ctx[29], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$2.name,
    		type: "if",
    		source: "(344:24) {#if orderStates.arrival !== State.none}",
    		ctx
    	});

    	return block;
    }

    // (352:24) {#if orderStates.departure !== State.none}
    function create_if_block_10$4(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			a.textContent = "";
    			attr_dev(a, "class", "uk-link-reset");
    			attr_dev(a, "href", '#');
    			add_location(a, file$p, 352, 28, 17398);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_3*/ ctx[31], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$4.name,
    		type: "if",
    		source: "(352:24) {#if orderStates.departure !== State.none}",
    		ctx
    	});

    	return block;
    }

    // (365:28) {#if booking.cancelled}
    function create_if_block_9$4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "close");
    			add_location(span, file$p, 364, 51, 18068);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$4.name,
    		type: "if",
    		source: "(365:28) {#if booking.cancelled}",
    		ctx
    	});

    	return block;
    }

    // (370:49) {#if booking.info}
    function create_if_block_8$4(ctx) {
    	let span;
    	let span_uk_tooltip_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "icon: info");
    			attr_dev(span, "uk-tooltip", span_uk_tooltip_value = "title: " + /*booking*/ ctx[45].info);
    			add_location(span, file$p, 369, 67, 18628);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && span_uk_tooltip_value !== (span_uk_tooltip_value = "title: " + /*booking*/ ctx[45].info)) {
    				attr_dev(span, "uk-tooltip", span_uk_tooltip_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$4.name,
    		type: "if",
    		source: "(370:49) {#if booking.info}",
    		ctx
    	});

    	return block;
    }

    // (372:28) {#if booking.paf_events !== null}
    function create_if_block_7$6(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*booking*/ ctx[45].paf_events;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1) {
    				each_value_1 = /*booking*/ ctx[45].paf_events;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$6.name,
    		type: "if",
    		source: "(372:28) {#if booking.paf_events !== null}",
    		ctx
    	});

    	return block;
    }

    // (373:32) {#each booking.paf_events as event}
    function create_each_block_1$5(ctx) {
    	let span;
    	let t0_value = /*event*/ ctx[48].abbreviation + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text$1(t0_value);
    			t1 = text$1("");
    			attr_dev(span, "class", "uk-label");
    			toggle_class(span, "uk-label-success", /*event*/ ctx[48].confirmed);
    			toggle_class(span, "uk-label-warning", !/*event*/ ctx[48].confirmed);
    			add_location(span, file$p, 373, 36, 18960);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && t0_value !== (t0_value = /*event*/ ctx[48].abbreviation + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*data*/ 1) {
    				toggle_class(span, "uk-label-success", /*event*/ ctx[48].confirmed);
    			}

    			if (dirty[0] & /*data*/ 1) {
    				toggle_class(span, "uk-label-warning", !/*event*/ ctx[48].confirmed);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(373:32) {#each booking.paf_events as event}",
    		ctx
    	});

    	return block;
    }

    // (388:56) 
    function create_if_block_6$7(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-muted");
    			attr_dev(span, "uk-icon", "minus");
    			add_location(span, file$p, 388, 32, 20325);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$7.name,
    		type: "if",
    		source: "(388:56) ",
    		ctx
    	});

    	return block;
    }

    // (386:58) 
    function create_if_block_5$8(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "class", "uk-text-danger");
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "close");
    			add_location(a, file$p, 386, 32, 20153);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler_12, false, false, false);
    				mounted = true;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$8.name,
    		type: "if",
    		source: "(386:58) ",
    		ctx
    	});

    	return block;
    }

    // (384:112) 
    function create_if_block_4$9(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "class", "uk-text-muted");
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "close");
    			add_location(a, file$p, 384, 32, 19980);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler_11, false, false, false);
    				mounted = true;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$9.name,
    		type: "if",
    		source: "(384:112) ",
    		ctx
    	});

    	return block;
    }

    // (382:167) 
    function create_if_block_3$d(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "class", "uk-text-warning");
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "close");
    			add_location(a, file$p, 382, 32, 19751);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler_10, false, false, false);
    				mounted = true;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$d.name,
    		type: "if",
    		source: "(382:167) ",
    		ctx
    	});

    	return block;
    }

    // (380:28) {#if booking.paid}
    function create_if_block_2$e(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "uk-text-success");
    			attr_dev(span, "uk-icon", "check");
    			add_location(span, file$p, 380, 32, 19497);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$e.name,
    		type: "if",
    		source: "(380:28) {#if booking.paid}",
    		ctx
    	});

    	return block;
    }

    // (363:16) {#each data as booking}
    function create_each_block$h(ctx) {
    	let tr;
    	let td0;
    	let t0;
    	let td1;
    	let t1_value = /*booking*/ ctx[45].name + "";
    	let t1;
    	let t2;
    	let td2;
    	let t3_value = /*booking*/ ctx[45].people_count + "";
    	let t3;
    	let t4;
    	let td3;
    	let t5_value = DateTime_1.fromSQL(/*booking*/ ctx[45].arrival).toFormat('dd LLL yyyy') + "";
    	let t5;
    	let t6;
    	let td4;
    	let t7_value = DateTime_1.fromSQL(/*booking*/ ctx[45].departure).toFormat('dd LLL yyyy') + "";
    	let t7;
    	let t8;
    	let td5;
    	let t9;
    	let td6;
    	let t10;
    	let td7;
    	let span;
    	let t11_value = /*booking*/ ctx[45].group_name + "";
    	let t11;
    	let t12;
    	let td8;
    	let show_if;
    	let show_if_1;
    	let t13;
    	let mounted;
    	let dispose;
    	let if_block0 = /*booking*/ ctx[45].cancelled && create_if_block_9$4(ctx);

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[32](/*booking*/ ctx[45]);
    	}

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[33](/*booking*/ ctx[45]);
    	}

    	function click_handler_6() {
    		return /*click_handler_6*/ ctx[34](/*booking*/ ctx[45]);
    	}

    	function click_handler_7() {
    		return /*click_handler_7*/ ctx[35](/*booking*/ ctx[45]);
    	}

    	let if_block1 = /*booking*/ ctx[45].info && create_if_block_8$4(ctx);
    	let if_block2 = /*booking*/ ctx[45].paf_events !== null && create_if_block_7$6(ctx);

    	function click_handler_8() {
    		return /*click_handler_8*/ ctx[36](/*booking*/ ctx[45]);
    	}

    	function click_handler_9() {
    		return /*click_handler_9*/ ctx[37](/*booking*/ ctx[45]);
    	}

    	function select_block_type_1(ctx, dirty) {
    		if (dirty[0] & /*data*/ 1) show_if = null;
    		if (dirty[0] & /*data*/ 1) show_if_1 = null;
    		if (/*booking*/ ctx[45].paid) return create_if_block_2$e;
    		if (show_if == null) show_if = !!(!/*booking*/ ctx[45].cancelled && DateTime_1.fromSQL(/*booking*/ ctx[45].arrival) < DateTime_1.now() && DateTime_1.fromSQL(/*booking*/ ctx[45].departure) > DateTime_1.now());
    		if (show_if) return create_if_block_3$d;
    		if (show_if_1 == null) show_if_1 = !!(!/*booking*/ ctx[45].cancelled && DateTime_1.fromSQL(/*booking*/ ctx[45].arrival) > DateTime_1.now());
    		if (show_if_1) return create_if_block_4$9;
    		if (!/*booking*/ ctx[45].cancelled) return create_if_block_5$8;
    		if (/*booking*/ ctx[45].cancelled) return create_if_block_6$7;
    	}

    	let current_block_type = select_block_type_1(ctx, [-1, -1]);
    	let if_block3 = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			td1 = element("td");
    			t1 = text$1(t1_value);
    			t2 = space();
    			td2 = element("td");
    			t3 = text$1(t3_value);
    			t4 = space();
    			td3 = element("td");
    			t5 = text$1(t5_value);
    			t6 = space();
    			td4 = element("td");
    			t7 = text$1(t7_value);
    			t8 = space();
    			td5 = element("td");
    			if (if_block1) if_block1.c();
    			t9 = space();
    			td6 = element("td");
    			if (if_block2) if_block2.c();
    			t10 = space();
    			td7 = element("td");
    			span = element("span");
    			t11 = text$1(t11_value);
    			t12 = space();
    			td8 = element("td");
    			if (if_block3) if_block3.c();
    			t13 = space();
    			add_location(td0, file$p, 364, 24, 18041);
    			add_location(td1, file$p, 365, 24, 18132);
    			attr_dev(td2, "class", "uk-visible@s");
    			add_location(td2, file$p, 366, 24, 18215);
    			add_location(td3, file$p, 367, 24, 18327);
    			add_location(td4, file$p, 368, 24, 18455);
    			attr_dev(td5, "class", "uk-visible@m");
    			add_location(td5, file$p, 369, 24, 18585);
    			attr_dev(td6, "class", "uk-visible@m");
    			add_location(td6, file$p, 370, 24, 18733);
    			attr_dev(span, "class", "uk-label uk-background-secondary");
    			add_location(span, file$p, 377, 84, 19288);
    			attr_dev(td7, "class", "uk-visible@l");
    			add_location(td7, file$p, 377, 24, 19228);
    			attr_dev(td8, "class", "uk-visible@s");
    			add_location(td8, file$p, 378, 24, 19392);
    			attr_dev(tr, "class", "uk-table-link");
    			toggle_class(tr, "uk-text-muted", /*booking*/ ctx[45].cancelled);
    			add_location(tr, file$p, 363, 20, 17950);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			if (if_block0) if_block0.m(td0, null);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			append_dev(td3, t5);
    			append_dev(tr, t6);
    			append_dev(tr, td4);
    			append_dev(td4, t7);
    			append_dev(tr, t8);
    			append_dev(tr, td5);
    			if (if_block1) if_block1.m(td5, null);
    			append_dev(tr, t9);
    			append_dev(tr, td6);
    			if (if_block2) if_block2.m(td6, null);
    			append_dev(tr, t10);
    			append_dev(tr, td7);
    			append_dev(td7, span);
    			append_dev(span, t11);
    			append_dev(tr, t12);
    			append_dev(tr, td8);
    			if (if_block3) if_block3.m(td8, null);
    			append_dev(tr, t13);

    			if (!mounted) {
    				dispose = [
    					listen_dev(td1, "click", click_handler_4, false, false, false),
    					listen_dev(td2, "click", click_handler_5, false, false, false),
    					listen_dev(td3, "click", click_handler_6, false, false, false),
    					listen_dev(td4, "click", click_handler_7, false, false, false),
    					listen_dev(td6, "click", click_handler_8, false, false, false),
    					listen_dev(td7, "click", click_handler_9, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (/*booking*/ ctx[45].cancelled) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_9$4(ctx);
    					if_block0.c();
    					if_block0.m(td0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*data*/ 1 && t1_value !== (t1_value = /*booking*/ ctx[45].name + "")) set_data_dev(t1, t1_value);
    			if (dirty[0] & /*data*/ 1 && t3_value !== (t3_value = /*booking*/ ctx[45].people_count + "")) set_data_dev(t3, t3_value);
    			if (dirty[0] & /*data*/ 1 && t5_value !== (t5_value = DateTime_1.fromSQL(/*booking*/ ctx[45].arrival).toFormat('dd LLL yyyy') + "")) set_data_dev(t5, t5_value);
    			if (dirty[0] & /*data*/ 1 && t7_value !== (t7_value = DateTime_1.fromSQL(/*booking*/ ctx[45].departure).toFormat('dd LLL yyyy') + "")) set_data_dev(t7, t7_value);

    			if (/*booking*/ ctx[45].info) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_8$4(ctx);
    					if_block1.c();
    					if_block1.m(td5, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*booking*/ ctx[45].paf_events !== null) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_7$6(ctx);
    					if_block2.c();
    					if_block2.m(td6, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*data*/ 1 && t11_value !== (t11_value = /*booking*/ ctx[45].group_name + "")) set_data_dev(t11, t11_value);

    			if (current_block_type !== (current_block_type = select_block_type_1(ctx, dirty))) {
    				if (if_block3) if_block3.d(1);
    				if_block3 = current_block_type && current_block_type(ctx);

    				if (if_block3) {
    					if_block3.c();
    					if_block3.m(td8, null);
    				}
    			}

    			if (dirty[0] & /*data*/ 1) {
    				toggle_class(tr, "uk-text-muted", /*booking*/ ctx[45].cancelled);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();

    			if (if_block3) {
    				if_block3.d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(363:16) {#each data as booking}",
    		ctx
    	});

    	return block;
    }

    // (416:16) {#key recreateForm}
    function create_key_block$9(ctx) {
    	let bookingform;
    	let updating_booking;
    	let updating_edit;
    	let current;

    	function bookingform_booking_binding(value) {
    		/*bookingform_booking_binding*/ ctx[39](value);
    	}

    	function bookingform_edit_binding(value) {
    		/*bookingform_edit_binding*/ ctx[40](value);
    	}

    	let bookingform_props = {};

    	if (/*selectedBooking*/ ctx[6] !== void 0) {
    		bookingform_props.booking = /*selectedBooking*/ ctx[6];
    	}

    	if (/*editBooking*/ ctx[7] !== void 0) {
    		bookingform_props.edit = /*editBooking*/ ctx[7];
    	}

    	bookingform = new BookingForm({ props: bookingform_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(bookingform, 'booking', bookingform_booking_binding));
    	binding_callbacks.push(() => bind$1(bookingform, 'edit', bookingform_edit_binding));
    	bookingform.$on("message", /*processBooking*/ ctx[17]);

    	const block = {
    		c: function create() {
    			create_component(bookingform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(bookingform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const bookingform_changes = {};

    			if (!updating_booking && dirty[0] & /*selectedBooking*/ 64) {
    				updating_booking = true;
    				bookingform_changes.booking = /*selectedBooking*/ ctx[6];
    				add_flush_callback(() => updating_booking = false);
    			}

    			if (!updating_edit && dirty[0] & /*editBooking*/ 128) {
    				updating_edit = true;
    				bookingform_changes.edit = /*editBooking*/ ctx[7];
    				add_flush_callback(() => updating_edit = false);
    			}

    			bookingform.$set(bookingform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bookingform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bookingform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(bookingform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$9.name,
    		type: "key",
    		source: "(416:16) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div5;
    	let div4;
    	let div3;
    	let input0;
    	let input0_class_value;
    	let t0;
    	let button0;
    	let span0;
    	let t1;
    	let div2;
    	let ul;
    	let li0;
    	let div1;
    	let div0;
    	let span1;
    	let t3;
    	let span3;
    	let a;
    	let span2;
    	let t4;
    	let t5;
    	let li1;
    	let select0;
    	let option0;
    	let option1;
    	let option2;
    	let t8;
    	let option3;
    	let t9;
    	let option4;
    	let t10;
    	let option5;
    	let t11;
    	let option6;
    	let t12;
    	let option7;
    	let t13;
    	let t14;
    	let li2;
    	let select1;
    	let option8;
    	let option9;
    	let option10;
    	let t17;
    	let option11;
    	let t18;
    	let option12;
    	let t19;
    	let option13;
    	let t20;
    	let option14;
    	let t21;
    	let option15;
    	let t22;
    	let t23;
    	let li3;
    	let select2;
    	let option16;
    	let option17;
    	let t26;
    	let li4;
    	let select3;
    	let option18;
    	let option19;
    	let t29;
    	let li5;
    	let input1;
    	let t30;
    	let t31;
    	let li6;
    	let input2;
    	let t32;
    	let t33;
    	let li7;
    	let input3;
    	let t34;
    	let t35;
    	let li8;
    	let input4;
    	let t36;
    	let t37;
    	let button1;
    	let span4;

    	let t38_value = (/*$screenWidthS*/ ctx[9]
    	? ''
    	: /*$screenWidthM*/ ctx[10]
    		? '\xa0booking'
    		: '\xa0New booking') + "";

    	let t38;
    	let t39;
    	let div7;
    	let div6;
    	let t40;
    	let infinitescroll;
    	let t41;
    	let div11;
    	let div10;
    	let button2;
    	let t42;
    	let div9;
    	let div8;
    	let previous_key = /*recreateForm*/ ctx[8];
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_3 = /*$events*/ ctx[12];
    	validate_each_argument(each_value_3);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*groupNames*/ ctx[3];
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0 && (/*bookingQuery*/ ctx[4].filter || /*bookingQuery*/ ctx[4].name)) return create_if_block$o;
    		if (/*data*/ ctx[0].length === 0) return create_if_block_1$f;
    		return create_else_block$n;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	infinitescroll = new InfiniteScroll({
    			props: {
    				hasMore: /*newBatch*/ ctx[1].length,
    				threshold: 80
    			},
    			$$inline: true
    		});

    	infinitescroll.$on("loadMore", /*loadMore_handler*/ ctx[38]);
    	let key_block = create_key_block$9(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			input0 = element("input");
    			t0 = space();
    			button0 = element("button");
    			span0 = element("span");
    			t1 = space();
    			div2 = element("div");
    			ul = element("ul");
    			li0 = element("li");
    			div1 = element("div");
    			div0 = element("div");
    			span1 = element("span");
    			span1.textContent = "Filters";
    			t3 = space();
    			span3 = element("span");
    			a = element("a");
    			span2 = element("span");
    			t4 = text$1(" Clear");
    			t5 = space();
    			li1 = element("li");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "Arrival";
    			option1 = element("option");
    			option1.textContent = "-";
    			option2 = element("option");
    			t8 = text$1("Today");
    			option3 = element("option");
    			t9 = text$1("Next week");
    			option4 = element("option");
    			t10 = text$1("Next month");
    			option5 = element("option");
    			t11 = text$1("Yesterday");
    			option6 = element("option");
    			t12 = text$1("Last week");
    			option7 = element("option");
    			t13 = text$1("Last month");
    			t14 = space();
    			li2 = element("li");
    			select1 = element("select");
    			option8 = element("option");
    			option8.textContent = "Stay Period";
    			option9 = element("option");
    			option9.textContent = "-";
    			option10 = element("option");
    			t17 = text$1("Today");
    			option11 = element("option");
    			t18 = text$1("Next week");
    			option12 = element("option");
    			t19 = text$1("Next month");
    			option13 = element("option");
    			t20 = text$1("Yesterday");
    			option14 = element("option");
    			t21 = text$1("Last week");
    			option15 = element("option");
    			t22 = text$1("Last month");
    			t23 = space();
    			li3 = element("li");
    			select2 = element("select");
    			option16 = element("option");
    			option16.textContent = "Event";
    			option17 = element("option");
    			option17.textContent = "-";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t26 = space();
    			li4 = element("li");
    			select3 = element("select");
    			option18 = element("option");
    			option18.textContent = "Group";
    			option19 = element("option");
    			option19.textContent = "-";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t29 = space();
    			li5 = element("li");
    			input1 = element("input");
    			t30 = text$1(" Cancelled");
    			t31 = space();
    			li6 = element("li");
    			input2 = element("input");
    			t32 = text$1(" Paid");
    			t33 = space();
    			li7 = element("li");
    			input3 = element("input");
    			t34 = text$1(" Not paid");
    			t35 = space();
    			li8 = element("li");
    			input4 = element("input");
    			t36 = text$1(" Longstayer");
    			t37 = space();
    			button1 = element("button");
    			span4 = element("span");
    			t38 = text$1(t38_value);
    			t39 = space();
    			div7 = element("div");
    			div6 = element("div");
    			if_block.c();
    			t40 = space();
    			create_component(infinitescroll.$$.fragment);
    			t41 = space();
    			div11 = element("div");
    			div10 = element("div");
    			button2 = element("button");
    			t42 = space();
    			div9 = element("div");
    			div8 = element("div");
    			key_block.c();

    			attr_dev(input0, "class", input0_class_value = "uk-input " + (/*$screenWidthS*/ ctx[9]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[10] || /*$screenWidthL*/ ctx[11]
    				? 'uk-width-medium'
    				: 'uk-width-large'));

    			attr_dev(input0, "id", "autocomplete");
    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "spellcheck", "false");
    			attr_dev(input0, "autocorrect", "off");
    			attr_dev(input0, "autocomplete", "off");
    			attr_dev(input0, "autocapitalize", "off");
    			attr_dev(input0, "maxlength", "256");
    			add_location(input0, file$p, 266, 12, 10166);
    			attr_dev(span0, "class", "uk-text-muted");
    			attr_dev(span0, "uk-icon", "settings");
    			add_location(span0, file$p, 270, 16, 10759);
    			attr_dev(button0, "class", "uk-button uk-button-small uk-button-default uk-margin-left");
    			attr_dev(button0, "type", "button");
    			toggle_class(button0, "uk-button-danger", /*bookingQuery*/ ctx[4].filter && Object.keys(/*bookingQuery*/ ctx[4].filter).length > 0);
    			toggle_class(button0, "uk-light", /*bookingQuery*/ ctx[4].filter && Object.keys(/*bookingQuery*/ ctx[4].filter).length > 0);
    			add_location(button0, file$p, 267, 12, 10435);
    			attr_dev(span1, "class", "uk-nav-header");
    			add_location(span1, file$p, 277, 32, 11139);
    			attr_dev(span2, "uk-icon", "icon: close; ratio: 0.9");
    			add_location(span2, file$p, 277, 189, 11296);
    			attr_dev(a, "href", '#');
    			attr_dev(a, "class", "uk-link-reset");
    			add_location(a, file$p, 277, 127, 11234);
    			attr_dev(span3, "class", "uk-position-center-right uk-text-meta");
    			add_location(span3, file$p, 277, 75, 11182);
    			attr_dev(div0, "class", "uk-width-1-1 uk-inline");
    			add_location(div0, file$p, 276, 28, 11070);
    			attr_dev(div1, "class", "uk-grid-small");
    			attr_dev(div1, "uk-grid", "");
    			add_location(div1, file$p, 275, 24, 11006);
    			attr_dev(li0, "class", "uk-margin-bottom");
    			add_location(li0, file$p, 274, 20, 10952);
    			option0.__value = "[]";
    			option0.value = option0.__value;
    			option0.selected = true;
    			add_location(option0, file$p, 282, 24, 11626);
    			option1.__value = "[]";
    			option1.value = option1.__value;
    			add_location(option1, file$p, 283, 24, 11695);
    			option2.__value = "[\"" + DateTime_1.now().toSQLDate() + "\"]";
    			option2.value = option2.__value;
    			add_location(option2, file$p, 284, 24, 11749);
    			option3.__value = "[\"" + DateTime_1.now().toSQLDate() + "\", \"" + DateTime_1.now().plus({ weeks: 1 }).toSQLDate() + "\"]";
    			option3.value = option3.__value;
    			add_location(option3, file$p, 285, 24, 11843);
    			option4.__value = "[\"" + DateTime_1.now().toSQLDate() + "\", \"" + DateTime_1.now().plus({ months: 1 }).toSQLDate() + "\"]";
    			option4.value = option4.__value;
    			add_location(option4, file$p, 286, 24, 11993);
    			option5.__value = "[\"" + DateTime_1.now().minus({ days: 1 }).toSQLDate() + "\"]";
    			option5.value = option5.__value;
    			add_location(option5, file$p, 287, 24, 12145);
    			option6.__value = "[\"" + DateTime_1.now().minus({ weeks: 1 }).toSQLDate() + "\", \"" + DateTime_1.now().toSQLDate() + "\"]";
    			option6.value = option6.__value;
    			add_location(option6, file$p, 288, 24, 12259);
    			option7.__value = "[\"" + DateTime_1.now().minus({ months: 1 }).toSQLDate() + "\", \"" + DateTime_1.now().toSQLDate() + "\"]";
    			option7.value = option7.__value;
    			add_location(option7, file$p, 289, 24, 12410);
    			attr_dev(select0, "class", "uk-select uk-margin-small-bottom");
    			attr_dev(select0, "id", "date_arrival");
    			attr_dev(select0, "type", "text");
    			add_location(select0, file$p, 281, 24, 11477);
    			add_location(li1, file$p, 281, 20, 11473);
    			option8.__value = "[]";
    			option8.value = option8.__value;
    			option8.selected = true;
    			add_location(option8, file$p, 292, 24, 12747);
    			option9.__value = "[]";
    			option9.value = option9.__value;
    			add_location(option9, file$p, 293, 24, 12820);
    			option10.__value = "[\"" + DateTime_1.now().toSQLDate() + "\"]";
    			option10.value = option10.__value;
    			add_location(option10, file$p, 294, 24, 12874);
    			option11.__value = "[\"" + DateTime_1.now().toSQLDate() + "\", \"" + DateTime_1.now().plus({ weeks: 1 }).toSQLDate() + "\"]";
    			option11.value = option11.__value;
    			add_location(option11, file$p, 295, 24, 12968);
    			option12.__value = "[\"" + DateTime_1.now().toSQLDate() + "\", \"" + DateTime_1.now().plus({ months: 1 }).toSQLDate() + "\"]";
    			option12.value = option12.__value;
    			add_location(option12, file$p, 296, 24, 13118);
    			option13.__value = "[\"" + DateTime_1.now().minus({ days: 1 }).toSQLDate() + "\"]";
    			option13.value = option13.__value;
    			add_location(option13, file$p, 297, 24, 13270);
    			option14.__value = "[\"" + DateTime_1.now().minus({ weeks: 1 }).toSQLDate() + "\", \"" + DateTime_1.now().toSQLDate() + "\"]";
    			option14.value = option14.__value;
    			add_location(option14, file$p, 298, 24, 13384);
    			option15.__value = "[\"" + DateTime_1.now().minus({ months: 1 }).toSQLDate() + "\", \"" + DateTime_1.now().toSQLDate() + "\"]";
    			option15.value = option15.__value;
    			add_location(option15, file$p, 299, 24, 13535);
    			attr_dev(select1, "class", "uk-select uk-margin-small-bottom");
    			attr_dev(select1, "id", "date_present");
    			attr_dev(select1, "type", "text");
    			add_location(select1, file$p, 291, 24, 12598);
    			add_location(li2, file$p, 291, 20, 12594);
    			option16.__value = "0";
    			option16.value = option16.__value;
    			option16.selected = true;
    			add_location(option16, file$p, 302, 24, 13858);
    			option17.__value = "0";
    			option17.value = option17.__value;
    			add_location(option17, file$p, 303, 24, 13924);
    			attr_dev(select2, "class", "uk-select uk-margin-small-bottom");
    			attr_dev(select2, "id", "event");
    			attr_dev(select2, "type", "text");
    			add_location(select2, file$p, 301, 24, 13723);
    			add_location(li3, file$p, 301, 20, 13719);
    			option18.__value = "";
    			option18.value = option18.__value;
    			option18.selected = true;
    			add_location(option18, file$p, 309, 24, 14303);
    			option19.__value = "";
    			option19.value = option19.__value;
    			add_location(option19, file$p, 310, 24, 14368);
    			attr_dev(select3, "class", "uk-select uk-margin-small-bottom");
    			attr_dev(select3, "id", "group");
    			attr_dev(select3, "type", "text");
    			add_location(select3, file$p, 308, 24, 14168);
    			add_location(li4, file$p, 308, 20, 14164);
    			attr_dev(input1, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input1, "id", "cancelled");
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$p, 315, 24, 14606);
    			add_location(li5, file$p, 315, 20, 14602);
    			attr_dev(input2, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input2, "id", "paid");
    			attr_dev(input2, "type", "checkbox");
    			add_location(input2, file$p, 316, 24, 14768);
    			add_location(li6, file$p, 316, 20, 14764);
    			attr_dev(input3, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input3, "id", "not_paid");
    			attr_dev(input3, "type", "checkbox");
    			add_location(input3, file$p, 317, 24, 14915);
    			add_location(li7, file$p, 317, 20, 14911);
    			attr_dev(input4, "class", "uk-checkbox uk-margin-small-right");
    			attr_dev(input4, "id", "longstayer");
    			attr_dev(input4, "type", "checkbox");
    			add_location(input4, file$p, 318, 24, 15074);
    			add_location(li8, file$p, 318, 20, 15070);
    			attr_dev(ul, "class", "uk-nav uk-dropdown-nav");
    			add_location(ul, file$p, 273, 16, 10896);
    			attr_dev(div2, "uk-dropdown", "mode: click");
    			add_location(div2, file$p, 272, 12, 10848);
    			attr_dev(span4, "uk-icon", "icon: plus; ratio: 0.6");
    			add_location(span4, file$p, 321, 107, 15363);
    			attr_dev(button1, "class", "uk-button uk-button-small uk-button-primary uk-margin-left");
    			add_location(button1, file$p, 321, 12, 15268);
    			attr_dev(div3, "class", "uk-flex uk-flex-center");
    			add_location(div3, file$p, 265, 8, 10117);
    			attr_dev(div4, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6 paf-top-section-bg");
    			add_location(div4, file$p, 264, 4, 10019);
    			attr_dev(div5, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div5, file$p, 263, 0, 9941);
    			attr_dev(div6, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6");
    			add_location(div6, file$p, 327, 4, 15610);
    			attr_dev(div7, "class", "uk-flex uk-flex-center");
    			set_style(div7, "max-height", "75%");
    			set_style(div7, "overflow-x", "scroll");
    			add_location(div7, file$p, 326, 0, 15524);
    			attr_dev(button2, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "uk-close", "");
    			add_location(button2, file$p, 412, 8, 21024);
    			attr_dev(div8, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div8, "uk-height-viewport", "");
    			add_location(div8, file$p, 414, 12, 21165);
    			attr_dev(div9, "class", "uk-flex uk-flex-center");
    			add_location(div9, file$p, 413, 8, 21116);
    			attr_dev(div10, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div10, file$p, 411, 4, 20954);
    			attr_dev(div11, "id", "modal-booking");
    			attr_dev(div11, "class", "uk-modal-full");
    			attr_dev(div11, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div11, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[10]);
    			add_location(div11, file$p, 407, 0, 20800);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, input0);
    			append_dev(div3, t0);
    			append_dev(div3, button0);
    			append_dev(button0, span0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, ul);
    			append_dev(ul, li0);
    			append_dev(li0, div1);
    			append_dev(div1, div0);
    			append_dev(div0, span1);
    			append_dev(div0, t3);
    			append_dev(div0, span3);
    			append_dev(span3, a);
    			append_dev(a, span2);
    			append_dev(a, t4);
    			append_dev(ul, t5);
    			append_dev(ul, li1);
    			append_dev(li1, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);
    			append_dev(select0, option2);
    			append_dev(option2, t8);
    			append_dev(select0, option3);
    			append_dev(option3, t9);
    			append_dev(select0, option4);
    			append_dev(option4, t10);
    			append_dev(select0, option5);
    			append_dev(option5, t11);
    			append_dev(select0, option6);
    			append_dev(option6, t12);
    			append_dev(select0, option7);
    			append_dev(option7, t13);
    			append_dev(ul, t14);
    			append_dev(ul, li2);
    			append_dev(li2, select1);
    			append_dev(select1, option8);
    			append_dev(select1, option9);
    			append_dev(select1, option10);
    			append_dev(option10, t17);
    			append_dev(select1, option11);
    			append_dev(option11, t18);
    			append_dev(select1, option12);
    			append_dev(option12, t19);
    			append_dev(select1, option13);
    			append_dev(option13, t20);
    			append_dev(select1, option14);
    			append_dev(option14, t21);
    			append_dev(select1, option15);
    			append_dev(option15, t22);
    			append_dev(ul, t23);
    			append_dev(ul, li3);
    			append_dev(li3, select2);
    			append_dev(select2, option16);
    			append_dev(select2, option17);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select2, null);
    			}

    			append_dev(ul, t26);
    			append_dev(ul, li4);
    			append_dev(li4, select3);
    			append_dev(select3, option18);
    			append_dev(select3, option19);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select3, null);
    			}

    			append_dev(ul, t29);
    			append_dev(ul, li5);
    			append_dev(li5, input1);
    			append_dev(li5, t30);
    			append_dev(ul, t31);
    			append_dev(ul, li6);
    			append_dev(li6, input2);
    			append_dev(li6, t32);
    			append_dev(ul, t33);
    			append_dev(ul, li7);
    			append_dev(li7, input3);
    			append_dev(li7, t34);
    			append_dev(ul, t35);
    			append_dev(ul, li8);
    			append_dev(li8, input4);
    			append_dev(li8, t36);
    			append_dev(div3, t37);
    			append_dev(div3, button1);
    			append_dev(button1, span4);
    			append_dev(button1, t38);
    			insert_dev(target, t39, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			if_block.m(div6, null);
    			append_dev(div7, t40);
    			mount_component(infinitescroll, div7, null);
    			insert_dev(target, t41, anchor);
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div10);
    			append_dev(div10, button2);
    			append_dev(div10, t42);
    			append_dev(div10, div9);
    			append_dev(div9, div8);
    			key_block.m(div8, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*clearFilters*/ ctx[19], false, false, false),
    					listen_dev(select0, "change", /*change_handler*/ ctx[20], false, false, false),
    					listen_dev(select1, "change", /*change_handler_1*/ ctx[21], false, false, false),
    					listen_dev(select2, "change", /*change_handler_2*/ ctx[22], false, false, false),
    					listen_dev(select3, "change", /*change_handler_3*/ ctx[23], false, false, false),
    					listen_dev(input1, "change", /*change_handler_4*/ ctx[24], false, false, false),
    					listen_dev(input2, "change", /*change_handler_5*/ ctx[25], false, false, false),
    					listen_dev(input3, "change", /*change_handler_6*/ ctx[26], false, false, false),
    					listen_dev(input4, "change", /*change_handler_7*/ ctx[27], false, false, false),
    					listen_dev(button1, "click", /*openForm*/ ctx[16], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*$screenWidthS, $screenWidthM, $screenWidthL*/ 3584 && input0_class_value !== (input0_class_value = "uk-input " + (/*$screenWidthS*/ ctx[9]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[10] || /*$screenWidthL*/ ctx[11]
    				? 'uk-width-medium'
    				: 'uk-width-large'))) {
    				attr_dev(input0, "class", input0_class_value);
    			}

    			if (dirty[0] & /*bookingQuery*/ 16) {
    				toggle_class(button0, "uk-button-danger", /*bookingQuery*/ ctx[4].filter && Object.keys(/*bookingQuery*/ ctx[4].filter).length > 0);
    			}

    			if (dirty[0] & /*bookingQuery*/ 16) {
    				toggle_class(button0, "uk-light", /*bookingQuery*/ ctx[4].filter && Object.keys(/*bookingQuery*/ ctx[4].filter).length > 0);
    			}

    			if (dirty[0] & /*$events*/ 4096) {
    				each_value_3 = /*$events*/ ctx[12];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_3(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_3.length;
    			}

    			if (dirty[0] & /*groupNames*/ 8) {
    				each_value_2 = /*groupNames*/ ctx[3];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}

    			if ((!current || dirty[0] & /*$screenWidthS, $screenWidthM*/ 1536) && t38_value !== (t38_value = (/*$screenWidthS*/ ctx[9]
    			? ''
    			: /*$screenWidthM*/ ctx[10]
    				? '\xa0booking'
    				: '\xa0New booking') + "")) set_data_dev(t38, t38_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div6, null);
    				}
    			}

    			const infinitescroll_changes = {};
    			if (dirty[0] & /*newBatch*/ 2) infinitescroll_changes.hasMore = /*newBatch*/ ctx[1].length;
    			infinitescroll.$set(infinitescroll_changes);

    			if (dirty[0] & /*recreateForm*/ 256 && safe_not_equal(previous_key, previous_key = /*recreateForm*/ ctx[8])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block$9(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div8, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (dirty[0] & /*$screenWidthM*/ 1024) {
    				toggle_class(div11, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[10]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(infinitescroll.$$.fragment, local);
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(infinitescroll.$$.fragment, local);
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t39);
    			if (detaching) detach_dev(div7);
    			if_block.d();
    			destroy_component(infinitescroll);
    			if (detaching) detach_dev(t41);
    			if (detaching) detach_dev(div11);
    			key_block.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const click_handler_10 = () => true;
    const click_handler_11 = () => true;
    const click_handler_12 = () => true;

    function instance$p($$self, $$props, $$invalidate) {
    	let $bookingNames;
    	let $screenWidthS;
    	let $screenWidthM;
    	let $screenWidthL;
    	let $events;
    	validate_store(bookingNames, 'bookingNames');
    	component_subscribe($$self, bookingNames, $$value => $$invalidate(41, $bookingNames = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(9, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(10, $screenWidthM = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(11, $screenWidthL = $$value));
    	validate_store(events, 'events');
    	component_subscribe($$self, events, $$value => $$invalidate(12, $events = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Booking', slots, []);
    	const State = Object.freeze({ none: 'none', asc: 'ASC', desc: 'DESC' });
    	let maxPage = 2;
    	let data = [];
    	let newBatch = [];
    	let groupNames = [];
    	let bookingQuery = { page: 1, limit: 50 };

    	let orderStates = {
    		arrival: State.none,
    		departure: State.none
    	};

    	let selectedBooking;
    	let editBooking = false;
    	let recreateForm = false;
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		await fetchData();
    		$$invalidate(3, groupNames = await getGroupNames());

    		const autoCompleteJS = new autoComplete({
    				selector: "#autocomplete",
    				placeHolder: "Search bookings...",
    				diacritics: true,
    				searchEngine: 'strict',
    				data: { src: $bookingNames, cache: true },
    				resultsList: {
    					element: (list, data) => {
    						if (!data.results.length) {
    							const message = document.createElement("div");
    							message.setAttribute("class", "no_result");
    							message.innerHTML = `<span>No Booking for "${data.query}"</span>`;
    							list.prepend(message);
    						}
    					},
    					maxResults: 50,
    					noResults: true
    				},
    				resultItem: { highlight: true },
    				events: {
    					input: {
    						selection: event => {
    							autoCompleteJS.input.value = event.detail.selection.value;
    							fetchBooking(event.detail.selection.value);
    						},
    						keyup: () => {
    							if (autoCompleteJS.input.value === '') fetchBooking(null);
    						}
    					}
    				}
    			});
    	});

    	async function fetchData() {
    		const result = await getBookings(bookingQuery);
    		$$invalidate(2, maxPage = result.meta.last_page);
    		$$invalidate(1, newBatch = result.data);
    	}

    	async function fetchBooking(bookingName) {
    		$$invalidate(4, bookingQuery.page = 1, bookingQuery);
    		$$invalidate(1, newBatch = []);

    		if (bookingName !== undefined && bookingName !== null) {
    			$$invalidate(4, bookingQuery.name = bookingName, bookingQuery);
    			const result = await getBookings(bookingQuery);
    			$$invalidate(2, maxPage = result.meta.last_page);
    			$$invalidate(0, data = [...result.data]);
    		} else {
    			delete bookingQuery.name;
    			$$invalidate(0, data = []);
    			await fetchData();
    		}
    	}

    	function switchOrderBy(col) {
    		// TODO: simplify by removing orderStates working only with bookingQuery.orderBy
    		switch (col) {
    			case 'arrival':
    				$$invalidate(
    					5,
    					orderStates.arrival = orderStates.arrival !== State.desc
    					? State.desc
    					: State.asc,
    					orderStates
    				);
    				$$invalidate(5, orderStates.departure = State.none, orderStates);
    				$$invalidate(
    					4,
    					bookingQuery.orderBy = {
    						key: 'arrival',
    						order: orderStates.arrival
    					},
    					bookingQuery
    				);
    				break;
    			case 'departure':
    				$$invalidate(
    					5,
    					orderStates.departure = orderStates.departure !== State.desc
    					? State.desc
    					: State.asc,
    					orderStates
    				);
    				$$invalidate(5, orderStates.arrival = State.none, orderStates);
    				$$invalidate(
    					4,
    					bookingQuery.orderBy = {
    						key: 'departure',
    						order: orderStates.departure
    					},
    					bookingQuery
    				);
    				break;
    			case null:
    				$$invalidate(5, orderStates.arrival = State.none, orderStates);
    				$$invalidate(5, orderStates.departure = State.none, orderStates);
    				delete bookingQuery.orderBy;
    		}

    		fetchBooking(bookingQuery.name);
    	}

    	function dispatchReload() {
    		dispatch('message', { reload: 'booking' });
    	}

    	function openForm(booking) {
    		$$invalidate(6, selectedBooking = booking instanceof MouseEvent
    		? null
    		: JSON.parse(JSON.stringify(booking)));

    		$$invalidate(7, editBooking = selectedBooking !== null);
    		$$invalidate(8, recreateForm = !recreateForm);
    		uikit.modal("#modal-booking").show();
    	}

    	async function processBooking(event) {
    		if (event.detail.goto !== undefined) {
    			let success = false;

    			switch (event.detail.goto) {
    				case 'cancel':
    					uikit.modal("#modal-booking").hide();
    					break;
    				case 'save':
    					if (!editBooking) success = await createBooking(selectedBooking) > 0; else if (selectedBooking.id !== undefined && selectedBooking.id !== null) {
    						if (selectedBooking.mattress_booking) {
    							let transaction = await getTransactionsByBookingId(selectedBooking.id);
    							$$invalidate(6, selectedBooking = calculateBookingAmounts(selectedBooking));
    							transaction.amount = selectedBooking.total_amount;
    							transaction.booking_nights = selectedBooking.stay_days;
    							success = await updateTransaction(transaction);
    							if (success) uikit.notification('<span uk-icon="icon: check"></span> Successfully updated mattress!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed updating mattress!', { status: 'danger', pos: 'bottom-center' });
    							success = false;
    						}

    						success = await updateBooking(selectedBooking);
    					}
    					if (success) {
    						uikit.modal("#modal-booking").hide();
    						uikit.notification('<span uk-icon="icon: check"></span> Successfully ' + (editBooking ? 'updated!' : 'created!'), { status: 'success', pos: 'bottom-center' });
    					} else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    					if (selectedBooking) dispatchReload();
    					break;
    				case 'delete':
    					success = await deleteBooking(selectedBooking.id);
    					if (success) {
    						uikit.modal("#modal-booking").hide();
    						uikit.notification('<span uk-icon="icon: check"></span> Successfully deleted', { status: 'success', pos: 'bottom-center' });
    					} else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    					dispatchReload();
    					break;
    			}
    		}
    	}

    	function setFilters(field) {
    		$$invalidate(4, bookingQuery.filter = {}, bookingQuery);

    		if (field !== 'date_present' && document.getElementById('date_arrival').value !== '[]') {
    			document.getElementById('date_present').value = '[]';
    			$$invalidate(4, bookingQuery.filter.arrival = JSON.parse(document.getElementById('date_arrival').value), bookingQuery);
    		}

    		if (field !== 'date_arrival' && document.getElementById('date_present').value !== '[]') {
    			document.getElementById('date_arrival').value = '[]';
    			$$invalidate(4, bookingQuery.filter.present = JSON.parse(document.getElementById('date_present').value), bookingQuery);
    		}

    		if (field !== 'group' && document.getElementById('event').value > 0) {
    			document.getElementById('group').value = '';
    			$$invalidate(4, bookingQuery.filter.event = Number(document.getElementById('event').value), bookingQuery);
    		}

    		if (field !== 'event' && document.getElementById('group').value !== '') {
    			document.getElementById('event').value = 0;
    			$$invalidate(4, bookingQuery.filter.group = document.getElementById('group').value, bookingQuery);
    		}

    		if (document.getElementById('cancelled').checked) $$invalidate(4, bookingQuery.filter.cancelled = true, bookingQuery);

    		if (field === 'paid') {
    			document.getElementById('not_paid').checked = false;
    			if (document.getElementById('paid').checked) $$invalidate(4, bookingQuery.filter.paid = true, bookingQuery);
    		}

    		if (field === 'not_paid') {
    			document.getElementById('paid').checked = false;
    			if (document.getElementById('not_paid').checked) $$invalidate(4, bookingQuery.filter.paid = false, bookingQuery);
    		}

    		if (document.getElementById('longstayer').checked) $$invalidate(4, bookingQuery.filter.longstayer = true, bookingQuery);
    		$$invalidate(0, data = []);
    		$$invalidate(1, newBatch = []);
    		$$invalidate(4, bookingQuery.page = 1, bookingQuery);
    		fetchData();
    	}

    	function clearFilters() {
    		document.getElementById('date_arrival').value = '[]';
    		document.getElementById('date_present').value = '[]';
    		document.getElementById('event').value = 0;
    		document.getElementById('group').value = '';
    		document.getElementById('cancelled').checked = false;
    		document.getElementById('paid').checked = false;
    		document.getElementById('not_paid').checked = false;
    		document.getElementById('longstayer').checked = false;
    		$$invalidate(4, bookingQuery.filter = {}, bookingQuery);
    		$$invalidate(0, data = []);
    		$$invalidate(1, newBatch = []);
    		$$invalidate(4, bookingQuery.page = 1, bookingQuery);
    		fetchData();
    	}

    	const writable_props = [];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Booking> was created with unknown prop '${key}'`);
    	});

    	const change_handler = () => setFilters('date_arrival');
    	const change_handler_1 = () => setFilters('date_present');
    	const change_handler_2 = () => setFilters('event');
    	const change_handler_3 = () => setFilters('group');
    	const change_handler_4 = () => setFilters('cancelled');
    	const change_handler_5 = () => setFilters('paid');
    	const change_handler_6 = () => setFilters('not_paid');
    	const change_handler_7 = () => setFilters('longstayer');
    	const click_handler = () => switchOrderBy('arrival');
    	const click_handler_1 = () => switchOrderBy(null);
    	const click_handler_2 = () => switchOrderBy('departure');
    	const click_handler_3 = () => switchOrderBy(null);
    	const click_handler_4 = booking => openForm(booking);
    	const click_handler_5 = booking => openForm(booking);
    	const click_handler_6 = booking => openForm(booking);
    	const click_handler_7 = booking => openForm(booking);
    	const click_handler_8 = booking => openForm(booking);
    	const click_handler_9 = booking => openForm(booking);

    	const loadMore_handler = () => {
    		if (bookingQuery.page < maxPage) {
    			$$invalidate(4, bookingQuery.page++, bookingQuery);
    			fetchData();
    		}
    	};

    	function bookingform_booking_binding(value) {
    		selectedBooking = value;
    		$$invalidate(6, selectedBooking);
    	}

    	function bookingform_edit_binding(value) {
    		editBooking = value;
    		$$invalidate(7, editBooking);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		bookingNames,
    		getBookings,
    		createBooking,
    		updateBooking,
    		getGroupNames,
    		deleteBooking,
    		calculateBookingAmounts,
    		InfiniteScroll,
    		UIkit: uikit,
    		BookingForm,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		autoComplete,
    		DateTime: DateTime_1,
    		events,
    		getTransactionsByBookingId,
    		updateTransaction,
    		State,
    		maxPage,
    		data,
    		newBatch,
    		groupNames,
    		bookingQuery,
    		orderStates,
    		selectedBooking,
    		editBooking,
    		recreateForm,
    		dispatch,
    		fetchData,
    		fetchBooking,
    		switchOrderBy,
    		dispatchReload,
    		openForm,
    		processBooking,
    		setFilters,
    		clearFilters,
    		$bookingNames,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		$events
    	});

    	$$self.$inject_state = $$props => {
    		if ('maxPage' in $$props) $$invalidate(2, maxPage = $$props.maxPage);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('newBatch' in $$props) $$invalidate(1, newBatch = $$props.newBatch);
    		if ('groupNames' in $$props) $$invalidate(3, groupNames = $$props.groupNames);
    		if ('bookingQuery' in $$props) $$invalidate(4, bookingQuery = $$props.bookingQuery);
    		if ('orderStates' in $$props) $$invalidate(5, orderStates = $$props.orderStates);
    		if ('selectedBooking' in $$props) $$invalidate(6, selectedBooking = $$props.selectedBooking);
    		if ('editBooking' in $$props) $$invalidate(7, editBooking = $$props.editBooking);
    		if ('recreateForm' in $$props) $$invalidate(8, recreateForm = $$props.recreateForm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*data, newBatch*/ 3) {
    			$$invalidate(0, data = [...data, ...newBatch]);
    		}
    	};

    	return [
    		data,
    		newBatch,
    		maxPage,
    		groupNames,
    		bookingQuery,
    		orderStates,
    		selectedBooking,
    		editBooking,
    		recreateForm,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		$events,
    		State,
    		fetchData,
    		switchOrderBy,
    		openForm,
    		processBooking,
    		setFilters,
    		clearFilters,
    		change_handler,
    		change_handler_1,
    		change_handler_2,
    		change_handler_3,
    		change_handler_4,
    		change_handler_5,
    		change_handler_6,
    		change_handler_7,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8,
    		click_handler_9,
    		loadMore_handler,
    		bookingform_booking_binding,
    		bookingform_edit_binding
    	];
    }

    class Booking extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$p, create_fragment$p, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Booking",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    const invoiceNames = writable([]);
    const invoiceNumbers = writable([]);
    const invoiceNumberStrings = writable([]);
    const invoiceBankRunNumbers = writable([]);
    const invoiceReconciliationNumbers = writable([]);


    async function getInvoices(page) {
        try {
            const result = await api.post('/invoices/', {page: page, limit: 50});
            return result.data
        } catch (error) {}
    }

    async function getBankRunInvoices(array) {
        try {
            const result = await api.post('/invoicesBankRun', {array: array});
            return result.data
        } catch (error) {}
    }

    async function getAllBankRunInvoices() {
        try {
            const result = await api.get('/invoicesBankRun');
            return result.data
        } catch (error) {}
    }

    async function getReconciliationInvoices(query) {
        try {
            const result = await api.post('/invoices/reconciliation', query);
            return result.data
        } catch (error) {}
    }

    async function getInvoiceById(id) {
        try {
            const result = await api.get('/invoice/'+id);
            return result.data
        } catch (error) {}
    }

    async function getInvoiceByName(name) {
        try {
            const result = await api.post('/invoices/byName/', {name: name});
            return result.data
        } catch (error) {}
    }

    async function getInvoiceByNumber(invoice_nr) {
        try {
            const result = await api.post('/invoices/byNumber/', {invoice_nr: invoice_nr});
            return result.data
        } catch (error) {}
    }

    async function getInvoiceNames() {
        try {
            const result = await api.get('/invoices/');
            invoiceNames.set(result.data);
        } catch (error) {}
    }

    async function getInvoiceNumbers() {
        try {
            const result = await api.get('/invoiceNumbers/');
            invoiceNumbers.set(result.data.all.map(num => num.substring(0, 6)));
            if (result.data.all)
                invoiceNumberStrings.set(result.data.all);
            if (result.data.bankrun)
                invoiceBankRunNumbers.set(result.data.bankrun);
            if (result.data.reconciliation)
                invoiceReconciliationNumbers.set(result.data.reconciliation);
        } catch (error) {
            console.error(error.message);
        }
    }

    async function createInvoice(invoice) {
        try {
            const result = await api.post('/invoice/', invoice);
            return result.data
        } catch (error) {}
    }

    async function updateInvoice(invoice, sendMail) {
        try {
            const result = await api.put('/invoice/'+invoice.id+'/'+sendMail, invoice);
            return result.data
        } catch (error) {}
    }

    async function deleteInvoice(id) {
        try {
            const result = await api.delete('/invoice/'+id);
            return result.status === 200
        } catch (error) {}
    }

    async function downloadPDF(id, fileName) {
        try {
            return await api.get('/invoice/pdf/'+id, {responseType: 'blob'})
                .then(response => {
                    let url = window.URL.createObjectURL(response.data);
                    let a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    a.click();
                    a.remove();
                    setTimeout(() => window.URL.revokeObjectURL(url), 100);
                })
        } catch (error) {}
    }

    /* src/components/InvoiceForm.svelte generated by Svelte v3.45.0 */

    const { Object: Object_1$2, console: console_1 } = globals;
    const file$o = "src/components/InvoiceForm.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[53] = list[i];
    	return child_ctx;
    }

    // (270:4) {:else }
    function create_else_block_2$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Creating invoice");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$7.name,
    		type: "else",
    		source: "(270:4) {:else }",
    		ctx
    	});

    	return block;
    }

    // (268:19) 
    function create_if_block_10$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Updating invoice");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$3.name,
    		type: "if",
    		source: "(268:19) ",
    		ctx
    	});

    	return block;
    }

    // (263:26) 
    function create_if_block_8$3(ctx) {
    	let t;
    	let if_block_anchor;
    	let if_block = (/*$role*/ ctx[13] === 'admin' || /*$role*/ ctx[13] === 'root') && create_if_block_9$3(ctx);

    	const block = {
    		c: function create() {
    			t = text$1("Edit invoice\n        ");
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*$role*/ ctx[13] === 'admin' || /*$role*/ ctx[13] === 'root') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_9$3(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$3.name,
    		type: "if",
    		source: "(263:26) ",
    		ctx
    	});

    	return block;
    }

    // (261:4) {#if !edit && !dispatched}
    function create_if_block_7$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("New invoice");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$5.name,
    		type: "if",
    		source: "(261:4) {#if !edit && !dispatched}",
    		ctx
    	});

    	return block;
    }

    // (265:8) {#if $role === 'admin' || $role === 'root'}
    function create_if_block_9$3(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Delete";
    			attr_dev(button, "class", "uk-button uk-text-normal uk-margin uk-button-secondary uk-position-bottom-right uk-button-danger");
    			attr_dev(button, "type", "button");
    			add_location(button, file$o, 265, 12, 13534);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*deleteMe*/ ctx[28], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$3.name,
    		type: "if",
    		source: "(265:8) {#if $role === 'admin' || $role === 'root'}",
    		ctx
    	});

    	return block;
    }

    // (278:0) {:else}
    function create_else_block$m(ctx) {
    	let form_1;
    	let div2;
    	let label;
    	let t1;
    	let div1;
    	let div0;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let t6;
    	let mounted;
    	let dispose;
    	let if_block = /*hasPaymentType*/ ctx[4] && create_if_block_1$e(ctx);

    	const block = {
    		c: function create() {
    			form_1 = element("form");
    			div2 = element("div");
    			label = element("label");
    			label.textContent = "Invoice";
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Select payment type:";
    			option1 = element("option");
    			option1.textContent = "Cash";
    			option2 = element("option");
    			option2.textContent = "Cheque";
    			option3 = element("option");
    			option3.textContent = "Bank transfer";
    			t6 = space();
    			if (if_block) if_block.c();
    			attr_dev(label, "class", "uk-form-label");
    			attr_dev(label, "for", "form-invoice-type");
    			add_location(label, file$o, 281, 12, 14119);
    			option0.__value = "";
    			option0.value = option0.__value;
    			option0.selected = true;
    			add_location(option0, file$o, 285, 24, 14567);
    			option1.__value = "cash";
    			option1.value = option1.__value;
    			add_location(option1, file$o, 286, 24, 14647);
    			option2.__value = "cheque";
    			option2.value = option2.__value;
    			add_location(option2, file$o, 287, 24, 14706);
    			option3.__value = "transfer";
    			option3.value = option3.__value;
    			add_location(option3, file$o, 288, 24, 14769);
    			attr_dev(select, "class", "uk-select");
    			attr_dev(select, "id", "form-payment_type");
    			attr_dev(select, "name", "payment_type");
    			attr_dev(select, "type", "text");
    			if (/*$form*/ ctx[2].payment_type === void 0) add_render_callback(() => /*select_change_handler*/ ctx[32].call(select));
    			add_location(select, file$o, 284, 20, 14398);
    			attr_dev(div0, "class", "uk-width-1-1@s uk-inline");
    			add_location(div0, file$o, 283, 16, 14339);
    			attr_dev(div1, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l uk-margin-small-bottom");
    			attr_dev(div1, "id", "form-invoice-type");
    			attr_dev(div1, "uk-grid", "");
    			add_location(div1, file$o, 282, 12, 14200);
    			attr_dev(div2, "class", "uk-margin-medium uk-margin-small-bottom");
    			add_location(div2, file$o, 280, 8, 14053);
    			attr_dev(form_1, "class", "uk-form");
    			toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[14]);
    			add_location(form_1, file$o, 278, 4, 13954);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form_1, anchor);
    			append_dev(form_1, div2);
    			append_dev(div2, label);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			select_option(select, /*$form*/ ctx[2].payment_type);
    			append_dev(form_1, t6);
    			if (if_block) if_block.m(form_1, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*selectPaymentType*/ ctx[26], false, false, false),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[32]),
    					listen_dev(form_1, "submit", /*handleSubmit*/ ctx[22], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 4) {
    				select_option(select, /*$form*/ ctx[2].payment_type);
    			}

    			if (/*hasPaymentType*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$e(ctx);
    					if_block.c();
    					if_block.m(form_1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty[0] & /*$screenWidthL*/ 16384) {
    				toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[14]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form_1);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$m.name,
    		type: "else",
    		source: "(278:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (274:0) {#if dispatched}
    function create_if_block$n(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$o, 275, 8, 13897);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-xlarge-top");
    			add_location(div1, file$o, 274, 4, 13831);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(274:0) {#if dispatched}",
    		ctx
    	});

    	return block;
    }

    // (294:8) {#if hasPaymentType}
    function create_if_block_1$e(ctx) {
    	let div3;
    	let label0;
    	let t0;
    	let div2;
    	let div0;
    	let input0;
    	let t1;
    	let span;
    	let t2_value = /*$form*/ ctx[2].payment_type + "";
    	let t2;
    	let t3;
    	let div1;
    	let input1;
    	let t4;
    	let t5;
    	let t6;
    	let div14;
    	let label1;
    	let t8;
    	let div13;
    	let div4;
    	let input2;
    	let t9;
    	let div5;
    	let input3;
    	let t10;
    	let div6;
    	let t11;
    	let div8;
    	let div7;
    	let t13;
    	let div9;
    	let input4;
    	let t14;
    	let div10;
    	let input5;
    	let t15;
    	let div11;
    	let input6;
    	let t16;
    	let div12;
    	let select;
    	let if_block2_anchor;
    	let t17;
    	let div18;
    	let label2;
    	let t19;
    	let div17;
    	let div15;
    	let input7;
    	let t20;
    	let div16;
    	let input8;
    	let t21;
    	let div22;
    	let label3;
    	let t23;
    	let div21;
    	let div19;
    	let t24;
    	let t25;
    	let t26;
    	let div20;
    	let input9;
    	let t27;
    	let div26;
    	let label4;
    	let t29;
    	let div25;
    	let div23;
    	let t30;
    	let t31_value = /*$settings*/ ctx[11].text_membership + "";
    	let t31;
    	let t32;
    	let div24;
    	let input10;
    	let t33;
    	let div30;
    	let label5;
    	let t35;
    	let div29;
    	let div27;
    	let t36;
    	let t37_value = /*$settings*/ ctx[11].text_meals + "";
    	let t37;
    	let t38;
    	let div28;
    	let input11;
    	let t39;
    	let div34;
    	let label6;
    	let t41;
    	let div33;
    	let div31;
    	let input12;
    	let t42;
    	let div32;
    	let input13;
    	let t43;
    	let div38;
    	let label7;
    	let t44;
    	let div37;
    	let div35;
    	let t46;
    	let div36;
    	let t47;
    	let t48;
    	let t49;
    	let t50;
    	let div39;
    	let button;
    	let t52;
    	let mounted;
    	let dispose;
    	let if_block0 = !/*okInvoiceNr*/ ctx[6] && create_if_block_6$6(ctx);
    	let if_block1 = /*invoiceWarning*/ ctx[7] && create_if_block_5$7(ctx);
    	let if_block2 = (/*invoice*/ ctx[0] === undefined || /*invoice*/ ctx[0] === null || /*invoice*/ ctx[0].country === null || /*invoice*/ ctx[0].country === '' || /*$form*/ ctx[2].country === null || /*$form*/ ctx[2].country === '') && create_if_block_4$8(ctx);
    	let each_value = countryArray;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	let if_block3 = (!/*edit*/ ctx[1] || /*$role*/ ctx[13] === 'admin' || /*$role*/ ctx[13] === 'root') && create_if_block_2$d(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			label0 = element("label");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t1 = space();
    			span = element("span");
    			t2 = text$1(t2_value);
    			t3 = space();
    			div1 = element("div");
    			input1 = element("input");
    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			t6 = space();
    			div14 = element("div");
    			label1 = element("label");
    			label1.textContent = "Personals";
    			t8 = space();
    			div13 = element("div");
    			div4 = element("div");
    			input2 = element("input");
    			t9 = space();
    			div5 = element("div");
    			input3 = element("input");
    			t10 = space();
    			div6 = element("div");
    			t11 = space();
    			div8 = element("div");
    			div7 = element("div");
    			div7.textContent = "Please ensure that this email address is valid!";
    			t13 = space();
    			div9 = element("div");
    			input4 = element("input");
    			t14 = space();
    			div10 = element("div");
    			input5 = element("input");
    			t15 = space();
    			div11 = element("div");
    			input6 = element("input");
    			t16 = space();
    			div12 = element("div");
    			select = element("select");
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty$3();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t17 = space();
    			div18 = element("div");
    			label2 = element("label");
    			label2.textContent = "Dates";
    			t19 = space();
    			div17 = element("div");
    			div15 = element("div");
    			input7 = element("input");
    			t20 = space();
    			div16 = element("div");
    			input8 = element("input");
    			t21 = space();
    			div22 = element("div");
    			label3 = element("label");
    			label3.textContent = "Stay";
    			t23 = space();
    			div21 = element("div");
    			div19 = element("div");
    			t24 = text$1(" ");
    			t25 = text$1(/*stayDisplayLabelString*/ ctx[9]);
    			t26 = space();
    			div20 = element("div");
    			input9 = element("input");
    			t27 = space();
    			div26 = element("div");
    			label4 = element("label");
    			label4.textContent = "Membership";
    			t29 = space();
    			div25 = element("div");
    			div23 = element("div");
    			t30 = text$1(" ");
    			t31 = text$1(t31_value);
    			t32 = space();
    			div24 = element("div");
    			input10 = element("input");
    			t33 = space();
    			div30 = element("div");
    			label5 = element("label");
    			label5.textContent = "Meals";
    			t35 = space();
    			div29 = element("div");
    			div27 = element("div");
    			t36 = text$1(" ");
    			t37 = text$1(t37_value);
    			t38 = space();
    			div28 = element("div");
    			input11 = element("input");
    			t39 = space();
    			div34 = element("div");
    			label6 = element("label");
    			label6.textContent = "Custom";
    			t41 = space();
    			div33 = element("div");
    			div31 = element("div");
    			input12 = element("input");
    			t42 = space();
    			div32 = element("div");
    			input13 = element("input");
    			t43 = space();
    			div38 = element("div");
    			label7 = element("label");
    			t44 = space();
    			div37 = element("div");
    			div35 = element("div");
    			div35.textContent = " TOTAL";
    			t46 = space();
    			div36 = element("div");
    			t47 = text$1(" ");
    			t48 = text$1(/*total*/ ctx[3]);
    			t49 = text$1(" ");
    			t50 = space();
    			div39 = element("div");
    			button = element("button");
    			button.textContent = "Cancel";
    			t52 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-invoice");
    			add_location(label0, file$o, 295, 16, 15013);
    			attr_dev(input0, "class", "uk-input");
    			attr_dev(input0, "id", "form-invoice_nr");
    			attr_dev(input0, "name", "invoice_nr");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Invoice Nr");
    			attr_dev(input0, "maxlength", "8");
    			set_style(input0, "color", "black");
    			toggle_class(input0, "uk-form-danger", !/*okInvoiceNr*/ ctx[6] || /*$errors*/ ctx[15].invoice_nr && /*$touched*/ ctx[12].invoice_nr);
    			add_location(input0, file$o, 298, 24, 15264);
    			attr_dev(span, "class", "uk-label uk-label-success uk-position-center-right uk-margin-small-right");
    			add_location(span, file$o, 301, 24, 15646);
    			attr_dev(div0, "class", "uk-width-1-2@s uk-inline");
    			add_location(div0, file$o, 297, 20, 15201);
    			attr_dev(input1, "class", "uk-input");
    			attr_dev(input1, "id", "form-date");
    			attr_dev(input1, "name", "date");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "Invoice Date");
    			input1.readOnly = true;
    			set_style(input1, "color", "black");
    			toggle_class(input1, "uk-form-danger", /*$errors*/ ctx[15].date && /*$touched*/ ctx[12].date);
    			add_location(input1, file$o, 304, 24, 15861);
    			attr_dev(div1, "class", "uk-width-1-2@s");
    			add_location(div1, file$o, 303, 20, 15808);
    			attr_dev(div2, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div2, "id", "form-invoice");
    			attr_dev(div2, "uk-grid", "");
    			add_location(div2, file$o, 296, 16, 15086);
    			attr_dev(div3, "class", "uk-margin-medium uk-margin-remove-top");
    			add_location(div3, file$o, 294, 12, 14945);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "form-personals");
    			add_location(label1, file$o, 321, 16, 16831);
    			attr_dev(input2, "class", "uk-input uk-form-width-large");
    			attr_dev(input2, "id", "form-name");
    			attr_dev(input2, "name", "name");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", "Name");
    			set_style(input2, "color", "black");
    			toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[15].name && /*$touched*/ ctx[12].name);
    			add_location(input2, file$o, 324, 24, 17085);
    			attr_dev(div4, "class", "uk-width-1-2@s");
    			add_location(div4, file$o, 323, 20, 17032);
    			attr_dev(input3, "class", "uk-input");
    			attr_dev(input3, "id", "form-email-no1pw-search");
    			attr_dev(input3, "name", "email");
    			attr_dev(input3, "type", "email");
    			attr_dev(input3, "placeholder", "Email");
    			attr_dev(input3, "autocomplete", "'off");
    			set_style(input3, "color", "black");
    			toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[15].email && /*$touched*/ ctx[12].email);
    			add_location(input3, file$o, 329, 24, 17495);
    			attr_dev(div5, "class", "uk-width-1-2@s");
    			add_location(div5, file$o, 328, 20, 17442);
    			attr_dev(div6, "class", "uk-width-1-2@s");
    			add_location(div6, file$o, 333, 20, 17872);
    			attr_dev(div7, "class", "uk-width-1-1 uk-text-warning uk-align-right");
    			add_location(div7, file$o, 335, 24, 17980);
    			attr_dev(div8, "class", "uk-width-1-2@s");
    			add_location(div8, file$o, 334, 20, 17927);
    			attr_dev(input4, "class", "uk-input");
    			attr_dev(input4, "id", "form-address");
    			attr_dev(input4, "name", "address");
    			attr_dev(input4, "type", "text");
    			attr_dev(input4, "placeholder", "Address");
    			set_style(input4, "color", "black");
    			toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[15].address && /*$touched*/ ctx[12].address);
    			add_location(input4, file$o, 340, 24, 18245);
    			attr_dev(div9, "class", "uk-width-1-2@s");
    			add_location(div9, file$o, 339, 20, 18192);
    			attr_dev(input5, "class", "uk-input");
    			attr_dev(input5, "id", "form-zip");
    			attr_dev(input5, "name", "zip");
    			attr_dev(input5, "type", "text");
    			attr_dev(input5, "placeholder", "ZIP");
    			set_style(input5, "color", "black");
    			toggle_class(input5, "uk-form-danger", /*$errors*/ ctx[15].zip && /*$touched*/ ctx[12].zip);
    			add_location(input5, file$o, 345, 24, 18653);
    			attr_dev(div10, "class", "uk-width-1-2@s");
    			add_location(div10, file$o, 344, 20, 18600);
    			attr_dev(input6, "class", "uk-input");
    			attr_dev(input6, "id", "form-city");
    			attr_dev(input6, "name", "city");
    			attr_dev(input6, "type", "text");
    			attr_dev(input6, "placeholder", "City");
    			set_style(input6, "color", "black");
    			toggle_class(input6, "uk-form-danger", /*$errors*/ ctx[15].city && /*$touched*/ ctx[12].city);
    			add_location(input6, file$o, 350, 24, 19037);
    			attr_dev(div11, "class", "uk-width-1-2@s");
    			add_location(div11, file$o, 349, 20, 18984);
    			attr_dev(select, "class", "uk-select");
    			attr_dev(select, "id", "form-country");
    			attr_dev(select, "name", "country");
    			attr_dev(select, "type", "text");
    			set_style(select, "color", "black");
    			toggle_class(select, "uk-form-danger", /*$errors*/ ctx[15].country && /*$touched*/ ctx[12].country);
    			add_location(select, file$o, 355, 24, 19427);
    			attr_dev(div12, "class", "uk-width-1-2@s");
    			add_location(div12, file$o, 354, 20, 19374);
    			attr_dev(div13, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div13, "id", "form-personals");
    			attr_dev(div13, "uk-grid", "");
    			add_location(div13, file$o, 322, 16, 16915);
    			attr_dev(div14, "class", "uk-margin-medium");
    			add_location(div14, file$o, 320, 12, 16784);
    			attr_dev(label2, "class", "uk-form-label");
    			attr_dev(label2, "for", "form-dates");
    			add_location(label2, file$o, 375, 16, 20742);
    			attr_dev(input7, "class", "uk-input");
    			attr_dev(input7, "id", "form-stay_start");
    			attr_dev(input7, "name", "stay_start");
    			attr_dev(input7, "type", "text");
    			attr_dev(input7, "placeholder", "Arrival");
    			input7.readOnly = true;
    			set_style(input7, "color", "black");
    			toggle_class(input7, "uk-form-danger", /*needDates*/ ctx[5]);
    			add_location(input7, file$o, 378, 24, 20984);
    			attr_dev(div15, "class", "uk-width-1-2@s");
    			add_location(div15, file$o, 377, 20, 20931);
    			attr_dev(input8, "class", "uk-input");
    			attr_dev(input8, "id", "form-stay_end");
    			attr_dev(input8, "name", "stay_end");
    			attr_dev(input8, "type", "text");
    			attr_dev(input8, "placeholder", "Departure");
    			input8.readOnly = true;
    			set_style(input8, "color", "black");
    			toggle_class(input8, "uk-form-danger", /*needDates*/ ctx[5]);
    			add_location(input8, file$o, 383, 24, 21419);
    			attr_dev(div16, "class", "uk-width-1-2@s");
    			add_location(div16, file$o, 382, 20, 21366);
    			attr_dev(div17, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div17, "id", "form-dates");
    			attr_dev(div17, "uk-grid", "");
    			add_location(div17, file$o, 376, 16, 20818);
    			attr_dev(div18, "class", "uk-margin-medium");
    			add_location(div18, file$o, 374, 12, 20695);
    			attr_dev(label3, "class", "uk-form-label");
    			attr_dev(label3, "for", "form-accounting");
    			add_location(label3, file$o, 390, 16, 21876);
    			attr_dev(div19, "class", "uk-width-5-6@s uk-text-small");
    			toggle_class(div19, "uk-text-muted", Number(/*$form*/ ctx[2].stay_amount) === 0);
    			add_location(div19, file$o, 392, 20, 22074);
    			attr_dev(input9, "class", "uk-input");
    			attr_dev(input9, "id", "form-stay_amount");
    			attr_dev(input9, "name", "stay_amount");
    			attr_dev(input9, "type", "text");
    			attr_dev(input9, "placeholder", "0");
    			set_style(input9, "color", "black");
    			toggle_class(input9, "uk-form-danger", /*$errors*/ ctx[15].stay_amount);
    			add_location(input9, file$o, 396, 24, 22327);
    			attr_dev(div20, "class", "uk-width-1-6@s");
    			add_location(div20, file$o, 395, 20, 22274);
    			attr_dev(div21, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div21, "id", "form-accounting");
    			attr_dev(div21, "uk-grid", "");
    			add_location(div21, file$o, 391, 16, 21956);
    			attr_dev(div22, "class", "uk-margin-small");
    			add_location(div22, file$o, 389, 12, 21830);
    			attr_dev(label4, "class", "uk-form-label");
    			attr_dev(label4, "for", "form-membership");
    			add_location(label4, file$o, 403, 16, 22765);
    			attr_dev(div23, "class", "uk-width-5-6@s uk-text-small");
    			toggle_class(div23, "uk-text-muted", Number(/*$form*/ ctx[2].membership_amount) === 0);
    			add_location(div23, file$o, 405, 20, 22969);
    			attr_dev(input10, "class", "uk-input");
    			attr_dev(input10, "id", "form-membership_amount-no1pw-search");
    			attr_dev(input10, "name", "membership_amount");
    			attr_dev(input10, "type", "text");
    			set_style(input10, "color", "black");
    			toggle_class(input10, "uk-form-danger", /*$errors*/ ctx[15].membership_amount);
    			add_location(input10, file$o, 409, 24, 23231);
    			attr_dev(div24, "class", "uk-width-1-6@s");
    			add_location(div24, file$o, 408, 20, 23178);
    			attr_dev(div25, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div25, "id", "form-membership");
    			attr_dev(div25, "uk-grid", "");
    			add_location(div25, file$o, 404, 16, 22851);
    			attr_dev(div26, "class", "uk-margin-small");
    			add_location(div26, file$o, 402, 12, 22719);
    			attr_dev(label5, "class", "uk-form-label");
    			attr_dev(label5, "for", "form-meals");
    			add_location(label5, file$o, 416, 16, 23690);
    			attr_dev(div27, "class", "uk-width-5-6@s uk-text-small");
    			toggle_class(div27, "uk-text-muted", Number(/*$form*/ ctx[2].meals_amount) === 0);
    			add_location(div27, file$o, 418, 20, 23879);
    			attr_dev(input11, "class", "uk-input");
    			attr_dev(input11, "id", "form-meals_amount");
    			attr_dev(input11, "name", "meals_amount");
    			attr_dev(input11, "type", "text");
    			attr_dev(input11, "placeholder", "0");
    			set_style(input11, "color", "black");
    			toggle_class(input11, "uk-form-danger", /*$errors*/ ctx[15].meals_amount);
    			add_location(input11, file$o, 422, 24, 24131);
    			attr_dev(div28, "class", "uk-width-1-6@s");
    			add_location(div28, file$o, 421, 20, 24078);
    			attr_dev(div29, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div29, "id", "form-meals");
    			attr_dev(div29, "uk-grid", "");
    			add_location(div29, file$o, 417, 16, 23766);
    			attr_dev(div30, "class", "uk-margin-small");
    			add_location(div30, file$o, 415, 12, 23644);
    			attr_dev(label6, "class", "uk-form-label");
    			attr_dev(label6, "for", "form-custom");
    			add_location(label6, file$o, 429, 16, 24573);
    			attr_dev(input12, "class", "uk-input");
    			attr_dev(input12, "id", "form-custom_label");
    			attr_dev(input12, "name", "custom_label");
    			attr_dev(input12, "type", "text");
    			attr_dev(input12, "placeholder", "Label text custom");
    			set_style(input12, "color", "black");
    			toggle_class(input12, "uk-form-danger", !/*okCustom*/ ctx[8]);
    			add_location(input12, file$o, 432, 24, 24818);
    			attr_dev(div31, "class", "uk-width-5-6@s");
    			add_location(div31, file$o, 431, 20, 24765);
    			attr_dev(input13, "class", "uk-input");
    			attr_dev(input13, "id", "form-custom_amount");
    			attr_dev(input13, "name", "custom_amount");
    			attr_dev(input13, "type", "text");
    			attr_dev(input13, "placeholder", "0");
    			set_style(input13, "color", "black");
    			toggle_class(input13, "uk-form-danger", /*$errors*/ ctx[15].custom_amount);
    			add_location(input13, file$o, 437, 24, 25225);
    			attr_dev(div32, "class", "uk-width-1-6@s");
    			add_location(div32, file$o, 436, 20, 25172);
    			attr_dev(div33, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div33, "id", "form-custom");
    			attr_dev(div33, "uk-grid", "");
    			add_location(div33, file$o, 430, 16, 24651);
    			attr_dev(div34, "class", "uk-margin-small");
    			add_location(div34, file$o, 428, 12, 24527);
    			attr_dev(label7, "class", "uk-form-label");
    			attr_dev(label7, "for", "form-total");
    			add_location(label7, file$o, 444, 16, 25672);
    			attr_dev(div35, "class", "uk-width-5-6@s uk-text-emphasis uk-text-bold");
    			add_location(div35, file$o, 446, 20, 25856);
    			attr_dev(div36, "class", "uk-width-1-6@s uk-text-emphasis uk-text-bold");
    			add_location(div36, file$o, 447, 20, 25953);
    			attr_dev(div37, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div37, "id", "form-total");
    			attr_dev(div37, "uk-grid", "");
    			add_location(div37, file$o, 445, 16, 25743);
    			attr_dev(div38, "class", "uk-margin-medium");
    			add_location(div38, file$o, 443, 12, 25625);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			attr_dev(button, "type", "button");
    			add_location(button, file$o, 451, 16, 26178);
    			attr_dev(div39, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div39, file$o, 450, 12, 26088);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, label0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$form*/ ctx[2].invoice_nr);
    			append_dev(div0, t1);
    			append_dev(div0, span);
    			append_dev(span, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, input1);
    			set_input_value(input1, /*$form*/ ctx[2].date);
    			append_dev(div2, t4);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t5);
    			if (if_block1) if_block1.m(div2, null);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div14, anchor);
    			append_dev(div14, label1);
    			append_dev(div14, t8);
    			append_dev(div14, div13);
    			append_dev(div13, div4);
    			append_dev(div4, input2);
    			set_input_value(input2, /*$form*/ ctx[2].name);
    			append_dev(div13, t9);
    			append_dev(div13, div5);
    			append_dev(div5, input3);
    			set_input_value(input3, /*$form*/ ctx[2].email);
    			append_dev(div13, t10);
    			append_dev(div13, div6);
    			append_dev(div13, t11);
    			append_dev(div13, div8);
    			append_dev(div8, div7);
    			append_dev(div13, t13);
    			append_dev(div13, div9);
    			append_dev(div9, input4);
    			set_input_value(input4, /*$form*/ ctx[2].address);
    			append_dev(div13, t14);
    			append_dev(div13, div10);
    			append_dev(div10, input5);
    			set_input_value(input5, /*$form*/ ctx[2].zip);
    			append_dev(div13, t15);
    			append_dev(div13, div11);
    			append_dev(div11, input6);
    			set_input_value(input6, /*$form*/ ctx[2].city);
    			append_dev(div13, t16);
    			append_dev(div13, div12);
    			append_dev(div12, select);
    			if (if_block2) if_block2.m(select, null);
    			append_dev(select, if_block2_anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			insert_dev(target, t17, anchor);
    			insert_dev(target, div18, anchor);
    			append_dev(div18, label2);
    			append_dev(div18, t19);
    			append_dev(div18, div17);
    			append_dev(div17, div15);
    			append_dev(div15, input7);
    			set_input_value(input7, /*$form*/ ctx[2].stay_start);
    			append_dev(div17, t20);
    			append_dev(div17, div16);
    			append_dev(div16, input8);
    			set_input_value(input8, /*$form*/ ctx[2].stay_end);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, div22, anchor);
    			append_dev(div22, label3);
    			append_dev(div22, t23);
    			append_dev(div22, div21);
    			append_dev(div21, div19);
    			append_dev(div19, t24);
    			append_dev(div19, t25);
    			append_dev(div21, t26);
    			append_dev(div21, div20);
    			append_dev(div20, input9);
    			set_input_value(input9, /*$form*/ ctx[2].stay_amount);
    			insert_dev(target, t27, anchor);
    			insert_dev(target, div26, anchor);
    			append_dev(div26, label4);
    			append_dev(div26, t29);
    			append_dev(div26, div25);
    			append_dev(div25, div23);
    			append_dev(div23, t30);
    			append_dev(div23, t31);
    			append_dev(div25, t32);
    			append_dev(div25, div24);
    			append_dev(div24, input10);
    			set_input_value(input10, /*$form*/ ctx[2].membership_amount);
    			insert_dev(target, t33, anchor);
    			insert_dev(target, div30, anchor);
    			append_dev(div30, label5);
    			append_dev(div30, t35);
    			append_dev(div30, div29);
    			append_dev(div29, div27);
    			append_dev(div27, t36);
    			append_dev(div27, t37);
    			append_dev(div29, t38);
    			append_dev(div29, div28);
    			append_dev(div28, input11);
    			set_input_value(input11, /*$form*/ ctx[2].meals_amount);
    			insert_dev(target, t39, anchor);
    			insert_dev(target, div34, anchor);
    			append_dev(div34, label6);
    			append_dev(div34, t41);
    			append_dev(div34, div33);
    			append_dev(div33, div31);
    			append_dev(div31, input12);
    			set_input_value(input12, /*$form*/ ctx[2].custom_label);
    			append_dev(div33, t42);
    			append_dev(div33, div32);
    			append_dev(div32, input13);
    			set_input_value(input13, /*$form*/ ctx[2].custom_amount);
    			insert_dev(target, t43, anchor);
    			insert_dev(target, div38, anchor);
    			append_dev(div38, label7);
    			append_dev(div38, t44);
    			append_dev(div38, div37);
    			append_dev(div37, div35);
    			append_dev(div37, t46);
    			append_dev(div37, div36);
    			append_dev(div36, t47);
    			append_dev(div36, t48);
    			append_dev(div36, t49);
    			insert_dev(target, t50, anchor);
    			insert_dev(target, div39, anchor);
    			append_dev(div39, button);
    			append_dev(div39, t52);
    			if (if_block3) if_block3.m(div39, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keyup", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input0, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[33]),
    					listen_dev(input1, "focus", /*attachDatePicker*/ ctx[24](false), false, false, false),
    					listen_dev(input1, "change", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input1, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[34]),
    					listen_dev(input2, "keyup", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input2, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[35]),
    					listen_dev(input3, "keyup", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input3, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[36]),
    					listen_dev(input4, "keyup", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input4, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[37]),
    					listen_dev(input5, "keyup", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input5, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[38]),
    					listen_dev(input6, "keyup", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input6, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[39]),
    					listen_dev(select, "change", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(select, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input7, "focus", /*attachDatePicker*/ ctx[24](true), false, false, false),
    					listen_dev(input7, "change", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input7, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[40]),
    					listen_dev(input8, "change", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input8, "blur", /*blur_handler*/ ctx[41], false, false, false),
    					listen_dev(input8, "input", /*input8_input_handler*/ ctx[42]),
    					listen_dev(input9, "keyup", /*handleChange*/ ctx[21] && /*calcTotal*/ ctx[27], false, false, false),
    					listen_dev(input9, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input9, "input", /*input9_input_handler*/ ctx[43]),
    					listen_dev(input10, "keyup", /*handleChange*/ ctx[21] && /*calcTotal*/ ctx[27], false, false, false),
    					listen_dev(input10, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input10, "input", /*input10_input_handler*/ ctx[44]),
    					listen_dev(input11, "keyup", /*handleChange*/ ctx[21] && /*calcTotal*/ ctx[27], false, false, false),
    					listen_dev(input11, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input11, "input", /*input11_input_handler*/ ctx[45]),
    					listen_dev(input12, "keyup", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input12, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input12, "input", /*input12_input_handler*/ ctx[46]),
    					listen_dev(input13, "keyup", /*handleChange*/ ctx[21] && /*calcTotal*/ ctx[27], false, false, false),
    					listen_dev(input13, "blur", /*handleChange*/ ctx[21], false, false, false),
    					listen_dev(input13, "input", /*input13_input_handler*/ ctx[47]),
    					listen_dev(button, "click", /*cancel*/ ctx[29], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 4 && input0.value !== /*$form*/ ctx[2].invoice_nr) {
    				set_input_value(input0, /*$form*/ ctx[2].invoice_nr);
    			}

    			if (dirty[0] & /*okInvoiceNr, $errors, $touched*/ 36928) {
    				toggle_class(input0, "uk-form-danger", !/*okInvoiceNr*/ ctx[6] || /*$errors*/ ctx[15].invoice_nr && /*$touched*/ ctx[12].invoice_nr);
    			}

    			if (dirty[0] & /*$form*/ 4 && t2_value !== (t2_value = /*$form*/ ctx[2].payment_type + "")) set_data_dev(t2, t2_value);

    			if (dirty[0] & /*$form*/ 4 && input1.value !== /*$form*/ ctx[2].date) {
    				set_input_value(input1, /*$form*/ ctx[2].date);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 36864) {
    				toggle_class(input1, "uk-form-danger", /*$errors*/ ctx[15].date && /*$touched*/ ctx[12].date);
    			}

    			if (!/*okInvoiceNr*/ ctx[6]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_6$6(ctx);
    					if_block0.c();
    					if_block0.m(div2, t5);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*invoiceWarning*/ ctx[7]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_5$7(ctx);
    					if_block1.c();
    					if_block1.m(div2, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*$form*/ 4 && input2.value !== /*$form*/ ctx[2].name) {
    				set_input_value(input2, /*$form*/ ctx[2].name);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 36864) {
    				toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[15].name && /*$touched*/ ctx[12].name);
    			}

    			if (dirty[0] & /*$form*/ 4 && input3.value !== /*$form*/ ctx[2].email) {
    				set_input_value(input3, /*$form*/ ctx[2].email);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 36864) {
    				toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[15].email && /*$touched*/ ctx[12].email);
    			}

    			if (dirty[0] & /*$form*/ 4 && input4.value !== /*$form*/ ctx[2].address) {
    				set_input_value(input4, /*$form*/ ctx[2].address);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 36864) {
    				toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[15].address && /*$touched*/ ctx[12].address);
    			}

    			if (dirty[0] & /*$form*/ 4 && input5.value !== /*$form*/ ctx[2].zip) {
    				set_input_value(input5, /*$form*/ ctx[2].zip);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 36864) {
    				toggle_class(input5, "uk-form-danger", /*$errors*/ ctx[15].zip && /*$touched*/ ctx[12].zip);
    			}

    			if (dirty[0] & /*$form*/ 4 && input6.value !== /*$form*/ ctx[2].city) {
    				set_input_value(input6, /*$form*/ ctx[2].city);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 36864) {
    				toggle_class(input6, "uk-form-danger", /*$errors*/ ctx[15].city && /*$touched*/ ctx[12].city);
    			}

    			if (/*invoice*/ ctx[0] === undefined || /*invoice*/ ctx[0] === null || /*invoice*/ ctx[0].country === null || /*invoice*/ ctx[0].country === '' || /*$form*/ ctx[2].country === null || /*$form*/ ctx[2].country === '') {
    				if (if_block2) ; else {
    					if_block2 = create_if_block_4$8(ctx);
    					if_block2.c();
    					if_block2.m(select, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*invoice, $form*/ 5) {
    				each_value = countryArray;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*$errors, $touched*/ 36864) {
    				toggle_class(select, "uk-form-danger", /*$errors*/ ctx[15].country && /*$touched*/ ctx[12].country);
    			}

    			if (dirty[0] & /*$form*/ 4 && input7.value !== /*$form*/ ctx[2].stay_start) {
    				set_input_value(input7, /*$form*/ ctx[2].stay_start);
    			}

    			if (dirty[0] & /*needDates*/ 32) {
    				toggle_class(input7, "uk-form-danger", /*needDates*/ ctx[5]);
    			}

    			if (dirty[0] & /*$form*/ 4 && input8.value !== /*$form*/ ctx[2].stay_end) {
    				set_input_value(input8, /*$form*/ ctx[2].stay_end);
    			}

    			if (dirty[0] & /*needDates*/ 32) {
    				toggle_class(input8, "uk-form-danger", /*needDates*/ ctx[5]);
    			}

    			if (dirty[0] & /*stayDisplayLabelString*/ 512) set_data_dev(t25, /*stayDisplayLabelString*/ ctx[9]);

    			if (dirty[0] & /*$form*/ 4) {
    				toggle_class(div19, "uk-text-muted", Number(/*$form*/ ctx[2].stay_amount) === 0);
    			}

    			if (dirty[0] & /*$form*/ 4 && input9.value !== /*$form*/ ctx[2].stay_amount) {
    				set_input_value(input9, /*$form*/ ctx[2].stay_amount);
    			}

    			if (dirty[0] & /*$errors*/ 32768) {
    				toggle_class(input9, "uk-form-danger", /*$errors*/ ctx[15].stay_amount);
    			}

    			if (dirty[0] & /*$settings*/ 2048 && t31_value !== (t31_value = /*$settings*/ ctx[11].text_membership + "")) set_data_dev(t31, t31_value);

    			if (dirty[0] & /*$form*/ 4) {
    				toggle_class(div23, "uk-text-muted", Number(/*$form*/ ctx[2].membership_amount) === 0);
    			}

    			if (dirty[0] & /*$form*/ 4 && input10.value !== /*$form*/ ctx[2].membership_amount) {
    				set_input_value(input10, /*$form*/ ctx[2].membership_amount);
    			}

    			if (dirty[0] & /*$errors*/ 32768) {
    				toggle_class(input10, "uk-form-danger", /*$errors*/ ctx[15].membership_amount);
    			}

    			if (dirty[0] & /*$settings*/ 2048 && t37_value !== (t37_value = /*$settings*/ ctx[11].text_meals + "")) set_data_dev(t37, t37_value);

    			if (dirty[0] & /*$form*/ 4) {
    				toggle_class(div27, "uk-text-muted", Number(/*$form*/ ctx[2].meals_amount) === 0);
    			}

    			if (dirty[0] & /*$form*/ 4 && input11.value !== /*$form*/ ctx[2].meals_amount) {
    				set_input_value(input11, /*$form*/ ctx[2].meals_amount);
    			}

    			if (dirty[0] & /*$errors*/ 32768) {
    				toggle_class(input11, "uk-form-danger", /*$errors*/ ctx[15].meals_amount);
    			}

    			if (dirty[0] & /*$form*/ 4 && input12.value !== /*$form*/ ctx[2].custom_label) {
    				set_input_value(input12, /*$form*/ ctx[2].custom_label);
    			}

    			if (dirty[0] & /*okCustom*/ 256) {
    				toggle_class(input12, "uk-form-danger", !/*okCustom*/ ctx[8]);
    			}

    			if (dirty[0] & /*$form*/ 4 && input13.value !== /*$form*/ ctx[2].custom_amount) {
    				set_input_value(input13, /*$form*/ ctx[2].custom_amount);
    			}

    			if (dirty[0] & /*$errors*/ 32768) {
    				toggle_class(input13, "uk-form-danger", /*$errors*/ ctx[15].custom_amount);
    			}

    			if (dirty[0] & /*total*/ 8) set_data_dev(t48, /*total*/ ctx[3]);

    			if (!/*edit*/ ctx[1] || /*$role*/ ctx[13] === 'admin' || /*$role*/ ctx[13] === 'root') {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_2$d(ctx);
    					if_block3.c();
    					if_block3.m(div39, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div14);
    			if (if_block2) if_block2.d();
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t17);
    			if (detaching) detach_dev(div18);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(div22);
    			if (detaching) detach_dev(t27);
    			if (detaching) detach_dev(div26);
    			if (detaching) detach_dev(t33);
    			if (detaching) detach_dev(div30);
    			if (detaching) detach_dev(t39);
    			if (detaching) detach_dev(div34);
    			if (detaching) detach_dev(t43);
    			if (detaching) detach_dev(div38);
    			if (detaching) detach_dev(t50);
    			if (detaching) detach_dev(div39);
    			if (if_block3) if_block3.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(294:8) {#if hasPaymentType}",
    		ctx
    	});

    	return block;
    }

    // (309:20) {#if !okInvoiceNr}
    function create_if_block_6$6(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Invoice Nr already in use!";
    			attr_dev(div, "class", "uk-width-1-1 uk-text-danger");
    			add_location(div, file$o, 309, 24, 16294);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$6.name,
    		type: "if",
    		source: "(309:20) {#if !okInvoiceNr}",
    		ctx
    	});

    	return block;
    }

    // (314:20) {#if invoiceWarning}
    function create_if_block_5$7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Invoice Nr is not consecutive or wrong type. Only proceed if you know what you're doing!";
    			attr_dev(div, "class", "uk-width-1-1 uk-text-warning");
    			add_location(div, file$o, 314, 24, 16513);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$7.name,
    		type: "if",
    		source: "(314:20) {#if invoiceWarning}",
    		ctx
    	});

    	return block;
    }

    // (359:28) {#if invoice === undefined || invoice === null || invoice.country === null || invoice.country === ''                             || $form.country === null || $form.country === '' }
    function create_if_block_4$8(ctx) {
    	let option;

    	const block = {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Please select country";
    			option.__value = "";
    			option.value = option.__value;
    			option.selected = true;
    			add_location(option, file$o, 360, 32, 19932);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$8.name,
    		type: "if",
    		source: "(359:28) {#if invoice === undefined || invoice === null || invoice.country === null || invoice.country === ''                             || $form.country === null || $form.country === '' }",
    		ctx
    	});

    	return block;
    }

    // (367:32) {:else}
    function create_else_block_1$b(ctx) {
    	let option;
    	let t_value = /*country*/ ctx[53].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = /*country*/ ctx[53].title;
    			option.value = option.__value;
    			add_location(option, file$o, 367, 36, 20449);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$b.name,
    		type: "else",
    		source: "(367:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (364:32) {#if (invoice !== undefined && invoice !== null && invoice.country === country.title)                                 || ($form.country === country.title)}
    function create_if_block_3$c(ctx) {
    	let option;
    	let t_value = /*country*/ ctx[53].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text$1(t_value);
    			option.__value = /*country*/ ctx[53].title;
    			option.value = option.__value;
    			option.selected = true;
    			add_location(option, file$o, 365, 36, 20307);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$c.name,
    		type: "if",
    		source: "(364:32) {#if (invoice !== undefined && invoice !== null && invoice.country === country.title)                                 || ($form.country === country.title)}",
    		ctx
    	});

    	return block;
    }

    // (363:28) {#each countryArray as country}
    function create_each_block$g(ctx) {
    	let if_block_anchor;

    	function select_block_type_2(ctx, dirty) {
    		if (/*invoice*/ ctx[0] !== undefined && /*invoice*/ ctx[0] !== null && /*invoice*/ ctx[0].country === /*country*/ ctx[53].title || /*$form*/ ctx[2].country === /*country*/ ctx[53].title) return create_if_block_3$c;
    		return create_else_block_1$b;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(363:28) {#each countryArray as country}",
    		ctx
    	});

    	return block;
    }

    // (453:16) {#if !edit || $role === 'admin' || $role === 'root'}
    function create_if_block_2$d(ctx) {
    	let button;
    	let t_value = (/*edit*/ ctx[1] ? 'Update' : 'Create') + "";
    	let t;
    	let button_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text$1(t_value);
    			attr_dev(button, "class", "uk-button uk-margin-large-left");
    			attr_dev(button, "id", "submit");
    			attr_dev(button, "type", "submit");
    			button.disabled = button_disabled_value = !/*$isValid*/ ctx[16] || /*needDates*/ ctx[5] || !/*okInvoiceNr*/ ctx[6] || !/*okCustom*/ ctx[8];
    			toggle_class(button, "uk-button-primary", /*$isValid*/ ctx[16] && !/*needDates*/ ctx[5] && /*okInvoiceNr*/ ctx[6] && /*okCustom*/ ctx[8]);
    			add_location(button, file$o, 453, 20, 26359);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "mousedown", /*forceValidate*/ ctx[23], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*edit*/ 2 && t_value !== (t_value = (/*edit*/ ctx[1] ? 'Update' : 'Create') + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*$isValid, needDates, okInvoiceNr, okCustom*/ 65888 && button_disabled_value !== (button_disabled_value = !/*$isValid*/ ctx[16] || /*needDates*/ ctx[5] || !/*okInvoiceNr*/ ctx[6] || !/*okCustom*/ ctx[8])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (dirty[0] & /*$isValid, needDates, okInvoiceNr, okCustom*/ 65888) {
    				toggle_class(button, "uk-button-primary", /*$isValid*/ ctx[16] && !/*needDates*/ ctx[5] && /*okInvoiceNr*/ ctx[6] && /*okCustom*/ ctx[8]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$d.name,
    		type: "if",
    		source: "(453:16) {#if !edit || $role === 'admin' || $role === 'root'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let h4;
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (!/*edit*/ ctx[1] && !/*dispatched*/ ctx[10]) return create_if_block_7$5;
    		if (!/*dispatched*/ ctx[10]) return create_if_block_8$3;
    		if (/*edit*/ ctx[1]) return create_if_block_10$3;
    		return create_else_block_2$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*dispatched*/ ctx[10]) return create_if_block$n;
    		return create_else_block$m;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			if_block0.c();
    			t = space();
    			if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-inline uk-width-1-1");
    			add_location(h4, file$o, 259, 0, 13261);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			if_block0.m(h4, null);
    			insert_dev(target, t, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h4, null);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if_block0.d();
    			if (detaching) detach_dev(t);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $form;
    	let $settings;
    	let $touched;
    	let $invoiceNumbers;
    	let $role;
    	let $screenWidthL;
    	let $errors;
    	let $isValid;
    	validate_store(settings, 'settings');
    	component_subscribe($$self, settings, $$value => $$invalidate(11, $settings = $$value));
    	validate_store(invoiceNumbers, 'invoiceNumbers');
    	component_subscribe($$self, invoiceNumbers, $$value => $$invalidate(31, $invoiceNumbers = $$value));
    	validate_store(role, 'role');
    	component_subscribe($$self, role, $$value => $$invalidate(13, $role = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(14, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('InvoiceForm', slots, []);
    	let { invoice = undefined } = $$props;
    	let { booking = undefined } = $$props;
    	let { edit = false } = $$props;
    	let total = 0;
    	let hasPaymentType = false;
    	let needDates = false;
    	let okInvoiceNr = true;
    	let invoiceWarning = false;
    	let okCustom = true;
    	let stayDisplayLabelString = $settings.text_stay;
    	let dispatched = false;
    	let datePicker;

    	function logForm() {
    		console.log('$: $form.invoice_nr: invoice?.invoice_nr=' + invoice?.invoice_nr + ', getInvoiceNumber=' + getInvoiceNumber());
    		return true;
    	}

    	const dispatch = createEventDispatcher();

    	const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    		initialValues: {
    			id: null,
    			invoice_nr: '',
    			name: '',
    			email: '',
    			address: '',
    			zip: '',
    			city: '',
    			country: '',
    			date: DateTime_1.now().toSQLDate(),
    			stay_start: '',
    			stay_end: '',
    			stay_amount: 0,
    			membership_amount: 0,
    			meals_amount: 0,
    			custom_label: '',
    			custom_amount: 0,
    			payment_type: ''
    		},
    		onSubmit: values => {
    			if (!edit && !dispatched && confirm('Please be reminded that an email with the PDF of this invoice will be sent to the provided address.') || edit && !dispatched) {
    				let sendMail = true;
    				if (edit) sendMail = confirm('An email will be sent again to this person with a new PDF of the edited invoice.\nCancel to save invoice without emailing.');
    				$$invalidate(10, dispatched = true);
    				if (invoice === null) $$invalidate(0, invoice = {});
    				Object.entries(values).forEach(e => $$invalidate(0, invoice[e[0]] = e[1], invoice));

    				$$invalidate(
    					0,
    					invoice.stay_amount = invoice.stay_amount === ''
    					? 0
    					: Number(invoice.stay_amount),
    					invoice
    				);

    				$$invalidate(
    					0,
    					invoice.meals_amount = invoice.meals_amount === ''
    					? 0
    					: Number(invoice.meals_amount),
    					invoice
    				);

    				$$invalidate(
    					0,
    					invoice.membership_amount = invoice.membership_amount === ''
    					? 0
    					: Number(invoice.membership_amount),
    					invoice
    				);

    				$$invalidate(
    					0,
    					invoice.custom_amount = invoice.custom_amount === ''
    					? 0
    					: Number(invoice.custom_amount),
    					invoice
    				);

    				$$invalidate(0, invoice.total_amount = invoice.stay_amount + invoice.meals_amount + invoice.membership_amount + invoice.custom_amount, invoice);
    				if ($form.payment_type === 'cash') $$invalidate(0, invoice.date_paid = DateTime_1.now().toSQLDate(), invoice); else $$invalidate(0, invoice.date_paid = null, invoice);
    				dispatch('message', { goto: 'save', sendMail });
    			}
    		},
    		validationSchema: create$4().shape({
    			id: create$9(),
    			invoice_nr: create$6().moreThan(DateTime_1.now().minus({ years: 1 }).toFormat('yy') * 10000).lessThan(DateTime_1.now().plus({ years: 2 }).toFormat('yy') * 10000 - 1).transform((number, string) => {
    				if (!(string.length > 6 && String(string).substring(6) === 'CB') && string.length !== 6) return 0; else return Number(String(string).substring(0, 6));
    			}).required(),
    			name: create$7().min(4).max(128).required(),
    			email: create$7().max(128).email().required(),
    			address: create$7().min(4).max(256).required(),
    			zip: create$7().min(4).max(16).required(),
    			city: create$7().min(2).max(32).required(),
    			country: create$7().min(4).max(32).required(),
    			date: create$5().min(DateTime_1.now().minus({ years: 2 }).toJSDate()).max(DateTime_1.now().plus({ years: 1 }).toJSDate()).transform((date, string) => DateTime_1.fromSQL(string).toJSDate()).required(),
    			stay_start: create$9(),
    			stay_end: create$9(),
    			stay_amount: create$6().transform((number, string) => string === '' ? 0 : Number(string)),
    			membership_amount: create$6().transform((number, string) => string === '' ? 0 : Number(string)),
    			meals_amount: create$6().transform((number, string) => string === '' ? 0 : Number(string)),
    			custom_label: create$7().max(512).test('has-custom-amount', 'custom_amount > 0 requires custom_label', (value, context) => value.length > 0 || Number($form.custom_amount) === 0),
    			custom_amount: create$6().transform((number, string) => string === '' ? 0 : Number(string)).test('has-custom-label', 'custom_label requires custom_amount > 0', (value, context) => value > 0 || $form.custom_label.length === 0),
    			payment_type: create$7().min(4)
    		})
    	});

    	validate_store(form, 'form');
    	component_subscribe($$self, form, value => $$invalidate(2, $form = value));
    	validate_store(errors, 'errors');
    	component_subscribe($$self, errors, value => $$invalidate(15, $errors = value));
    	validate_store(touched, 'touched');
    	component_subscribe($$self, touched, value => $$invalidate(12, $touched = value));
    	validate_store(isValid, 'isValid');
    	component_subscribe($$self, isValid, value => $$invalidate(16, $isValid = value));

    	onMount(async () => {
    		if (invoice !== undefined && (booking === undefined || booking === null)) {
    			set_store_value(
    				form,
    				$form.id = invoice !== null && invoice.id !== null
    				? invoice.id
    				: null,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.name = invoice !== null && invoice.name !== null
    				? invoice.name
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.email = invoice !== null && invoice.email !== null
    				? invoice.email
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.address = invoice !== null && invoice.address !== null
    				? invoice.address
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.zip = invoice !== null && invoice.zip !== null
    				? invoice.zip
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.city = invoice !== null && invoice.city !== null
    				? invoice.city
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.country = invoice !== null && invoice.country !== null
    				? invoice.country
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.date = invoice !== null && invoice.date !== null
    				? invoice.date
    				: DateTime_1.now().toSQLDate(),
    				$form
    			);

    			set_store_value(
    				form,
    				$form.stay_start = invoice !== null && invoice.stay_start !== null
    				? invoice.stay_start
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.stay_end = invoice !== null && invoice.stay_end !== null
    				? invoice.stay_end
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.stay_amount = invoice !== null && invoice.stay_amount !== null
    				? invoice.stay_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.membership_amount = invoice !== null && invoice.membership_amount !== null
    				? invoice.membership_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.meals_amount = invoice !== null && invoice.meals_amount !== null
    				? invoice.meals_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.custom_label = invoice !== null && invoice.custom_label !== null
    				? invoice.custom_label
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.custom_amount = invoice !== null && invoice.custom_amount !== null
    				? invoice.custom_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.payment_type = invoice !== null && invoice.payment_type !== null
    				? invoice.payment_type
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.invoice_nr = invoice !== null && invoice.invoice_nr !== null
    				? invoice.invoice_nr
    				: getInvoiceNumber(),
    				$form
    			);

    			// ugly hack to get force evaluate isValid
    			if (invoice === null) handleSubmit(null);

    			computeDateStuff();
    		}

    		if (booking !== undefined && (invoice === undefined || invoice === null || Object.keys(invoice).length <= 2)) {
    			let member = null;
    			if (booking !== null && booking.member_id !== null && booking.member_id > 0) member = await getMemberById(booking.member_id);

    			set_store_value(
    				form,
    				$form.id = booking !== null && booking.invoice_id !== null
    				? booking.invoice_id
    				: null,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.name = booking !== null && booking.name !== null
    				? booking.name
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.email = member !== null && member.email !== null
    				? member.email
    				: booking !== null && booking.email !== null
    					? booking.email
    					: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.address = member !== null && member.address !== null
    				? member.address
    				: '',
    				$form
    			);

    			set_store_value(form, $form.zip = member !== null && member.zip !== null ? member.zip : '', $form);

    			set_store_value(
    				form,
    				$form.city = member !== null && member.city !== null
    				? member.city
    				: booking !== null && booking.city !== null
    					? booking.city
    					: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.country = member !== null && member.country !== null
    				? member.country
    				: '',
    				$form
    			);

    			set_store_value(form, $form.date = DateTime_1.now().toSQLDate(), $form);

    			set_store_value(
    				form,
    				$form.stay_start = booking !== null && booking.arrival !== null
    				? booking.arrival
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.stay_end = booking !== null && booking.departure !== null
    				? booking.departure
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.stay_amount = booking !== null && booking.stay_amount !== null
    				? booking.stay_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.membership_amount = booking !== null && booking.membership_amount !== null
    				? booking.membership_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.meals_amount = booking !== null && booking.meals_amount !== null
    				? booking.meals_amount
    				: 0,
    				$form
    			);

    			set_store_value(form, $form.custom_label = '', $form);
    			set_store_value(form, $form.custom_amount = 0, $form);
    			set_store_value(form, $form.payment_type = '', $form);

    			set_store_value(
    				form,
    				$form.invoice_nr = (invoice?.invoice_nr)
    				? invoice?.invoice_nr
    				: getInvoiceNumber(),
    				$form
    			);

    			// ugly hack to get force evaluate isValid
    			if (booking === null) handleSubmit(null);

    			computeDateStuff();
    		}

    		$$invalidate(4, hasPaymentType = $form.payment_type !== '');
    	});

    	function getInvoiceNumber() {
    		return ($settings.deleted_invoice_nrs?.length > 0
    		? $settings.deleted_invoice_nrs[0].substring(0, 6)
    		: $settings.invoice_nr) + ($form.payment_type === 'transfer' ? '' : 'CB');
    	}

    	function forceValidate() {
    		setTimeout(() => Object.keys($touched).forEach(key => set_store_value(touched, $touched[key] = true, $touched)), 100);
    	}

    	// For some weird reason flatpickr won't attach in onMount() as everywhere else. That's why here 'manually'...
    	function attachDatePicker(range) {
    		if (range) datePicker = flatpickr('#form-dates', {
    			monthSelectorType: 'static',
    			mode: 'range',
    			defaultDate: [$form.stay_start, $form.stay_end],
    			onChange(selectedDates, dateStr) {
    				set_store_value(form, $form.stay_start = dateStr.substring(0, 10), $form);
    				set_store_value(form, $form.stay_end = dateStr.substring(14), $form);
    				if ($form.stay_start !== '') document.getElementById('form-stay_start').focus();

    				if ($form.stay_end !== '') {
    					document.getElementById('form-stay_end').focus();
    					setTimeout(() => document.getElementById('form-stay_end').blur(), 0);
    				}
    			}
    		}); else datePicker = flatpickr('#form-date', { monthSelectorType: 'static' });
    	}

    	function computeDateStuff() {
    		if ($form.stay_start !== '' && $form.stay_end !== '') {
    			const startDate = DateTime_1.fromSQL($form.stay_start);
    			const endDate = DateTime_1.fromSQL($form.stay_end);
    			const dateString = startDate.toLocaleString() + '  ' + endDate.toLocaleString();

    			// if (!String($form.stay_label).includes(dateString))
    			$$invalidate(9, stayDisplayLabelString = $settings.text_stay + ' ' + dateString);
    		} // if (!excludeStayAmount) {
    		//     const days = Interval.fromDateTimes(startDate, endDate).length('days')

    		//     $form.stay_amount = days <= $settings.short_stay_duration ? days * $settings.price_stay_short : days * $settings.price_stay
    		// }
    		calcTotal();
    	}

    	function selectPaymentType(event) {
    		handleChange(event);
    		$$invalidate(4, hasPaymentType = $form.payment_type !== '');
    		if ($form.payment_type === 'cash' || $form.payment_type === 'cheque') set_store_value(form, $form.invoice_nr = $form.invoice_nr.substring(0, 6).concat('CB'), $form); else set_store_value(form, $form.invoice_nr = $form.invoice_nr.substring(0, 6), $form);
    	}

    	function calcTotal() {
    		$$invalidate(3, total = Number($form.stay_amount) + Number($form.membership_amount) + Number($form.meals_amount) + Number($form.custom_amount));
    	}

    	async function deleteMe() {
    		if (invoice !== null && invoice.id !== null && confirm("Are you sure to delete this invoice?")) {
    			dispatch('message', { goto: 'delete' });
    		}
    	}

    	function cancel() {
    		dispatch('message', { goto: 'cancel' });
    	}

    	const writable_props = ['invoice', 'booking', 'edit'];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<InvoiceForm> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		$form.payment_type = select_value(this);
    		form.set($form);
    	}

    	function input0_input_handler() {
    		$form.invoice_nr = this.value;
    		form.set($form);
    	}

    	function input1_input_handler() {
    		$form.date = this.value;
    		form.set($form);
    	}

    	function input2_input_handler() {
    		$form.name = this.value;
    		form.set($form);
    	}

    	function input3_input_handler() {
    		$form.email = this.value;
    		form.set($form);
    	}

    	function input4_input_handler() {
    		$form.address = this.value;
    		form.set($form);
    	}

    	function input5_input_handler() {
    		$form.zip = this.value;
    		form.set($form);
    	}

    	function input6_input_handler() {
    		$form.city = this.value;
    		form.set($form);
    	}

    	function input7_input_handler() {
    		$form.stay_start = this.value;
    		form.set($form);
    	}

    	const blur_handler = () => handleChange && computeDateStuff();

    	function input8_input_handler() {
    		$form.stay_end = this.value;
    		form.set($form);
    	}

    	function input9_input_handler() {
    		$form.stay_amount = this.value;
    		form.set($form);
    	}

    	function input10_input_handler() {
    		$form.membership_amount = this.value;
    		form.set($form);
    	}

    	function input11_input_handler() {
    		$form.meals_amount = this.value;
    		form.set($form);
    	}

    	function input12_input_handler() {
    		$form.custom_label = this.value;
    		form.set($form);
    	}

    	function input13_input_handler() {
    		$form.custom_amount = this.value;
    		form.set($form);
    	}

    	$$self.$$set = $$props => {
    		if ('invoice' in $$props) $$invalidate(0, invoice = $$props.invoice);
    		if ('booking' in $$props) $$invalidate(30, booking = $$props.booking);
    		if ('edit' in $$props) $$invalidate(1, edit = $$props.edit);
    	};

    	$$self.$capture_state = () => ({
    		DateTime: DateTime_1,
    		createEventDispatcher,
    		onMount,
    		createForm,
    		yup,
    		flatpickr,
    		invoiceNumbers,
    		screenWidthL,
    		countryArray,
    		getMemberById,
    		role,
    		settings,
    		invoice,
    		booking,
    		edit,
    		total,
    		hasPaymentType,
    		needDates,
    		okInvoiceNr,
    		invoiceWarning,
    		okCustom,
    		stayDisplayLabelString,
    		dispatched,
    		datePicker,
    		logForm,
    		dispatch,
    		form,
    		errors,
    		touched,
    		state,
    		isValid,
    		handleChange,
    		handleSubmit,
    		getInvoiceNumber,
    		forceValidate,
    		attachDatePicker,
    		computeDateStuff,
    		selectPaymentType,
    		calcTotal,
    		deleteMe,
    		cancel,
    		$form,
    		$settings,
    		$touched,
    		$invoiceNumbers,
    		$role,
    		$screenWidthL,
    		$errors,
    		$isValid
    	});

    	$$self.$inject_state = $$props => {
    		if ('invoice' in $$props) $$invalidate(0, invoice = $$props.invoice);
    		if ('booking' in $$props) $$invalidate(30, booking = $$props.booking);
    		if ('edit' in $$props) $$invalidate(1, edit = $$props.edit);
    		if ('total' in $$props) $$invalidate(3, total = $$props.total);
    		if ('hasPaymentType' in $$props) $$invalidate(4, hasPaymentType = $$props.hasPaymentType);
    		if ('needDates' in $$props) $$invalidate(5, needDates = $$props.needDates);
    		if ('okInvoiceNr' in $$props) $$invalidate(6, okInvoiceNr = $$props.okInvoiceNr);
    		if ('invoiceWarning' in $$props) $$invalidate(7, invoiceWarning = $$props.invoiceWarning);
    		if ('okCustom' in $$props) $$invalidate(8, okCustom = $$props.okCustom);
    		if ('stayDisplayLabelString' in $$props) $$invalidate(9, stayDisplayLabelString = $$props.stayDisplayLabelString);
    		if ('dispatched' in $$props) $$invalidate(10, dispatched = $$props.dispatched);
    		if ('datePicker' in $$props) datePicker = $$props.datePicker;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*invoice*/ 1) {
    			set_store_value(
    				form,
    				$form.invoice_nr = (invoice?.invoice_nr)
    				? invoice?.invoice_nr
    				: getInvoiceNumber(),
    				$form
    			);
    		}

    		if ($$self.$$.dirty[0] & /*$form*/ 4) {
    			$$invalidate(5, needDates = $form.stay_amount > 0
    			? $form.stay_start === '' || $form.stay_end === ''
    			: $form.stay_start !== '' && $form.stay_end === '');
    		}

    		if ($$self.$$.dirty[0] & /*invoice, $form*/ 5 | $$self.$$.dirty[1] & /*$invoiceNumbers*/ 1) {
    			$$invalidate(6, okInvoiceNr = invoice?.invoice_nr !== null && invoice?.invoice_nr.substring(0, 6) === $form.invoice_nr.substring(0, 6) || !$invoiceNumbers.includes($form.invoice_nr.substring(0, 6)));
    		}

    		if ($$self.$$.dirty[0] & /*$form*/ 4) {
    			$$invalidate(8, okCustom = !($form.custom_amount !== '' && Number($form.custom_amount > 0) && $form.custom_label === ''));
    		}

    		if ($$self.$$.dirty[0] & /*$form, invoice*/ 5 | $$self.$$.dirty[1] & /*$invoiceNumbers*/ 1) {
    			$$invalidate(7, invoiceWarning = /* Number($form.invoice_nr.substring(0, 6)) !== $settings.invoice_nr && */
    			$form.invoice_nr !== getInvoiceNumber() && (invoice?.invoice_nr !== null && invoice?.invoice_nr !== $form.invoice_nr) && !$invoiceNumbers.includes($form.invoice_nr.substring(0, 6)));
    		}
    	};

    	return [
    		invoice,
    		edit,
    		$form,
    		total,
    		hasPaymentType,
    		needDates,
    		okInvoiceNr,
    		invoiceWarning,
    		okCustom,
    		stayDisplayLabelString,
    		dispatched,
    		$settings,
    		$touched,
    		$role,
    		$screenWidthL,
    		$errors,
    		$isValid,
    		form,
    		errors,
    		touched,
    		isValid,
    		handleChange,
    		handleSubmit,
    		forceValidate,
    		attachDatePicker,
    		computeDateStuff,
    		selectPaymentType,
    		calcTotal,
    		deleteMe,
    		cancel,
    		booking,
    		$invoiceNumbers,
    		select_change_handler,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		input7_input_handler,
    		blur_handler,
    		input8_input_handler,
    		input9_input_handler,
    		input10_input_handler,
    		input11_input_handler,
    		input12_input_handler,
    		input13_input_handler
    	];
    }

    class InvoiceForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$o, create_fragment$o, safe_not_equal, { invoice: 0, booking: 30, edit: 1 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InvoiceForm",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get invoice() {
    		throw new Error("<InvoiceForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set invoice(value) {
    		throw new Error("<InvoiceForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get booking() {
    		throw new Error("<InvoiceForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set booking(value) {
    		throw new Error("<InvoiceForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get edit() {
    		throw new Error("<InvoiceForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set edit(value) {
    		throw new Error("<InvoiceForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Invoice.svelte generated by Svelte v3.45.0 */
    const file$n = "src/components/Invoice.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	return child_ctx;
    }

    // (177:8) {:else }
    function create_else_block$l(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let th5;
    	let t11;
    	let th6;
    	let t13;
    	let tbody;
    	let each_value = /*data*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Invoice Nr";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Date";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Name";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Stay";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Type";
    			t9 = space();
    			th5 = element("th");
    			th5.textContent = "Amount";
    			t11 = space();
    			th6 = element("th");
    			th6.textContent = "PDF";
    			t13 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(th0, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(th0, file$n, 180, 20, 7229);
    			add_location(th1, file$n, 181, 20, 7308);
    			add_location(th2, file$n, 182, 20, 7342);
    			attr_dev(th3, "class", "uk-visible@m");
    			add_location(th3, file$n, 183, 20, 7376);
    			add_location(th4, file$n, 184, 20, 7431);
    			attr_dev(th5, "class", "uk-visible@s uk-table-shrink uk-text-nowrap");
    			add_location(th5, file$n, 185, 20, 7465);
    			attr_dev(th6, "class", "uk-visible@s uk-table-shrink uk-text-nowrap");
    			add_location(th6, file$n, 186, 20, 7553);
    			add_location(tr, file$n, 179, 16, 7204);
    			add_location(thead, file$n, 178, 16, 7180);
    			add_location(tbody, file$n, 189, 16, 7681);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$n, 177, 12, 7078);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(table, t13);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*download, data, openForm*/ 10241) {
    				each_value = /*data*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$l.name,
    		type: "else",
    		source: "(177:8) {:else }",
    		ctx
    	});

    	return block;
    }

    // (175:8) {#if data.length === 0}
    function create_if_block$m(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading invoices...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(175:8) {#if data.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (200:28) {#if invoice.pdf_path !== null}
    function create_if_block_1$d(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[19](/*invoice*/ ctx[29]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "file-pdf");
    			add_location(a, file$n, 200, 32, 8744);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler_5, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(200:28) {#if invoice.pdf_path !== null}",
    		ctx
    	});

    	return block;
    }

    // (191:16) {#each data as invoice}
    function create_each_block$f(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*invoice*/ ctx[29].invoice_nr + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = DateTime_1.fromSQL(/*invoice*/ ctx[29].date).toFormat('dd LLL yyyy') + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*invoice*/ ctx[29].name + "";
    	let t4;
    	let t5;
    	let td3;

    	let t6_value = (/*invoice*/ ctx[29].stay_start !== null && /*invoice*/ ctx[29].stay_end !== null
    	? DateTime_1.fromSQL(/*invoice*/ ctx[29].stay_start).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*invoice*/ ctx[29].stay_end).toFormat('dd LLL yyyy')
    	: '  ') + "";

    	let t6;
    	let t7;
    	let td4;
    	let span;
    	let t8_value = /*invoice*/ ctx[29].payment_type + "";
    	let t8;
    	let t9;
    	let td5;
    	let t10_value = /*invoice*/ ctx[29].total_amount + "";
    	let t10;
    	let t11;
    	let td6;
    	let t12;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[14](/*invoice*/ ctx[29]);
    	}

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[15](/*invoice*/ ctx[29]);
    	}

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[16](/*invoice*/ ctx[29]);
    	}

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[17](/*invoice*/ ctx[29]);
    	}

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[18](/*invoice*/ ctx[29]);
    	}

    	let if_block = /*invoice*/ ctx[29].pdf_path !== null && create_if_block_1$d(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element("td");
    			span = element("span");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			td6 = element("td");
    			if (if_block) if_block.c();
    			t12 = space();
    			add_location(td0, file$n, 192, 24, 7800);
    			add_location(td1, file$n, 193, 24, 7889);
    			add_location(td2, file$n, 194, 24, 8014);
    			attr_dev(td3, "class", "uk-visible@m");
    			add_location(td3, file$n, 195, 24, 8097);
    			attr_dev(span, "class", "uk-label uk-margin-remove uk-background-secondary");
    			add_location(span, file$n, 196, 28, 8391);
    			add_location(td4, file$n, 196, 24, 8387);
    			attr_dev(td5, "class", "uk-visible@s");
    			add_location(td5, file$n, 197, 24, 8514);
    			attr_dev(td6, "class", "uk-visible@s");
    			add_location(td6, file$n, 198, 24, 8626);
    			attr_dev(tr, "class", "uk-table-link");
    			add_location(tr, file$n, 191, 20, 7749);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, span);
    			append_dev(span, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			append_dev(td5, t10);
    			append_dev(tr, t11);
    			append_dev(tr, td6);
    			if (if_block) if_block.m(td6, null);
    			append_dev(tr, t12);

    			if (!mounted) {
    				dispose = [
    					listen_dev(td0, "click", click_handler, false, false, false),
    					listen_dev(td1, "click", click_handler_1, false, false, false),
    					listen_dev(td2, "click", click_handler_2, false, false, false),
    					listen_dev(td3, "click", click_handler_3, false, false, false),
    					listen_dev(td5, "click", click_handler_4, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*data*/ 1 && t0_value !== (t0_value = /*invoice*/ ctx[29].invoice_nr + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*data*/ 1 && t2_value !== (t2_value = DateTime_1.fromSQL(/*invoice*/ ctx[29].date).toFormat('dd LLL yyyy') + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*data*/ 1 && t4_value !== (t4_value = /*invoice*/ ctx[29].name + "")) set_data_dev(t4, t4_value);

    			if (dirty[0] & /*data*/ 1 && t6_value !== (t6_value = (/*invoice*/ ctx[29].stay_start !== null && /*invoice*/ ctx[29].stay_end !== null
    			? DateTime_1.fromSQL(/*invoice*/ ctx[29].stay_start).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*invoice*/ ctx[29].stay_end).toFormat('dd LLL yyyy')
    			: '  ') + "")) set_data_dev(t6, t6_value);

    			if (dirty[0] & /*data*/ 1 && t8_value !== (t8_value = /*invoice*/ ctx[29].payment_type + "")) set_data_dev(t8, t8_value);
    			if (dirty[0] & /*data*/ 1 && t10_value !== (t10_value = /*invoice*/ ctx[29].total_amount + "")) set_data_dev(t10, t10_value);

    			if (/*invoice*/ ctx[29].pdf_path !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$d(ctx);
    					if_block.c();
    					if_block.m(td6, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(191:16) {#each data as invoice}",
    		ctx
    	});

    	return block;
    }

    // (229:16) {#key recreateForm}
    function create_key_block$8(ctx) {
    	let invoiceform;
    	let updating_invoice;
    	let updating_edit;
    	let current;

    	function invoiceform_invoice_binding(value) {
    		/*invoiceform_invoice_binding*/ ctx[21](value);
    	}

    	function invoiceform_edit_binding(value) {
    		/*invoiceform_edit_binding*/ ctx[22](value);
    	}

    	let invoiceform_props = {};

    	if (/*selectedInvoice*/ ctx[4] !== void 0) {
    		invoiceform_props.invoice = /*selectedInvoice*/ ctx[4];
    	}

    	if (/*editInvoice*/ ctx[5] !== void 0) {
    		invoiceform_props.edit = /*editInvoice*/ ctx[5];
    	}

    	invoiceform = new InvoiceForm({ props: invoiceform_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(invoiceform, 'invoice', invoiceform_invoice_binding));
    	binding_callbacks.push(() => bind$1(invoiceform, 'edit', invoiceform_edit_binding));
    	invoiceform.$on("message", /*processInvoice*/ ctx[12]);

    	const block = {
    		c: function create() {
    			create_component(invoiceform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(invoiceform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const invoiceform_changes = {};

    			if (!updating_invoice && dirty[0] & /*selectedInvoice*/ 16) {
    				updating_invoice = true;
    				invoiceform_changes.invoice = /*selectedInvoice*/ ctx[4];
    				add_flush_callback(() => updating_invoice = false);
    			}

    			if (!updating_edit && dirty[0] & /*editInvoice*/ 32) {
    				updating_edit = true;
    				invoiceform_changes.edit = /*editInvoice*/ ctx[5];
    				add_flush_callback(() => updating_edit = false);
    			}

    			invoiceform.$set(invoiceform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(invoiceform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(invoiceform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(invoiceform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$8.name,
    		type: "key",
    		source: "(229:16) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let input;
    	let input_class_value;
    	let t0;
    	let button0;
    	let span;

    	let t1_value = (/*$screenWidthS*/ ctx[7]
    	? ''
    	: /*$screenWidthM*/ ctx[8]
    		? '\xa0invoice'
    		: '\xa0New invoice') + "";

    	let t1;
    	let t2;
    	let div4;
    	let div3;
    	let t3;
    	let infinitescroll;
    	let t4;
    	let div8;
    	let div7;
    	let button1;
    	let t5;
    	let div6;
    	let div5;
    	let previous_key = /*recreateForm*/ ctx[6];
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0) return create_if_block$m;
    		return create_else_block$l;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	infinitescroll = new InfiniteScroll({
    			props: {
    				hasMore: /*newBatch*/ ctx[1].length,
    				threshold: 80
    			},
    			$$inline: true
    		});

    	infinitescroll.$on("loadMore", /*loadMore_handler*/ ctx[20]);
    	let key_block = create_key_block$8(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			button0 = element("button");
    			span = element("span");
    			t1 = text$1(t1_value);
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			if_block.c();
    			t3 = space();
    			create_component(infinitescroll.$$.fragment);
    			t4 = space();
    			div8 = element("div");
    			div7 = element("div");
    			button1 = element("button");
    			t5 = space();
    			div6 = element("div");
    			div5 = element("div");
    			key_block.c();

    			attr_dev(input, "class", input_class_value = "uk-input " + (/*$screenWidthS*/ ctx[7]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[8] || /*$screenWidthL*/ ctx[9]
    				? 'uk-width-medium'
    				: 'uk-width-large'));

    			attr_dev(input, "id", "autocomplete");
    			attr_dev(input, "type", "search");
    			attr_dev(input, "spellcheck", "false");
    			attr_dev(input, "autocorrect", "off");
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "autocapitalize", "off");
    			attr_dev(input, "maxlength", "256");
    			add_location(input, file$n, 166, 12, 6296);
    			attr_dev(span, "uk-icon", "icon: plus; ratio: 0.6");
    			add_location(span, file$n, 167, 114, 6667);
    			attr_dev(button0, "class", "uk-button uk-button-small uk-button-primary uk-margin-large-left");
    			add_location(button0, file$n, 167, 12, 6565);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$n, 165, 8, 6247);
    			attr_dev(div1, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6 paf-top-section-bg");
    			add_location(div1, file$n, 164, 4, 6149);
    			attr_dev(div2, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div2, file$n, 163, 0, 6071);
    			attr_dev(div3, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6");
    			add_location(div3, file$n, 173, 4, 6914);
    			attr_dev(div4, "class", "uk-flex uk-flex-center");
    			set_style(div4, "max-height", "75%");
    			set_style(div4, "overflow-x", "scroll");
    			add_location(div4, file$n, 172, 0, 6828);
    			attr_dev(button1, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "uk-close", "");
    			add_location(button1, file$n, 224, 8, 9438);
    			attr_dev(div5, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div5, "uk-height-viewport", "");
    			add_location(div5, file$n, 226, 12, 9579);
    			attr_dev(div6, "class", "uk-flex uk-flex-center");
    			add_location(div6, file$n, 225, 8, 9530);
    			attr_dev(div7, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div7, file$n, 223, 4, 9368);
    			attr_dev(div8, "id", "modal-full");
    			attr_dev(div8, "class", "uk-modal-full");
    			attr_dev(div8, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div8, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[8]);
    			add_location(div8, file$n, 219, 0, 9217);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			append_dev(div0, t0);
    			append_dev(div0, button0);
    			append_dev(button0, span);
    			append_dev(button0, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			if_block.m(div3, null);
    			append_dev(div4, t3);
    			mount_component(infinitescroll, div4, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, button1);
    			append_dev(div7, t5);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			key_block.m(div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*openForm*/ ctx[11], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*$screenWidthS, $screenWidthM, $screenWidthL*/ 896 && input_class_value !== (input_class_value = "uk-input " + (/*$screenWidthS*/ ctx[7]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[8] || /*$screenWidthL*/ ctx[9]
    				? 'uk-width-medium'
    				: 'uk-width-large'))) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if ((!current || dirty[0] & /*$screenWidthS, $screenWidthM*/ 384) && t1_value !== (t1_value = (/*$screenWidthS*/ ctx[7]
    			? ''
    			: /*$screenWidthM*/ ctx[8]
    				? '\xa0invoice'
    				: '\xa0New invoice') + "")) set_data_dev(t1, t1_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			}

    			const infinitescroll_changes = {};
    			if (dirty[0] & /*newBatch*/ 2) infinitescroll_changes.hasMore = /*newBatch*/ ctx[1].length;
    			infinitescroll.$set(infinitescroll_changes);

    			if (dirty[0] & /*recreateForm*/ 64 && safe_not_equal(previous_key, previous_key = /*recreateForm*/ ctx[6])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block$8(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div5, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (dirty[0] & /*$screenWidthM*/ 256) {
    				toggle_class(div8, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(infinitescroll.$$.fragment, local);
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(infinitescroll.$$.fragment, local);
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div4);
    			if_block.d();
    			destroy_component(infinitescroll);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div8);
    			key_block.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $invoiceNames;
    	let $invoiceNumberStrings;
    	let $screenWidthS;
    	let $screenWidthM;
    	let $screenWidthL;
    	validate_store(invoiceNames, 'invoiceNames');
    	component_subscribe($$self, invoiceNames, $$value => $$invalidate(24, $invoiceNames = $$value));
    	validate_store(invoiceNumberStrings, 'invoiceNumberStrings');
    	component_subscribe($$self, invoiceNumberStrings, $$value => $$invalidate(25, $invoiceNumberStrings = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(7, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(8, $screenWidthM = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(9, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Invoice', slots, []);
    	let page = 1;
    	let maxPage = 2;
    	let data = [];
    	let newBatch = [];
    	let autocompleteData = [];
    	let selectedInvoice;
    	let editInvoice = false;
    	let recreateForm = false;
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		await fetchData();
    		autocompleteData = [...$invoiceNumberStrings, ...$invoiceNames];

    		const autoCompleteJS = new autoComplete({
    				selector: "#autocomplete",
    				placeHolder: "Search invoices...",
    				diacritics: true,
    				searchEngine: 'strict',
    				data: { src: autocompleteData, cache: true },
    				resultsList: {
    					element: (list, data) => {
    						if (!data.results.length) {
    							const message = document.createElement("div");
    							message.setAttribute("class", "no_result");
    							message.innerHTML = `<span>No Invoice for "${data.query}"</span>`;
    							list.prepend(message);
    						}
    					},
    					maxResults: 50,
    					noResults: true
    				},
    				resultItem: { highlight: true },
    				events: {
    					input: {
    						selection: event => {
    							let input = event.detail.selection.value;
    							autoCompleteJS.input.value = input;
    							if ($invoiceNumberStrings.findIndex(number => number === input) > -1) fetchInvoice({ invoice_nr: input });
    							if ($invoiceNames.findIndex(name => name === input) > -1) fetchInvoice({ name: input });
    						},
    						keyup: () => {
    							if (autoCompleteJS.input.value === '') fetchInvoice(null);
    						}
    					}
    				}
    			});
    	});

    	async function fetchData() {
    		const response = await getInvoices(page);
    		$$invalidate(3, maxPage = response.meta.last_page);
    		$$invalidate(1, newBatch = await response.data);
    	}

    	async function fetchInvoice(queryField) {
    		if (queryField !== null) {
    			$$invalidate(1, newBatch = []);
    			if (queryField.invoice_nr) $$invalidate(0, data = [...await getInvoiceByNumber(queryField.invoice_nr)]);
    			if (queryField.name) $$invalidate(0, data = [...await getInvoiceByName(queryField.name)]);
    		} else {
    			$$invalidate(0, data = []);
    			$$invalidate(2, page = 1);
    			await fetchData();
    		}
    	}

    	function dispatchReload() {
    		dispatch('message', { reload: 'invoice' });
    	}

    	function openForm(invoice) {
    		dispatch('message', { reload: 'settings' });

    		$$invalidate(4, selectedInvoice = invoice instanceof MouseEvent
    		? null
    		: JSON.parse(JSON.stringify(invoice)));

    		$$invalidate(5, editInvoice = selectedInvoice !== null);
    		$$invalidate(6, recreateForm = !recreateForm);
    		uikit.modal("#modal-full").show();
    	}

    	async function processInvoice(event) {
    		if (event.detail.goto !== undefined) {
    			switch (event.detail.goto) {
    				case 'cancel':
    					uikit.modal("#modal-full").hide();
    					break;
    				case 'save':
    					const sendMail = event.detail.sendMail ? event.detail.sendMail : false;
    					let invoiceSuccess;
    					if (!editInvoice) invoiceSuccess = await createInvoice(selectedInvoice); else if (selectedInvoice.id !== undefined && selectedInvoice.id !== null) invoiceSuccess = await updateInvoice(selectedInvoice, sendMail);
    					if (invoiceSuccess?.id) uikit.notification('<span uk-icon="icon: check"></span> Invoice ' + (editInvoice ? 'updated!' : 'created!'), { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    					if (invoiceSuccess?.mail) uikit.notification('<span uk-icon="icon: check"></span> Email sent!', { status: 'success', pos: 'bottom-center' });
    					if (invoiceSuccess && invoiceSuccess.number !== selectedInvoice.invoice_nr) alert('Invoice number has changed to ' + invoiceSuccess.number + '!\nPlease correct in payment sheet if this is an in-house payment!');
    					uikit.modal("#modal-full").hide();
    					dispatchReload();
    					break;
    				case 'delete':
    					const success = await deleteInvoice(selectedInvoice.id);
    					if (success) {
    						uikit.modal("#modal-full").hide();
    						uikit.notification('<span uk-icon="icon: check"></span> Successfully deleted', { status: 'success', pos: 'bottom-center' });
    					} else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    					dispatchReload();
    					break;
    			}
    		}
    	}

    	function download(invoice) {
    		downloadPDF(invoice.id, invoice.pdf_path);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Invoice> was created with unknown prop '${key}'`);
    	});

    	const click_handler = invoice => openForm(invoice);
    	const click_handler_1 = invoice => openForm(invoice);
    	const click_handler_2 = invoice => openForm(invoice);
    	const click_handler_3 = invoice => openForm(invoice);
    	const click_handler_4 = invoice => openForm(invoice);
    	const click_handler_5 = invoice => download(invoice);

    	const loadMore_handler = () => {
    		if (page < maxPage) {
    			$$invalidate(2, page++, page);
    			fetchData();
    		}
    	};

    	function invoiceform_invoice_binding(value) {
    		selectedInvoice = value;
    		$$invalidate(4, selectedInvoice);
    	}

    	function invoiceform_edit_binding(value) {
    		editInvoice = value;
    		$$invalidate(5, editInvoice);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		createInvoice,
    		downloadPDF,
    		getInvoiceByName,
    		getInvoiceByNumber,
    		getInvoices,
    		invoiceNames,
    		invoiceNumberStrings,
    		updateInvoice,
    		deleteInvoice,
    		InfiniteScroll,
    		UIkit: uikit,
    		screenWidthS,
    		screenWidthL,
    		screenWidthM,
    		autoComplete,
    		InvoiceForm,
    		DateTime: DateTime_1,
    		page,
    		maxPage,
    		data,
    		newBatch,
    		autocompleteData,
    		selectedInvoice,
    		editInvoice,
    		recreateForm,
    		dispatch,
    		fetchData,
    		fetchInvoice,
    		dispatchReload,
    		openForm,
    		processInvoice,
    		download,
    		$invoiceNames,
    		$invoiceNumberStrings,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL
    	});

    	$$self.$inject_state = $$props => {
    		if ('page' in $$props) $$invalidate(2, page = $$props.page);
    		if ('maxPage' in $$props) $$invalidate(3, maxPage = $$props.maxPage);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('newBatch' in $$props) $$invalidate(1, newBatch = $$props.newBatch);
    		if ('autocompleteData' in $$props) autocompleteData = $$props.autocompleteData;
    		if ('selectedInvoice' in $$props) $$invalidate(4, selectedInvoice = $$props.selectedInvoice);
    		if ('editInvoice' in $$props) $$invalidate(5, editInvoice = $$props.editInvoice);
    		if ('recreateForm' in $$props) $$invalidate(6, recreateForm = $$props.recreateForm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*data, newBatch*/ 3) {
    			$$invalidate(0, data = [...data, ...newBatch]);
    		}
    	};

    	return [
    		data,
    		newBatch,
    		page,
    		maxPage,
    		selectedInvoice,
    		editInvoice,
    		recreateForm,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		fetchData,
    		openForm,
    		processInvoice,
    		download,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		loadMore_handler,
    		invoiceform_invoice_binding,
    		invoiceform_edit_binding
    	];
    }

    class Invoice extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$n, create_fragment$n, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Invoice",
    			options,
    			id: create_fragment$n.name
    		});
    	}
    }

    /**
     * Wrapper class that handles upgrading a normal checkbox into a SimpleSwitch.
     */
    class Switch {

        /**
         * Constructor for a new Switch.
         *
         * @param {Object} config The configuration information for the new Switch.
         *
         * @param {HTMLElement} config.element The HTMLElement object repesenting
         *  the checkbox to upgrade. Either this or config.selector MUST be
         *  specified.
         *
         * @param {String} config.selector The CSS selector that specifies the
         *  checkbox to be upgraded. Either this or the config.element MUST be
         *  specified.
         *
         * @param {Boolean} config.material Defaults to false. If true, will render
         *  the new Switch in a Material Design-inspired look.
         *
         * @param {Boolean} config.matchSizeToFont Defaults to false. If true, will
         *  attempt to figure out the impled font size for the Switch, and match
         *  its size to that font size.
         */
        constructor(config) {
            // set/get basic properties from config or defaults
            this.element = config.element
                || document.querySelector(config.selector);
            this.isMaterial = typeof config.material !== 'undefined'
                ? config.material : false;
            this.checked = !!this.element.checked;
            this.matchSizeToFont = typeof config.matchSizeToFont !== 'undefined' ?
                config.matchSizeToFont : false;

            // override from property
            if(this.element.dataset.material
                && this.element.dataset.material === "true") {
                this.isMaterial = true;
            }

            // actually create the elements that make up the Switch
            this.setup();
        }

        /**
         * Creates the elements that make up the Switch.
         */
        setup() {
            this.track = document.createElement("button");
            this.handle = document.createElement("span");

            this.element.classList.add("_simple-switch-checkbox");
            this.track.classList.add("_simple-switch-track");
            this.handle.classList.add("handle");

            if(this.isMaterial) {
                this.track.classList.add("_material");
            }

            if(this.checked) {
                this.track.classList.add(Switch.CHECKED_CLASS_NAME);
            }

            this.checkboxDisabled(!!this.element.disabled);

            // The track itself, despite being a button, shouldn't be tabbed to.
            // Instead, when the original checkbox gains focus, the Javascript will
            // update the track. This is so that screenreaders still read the
            // Switch as a checkbox.
            this.track.setAttribute("tabindex", -1);

            this.bind();

            this.track.appendChild(this.handle);
            this.element.insertAdjacentElement('afterend', this.track);

            this.updateSize();
        }

        /**
         * Updates the size of the Switch to match the inherited font size. Only
         * works on browsers that support CSS variables for now.
         */
        updateSize() {
            if(!this.matchSizeToFont) {
                return;
            }

            const _style = window.getComputedStyle(this.track);
            const inheritedFontSize = _style['font-size'];

            this.track.style.setProperty('--simple-switch_size', inheritedFontSize);
        }

        /**
         * Takes care of binding all relevant events from the checkbox so that the
         * Switch can update itself when those events happen.
         */
        bind() {
            this.track.addEventListener("click", this.handleTrackClick.bind(this), false);
            this.element.addEventListener("focus", this.handleElementFocus.bind(this), false);
            this.element.addEventListener("blur", this.handleElementBlur.bind(this), false);
            this.element.addEventListener("click", this.handleElementClick.bind(this), false);

            /** @private */
            // Bind changes to the attributes
            this.observer = new MutationObserver(this.handleMutation.bind(this));
            this.observer.observe(this.element, { attributes: true });
        }

        /**
         * Called automatically when the wrapped checkbox gains focus.
         *
         * @param {FocusEvent} e The focus event object.
         */
        checkboxFocused(e) {
            this.track.classList.add(Switch.FOCUSED_CLASS_NAME);
        }

        /**
         * Called automatically when the wrapped checkbox loses focus.
         *
         * @param {BlurEvent} e The blur event object.
         */
        checkboxBlurred(e) {
            this.track.classList.remove(Switch.FOCUSED_CLASS_NAME);
        }

        /**
         * Called automatically when the Switch track is clicked.
         *
         * @param {ClickEvent} e The click event object.
         */
        trackClicked(e) {
            this.toggle();
        }

        /**
         * Called automatically when the wrapped checkbox is clicked.
         *
         * @param {ClickEvent} e The click event object.
         */
        checkboxToggled(e) {
            this.toggle();
        }

        /**
         * Called automatically when the wrapped checkbox is disabled.
         *
         * @param {Boolean} disabled Whether the checkbox is now disabled
         */
        checkboxDisabled(disabled) {
            this.disabled = disabled;

            if (this.disabled) {
                this.track.classList.add(Switch.DISABLED_CLASS_NAME);
            } else {
                this.track.classList.remove(Switch.DISABLED_CLASS_NAME);
            }
        }

        /**
         * Toggles the state of the Switch. Also takes care of making sure the
         * wrapped checkbox is also updated.
         */
        toggle() {
            this.checked = this.track.classList.toggle(Switch.CHECKED_CLASS_NAME);

            this.syncState();
        }

        /**
         * Manages syncing the state between the Switch and the wrapped checkbox.
         */
        syncState() {
            this.element.checked = this.checked;
            this.dispatchEvent();
        }

        /**
         * Dispatches relevant events for the element changing, trying to emulate
         * natural <input> elements as much as possible.
         * @private
         */
        dispatchEvent() {
            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event
            const changeEvent = new Event("change");
            this.element.dispatchEvent(changeEvent);
            // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event
            const inputEvent = new Event("input");
            this.element.dispatchEvent(inputEvent);
        }

        handleTrackClick(e) {
            if (this.disabled) {
                e.preventDefault();
                return;
            }
            this.trackClicked(e);
        }

        handleElementFocus(e) {
            this.checkboxFocused(e);
        }

        handleElementBlur(e) {
            this.checkboxBlurred(e);
        }

        handleElementClick(e) {
            if (this.disabled) {
                e.preventDefault();
                return;
            }

            this.checkboxToggled(e);
        }

        handleMutation(mutations) {
            mutations.forEach((mutation) => {
                if (mutation.type !== "attributes") {
                    return;
                }
                // Check the modified attributeName is "disabled"
                if (mutation.attributeName === "disabled") {
                    const disabled = !!mutation.target.attributes["disabled"];
                    this.checkboxDisabled(disabled);
                }
            });
        }

        static get CHECKED_CLASS_NAME() {
            return "on";
        }

        static get FOCUSED_CLASS_NAME() {
            return "focus";
        }

        static get DISABLED_CLASS_NAME() {
            return "_simple-switch_disabled";
        }
    }

    // Takes care of finding Switches within the site code.
    var init$1 = function(options={}) {
        var x, _switch,
            switches = document.querySelectorAll(
                "[data-type='simple-switch']:not(._simple-switch-checkbox)"
            );

        for(x = 0; x < switches.length; x++) {
            _switch = switches[x];

            new Switch({
                element: _switch,
                ...options
            });
        }
    };

    var SimpleSwitch = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Switch: Switch,
        init: init$1
    });

    /* src/components/PaymentForm.svelte generated by Svelte v3.45.0 */
    const file$m = "src/components/PaymentForm.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	return child_ctx;
    }

    // (141:4) {:else }
    function create_else_block_4$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Payment processing");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4$3.name,
    		type: "else",
    		source: "(141:4) {:else }",
    		ctx
    	});

    	return block;
    }

    // (139:4) {#if !dispatched}
    function create_if_block_10$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Payment");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$2.name,
    		type: "if",
    		source: "(139:4) {#if !dispatched}",
    		ctx
    	});

    	return block;
    }

    // (149:0) {:else}
    function create_else_block$k(ctx) {
    	let form_1;
    	let div0;
    	let t0;
    	let div10;
    	let div9;
    	let div3;
    	let label0;
    	let t2;
    	let div1;
    	let input0;
    	let t3;
    	let span0;
    	let t5;
    	let span1;
    	let t6;
    	let label1;
    	let t8;
    	let div2;
    	let input1;
    	let t9;
    	let span2;
    	let t11;
    	let span3;
    	let t12;
    	let t13;
    	let div8;
    	let label2;
    	let t15;
    	let div4;
    	let input2;
    	let t16;
    	let label3;
    	let t18;
    	let div5;
    	let input3;
    	let t19;
    	let t20;
    	let label4;
    	let t22;
    	let div7;
    	let div6;
    	let t23;
    	let t24;
    	let div11;
    	let button0;
    	let t26;
    	let button1;
    	let t27;
    	let button1_disabled_value;
    	let t28;
    	let button2;
    	let t29;
    	let button2_disabled_value;
    	let mounted;
    	let dispose;
    	let if_block0 = /*booking*/ ctx[0] && create_if_block_3$b(ctx);
    	let if_block1 = /*booking*/ ctx[0]?.sci_member && !/*booking*/ ctx[0]?.no_stay_pay && create_if_block_2$c(ctx);
    	let if_block2 = /*booking*/ ctx[0]?.paf_events?.length > 0 && create_if_block_1$c(ctx);

    	const block = {
    		c: function create() {
    			form_1 = element("form");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div10 = element("div");
    			div9 = element("div");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Stay rate";
    			t2 = space();
    			div1 = element("div");
    			input0 = element("input");
    			t3 = text$1("\n                        ");
    			span0 = element("span");
    			span0.textContent = " per night";
    			t5 = text$1(" ");
    			span1 = element("span");
    			t6 = space();
    			label1 = element("label");
    			label1.textContent = "Institution";
    			t8 = space();
    			div2 = element("div");
    			input1 = element("input");
    			t9 = text$1("\n                        ");
    			span2 = element("span");
    			span2.textContent = "Institutional rate";
    			t11 = text$1(" ");
    			span3 = element("span");
    			t12 = space();
    			if (if_block1) if_block1.c();
    			t13 = space();
    			div8 = element("div");
    			label2 = element("label");
    			label2.textContent = "Stay";
    			t15 = space();
    			div4 = element("div");
    			input2 = element("input");
    			t16 = space();
    			label3 = element("label");
    			label3.textContent = "Membership";
    			t18 = space();
    			div5 = element("div");
    			input3 = element("input");
    			t19 = space();
    			if (if_block2) if_block2.c();
    			t20 = space();
    			label4 = element("label");
    			label4.textContent = "TOTAL";
    			t22 = space();
    			div7 = element("div");
    			div6 = element("div");
    			t23 = text$1(/*total*/ ctx[5]);
    			t24 = space();
    			div11 = element("div");
    			button0 = element("button");
    			button0.textContent = "Cancel";
    			t26 = space();
    			button1 = element("button");
    			t27 = text$1("Squid");
    			t28 = space();
    			button2 = element("button");
    			t29 = text$1("Invoice");
    			attr_dev(div0, "class", "uk-margin-medium uk-padding uk-text-justify uk-background-muted uk-text-emphasis");
    			toggle_class(div0, "uk-text-small", /*$screenWidthS*/ ctx[8]);
    			add_location(div0, file$m, 151, 8, 6569);
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-stay_rate");
    			add_location(label0, file$m, 192, 20, 9231);
    			attr_dev(input0, "class", "uk-input uk-width-1-4@s");
    			attr_dev(input0, "id", "form-stay_rate");
    			attr_dev(input0, "name", "stay_rate");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Rate");
    			attr_dev(input0, "maxlength", "4");
    			set_style(input0, "color", "black");
    			toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[9].stay_rate && /*$touched*/ ctx[10].stay_rate);
    			add_location(input0, file$m, 194, 24, 9397);
    			attr_dev(span0, "class", "uk-text-meta");
    			add_location(span0, file$m, 197, 30, 9811);
    			attr_dev(span1, "uk-icon", "icon: info");
    			attr_dev(span1, "uk-tooltip", "title: Adjust for sliding scale or institutional rate!");
    			add_location(span1, file$m, 197, 82, 9863);
    			attr_dev(div1, "class", "uk-form-controls uk-margin-small-bottom");
    			add_location(div1, file$m, 193, 20, 9319);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "form-institutional");
    			add_location(label1, file$m, 199, 20, 10014);
    			attr_dev(input1, "class", "uk-checkbox");
    			attr_dev(input1, "id", "form-institutional");
    			attr_dev(input1, "name", "institutional");
    			attr_dev(input1, "type", "checkbox");
    			add_location(input1, file$m, 201, 24, 10186);
    			attr_dev(span2, "class", "uk-text-meta");
    			add_location(span2, file$m, 203, 30, 10419);
    			attr_dev(span3, "uk-icon", "icon: info");
    			attr_dev(span3, "uk-tooltip", "title: Applies to groups with whom a higher price has been negotiated.");
    			add_location(span3, file$m, 203, 89, 10478);
    			attr_dev(div2, "class", "uk-form-controls uk-margin-small-bottom");
    			add_location(div2, file$m, 200, 20, 10108);
    			attr_dev(div3, "class", "uk-width-1-2@s");
    			add_location(div3, file$m, 191, 16, 9182);
    			attr_dev(label2, "class", "uk-form-label");
    			attr_dev(label2, "for", "form-stay");
    			add_location(label2, file$m, 216, 20, 11517);
    			attr_dev(input2, "class", "uk-input uk-form-width-large");
    			attr_dev(input2, "id", "form-stay_amount");
    			attr_dev(input2, "name", "stay_amount");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", "Stay amount");
    			set_style(input2, "color", "black");
    			set_style(input2, "text-align", "right");
    			toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[9].stay_amount && /*$touched*/ ctx[10].stay_amount);
    			add_location(input2, file$m, 218, 24, 11688);
    			attr_dev(div4, "class", "uk-form-controls uk-margin-small-bottom uk-width-1-4@s");
    			add_location(div4, file$m, 217, 20, 11595);
    			attr_dev(label3, "class", "uk-form-label");
    			attr_dev(label3, "for", "form-membership");
    			add_location(label3, file$m, 222, 20, 12106);
    			attr_dev(input3, "class", "uk-input uk-form-width-large");
    			attr_dev(input3, "id", "form-membership_amount");
    			attr_dev(input3, "name", "membership_amount");
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "placeholder", "Membership amount");
    			set_style(input3, "color", "black");
    			set_style(input3, "text-align", "right");
    			toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[9].membership_amount && /*$touched*/ ctx[10].membership_amount);
    			add_location(input3, file$m, 224, 24, 12289);
    			attr_dev(div5, "class", "uk-form-controls uk-margin-small-bottom uk-width-1-4@s");
    			add_location(div5, file$m, 223, 20, 12196);
    			attr_dev(label4, "class", "uk-form-label uk-text-bold uk-margin-medium");
    			attr_dev(label4, "for", "form-total");
    			add_location(label4, file$m, 236, 20, 13455);
    			attr_dev(div6, "class", "uk-text-right uk-text-bold uk-text-emphasis");
    			add_location(div6, file$m, 238, 24, 13690);
    			attr_dev(div7, "class", "uk-form-controls uk-form-controls-text uk-margin-medium uk-width-1-4@s");
    			attr_dev(div7, "id", "form-total");
    			add_location(div7, file$m, 237, 20, 13565);
    			attr_dev(div8, "class", "uk-width-1-2@s");
    			add_location(div8, file$m, 215, 16, 11468);
    			attr_dev(div9, "class", "uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div9, "uk-grid", "");
    			add_location(div9, file$m, 190, 12, 9106);
    			attr_dev(div10, "class", "uk-margin-medium");
    			add_location(div10, file$m, 189, 8, 9063);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$m, 244, 12, 13939);
    			attr_dev(button1, "class", "uk-button uk-margin-xlarge-left");
    			attr_dev(button1, "id", "submit");
    			attr_dev(button1, "type", "submit");
    			button1.disabled = button1_disabled_value = !/*$isValid*/ ctx[11];
    			toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[11]);
    			add_location(button1, file$m, 245, 12, 14043);
    			attr_dev(button2, "class", "uk-button uk-margin-large-left");
    			attr_dev(button2, "id", "submit");
    			attr_dev(button2, "type", "submit");
    			button2.disabled = button2_disabled_value = !/*$isValid*/ ctx[11];
    			toggle_class(button2, "uk-button-primary", /*$isValid*/ ctx[11]);
    			add_location(button2, file$m, 248, 12, 14257);
    			attr_dev(div11, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div11, file$m, 243, 8, 13853);
    			attr_dev(form_1, "class", "uk-form");
    			toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[7]);
    			add_location(form_1, file$m, 149, 4, 6470);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form_1, anchor);
    			append_dev(form_1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(form_1, t0);
    			append_dev(form_1, div10);
    			append_dev(div10, div9);
    			append_dev(div9, div3);
    			append_dev(div3, label0);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			append_dev(div1, input0);
    			set_input_value(input0, /*$form*/ ctx[3].stay_rate);
    			append_dev(div1, t3);
    			append_dev(div1, span0);
    			append_dev(div1, t5);
    			append_dev(div1, span1);
    			append_dev(div3, t6);
    			append_dev(div3, label1);
    			append_dev(div3, t8);
    			append_dev(div3, div2);
    			append_dev(div2, input1);
    			input1.checked = /*$form*/ ctx[3].institutional;
    			append_dev(div2, t9);
    			append_dev(div2, span2);
    			append_dev(div2, t11);
    			append_dev(div2, span3);
    			append_dev(div3, t12);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div9, t13);
    			append_dev(div9, div8);
    			append_dev(div8, label2);
    			append_dev(div8, t15);
    			append_dev(div8, div4);
    			append_dev(div4, input2);
    			set_input_value(input2, /*$form*/ ctx[3].stay_amount);
    			append_dev(div8, t16);
    			append_dev(div8, label3);
    			append_dev(div8, t18);
    			append_dev(div8, div5);
    			append_dev(div5, input3);
    			set_input_value(input3, /*$form*/ ctx[3].membership_amount);
    			append_dev(div8, t19);
    			if (if_block2) if_block2.m(div8, null);
    			append_dev(div8, t20);
    			append_dev(div8, label4);
    			append_dev(div8, t22);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, t23);
    			append_dev(form_1, t24);
    			append_dev(form_1, div11);
    			append_dev(div11, button0);
    			append_dev(div11, t26);
    			append_dev(div11, button1);
    			append_dev(button1, t27);
    			append_dev(div11, t28);
    			append_dev(div11, button2);
    			append_dev(button2, t29);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keyup", /*handleChange*/ ctx[16] && /*adjustStayAmount*/ ctx[18], false, false, false),
    					listen_dev(input0, "blur", /*handleChange*/ ctx[16] && /*adjustStayAmount*/ ctx[18], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[23]),
    					listen_dev(input1, "change", /*handleChange*/ ctx[16], false, false, false),
    					listen_dev(input1, "blur", /*handleChange*/ ctx[16], false, false, false),
    					listen_dev(input1, "change", /*input1_change_handler*/ ctx[24]),
    					listen_dev(input2, "keyup", /*handleChange*/ ctx[16], false, false, false),
    					listen_dev(input2, "blur", /*handleChange*/ ctx[16], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[27]),
    					listen_dev(input3, "keyup", /*handleChange*/ ctx[16], false, false, false),
    					listen_dev(input3, "blur", /*handleChange*/ ctx[16], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[28]),
    					listen_dev(button0, "click", /*cancel*/ ctx[20], false, false, false),
    					listen_dev(button1, "click", /*squid*/ ctx[22], false, false, false),
    					listen_dev(button2, "click", /*invoice*/ ctx[21], false, false, false),
    					listen_dev(form_1, "submit", /*handleSubmit*/ ctx[17], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*booking*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$b(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty[0] & /*$screenWidthS*/ 256) {
    				toggle_class(div0, "uk-text-small", /*$screenWidthS*/ ctx[8]);
    			}

    			if (dirty[0] & /*$form*/ 8 && input0.value !== /*$form*/ ctx[3].stay_rate) {
    				set_input_value(input0, /*$form*/ ctx[3].stay_rate);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 1536) {
    				toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[9].stay_rate && /*$touched*/ ctx[10].stay_rate);
    			}

    			if (dirty[0] & /*$form*/ 8) {
    				input1.checked = /*$form*/ ctx[3].institutional;
    			}

    			if (/*booking*/ ctx[0]?.sci_member && !/*booking*/ ctx[0]?.no_stay_pay) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$c(ctx);
    					if_block1.c();
    					if_block1.m(div3, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*$form*/ 8 && input2.value !== /*$form*/ ctx[3].stay_amount) {
    				set_input_value(input2, /*$form*/ ctx[3].stay_amount);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 1536) {
    				toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[9].stay_amount && /*$touched*/ ctx[10].stay_amount);
    			}

    			if (dirty[0] & /*$form*/ 8 && input3.value !== /*$form*/ ctx[3].membership_amount) {
    				set_input_value(input3, /*$form*/ ctx[3].membership_amount);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 1536) {
    				toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[9].membership_amount && /*$touched*/ ctx[10].membership_amount);
    			}

    			if (/*booking*/ ctx[0]?.paf_events?.length > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$c(ctx);
    					if_block2.c();
    					if_block2.m(div8, t20);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*total*/ 32) set_data_dev(t23, /*total*/ ctx[5]);

    			if (dirty[0] & /*$isValid*/ 2048 && button1_disabled_value !== (button1_disabled_value = !/*$isValid*/ ctx[11])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty[0] & /*$isValid*/ 2048) {
    				toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[11]);
    			}

    			if (dirty[0] & /*$isValid*/ 2048 && button2_disabled_value !== (button2_disabled_value = !/*$isValid*/ ctx[11])) {
    				prop_dev(button2, "disabled", button2_disabled_value);
    			}

    			if (dirty[0] & /*$isValid*/ 2048) {
    				toggle_class(button2, "uk-button-primary", /*$isValid*/ ctx[11]);
    			}

    			if (dirty[0] & /*$screenWidthL*/ 128) {
    				toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[7]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form_1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$k.name,
    		type: "else",
    		source: "(149:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (145:0) {#if dispatched}
    function create_if_block$l(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$m, 146, 8, 6413);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-xlarge-top");
    			add_location(div1, file$m, 145, 4, 6347);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(145:0) {#if dispatched}",
    		ctx
    	});

    	return block;
    }

    // (153:12) {#if booking}
    function create_if_block_3$b(ctx) {
    	let p;
    	let t0_value = /*booking*/ ctx[0].name + "";
    	let t0;
    	let t1;
    	let t2;
    	let div;
    	let t3_value = DateTime_1.fromSQL(/*booking*/ ctx[0].arrival).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*booking*/ ctx[0].departure).toFormat('dd LLL yyyy') + "";
    	let t3;
    	let t4;
    	let t5;
    	let br;
    	let t6;
    	let span0;
    	let t7_value = /*booking*/ ctx[0].people_count + "";
    	let t7;
    	let t8;
    	let span1;
    	let t9_value = /*booking*/ ctx[0].stay_days + "";
    	let t9;
    	let t10;
    	let span2;

    	function select_block_type_2(ctx, dirty) {
    		if (/*membership*/ ctx[4] === undefined || /*booking*/ ctx[0].people_count > 1) return create_if_block_8$2;
    		if (/*membership*/ ctx[4]) return create_if_block_9$2;
    		return create_else_block_3$4;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*booking*/ ctx[0]?.paf_events?.length > 0 && create_if_block_7$4(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*membership*/ ctx[4] === undefined || /*booking*/ ctx[0].people_count > 1) return create_if_block_4$7;
    		if (/*membership*/ ctx[4]) return create_if_block_6$5;
    		return create_else_block_2$6;
    	}

    	let current_block_type_1 = select_block_type_3(ctx);
    	let if_block2 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			p = element("p");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if_block0.c();
    			t2 = space();
    			div = element("div");
    			t3 = text$1(t3_value);
    			t4 = space();
    			if (if_block1) if_block1.c();
    			t5 = space();
    			br = element("br");
    			t6 = space();
    			span0 = element("span");
    			t7 = text$1(t7_value);
    			t8 = text$1(" people, ");
    			span1 = element("span");
    			t9 = text$1(t9_value);
    			t10 = text$1(" nights\n                    ");
    			span2 = element("span");
    			if_block2.c();
    			attr_dev(p, "class", "uk-text-lead uk-inline uk-width-1-1");
    			toggle_class(p, "uk-text-small", /*$screenWidthS*/ ctx[8]);
    			toggle_class(p, "uk-text-bold", /*$screenWidthS*/ ctx[8]);
    			add_location(p, file$m, 153, 16, 6742);
    			add_location(br, file$m, 170, 20, 8030);
    			attr_dev(span0, "class", "uk-text-bold");
    			add_location(span0, file$m, 171, 20, 8055);
    			attr_dev(span1, "class", "uk-text-bold");
    			add_location(span1, file$m, 171, 85, 8120);
    			attr_dev(span2, "class", "uk-text-meta uk-text-right uk-position-top-right uk-margin-small-right");
    			add_location(span2, file$m, 172, 20, 8201);
    			attr_dev(div, "class", "uk-inline uk-width-1-1");
    			add_location(div, file$m, 163, 16, 7494);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			if_block0.m(p, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t3);
    			append_dev(div, t4);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t5);
    			append_dev(div, br);
    			append_dev(div, t6);
    			append_dev(div, span0);
    			append_dev(span0, t7);
    			append_dev(div, t8);
    			append_dev(div, span1);
    			append_dev(span1, t9);
    			append_dev(div, t10);
    			append_dev(div, span2);
    			if_block2.m(span2, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*booking*/ 1 && t0_value !== (t0_value = /*booking*/ ctx[0].name + "")) set_data_dev(t0, t0_value);

    			if (current_block_type !== (current_block_type = select_block_type_2(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(p, null);
    				}
    			}

    			if (dirty[0] & /*$screenWidthS*/ 256) {
    				toggle_class(p, "uk-text-small", /*$screenWidthS*/ ctx[8]);
    			}

    			if (dirty[0] & /*$screenWidthS*/ 256) {
    				toggle_class(p, "uk-text-bold", /*$screenWidthS*/ ctx[8]);
    			}

    			if (dirty[0] & /*booking*/ 1 && t3_value !== (t3_value = DateTime_1.fromSQL(/*booking*/ ctx[0].arrival).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*booking*/ ctx[0].departure).toFormat('dd LLL yyyy') + "")) set_data_dev(t3, t3_value);

    			if (/*booking*/ ctx[0]?.paf_events?.length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_7$4(ctx);
    					if_block1.c();
    					if_block1.m(div, t5);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*booking*/ 1 && t7_value !== (t7_value = /*booking*/ ctx[0].people_count + "")) set_data_dev(t7, t7_value);
    			if (dirty[0] & /*booking*/ 1 && t9_value !== (t9_value = /*booking*/ ctx[0].stay_days + "")) set_data_dev(t9, t9_value);

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_1(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(span2, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			if_block0.d();
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    			if (if_block1) if_block1.d();
    			if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$b.name,
    		type: "if",
    		source: "(153:12) {#if booking}",
    		ctx
    	});

    	return block;
    }

    // (160:20) {:else}
    function create_else_block_3$4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Membership";
    			attr_dev(span, "class", "uk-label uk-label-danger uk-position-center-right uk-margin-small-right");
    			add_location(span, file$m, 160, 24, 7327);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$4.name,
    		type: "else",
    		source: "(160:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (158:41) 
    function create_if_block_9$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Membership";
    			attr_dev(span, "class", "uk-label uk-label-success uk-position-center-right uk-margin-small-right");
    			add_location(span, file$m, 158, 24, 7170);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$2.name,
    		type: "if",
    		source: "(158:41) ",
    		ctx
    	});

    	return block;
    }

    // (156:20) {#if membership === undefined || booking.people_count > 1}
    function create_if_block_8$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Membership";
    			attr_dev(span, "class", "uk-label uk-label-warning uk-position-center-right uk-margin-small-right");
    			add_location(span, file$m, 156, 24, 6999);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$2.name,
    		type: "if",
    		source: "(156:20) {#if membership === undefined || booking.people_count > 1}",
    		ctx
    	});

    	return block;
    }

    // (166:20) {#if booking?.paf_events?.length > 0}
    function create_if_block_7$4(ctx) {
    	let each_1_anchor;
    	let each_value = /*booking*/ ctx[0].paf_events;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*booking*/ 1) {
    				each_value = /*booking*/ ctx[0].paf_events;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$4.name,
    		type: "if",
    		source: "(166:20) {#if booking?.paf_events?.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (167:24) {#each booking.paf_events as pafEvent}
    function create_each_block$e(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*pafEvent*/ ctx[34].abbreviation + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-label uk-label-success");
    			toggle_class(span, "uk-label-danger", !/*pafEvent*/ ctx[34].confirmed);
    			add_location(span, file$m, 167, 35, 7837);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*booking*/ 1 && t1_value !== (t1_value = /*pafEvent*/ ctx[34].abbreviation + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*booking*/ 1) {
    				toggle_class(span, "uk-label-danger", !/*pafEvent*/ ctx[34].confirmed);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(167:24) {#each booking.paf_events as pafEvent}",
    		ctx
    	});

    	return block;
    }

    // (183:24) {:else}
    function create_else_block_2$6(ctx) {
    	let t0;
    	let br;
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text$1("Please create or renew their membership");
    			br = element("br");
    			t1 = text$1("Membership doesn't exist or is expired");
    			add_location(br, file$m, 183, 67, 8898);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$6.name,
    		type: "else",
    		source: "(183:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (181:45) 
    function create_if_block_6$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Membership is valid");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$5.name,
    		type: "if",
    		source: "(181:45) ",
    		ctx
    	});

    	return block;
    }

    // (174:24) {#if membership === undefined || booking.people_count > 1}
    function create_if_block_4$7(ctx) {
    	let t0;
    	let br;
    	let t1;
    	let if_block_anchor;

    	function select_block_type_4(ctx, dirty) {
    		if (/*booking*/ ctx[0].people_count === 1) return create_if_block_5$6;
    		return create_else_block_1$a;
    	}

    	let current_block_type = select_block_type_4(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			t0 = text$1("Please check their membership/s");
    			br = element("br");
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty$3();
    			add_location(br, file$m, 174, 59, 8429);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_4(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$7.name,
    		type: "if",
    		source: "(174:24) {#if membership === undefined || booking.people_count > 1}",
    		ctx
    	});

    	return block;
    }

    // (178:28) {:else}
    function create_else_block_1$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("This booking is for multiple people");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$a.name,
    		type: "else",
    		source: "(178:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (176:28) {#if booking.people_count === 1}
    function create_if_block_5$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("No membership is linked to this booking");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$6.name,
    		type: "if",
    		source: "(176:28) {#if booking.people_count === 1}",
    		ctx
    	});

    	return block;
    }

    // (206:20) {#if booking?.sci_member && !booking?.no_stay_pay}
    function create_if_block_2$c(ctx) {
    	let div;
    	let label;
    	let t1;
    	let input;
    	let t2;
    	let t3_value = /*$settings*/ ctx[6].sci_days - /*sciMember*/ ctx[1]?.sci_days_used + "";
    	let t3;
    	let t4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			label.textContent = "Use SCI days";
    			t1 = space();
    			input = element("input");
    			t2 = text$1("\n                             (");
    			t3 = text$1(t3_value);
    			t4 = text$1(" left)");
    			attr_dev(label, "class", "uk-form-label");
    			attr_dev(label, "for", "form-sci_days_used");
    			add_location(label, file$m, 207, 28, 10779);
    			attr_dev(input, "class", "uk-input uk-margin-small-left uk-form-width-xsmall");
    			attr_dev(input, "id", "form-sci_days_used");
    			attr_dev(input, "name", "sci_days_used");
    			attr_dev(input, "type", "text");
    			set_style(input, "color", "black");
    			toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].sci_days_used && /*$touched*/ ctx[10].sci_days_used);
    			add_location(input, file$m, 208, 28, 10882);
    			attr_dev(div, "class", "uk-margin-medium");
    			add_location(div, file$m, 206, 24, 10720);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(div, t1);
    			append_dev(div, input);
    			set_input_value(input, /*$form*/ ctx[3].sci_days_used);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, t4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "keyup", /*keyup_handler*/ ctx[25], false, false, false),
    					listen_dev(input, "blur", /*handleChange*/ ctx[16], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[26])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 8 && input.value !== /*$form*/ ctx[3].sci_days_used) {
    				set_input_value(input, /*$form*/ ctx[3].sci_days_used);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 1536) {
    				toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].sci_days_used && /*$touched*/ ctx[10].sci_days_used);
    			}

    			if (dirty[0] & /*$settings, sciMember*/ 66 && t3_value !== (t3_value = /*$settings*/ ctx[6].sci_days - /*sciMember*/ ctx[1]?.sci_days_used + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(206:20) {#if booking?.sci_member && !booking?.no_stay_pay}",
    		ctx
    	});

    	return block;
    }

    // (229:20) {#if booking?.paf_events?.length > 0}
    function create_if_block_1$c(ctx) {
    	let label;
    	let t1;
    	let div;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			label = element("label");
    			label.textContent = "Meals";
    			t1 = space();
    			div = element("div");
    			input = element("input");
    			attr_dev(label, "class", "uk-form-label");
    			attr_dev(label, "for", "form-meals_amount");
    			add_location(label, file$m, 229, 24, 12805);
    			attr_dev(input, "class", "uk-input uk-form-width-large");
    			attr_dev(input, "id", "form-meals_amount");
    			attr_dev(input, "name", "meals_amount");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "Meals amount");
    			set_style(input, "color", "black");
    			set_style(input, "text-align", "right");
    			toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].meals_amount && /*$touched*/ ctx[10].meals_amount);
    			add_location(input, file$m, 231, 28, 12993);
    			attr_dev(div, "class", "uk-form-controls uk-margin-small-bottom uk-width-1-4@s");
    			add_location(div, file$m, 230, 24, 12896);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*$form*/ ctx[3].meals_amount);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "keyup", /*handleChange*/ ctx[16], false, false, false),
    					listen_dev(input, "blur", /*handleChange*/ ctx[16], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_1*/ ctx[29])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 8 && input.value !== /*$form*/ ctx[3].meals_amount) {
    				set_input_value(input, /*$form*/ ctx[3].meals_amount);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 1536) {
    				toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].meals_amount && /*$touched*/ ctx[10].meals_amount);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(229:20) {#if booking?.paf_events?.length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let h4;
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (!/*dispatched*/ ctx[2]) return create_if_block_10$2;
    		return create_else_block_4$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*dispatched*/ ctx[2]) return create_if_block$l;
    		return create_else_block$k;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			if_block0.c();
    			t = space();
    			if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom");
    			add_location(h4, file$m, 137, 0, 6145);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			if_block0.m(h4, null);
    			insert_dev(target, t, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h4, null);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if_block0.d();
    			if (detaching) detach_dev(t);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $form;
    	let $settings;
    	let $screenWidthL;
    	let $screenWidthS;
    	let $errors;
    	let $touched;
    	let $isValid;
    	validate_store(settings, 'settings');
    	component_subscribe($$self, settings, $$value => $$invalidate(6, $settings = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(7, $screenWidthL = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(8, $screenWidthS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PaymentForm', slots, []);
    	let { booking = undefined } = $$props;
    	let { sciMember = undefined } = $$props;
    	let { dispatched = false } = $$props;
    	let membership = undefined;
    	let prevYearSciDaysUsed = 0;
    	let total = 0;
    	const dispatch = createEventDispatcher();

    	const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    		initialValues: {
    			stay_rate: 0,
    			institutional: false,
    			sci_days_used: 0,
    			stay_amount: 0,
    			membership_amount: 0,
    			meals_amount: 0,
    			total_amount: 0
    		},
    		onSubmit: values => {
    			
    		},
    		validationSchema: create$4().shape({
    			stay_rate: create$6().transform((number, string) => string === '' ? 0 : Number(string)),
    			institutional: create$8(),
    			sci_days_used: create$6().transform((number, string) => string === '' ? 0 : Number(string)),
    			stay_amount: create$6().transform((number, string) => string === '' ? 0 : Number(string)),
    			membership_amount: create$6().transform((number, string) => string === '' ? 0 : Number(string)),
    			meals_amount: create$6().transform((number, string) => string === '' ? 0 : Number(string)),
    			total_amount: create$6().transform((number, string) => string === '' ? 0 : Number(string))
    		})
    	});

    	validate_store(form, 'form');
    	component_subscribe($$self, form, value => $$invalidate(3, $form = value));
    	validate_store(errors, 'errors');
    	component_subscribe($$self, errors, value => $$invalidate(9, $errors = value));
    	validate_store(touched, 'touched');
    	component_subscribe($$self, touched, value => $$invalidate(10, $touched = value));
    	validate_store(isValid, 'isValid');
    	component_subscribe($$self, isValid, value => $$invalidate(11, $isValid = value));

    	onMount(async () => {
    		if (booking !== undefined) {
    			set_store_value(
    				form,
    				$form.stay_rate = booking !== null && booking.stay_rate !== null && booking.stay_rate > 0
    				? booking.stay_rate
    				: booking.stay_days <= booking.short_stay_duration
    					? $settings.price_stay_short
    					: $settings.price_stay,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.institutional = booking !== null && booking.institutional !== null
    				? booking.institutional
    				: false,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.sci_days_used = booking !== null && booking.sci_days_used !== null
    				? booking.sci_days_used
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.stay_amount = booking !== null && booking.stay_amount !== null
    				? booking.stay_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.membership_amount = booking !== null && booking.membership_amount !== null
    				? booking.membership_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.meals_amount = booking !== null && booking.meals_amount !== null
    				? booking.meals_amount
    				: 0,
    				$form
    			);

    			set_store_value(
    				form,
    				$form.total_amount = booking !== null && booking.total_amount !== null
    				? booking.total_amount
    				: 0,
    				$form
    			);

    			// ugly hack to get force evaluate isValid
    			if (booking === null) handleSubmit(null);

    			if (booking?.member_id > 0) {
    				let member = await getMemberById(booking.member_id);
    				if (member) $$invalidate(4, membership = DateTime_1.fromSQL(member.renew_date) >= DateTime_1.now());
    			}
    		}

    		adjustSciAmount(true);
    	});

    	function adjustStayAmount() {
    		adjustSciAmount(false);
    	}

    	function adjustSciAmount(init) {
    		if (!booking) return;

    		if (booking.no_stay_pay && init) {
    			set_store_value(form, $form.sci_days_used = 0, $form);
    			set_store_value(form, $form.stay_amount = 0, $form);
    		} else {
    			if (sciMember === undefined || sciMember === null) set_store_value(form, $form.sci_days_used = 0, $form); else if (DateTime_1.fromSQL(booking.arrival).year < DateTime_1.now().year) {
    				let prevYearDays = Math.round(DateTime_1.fromSQL(booking.arrival).until(DateTime_1.fromSQL(booking.departure).year < DateTime_1.now().year
    				? DateTime_1.fromSQL(booking.departure)
    				: DateTime_1.fromSQL(booking.arrival).endOf('year')).length('days'));

    				let currYearDays = Math.round(DateTime_1.fromSQL(booking.departure).year < DateTime_1.now().year
    				? 0
    				: DateTime_1.now().startOf('year').until(DateTime_1.fromSQL(booking.departure)).length('days'));

    				let prevYearSciDaysLeft = $settings.sci_days - sciMember.sci_days_used_prev_year;
    				let currYearSciDaysLeft = $settings.sci_days - sciMember.sci_days_used;

    				prevYearSciDaysUsed = prevYearDays > prevYearSciDaysLeft
    				? prevYearSciDaysLeft
    				: prevYearDays;

    				let currYearSciDaysUsed = currYearDays > currYearSciDaysLeft
    				? currYearSciDaysLeft
    				: currYearDays;

    				set_store_value(form, $form.sci_days_used = prevYearSciDaysUsed + currYearSciDaysUsed, $form);
    			} else if ($form.sci_days_used > $settings.sci_days - sciMember.sci_days_used) set_store_value(form, $form.sci_days_used = $settings.sci_days - sciMember.sci_days_used, $form);

    			if ($form.sci_days_used > booking.stay_days) set_store_value(form, $form.sci_days_used = booking.stay_days, $form);
    			set_store_value(form, $form.stay_amount = (booking.stay_days - $form.sci_days_used) * $form.stay_rate, $form);

    			// if booking is for more than one person, add amount for full period for the rest of
    			set_store_value(
    				form,
    				$form.stay_amount += $form.people_count === 1
    				? 0
    				: (booking.people_count - 1) * booking.stay_days * $form.stay_rate,
    				$form
    			);

    			$$invalidate(0, booking.stay_amount_orig = $form.stay_amount, booking);
    		}
    	}

    	function preparePayment() {
    		$$invalidate(0, booking.sci_days_used = $form.sci_days_used, booking);
    		$$invalidate(0, booking.stay_rate = $form.stay_rate, booking);
    		$$invalidate(0, booking.institutional = $form.institutional, booking);
    		$$invalidate(0, booking.stay_amount = $form.stay_amount, booking);
    		$$invalidate(0, booking.membership_amount = $form.membership_amount, booking);
    		$$invalidate(0, booking.meals_amount = $form.meals_amount, booking);
    		$$invalidate(0, booking.total_amount = total, booking);
    	}

    	function cancel() {
    		dispatch('message', { pay: 'cancel' });
    	}

    	function invoice() {
    		preparePayment();
    		dispatch('message', { pay: 'invoice', prevYearSciDaysUsed });
    	}

    	function squid() {
    		preparePayment();
    		dispatch('message', { pay: 'squid', prevYearSciDaysUsed });
    	}

    	const writable_props = ['booking', 'sciMember', 'dispatched'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PaymentForm> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		$form.stay_rate = this.value;
    		form.set($form);
    	}

    	function input1_change_handler() {
    		$form.institutional = this.checked;
    		form.set($form);
    	}

    	const keyup_handler = () => {
    		handleChange && adjustSciAmount(false);
    	};

    	function input_input_handler() {
    		$form.sci_days_used = this.value;
    		form.set($form);
    	}

    	function input2_input_handler() {
    		$form.stay_amount = this.value;
    		form.set($form);
    	}

    	function input3_input_handler() {
    		$form.membership_amount = this.value;
    		form.set($form);
    	}

    	function input_input_handler_1() {
    		$form.meals_amount = this.value;
    		form.set($form);
    	}

    	$$self.$$set = $$props => {
    		if ('booking' in $$props) $$invalidate(0, booking = $$props.booking);
    		if ('sciMember' in $$props) $$invalidate(1, sciMember = $$props.sciMember);
    		if ('dispatched' in $$props) $$invalidate(2, dispatched = $$props.dispatched);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		screenWidthL,
    		screenWidthS,
    		settings,
    		createForm,
    		yup,
    		DateTime: DateTime_1,
    		getMemberById,
    		booking,
    		sciMember,
    		dispatched,
    		membership,
    		prevYearSciDaysUsed,
    		total,
    		dispatch,
    		form,
    		errors,
    		touched,
    		state,
    		isValid,
    		handleChange,
    		handleSubmit,
    		adjustStayAmount,
    		adjustSciAmount,
    		preparePayment,
    		cancel,
    		invoice,
    		squid,
    		$form,
    		$settings,
    		$screenWidthL,
    		$screenWidthS,
    		$errors,
    		$touched,
    		$isValid
    	});

    	$$self.$inject_state = $$props => {
    		if ('booking' in $$props) $$invalidate(0, booking = $$props.booking);
    		if ('sciMember' in $$props) $$invalidate(1, sciMember = $$props.sciMember);
    		if ('dispatched' in $$props) $$invalidate(2, dispatched = $$props.dispatched);
    		if ('membership' in $$props) $$invalidate(4, membership = $$props.membership);
    		if ('prevYearSciDaysUsed' in $$props) prevYearSciDaysUsed = $$props.prevYearSciDaysUsed;
    		if ('total' in $$props) $$invalidate(5, total = $$props.total);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$form*/ 8) {
    			$$invalidate(5, total = Number($form.stay_amount) + Number($form.membership_amount) + Number($form.meals_amount));
    		}
    	};

    	return [
    		booking,
    		sciMember,
    		dispatched,
    		$form,
    		membership,
    		total,
    		$settings,
    		$screenWidthL,
    		$screenWidthS,
    		$errors,
    		$touched,
    		$isValid,
    		form,
    		errors,
    		touched,
    		isValid,
    		handleChange,
    		handleSubmit,
    		adjustStayAmount,
    		adjustSciAmount,
    		cancel,
    		invoice,
    		squid,
    		input0_input_handler,
    		input1_change_handler,
    		keyup_handler,
    		input_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input_input_handler_1
    	];
    }

    class PaymentForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$m, create_fragment$m, safe_not_equal, { booking: 0, sciMember: 1, dispatched: 2 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PaymentForm",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get booking() {
    		throw new Error("<PaymentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set booking(value) {
    		throw new Error("<PaymentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sciMember() {
    		throw new Error("<PaymentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sciMember(value) {
    		throw new Error("<PaymentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dispatched() {
    		throw new Error("<PaymentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dispatched(value) {
    		throw new Error("<PaymentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Payment.svelte generated by Svelte v3.45.0 */
    const file$l = "src/components/Payment.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[32] = list[i];
    	return child_ctx;
    }

    // (362:8) {:else }
    function create_else_block$j(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let th5;
    	let t11;
    	let th6;
    	let t13;
    	let th7;
    	let t15;
    	let th8;
    	let t17;
    	let th9;
    	let t19;
    	let t20;
    	let tbody;

    	function select_block_type_1(ctx, dirty) {
    		if (!/*bookingQuery*/ ctx[3].filter.paid) return create_if_block_7$3;
    		return create_else_block_6;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);
    	let each_value = /*data*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Stay";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "People";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Nights";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Rate ";
    			t9 = space();
    			th5 = element("th");
    			th5.textContent = "Stay ";
    			t11 = space();
    			th6 = element("th");
    			th6.textContent = "Member ";
    			t13 = space();
    			th7 = element("th");
    			th7.textContent = "Meals ";
    			t15 = space();
    			th8 = element("th");
    			th8.textContent = "Custom ";
    			t17 = space();
    			th9 = element("th");
    			th9.textContent = "Total ";
    			t19 = space();
    			if_block.c();
    			t20 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$l, 365, 20, 16305);
    			add_location(th1, file$l, 366, 20, 16339);
    			attr_dev(th2, "class", "uk-table-shrink uk-visible@m");
    			add_location(th2, file$l, 367, 20, 16373);
    			attr_dev(th3, "class", "uk-table-shrink uk-visible@m");
    			add_location(th3, file$l, 368, 20, 16446);
    			attr_dev(th4, "class", "uk-table-shrink uk-text-nowrap uk-visible@l");
    			add_location(th4, file$l, 369, 20, 16519);
    			attr_dev(th5, "class", "uk-table-shrink uk-text-nowrap uk-visible@l");
    			add_location(th5, file$l, 370, 20, 16607);
    			attr_dev(th6, "class", "uk-table-shrink uk-text-nowrap uk-visible@l");
    			add_location(th6, file$l, 371, 20, 16695);
    			attr_dev(th7, "class", "uk-table-shrink uk-text-nowrap uk-visible@l");
    			add_location(th7, file$l, 372, 20, 16785);
    			attr_dev(th8, "class", "uk-table-shrink uk-text-nowrap uk-visible@l");
    			add_location(th8, file$l, 373, 20, 16874);
    			attr_dev(th9, "class", "uk-table-shrink uk-text-nowrap uk-visible@s");
    			add_location(th9, file$l, 374, 20, 16964);
    			add_location(tr, file$l, 364, 16, 16280);
    			add_location(thead, file$l, 363, 16, 16256);
    			add_location(tbody, file$l, 383, 16, 17398);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$l, 362, 12, 16154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(tr, t13);
    			append_dev(tr, th7);
    			append_dev(tr, t15);
    			append_dev(tr, th8);
    			append_dev(tr, t17);
    			append_dev(tr, th9);
    			append_dev(tr, t19);
    			if_block.m(tr, null);
    			append_dev(table, t20);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(tr, null);
    				}
    			}

    			if (dirty[0] & /*data, openPaymentModal, bookingQuery*/ 8201) {
    				each_value = /*data*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			if_block.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(362:8) {:else }",
    		ctx
    	});

    	return block;
    }

    // (360:36) 
    function create_if_block_1$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading bookings...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(360:36) ",
    		ctx
    	});

    	return block;
    }

    // (358:8) {#if data.length === 0 && (bookingQuery.filter || bookingQuery.name)}
    function create_if_block$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("No filter results...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(358:8) {#if data.length === 0 && (bookingQuery.filter || bookingQuery.name)}",
    		ctx
    	});

    	return block;
    }

    // (378:20) {:else}
    function create_else_block_6(ctx) {
    	let th0;
    	let t1;
    	let th1;

    	const block = {
    		c: function create() {
    			th0 = element("th");
    			th0.textContent = "Invoice";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Paid";
    			attr_dev(th0, "class", "uk-table-shrink uk-visible@l");
    			add_location(th0, file$l, 378, 24, 17217);
    			add_location(th1, file$l, 379, 24, 17295);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, th1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(th1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_6.name,
    		type: "else",
    		source: "(378:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (376:20) {#if !bookingQuery.filter.paid}
    function create_if_block_7$3(ctx) {
    	let th;

    	const block = {
    		c: function create() {
    			th = element("th");
    			th.textContent = "Pay now";
    			attr_dev(th, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(th, file$l, 376, 24, 17109);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, th, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(th);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$3.name,
    		type: "if",
    		source: "(376:20) {#if !bookingQuery.filter.paid}",
    		ctx
    	});

    	return block;
    }

    // (394:28) {:else}
    function create_else_block_5$1(ctx) {
    	let t_value = /*booking*/ ctx[32].stay_amount + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && t_value !== (t_value = /*booking*/ ctx[32].stay_amount + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5$1.name,
    		type: "else",
    		source: "(394:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (393:28) {#if booking.stay_amount !== booking.stay_amount_orig}
    function create_if_block_6$4(ctx) {
    	let span;
    	let t_value = /*booking*/ ctx[32].stay_amount + "";
    	let t;
    	let span_uk_tooltip_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "uk-tooltip", span_uk_tooltip_value = /*booking*/ ctx[32].stay_amount_orig);
    			add_location(span, file$l, 392, 82, 18112);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && t_value !== (t_value = /*booking*/ ctx[32].stay_amount + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*data*/ 1 && span_uk_tooltip_value !== (span_uk_tooltip_value = /*booking*/ ctx[32].stay_amount_orig)) {
    				attr_dev(span, "uk-tooltip", span_uk_tooltip_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$4.name,
    		type: "if",
    		source: "(393:28) {#if booking.stay_amount !== booking.stay_amount_orig}",
    		ctx
    	});

    	return block;
    }

    // (399:28) {:else}
    function create_else_block_4$2(ctx) {
    	let t_value = /*booking*/ ctx[32].membership_amount + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && t_value !== (t_value = /*booking*/ ctx[32].membership_amount + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4$2.name,
    		type: "else",
    		source: "(399:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (398:28) {#if booking.membership_amount !== booking.membership_amount_orig}
    function create_if_block_5$5(ctx) {
    	let span;
    	let t_value = /*booking*/ ctx[32].membership_amount + "";
    	let t;
    	let span_uk_tooltip_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "uk-tooltip", span_uk_tooltip_value = /*booking*/ ctx[32].membership_amount_orig);
    			add_location(span, file$l, 397, 94, 18536);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && t_value !== (t_value = /*booking*/ ctx[32].membership_amount + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*data*/ 1 && span_uk_tooltip_value !== (span_uk_tooltip_value = /*booking*/ ctx[32].membership_amount_orig)) {
    				attr_dev(span, "uk-tooltip", span_uk_tooltip_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$5.name,
    		type: "if",
    		source: "(398:28) {#if booking.membership_amount !== booking.membership_amount_orig}",
    		ctx
    	});

    	return block;
    }

    // (404:28) {:else}
    function create_else_block_3$3(ctx) {
    	let t_value = /*booking*/ ctx[32].meals_amount + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && t_value !== (t_value = /*booking*/ ctx[32].meals_amount + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$3.name,
    		type: "else",
    		source: "(404:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (403:28) {#if booking.meals_amount !== booking.meals_amount_orig}
    function create_if_block_4$6(ctx) {
    	let span;
    	let t_value = /*booking*/ ctx[32].meals_amount + "";
    	let t;
    	let span_uk_tooltip_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "uk-tooltip", span_uk_tooltip_value = /*booking*/ ctx[32].meals_amount_orig);
    			add_location(span, file$l, 402, 84, 18958);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && t_value !== (t_value = /*booking*/ ctx[32].meals_amount + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*data*/ 1 && span_uk_tooltip_value !== (span_uk_tooltip_value = /*booking*/ ctx[32].meals_amount_orig)) {
    				attr_dev(span, "uk-tooltip", span_uk_tooltip_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(403:28) {#if booking.meals_amount !== booking.meals_amount_orig}",
    		ctx
    	});

    	return block;
    }

    // (482:24) {:else}
    function create_else_block_2$5(ctx) {
    	let td0;
    	let t0_value = /*booking*/ ctx[32].invoice_nr + "";
    	let t0;
    	let t1;
    	let td1;

    	let t2_value = (/*booking*/ ctx[32].date_paid !== null
    	? DateTime_1.fromSQL(/*booking*/ ctx[32].date_paid).toFormat('dd LLL yyyy')
    	: '') + "";

    	let t2;

    	const block = {
    		c: function create() {
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			attr_dev(td0, "class", "uk-text-nowrap uk-visible@l");
    			add_location(td0, file$l, 482, 28, 27117);
    			attr_dev(td1, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td1, file$l, 483, 28, 27211);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td0, anchor);
    			append_dev(td0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, td1, anchor);
    			append_dev(td1, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && t0_value !== (t0_value = /*booking*/ ctx[32].invoice_nr + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*data*/ 1 && t2_value !== (t2_value = (/*booking*/ ctx[32].date_paid !== null
    			? DateTime_1.fromSQL(/*booking*/ ctx[32].date_paid).toFormat('dd LLL yyyy')
    			: '') + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(td1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$5.name,
    		type: "else",
    		source: "(482:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (409:24) {#if !bookingQuery.filter.paid}
    function create_if_block_2$b(ctx) {
    	let td;

    	function select_block_type_6(ctx, dirty) {
    		if (/*booking*/ ctx[32].mattress_booking) return create_if_block_3$a;
    		return create_else_block_1$9;
    	}

    	let current_block_type = select_block_type_6(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			td = element("td");
    			if_block.c();
    			attr_dev(td, "class", "uk-text-nowrap");
    			add_location(td, file$l, 409, 28, 19395);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			if_block.m(td, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_6(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(td, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(409:24) {#if !bookingQuery.filter.paid}",
    		ctx
    	});

    	return block;
    }

    // (413:32) {:else}
    function create_else_block_1$9(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[16](/*booking*/ ctx[32]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Pay";
    			attr_dev(button, "class", "uk-button uk-button-small uk-button-default");
    			toggle_class(button, "uk-button-danger", DateTime_1.fromSQL(/*booking*/ ctx[32].departure) < DateTime_1.now());
    			add_location(button, file$l, 413, 36, 19685);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*data*/ 1) {
    				toggle_class(button, "uk-button-danger", DateTime_1.fromSQL(/*booking*/ ctx[32].departure) < DateTime_1.now());
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$9.name,
    		type: "else",
    		source: "(413:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (411:32) {#if booking.mattress_booking}
    function create_if_block_3$a(ctx) {
    	let button;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Mattress";
    			attr_dev(button, "class", "uk-button uk-button-small uk-button-default");
    			button.disabled = true;
    			add_location(button, file$l, 411, 36, 19522);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$a.name,
    		type: "if",
    		source: "(411:32) {#if booking.mattress_booking}",
    		ctx
    	});

    	return block;
    }

    // (385:16) {#each data as booking}
    function create_each_block$d(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*booking*/ ctx[32].name + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = DateTime_1.fromSQL(/*booking*/ ctx[32].arrival).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*booking*/ ctx[32].departure).toFormat('dd LLL yyyy') + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*booking*/ ctx[32].people_count + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*booking*/ ctx[32].stay_days + "";
    	let t6;
    	let t7;
    	let td4;
    	let t8_value = /*booking*/ ctx[32].stay_rate + "";
    	let t8;
    	let t9;
    	let td5;
    	let t10;
    	let td6;
    	let t11;
    	let td7;
    	let t12;
    	let td8;
    	let t13_value = /*booking*/ ctx[32].custom_amount + "";
    	let t13;
    	let t14;
    	let td9;
    	let t15_value = /*booking*/ ctx[32].total_amount + "";
    	let t15;
    	let t16;
    	let t17;

    	function select_block_type_2(ctx, dirty) {
    		if (/*booking*/ ctx[32].stay_amount !== /*booking*/ ctx[32].stay_amount_orig) return create_if_block_6$4;
    		return create_else_block_5$1;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*booking*/ ctx[32].membership_amount !== /*booking*/ ctx[32].membership_amount_orig) return create_if_block_5$5;
    		return create_else_block_4$2;
    	}

    	let current_block_type_1 = select_block_type_3(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	function select_block_type_4(ctx, dirty) {
    		if (/*booking*/ ctx[32].meals_amount !== /*booking*/ ctx[32].meals_amount_orig) return create_if_block_4$6;
    		return create_else_block_3$3;
    	}

    	let current_block_type_2 = select_block_type_4(ctx);
    	let if_block2 = current_block_type_2(ctx);

    	function select_block_type_5(ctx, dirty) {
    		if (!/*bookingQuery*/ ctx[3].filter.paid) return create_if_block_2$b;
    		return create_else_block_2$5;
    	}

    	let current_block_type_3 = select_block_type_5(ctx);
    	let if_block3 = current_block_type_3(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element("td");
    			if_block0.c();
    			t10 = space();
    			td6 = element("td");
    			if_block1.c();
    			t11 = space();
    			td7 = element("td");
    			if_block2.c();
    			t12 = space();
    			td8 = element("td");
    			t13 = text$1(t13_value);
    			t14 = space();
    			td9 = element("td");
    			t15 = text$1(t15_value);
    			t16 = space();
    			if_block3.c();
    			t17 = space();
    			add_location(td0, file$l, 386, 24, 17495);
    			add_location(td1, file$l, 387, 24, 17543);
    			attr_dev(td2, "class", "uk-visible@m");
    			add_location(td2, file$l, 388, 24, 17706);
    			attr_dev(td3, "class", "uk-visible@m");
    			add_location(td3, file$l, 389, 24, 17783);
    			attr_dev(td4, "class", "uk-visible@l");
    			add_location(td4, file$l, 390, 24, 17857);
    			attr_dev(td5, "class", "uk-visible@l");
    			toggle_class(td5, "uk-text-warning", /*booking*/ ctx[32].stay_amount !== /*booking*/ ctx[32].stay_amount_orig);
    			add_location(td5, file$l, 391, 24, 17931);
    			attr_dev(td6, "class", "uk-visible@l");
    			toggle_class(td6, "uk-text-warning", /*booking*/ ctx[32].membership_amount !== /*booking*/ ctx[32].membership_amount_orig);
    			add_location(td6, file$l, 396, 24, 18331);
    			attr_dev(td7, "class", "uk-visible@l");
    			toggle_class(td7, "uk-text-warning", /*booking*/ ctx[32].meals_amount !== /*booking*/ ctx[32].meals_amount_orig);
    			add_location(td7, file$l, 401, 24, 18773);
    			attr_dev(td8, "class", "uk-visible@s");
    			add_location(td8, file$l, 406, 24, 19180);
    			attr_dev(td9, "class", "uk-visible@s");
    			add_location(td9, file$l, 407, 24, 19258);
    			add_location(tr, file$l, 385, 20, 17466);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			if_block0.m(td5, null);
    			append_dev(tr, t10);
    			append_dev(tr, td6);
    			if_block1.m(td6, null);
    			append_dev(tr, t11);
    			append_dev(tr, td7);
    			if_block2.m(td7, null);
    			append_dev(tr, t12);
    			append_dev(tr, td8);
    			append_dev(td8, t13);
    			append_dev(tr, t14);
    			append_dev(tr, td9);
    			append_dev(td9, t15);
    			append_dev(tr, t16);
    			if_block3.m(tr, null);
    			append_dev(tr, t17);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data*/ 1 && t0_value !== (t0_value = /*booking*/ ctx[32].name + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*data*/ 1 && t2_value !== (t2_value = DateTime_1.fromSQL(/*booking*/ ctx[32].arrival).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*booking*/ ctx[32].departure).toFormat('dd LLL yyyy') + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*data*/ 1 && t4_value !== (t4_value = /*booking*/ ctx[32].people_count + "")) set_data_dev(t4, t4_value);
    			if (dirty[0] & /*data*/ 1 && t6_value !== (t6_value = /*booking*/ ctx[32].stay_days + "")) set_data_dev(t6, t6_value);
    			if (dirty[0] & /*data*/ 1 && t8_value !== (t8_value = /*booking*/ ctx[32].stay_rate + "")) set_data_dev(t8, t8_value);

    			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(td5, null);
    				}
    			}

    			if (dirty[0] & /*data*/ 1) {
    				toggle_class(td5, "uk-text-warning", /*booking*/ ctx[32].stay_amount !== /*booking*/ ctx[32].stay_amount_orig);
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_3(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(td6, null);
    				}
    			}

    			if (dirty[0] & /*data*/ 1) {
    				toggle_class(td6, "uk-text-warning", /*booking*/ ctx[32].membership_amount !== /*booking*/ ctx[32].membership_amount_orig);
    			}

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_4(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_2(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(td7, null);
    				}
    			}

    			if (dirty[0] & /*data*/ 1) {
    				toggle_class(td7, "uk-text-warning", /*booking*/ ctx[32].meals_amount !== /*booking*/ ctx[32].meals_amount_orig);
    			}

    			if (dirty[0] & /*data*/ 1 && t13_value !== (t13_value = /*booking*/ ctx[32].custom_amount + "")) set_data_dev(t13, t13_value);
    			if (dirty[0] & /*data*/ 1 && t15_value !== (t15_value = /*booking*/ ctx[32].total_amount + "")) set_data_dev(t15, t15_value);

    			if (current_block_type_3 === (current_block_type_3 = select_block_type_5(ctx)) && if_block3) {
    				if_block3.p(ctx, dirty);
    			} else {
    				if_block3.d(1);
    				if_block3 = current_block_type_3(ctx);

    				if (if_block3) {
    					if_block3.c();
    					if_block3.m(tr, t17);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if_block0.d();
    			if_block1.d();
    			if_block2.d();
    			if_block3.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(385:16) {#each data as booking}",
    		ctx
    	});

    	return block;
    }

    // (511:16) {#key recreateForm}
    function create_key_block_1$2(ctx) {
    	let paymentform;
    	let updating_booking;
    	let updating_sciMember;
    	let current;

    	function paymentform_booking_binding(value) {
    		/*paymentform_booking_binding*/ ctx[18](value);
    	}

    	function paymentform_sciMember_binding(value) {
    		/*paymentform_sciMember_binding*/ ctx[19](value);
    	}

    	let paymentform_props = {};

    	if (/*selectedBooking*/ ctx[4] !== void 0) {
    		paymentform_props.booking = /*selectedBooking*/ ctx[4];
    	}

    	if (/*sciMember*/ ctx[6] !== void 0) {
    		paymentform_props.sciMember = /*sciMember*/ ctx[6];
    	}

    	paymentform = new PaymentForm({ props: paymentform_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(paymentform, 'booking', paymentform_booking_binding));
    	binding_callbacks.push(() => bind$1(paymentform, 'sciMember', paymentform_sciMember_binding));
    	paymentform.$on("message", /*processPayment*/ ctx[14]);

    	const block = {
    		c: function create() {
    			create_component(paymentform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(paymentform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const paymentform_changes = {};

    			if (!updating_booking && dirty[0] & /*selectedBooking*/ 16) {
    				updating_booking = true;
    				paymentform_changes.booking = /*selectedBooking*/ ctx[4];
    				add_flush_callback(() => updating_booking = false);
    			}

    			if (!updating_sciMember && dirty[0] & /*sciMember*/ 64) {
    				updating_sciMember = true;
    				paymentform_changes.sciMember = /*sciMember*/ ctx[6];
    				add_flush_callback(() => updating_sciMember = false);
    			}

    			paymentform.$set(paymentform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(paymentform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(paymentform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(paymentform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_1$2.name,
    		type: "key",
    		source: "(511:16) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    // (530:16) {#key recreateForm}
    function create_key_block$7(ctx) {
    	let invoiceform;
    	let updating_booking;
    	let updating_invoice;
    	let current;

    	function invoiceform_booking_binding(value) {
    		/*invoiceform_booking_binding*/ ctx[20](value);
    	}

    	function invoiceform_invoice_binding(value) {
    		/*invoiceform_invoice_binding*/ ctx[21](value);
    	}

    	let invoiceform_props = {};

    	if (/*selectedBooking*/ ctx[4] !== void 0) {
    		invoiceform_props.booking = /*selectedBooking*/ ctx[4];
    	}

    	if (/*invoice*/ ctx[5] !== void 0) {
    		invoiceform_props.invoice = /*invoice*/ ctx[5];
    	}

    	invoiceform = new InvoiceForm({ props: invoiceform_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(invoiceform, 'booking', invoiceform_booking_binding));
    	binding_callbacks.push(() => bind$1(invoiceform, 'invoice', invoiceform_invoice_binding));
    	invoiceform.$on("message", /*processInvoice*/ ctx[15]);

    	const block = {
    		c: function create() {
    			create_component(invoiceform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(invoiceform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const invoiceform_changes = {};

    			if (!updating_booking && dirty[0] & /*selectedBooking*/ 16) {
    				updating_booking = true;
    				invoiceform_changes.booking = /*selectedBooking*/ ctx[4];
    				add_flush_callback(() => updating_booking = false);
    			}

    			if (!updating_invoice && dirty[0] & /*invoice*/ 32) {
    				updating_invoice = true;
    				invoiceform_changes.invoice = /*invoice*/ ctx[5];
    				add_flush_callback(() => updating_invoice = false);
    			}

    			invoiceform.$set(invoiceform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(invoiceform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(invoiceform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(invoiceform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$7.name,
    		type: "key",
    		source: "(530:16) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let input0;
    	let input0_class_value;
    	let t0;
    	let div0;
    	let input1;
    	let t1;
    	let t2_value = (/*bookingQuery*/ ctx[3].filter.paid ? 'Paid' : 'Unpaid') + "";
    	let t2;
    	let t3;
    	let div5;
    	let div4;
    	let t4;
    	let infinitescroll;
    	let t5;
    	let div9;
    	let div8;
    	let button0;
    	let t6;
    	let div7;
    	let div6;
    	let previous_key = /*recreateForm*/ ctx[7];
    	let t7;
    	let div13;
    	let div12;
    	let button1;
    	let t8;
    	let div11;
    	let div10;
    	let previous_key_1 = /*recreateForm*/ ctx[7];
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0 && (/*bookingQuery*/ ctx[3].filter || /*bookingQuery*/ ctx[3].name)) return create_if_block$k;
    		if (/*data*/ ctx[0].length === 0) return create_if_block_1$b;
    		return create_else_block$j;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	infinitescroll = new InfiniteScroll({
    			props: {
    				hasMore: /*newBatch*/ ctx[1].length,
    				threshold: 80
    			},
    			$$inline: true
    		});

    	infinitescroll.$on("loadMore", /*loadMore_handler*/ ctx[17]);
    	let key_block0 = create_key_block_1$2(ctx);
    	let key_block1 = create_key_block$7(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			input0 = element("input");
    			t0 = space();
    			div0 = element("div");
    			input1 = element("input");
    			t1 = space();
    			t2 = text$1(t2_value);
    			t3 = space();
    			div5 = element("div");
    			div4 = element("div");
    			if_block.c();
    			t4 = space();
    			create_component(infinitescroll.$$.fragment);
    			t5 = space();
    			div9 = element("div");
    			div8 = element("div");
    			button0 = element("button");
    			t6 = space();
    			div7 = element("div");
    			div6 = element("div");
    			key_block0.c();
    			t7 = space();
    			div13 = element("div");
    			div12 = element("div");
    			button1 = element("button");
    			t8 = space();
    			div11 = element("div");
    			div10 = element("div");
    			key_block1.c();

    			attr_dev(input0, "class", input0_class_value = "uk-input " + (/*$screenWidthS*/ ctx[8]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[9] || /*$screenWidthL*/ ctx[10]
    				? 'uk-width-medium'
    				: 'uk-width-large'));

    			attr_dev(input0, "id", "autocomplete");
    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "spellcheck", "false");
    			attr_dev(input0, "autocorrect", "off");
    			attr_dev(input0, "autocomplete", "off");
    			attr_dev(input0, "autocapitalize", "off");
    			attr_dev(input0, "maxlength", "256");
    			add_location(input0, file$l, 349, 12, 15311);
    			attr_dev(input1, "type", "checkbox");
    			attr_dev(input1, "id", "paid");
    			attr_dev(input1, "data-type", "simple-switch");
    			input1.checked = true;
    			add_location(input1, file$l, 350, 40, 15608);
    			attr_dev(div0, "class", "uk-margin-left");
    			add_location(div0, file$l, 350, 12, 15580);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-flex-middle");
    			add_location(div1, file$l, 348, 8, 15247);
    			attr_dev(div2, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6 paf-top-section-bg");
    			add_location(div2, file$l, 347, 4, 15149);
    			attr_dev(div3, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div3, file$l, 346, 0, 15071);
    			attr_dev(div4, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6");
    			add_location(div4, file$l, 356, 4, 15874);
    			attr_dev(div5, "class", "uk-flex uk-flex-center");
    			set_style(div5, "max-height", "75%");
    			set_style(div5, "overflow-x", "scroll");
    			add_location(div5, file$l, 355, 0, 15788);
    			attr_dev(button0, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "uk-close", "");
    			add_location(button0, file$l, 506, 8, 27968);
    			attr_dev(div6, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div6, "uk-height-viewport", "");
    			add_location(div6, file$l, 508, 12, 28109);
    			attr_dev(div7, "class", "uk-flex uk-flex-center");
    			add_location(div7, file$l, 507, 8, 28060);
    			attr_dev(div8, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div8, file$l, 505, 4, 27898);
    			attr_dev(div9, "id", "modal-payment");
    			attr_dev(div9, "class", "uk-modal-full");
    			attr_dev(div9, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div9, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[9]);
    			add_location(div9, file$l, 501, 0, 27744);
    			attr_dev(button1, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "uk-close", "");
    			add_location(button1, file$l, 525, 8, 28691);
    			attr_dev(div10, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div10, "uk-height-viewport", "");
    			add_location(div10, file$l, 527, 12, 28832);
    			attr_dev(div11, "class", "uk-flex uk-flex-center");
    			add_location(div11, file$l, 526, 8, 28783);
    			attr_dev(div12, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div12, file$l, 524, 4, 28621);
    			attr_dev(div13, "id", "modal-invoice");
    			attr_dev(div13, "class", "uk-modal-full");
    			attr_dev(div13, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div13, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[9]);
    			add_location(div13, file$l, 520, 0, 28467);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, input0);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, input1);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			if_block.m(div4, null);
    			append_dev(div5, t4);
    			mount_component(infinitescroll, div5, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div8);
    			append_dev(div8, button0);
    			append_dev(div8, t6);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			key_block0.m(div6, null);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div12);
    			append_dev(div12, button1);
    			append_dev(div12, t8);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			key_block1.m(div10, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input1, "change", /*togglePaid*/ ctx[12], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*$screenWidthS, $screenWidthM, $screenWidthL*/ 1792 && input0_class_value !== (input0_class_value = "uk-input " + (/*$screenWidthS*/ ctx[8]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[9] || /*$screenWidthL*/ ctx[10]
    				? 'uk-width-medium'
    				: 'uk-width-large'))) {
    				attr_dev(input0, "class", input0_class_value);
    			}

    			if ((!current || dirty[0] & /*bookingQuery*/ 8) && t2_value !== (t2_value = (/*bookingQuery*/ ctx[3].filter.paid ? 'Paid' : 'Unpaid') + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div4, null);
    				}
    			}

    			const infinitescroll_changes = {};
    			if (dirty[0] & /*newBatch*/ 2) infinitescroll_changes.hasMore = /*newBatch*/ ctx[1].length;
    			infinitescroll.$set(infinitescroll_changes);

    			if (dirty[0] & /*recreateForm*/ 128 && safe_not_equal(previous_key, previous_key = /*recreateForm*/ ctx[7])) {
    				group_outros();
    				transition_out(key_block0, 1, 1, noop$4);
    				check_outros();
    				key_block0 = create_key_block_1$2(ctx);
    				key_block0.c();
    				transition_in(key_block0);
    				key_block0.m(div6, null);
    			} else {
    				key_block0.p(ctx, dirty);
    			}

    			if (dirty[0] & /*$screenWidthM*/ 512) {
    				toggle_class(div9, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[9]);
    			}

    			if (dirty[0] & /*recreateForm*/ 128 && safe_not_equal(previous_key_1, previous_key_1 = /*recreateForm*/ ctx[7])) {
    				group_outros();
    				transition_out(key_block1, 1, 1, noop$4);
    				check_outros();
    				key_block1 = create_key_block$7(ctx);
    				key_block1.c();
    				transition_in(key_block1);
    				key_block1.m(div10, null);
    			} else {
    				key_block1.p(ctx, dirty);
    			}

    			if (dirty[0] & /*$screenWidthM*/ 512) {
    				toggle_class(div13, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[9]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(infinitescroll.$$.fragment, local);
    			transition_in(key_block0);
    			transition_in(key_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(infinitescroll.$$.fragment, local);
    			transition_out(key_block0);
    			transition_out(key_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div5);
    			if_block.d();
    			destroy_component(infinitescroll);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div9);
    			key_block0.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div13);
    			key_block1.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $sciMembers;
    	let $bookingNames;
    	let $screenWidthS;
    	let $screenWidthM;
    	let $screenWidthL;
    	validate_store(sciMembers, 'sciMembers');
    	component_subscribe($$self, sciMembers, $$value => $$invalidate(23, $sciMembers = $$value));
    	validate_store(bookingNames, 'bookingNames');
    	component_subscribe($$self, bookingNames, $$value => $$invalidate(24, $bookingNames = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(8, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(9, $screenWidthM = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(10, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Payment', slots, []);
    	let maxPage = 2;
    	let data = [];
    	let newBatch = [];

    	let bookingQuery = {
    		filter: {
    			arrival: [DateTime_1.now().minus({ years: 1 }).toSQLDate(), DateTime_1.now().toSQLDate()],
    			paid: false
    		},
    		page: 1,
    		limit: 50,
    		orderBy: { key: 'departure', order: 'ASC' }
    	};

    	let selectedBooking;
    	let invoice = null;
    	let sciMember;
    	let prevYearSciDaysUsed = 0;

    	// let total = 0
    	// let dispatched = false
    	let recreateForm = false;

    	// $: total = Number($form.stay_amount) + Number($form.membership_amount) + Number($form.meals_amount)
    	const dispatch = createEventDispatcher();

    	// const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    	//     initialValues: {
    	//         sci_days_used: 0,
    	//         stay_amount: 0,
    	//         membership_amount: 0,
    	//         meals_amount: 0
    	//     },
    	//     onSubmit: values => {
    	//         dispatched = true
    	//         // dispatch('message', {
    	//         //     goto: 'save'
    	//         // })
    	//     },
    	//     validationSchema: yup.object().shape({
    	//         sci_days_used: yup.number().transform((number, string) => string === '' ? 0 : Number(string)),
    	//         stay_amount: yup.number().transform((number, string) => string === '' ? 0 : Number(string)),
    	//         membership_amount: yup.number().transform((number, string) => string === '' ? 0 : Number(string)),
    	//         meals_amount: yup.number().transform((number, string) => string === '' ? 0 : Number(string))
    	//     })
    	// })
    	onMount(async () => {
    		await fetchData();
    		init$1();

    		const autoCompleteJS = new autoComplete({
    				selector: "#autocomplete",
    				placeHolder: "Search bookings...",
    				diacritics: true,
    				searchEngine: 'strict',
    				data: { src: $bookingNames, cache: true },
    				resultsList: {
    					element: (list, data) => {
    						if (!data.results.length) {
    							const message = document.createElement("div");
    							message.setAttribute("class", "no_result");
    							message.innerHTML = `<span>No Booking for "${data.query}"</span>`;
    							list.prepend(message);
    						}
    					},
    					maxResults: 50,
    					noResults: true
    				},
    				resultItem: { highlight: true },
    				events: {
    					input: {
    						selection: event => {
    							autoCompleteJS.input.value = event.detail.selection.value;
    							fetchBooking(event.detail.selection.value);
    						},
    						keyup: () => {
    							if (autoCompleteJS.input.value === '') fetchBooking(null);
    						}
    					}
    				}
    			});
    	});

    	async function fetchData() {
    		const result = await getPaymentBookings(bookingQuery);
    		$$invalidate(2, maxPage = result.meta.last_page);
    		$$invalidate(1, newBatch = calcBookingAmounts(result.data));
    	}

    	async function fetchBooking(bookingName) {
    		$$invalidate(3, bookingQuery.page = 1, bookingQuery);
    		$$invalidate(1, newBatch = []);

    		if (bookingName !== undefined && bookingName !== null) {
    			$$invalidate(3, bookingQuery.name = bookingName, bookingQuery);
    			const result = await getPaymentBookings(bookingQuery);
    			$$invalidate(2, maxPage = result.meta.last_page);
    			$$invalidate(0, data = [...calcBookingAmounts(result.data)]);
    		} else {
    			delete bookingQuery.name;
    			$$invalidate(0, data = []);
    			await fetchData();
    		}
    	}

    	function togglePaid() {
    		$$invalidate(3, bookingQuery.filter.paid = !document.getElementById('paid').checked, bookingQuery);
    		$$invalidate(3, bookingQuery.page = 1, bookingQuery);

    		$$invalidate(
    			3,
    			bookingQuery.orderBy = {
    				key: bookingQuery.filter.paid ? 'date_paid' : 'departure',
    				order: bookingQuery.filter.paid ? 'DESC' : 'ASC'
    			},
    			bookingQuery
    		);

    		$$invalidate(0, data = []);
    		$$invalidate(1, newBatch = []);
    		fetchData();
    	}

    	function dispatchReload() {
    		dispatch('message', { reload: 'payment' });
    	}

    	function calcBookingAmounts(bookings) {
    		bookings.forEach(booking => calculateBookingAmounts(booking));
    		return bookings;
    	}

    	// async function initPayForm(booking) {
    	//     Object.entries($errors).forEach(e => $errors[e[0]] = '')
    	//     Object.entries($form).forEach(e => $form[e[0]] = booking[e[0]])
    	//     sciMember = booking.sci_member ? $sciMembers.find(m => m.id === booking.member_id) : null
    	// }
    	// function adjustSciAmount(booking, init) {
    	//     if (booking.no_stay_pay && init) {
    	//         $form.sci_days_used = 0
    	//         $form.stay_amount = 0
    	//     } else {
    	//         if (sciMember === null)
    	//             $form.sci_days_used = 0
    	//         else if (DateTime.fromSQL(booking.arrival).year < DateTime.now().year) {
    	//             let prevYearDays = Math.round(DateTime.fromSQL(booking.arrival).until(DateTime.fromSQL(booking.departure).year < DateTime.now().year ? DateTime.fromSQL(booking.departure) : DateTime.fromSQL(booking.arrival).endOf('year')).length('days'))
    	//             let currYearDays = Math.round(DateTime.fromSQL(booking.departure).year < DateTime.now().year ? 0 : DateTime.now().startOf('year').until(DateTime.fromSQL(booking.departure)).length('days'))
    	//             let prevYearSciDaysLeft = $settings.sci_days - sciMember.sci_days_used_prev_year
    	//             let currYearSciDaysLeft = $settings.sci_days - sciMember.sci_days_used
    	//             prevYearSciDaysUsed = prevYearDays > prevYearSciDaysLeft ? prevYearSciDaysLeft : prevYearDays
    	//             let currYearSciDaysUsed = currYearDays > currYearSciDaysLeft ? currYearSciDaysLeft : currYearDays
    	//             $form.sci_days_used = prevYearSciDaysUsed + currYearSciDaysUsed
    	//         }
    	//         else if ($form.sci_days_used > $settings.sci_days - sciMember.sci_days_used)
    	//             $form.sci_days_used = $settings.sci_days - sciMember.sci_days_used
    	//         if ($form.sci_days_used > booking.stay_days)
    	//             $form.sci_days_used = booking.stay_days
    	//
    	//         $form.stay_amount = (booking.stay_days - $form.sci_days_used) * (booking.stay_days <= $settings.short_stay_duration ? $settings.price_stay_short : booking.stay_days < 30 ? $settings.price_stay : $settings.price_stay_month)
    	//
    	//         // if booking is for more than one person, add amount for full period for the rest of
    	//         $form.stay_amount += $form.people_count === 1 ? 0 : (booking.people_count - 1) * booking.stay_days * (booking.stay_days <= $settings.short_stay_duration ? $settings.price_stay_short : booking.stay_days < 30 ? $settings.price_stay : $settings.price_stay_month)
    	//         booking.stay_amount_orig = $form.stay_amount
    	//     }
    	// }
    	async function payDone() {
    		let reload = false;

    		if (selectedBooking.sci_member && sciMember?.id === selectedBooking.member_id && selectedBooking.sci_days_used > 0) {
    			if (prevYearSciDaysUsed > 0) {
    				$$invalidate(6, sciMember.sci_days_used_prev_year = sciMember.sci_days_used_prev_year + prevYearSciDaysUsed, sciMember);
    				$$invalidate(6, sciMember.sci_days_used = sciMember.sci_days_used + selectedBooking.sci_days_used - prevYearSciDaysUsed, sciMember);
    			} else $$invalidate(6, sciMember.sci_days_used = sciMember.sci_days_used + selectedBooking.sci_days_used, sciMember);

    			await updateMember(sciMember);
    			$$invalidate(6, sciMember = null);
    			reload = true;
    		}

    		// if (selectedBooking.total_amount !== total) {
    		//     selectedBooking.sci_days_used = $form.sci_days_used
    		//     selectedBooking.stay_amount = $form.stay_amount
    		//     selectedBooking.membership_amount = $form.membership_amount
    		//     selectedBooking.meals_amount = $form.meals_amount
    		//     selectedBooking.total_amount = total
    		// }
    		$$invalidate(4, selectedBooking.date_paid = DateTime_1.now().toSQLDate(), selectedBooking);

    		$$invalidate(4, selectedBooking.paid = true, selectedBooking);

    		if (await updateBooking(selectedBooking)) {
    			uikit.notification('<span uk-icon="icon: check"></span> $ thank you!', { status: 'success', pos: 'bottom-center' });
    			reload = true;
    		} else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });

    		// UIkit.dropdown('#dropdown-pay-'+booking.id).hide(false)
    		if (reload) await fetchBooking(null);
    	}

    	async function openPaymentModal(booking) {
    		$$invalidate(6, sciMember = booking.sci_member
    		? $sciMembers.find(m => m.id === booking.member_id)
    		: null);

    		$$invalidate(4, selectedBooking = JSON.parse(JSON.stringify(booking)));
    		$$invalidate(7, recreateForm = !recreateForm);
    		uikit.modal("#modal-payment").show();
    	}

    	async function payInvoice() {
    		// selectedBooking = JSON.parse(JSON.stringify(booking))
    		// selectedBooking.stay_amount = $form.stay_amount
    		// selectedBooking.membership_amount = $form.membership_amount
    		// selectedBooking.meals_amount = $form.meals_amount
    		let dbInvoice = null;

    		if (selectedBooking?.invoice_id !== null && selectedBooking?.invoice_id !== 0) dbInvoice = await getInvoiceById(selectedBooking.invoice_id);

    		$$invalidate(5, invoice = (dbInvoice?.invoice_nr)
    		? { invoice_nr: dbInvoice?.invoice_nr }
    		: null);

    		$$invalidate(7, recreateForm = !recreateForm);

    		// UIkit.dropdown('#dropdown-pay-'+booking.id).hide(false)
    		uikit.modal("#modal-invoice").show();
    	}

    	async function processPayment(event) {
    		if (event.detail.pay !== undefined) {
    			if (event.detail.pay.prevYearSciDaysUsed !== undefined) prevYearSciDaysUsed = event.detail.pay.prevYearSciDaysUsed;

    			switch (event.detail.pay) {
    				case 'cancel':
    					uikit.modal("#modal-payment").hide();
    					break;
    				case 'squid':
    					await payDone();
    					uikit.modal("#modal-payment").hide();
    					break;
    				case 'invoice':
    					uikit.modal("#modal-payment").hide();
    					payInvoice();
    			}
    		}
    	}

    	async function processInvoice(event) {
    		if (event.detail.goto !== undefined) {
    			switch (event.detail.goto) {
    				case 'cancel':
    					uikit.modal("#modal-invoice").hide();
    					break;
    				case 'save':
    					const sendMail = event.detail.sendMail ? event.detail.sendMail : false;
    					let invoiceSuccess;
    					if (selectedBooking.invoice_id && selectedBooking.invoice_id !== 0) {
    						$$invalidate(5, invoice.id = selectedBooking.invoice_id, invoice);
    						invoiceSuccess = await updateInvoice(invoice, sendMail);
    					} else invoiceSuccess = await createInvoice(invoice);
    					if (invoiceSuccess?.id) {
    						uikit.modal("#modal-invoice").hide();
    						uikit.notification('<span uk-icon="icon: check"></span> Invoice created!', { status: 'success', pos: 'bottom-center' });
    						await bookingUpdate(invoiceSuccess.id, invoiceSuccess.number, invoice.date_paid !== null);
    					} else uikit.notification('<span uk-icon="icon: warning"></span> Failed creating invoice!', { status: 'danger', pos: 'bottom-center' });
    					if (invoiceSuccess?.dropbox) uikit.notification('<span uk-icon="icon: check"></span> Dropbox upload successful!', { status: 'success', pos: 'bottom-center' });
    					if (invoiceSuccess?.email) uikit.notification('<span uk-icon="icon: check"></span> Email sent!', { status: 'success', pos: 'bottom-center' });
    					if (invoiceSuccess?.number !== invoice.invoice_nr) alert('Invoice number has changed to ' + invoiceSuccess.number + '!\nPlease correct in payment sheet if this is an in-house payment!');
    					dispatchReload();
    			}
    		}
    	}

    	async function bookingUpdate(invoiceId, invoiceNr, setPaidDate) {
    		let reload = false;

    		if (selectedBooking.sci_member && sciMember?.id === selectedBooking.member_id && selectedBooking.sci_days_used > 0) {
    			if (prevYearSciDaysUsed > 0) {
    				$$invalidate(6, sciMember.sci_days_used_prev_year = sciMember.sci_days_used_prev_year + prevYearSciDaysUsed, sciMember);
    				$$invalidate(6, sciMember.sci_days_used = sciMember.sci_days_used + selectedBooking.sci_days_used - prevYearSciDaysUsed, sciMember);
    			} else $$invalidate(6, sciMember.sci_days_used = sciMember.sci_days_used + selectedBooking.sci_days_used, sciMember);

    			await updateMember(sciMember);
    			$$invalidate(6, sciMember = null);
    			reload = true;
    		}

    		$$invalidate(4, selectedBooking.stay_amount = invoice.stay_amount, selectedBooking);
    		$$invalidate(4, selectedBooking.membership_amount = invoice.membership_amount, selectedBooking);
    		$$invalidate(4, selectedBooking.meals_amount = invoice.meals_amount, selectedBooking);
    		$$invalidate(4, selectedBooking.custom_amount = invoice.custom_amount, selectedBooking);
    		$$invalidate(4, selectedBooking.total_amount = invoice.total_amount, selectedBooking);
    		if (invoiceId !== null) $$invalidate(4, selectedBooking.invoice_id = invoiceId, selectedBooking);
    		$$invalidate(4, selectedBooking.invoice_nr = invoiceNr ? invoiceNr : invoice.invoice_nr, selectedBooking);
    		$$invalidate(4, selectedBooking.date_paid = setPaidDate ? DateTime_1.now().toSQLDate() : null, selectedBooking);
    		$$invalidate(4, selectedBooking.paid = true, selectedBooking);

    		if (await updateBooking(selectedBooking)) {
    			uikit.notification('<span uk-icon="icon: check"></span> $ thank you!', { status: 'success', pos: 'bottom-center' });
    			reload = true;
    		} else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });

    		if (reload) await fetchBooking(null);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Payment> was created with unknown prop '${key}'`);
    	});

    	const click_handler = booking => openPaymentModal(booking);

    	const loadMore_handler = () => {
    		if (bookingQuery.page < maxPage) {
    			$$invalidate(3, bookingQuery.page++, bookingQuery);
    			fetchData();
    		}
    	};

    	function paymentform_booking_binding(value) {
    		selectedBooking = value;
    		$$invalidate(4, selectedBooking);
    	}

    	function paymentform_sciMember_binding(value) {
    		sciMember = value;
    		$$invalidate(6, sciMember);
    	}

    	function invoiceform_booking_binding(value) {
    		selectedBooking = value;
    		$$invalidate(4, selectedBooking);
    	}

    	function invoiceform_invoice_binding(value) {
    		invoice = value;
    		$$invalidate(5, invoice);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		bookingNames,
    		calculateBookingAmounts,
    		getPaymentBookings,
    		updateBooking,
    		InfiniteScroll,
    		SimpleSwitch,
    		UIkit: uikit,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		autoComplete,
    		DateTime: DateTime_1,
    		Interval: Interval_1,
    		InvoiceForm,
    		sciMembers,
    		updateMember,
    		createInvoice,
    		getInvoiceById,
    		updateInvoice,
    		PaymentForm,
    		maxPage,
    		data,
    		newBatch,
    		bookingQuery,
    		selectedBooking,
    		invoice,
    		sciMember,
    		prevYearSciDaysUsed,
    		recreateForm,
    		dispatch,
    		fetchData,
    		fetchBooking,
    		togglePaid,
    		dispatchReload,
    		calcBookingAmounts,
    		payDone,
    		openPaymentModal,
    		payInvoice,
    		processPayment,
    		processInvoice,
    		bookingUpdate,
    		$sciMembers,
    		$bookingNames,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL
    	});

    	$$self.$inject_state = $$props => {
    		if ('maxPage' in $$props) $$invalidate(2, maxPage = $$props.maxPage);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('newBatch' in $$props) $$invalidate(1, newBatch = $$props.newBatch);
    		if ('bookingQuery' in $$props) $$invalidate(3, bookingQuery = $$props.bookingQuery);
    		if ('selectedBooking' in $$props) $$invalidate(4, selectedBooking = $$props.selectedBooking);
    		if ('invoice' in $$props) $$invalidate(5, invoice = $$props.invoice);
    		if ('sciMember' in $$props) $$invalidate(6, sciMember = $$props.sciMember);
    		if ('prevYearSciDaysUsed' in $$props) prevYearSciDaysUsed = $$props.prevYearSciDaysUsed;
    		if ('recreateForm' in $$props) $$invalidate(7, recreateForm = $$props.recreateForm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*data, newBatch*/ 3) {
    			$$invalidate(0, data = [...data, ...newBatch]);
    		}
    	};

    	return [
    		data,
    		newBatch,
    		maxPage,
    		bookingQuery,
    		selectedBooking,
    		invoice,
    		sciMember,
    		recreateForm,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		fetchData,
    		togglePaid,
    		openPaymentModal,
    		processPayment,
    		processInvoice,
    		click_handler,
    		loadMore_handler,
    		paymentform_booking_binding,
    		paymentform_sciMember_binding,
    		invoiceform_booking_binding,
    		invoiceform_invoice_binding
    	];
    }

    class Payment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$l, create_fragment$l, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Payment",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src/components/EventForm.svelte generated by Svelte v3.45.0 */

    const { Object: Object_1$1 } = globals;
    const file$k = "src/components/EventForm.svelte";

    // (115:4) {:else }
    function create_else_block_1$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Creating event");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$8.name,
    		type: "else",
    		source: "(115:4) {:else }",
    		ctx
    	});

    	return block;
    }

    // (113:19) 
    function create_if_block_3$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Updating event");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$9.name,
    		type: "if",
    		source: "(113:19) ",
    		ctx
    	});

    	return block;
    }

    // (110:26) 
    function create_if_block_2$a(ctx) {
    	let t0;
    	let t1_value = (/*$screenWidthS*/ ctx[3] ? '' : 'event') + "";
    	let t1;
    	let t2;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text$1("Edit ");
    			t1 = text$1(t1_value);
    			t2 = space();
    			button = element("button");
    			button.textContent = "Delete";
    			attr_dev(button, "class", "uk-button uk-text-normal uk-margin uk-button-secondary uk-position-bottom-right uk-button-danger");
    			attr_dev(button, "type", "button");
    			add_location(button, file$k, 111, 8, 4824);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*deleteMe*/ ctx[14], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$screenWidthS*/ 8 && t1_value !== (t1_value = (/*$screenWidthS*/ ctx[3] ? '' : 'event') + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(110:26) ",
    		ctx
    	});

    	return block;
    }

    // (108:4) {#if !edit && !dispatched}
    function create_if_block_1$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("New event");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(108:4) {#if !edit && !dispatched}",
    		ctx
    	});

    	return block;
    }

    // (123:0) {:else}
    function create_else_block$i(ctx) {
    	let form_1;
    	let div3;
    	let label0;
    	let t1;
    	let div2;
    	let div0;
    	let input0;
    	let t2;
    	let div1;
    	let input1;
    	let t3;
    	let div7;
    	let label1;
    	let t5;
    	let div6;
    	let div4;
    	let input2;
    	let t6;
    	let div5;
    	let input3;
    	let t7;
    	let div12;
    	let label2;
    	let t9;
    	let div11;
    	let div8;
    	let input4;
    	let t10;
    	let div9;
    	let input5;
    	let t11;
    	let div10;
    	let input6;
    	let t12;
    	let div15;
    	let label3;
    	let t14;
    	let div14;
    	let div13;
    	let textarea;
    	let t15;
    	let div18;
    	let label4;
    	let t17;
    	let div17;
    	let div16;
    	let input7;
    	let t18;
    	let div19;
    	let button0;
    	let t20;
    	let button1;
    	let t21_value = (/*edit*/ ctx[0] ? 'Update' : 'Create') + "";
    	let t21;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			form_1 = element("form");
    			div3 = element("div");
    			label0 = element("label");
    			label0.textContent = "Event";
    			t1 = space();
    			div2 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			input1 = element("input");
    			t3 = space();
    			div7 = element("div");
    			label1 = element("label");
    			label1.textContent = "Dates";
    			t5 = space();
    			div6 = element("div");
    			div4 = element("div");
    			input2 = element("input");
    			t6 = space();
    			div5 = element("div");
    			input3 = element("input");
    			t7 = space();
    			div12 = element("div");
    			label2 = element("label");
    			label2.textContent = "Organisation";
    			t9 = space();
    			div11 = element("div");
    			div8 = element("div");
    			input4 = element("input");
    			t10 = space();
    			div9 = element("div");
    			input5 = element("input");
    			t11 = space();
    			div10 = element("div");
    			input6 = element("input");
    			t12 = space();
    			div15 = element("div");
    			label3 = element("label");
    			label3.textContent = "Notes";
    			t14 = space();
    			div14 = element("div");
    			div13 = element("div");
    			textarea = element("textarea");
    			t15 = space();
    			div18 = element("div");
    			label4 = element("label");
    			label4.textContent = "Meal price";
    			t17 = space();
    			div17 = element("div");
    			div16 = element("div");
    			input7 = element("input");
    			t18 = space();
    			div19 = element("div");
    			button0 = element("button");
    			button0.textContent = "Cancel";
    			t20 = space();
    			button1 = element("button");
    			t21 = text$1(t21_value);
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-event");
    			add_location(label0, file$k, 126, 12, 5368);
    			attr_dev(input0, "class", "uk-input");
    			attr_dev(input0, "id", "form-name");
    			attr_dev(input0, "name", "name");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Name");
    			set_style(input0, "color", "black");
    			toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[5].name && /*$touched*/ ctx[6].name);
    			add_location(input0, file$k, 129, 20, 5598);
    			attr_dev(div0, "class", "uk-width-3-4@s");
    			add_location(div0, file$k, 128, 16, 5549);
    			attr_dev(input1, "class", "uk-input");
    			attr_dev(input1, "id", "form-abbreviation");
    			attr_dev(input1, "name", "abbreviation");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "Short");
    			attr_dev(input1, "maxlength", "8");
    			set_style(input1, "color", "black");
    			toggle_class(input1, "uk-form-danger", /*$errors*/ ctx[5].abbreviation && /*$touched*/ ctx[6].abbreviation);
    			add_location(input1, file$k, 134, 20, 5970);
    			attr_dev(div1, "class", "uk-width-1-4@s");
    			add_location(div1, file$k, 133, 16, 5921);
    			attr_dev(div2, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div2, "id", "form-event");
    			attr_dev(div2, "uk-grid", "");
    			add_location(div2, file$k, 127, 12, 5440);
    			attr_dev(div3, "class", "uk-margin-medium");
    			add_location(div3, file$k, 125, 8, 5325);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "form-dates");
    			add_location(label1, file$k, 141, 12, 6416);
    			attr_dev(input2, "class", "uk-input");
    			attr_dev(input2, "id", "form-start_date");
    			attr_dev(input2, "name", "start_date");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", "Start");
    			input2.readOnly = true;
    			set_style(input2, "color", "black");
    			toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[5].start_date && /*$touched*/ ctx[6].start_date);
    			add_location(input2, file$k, 144, 20, 6646);
    			attr_dev(div4, "class", "uk-width-1-2@s");
    			add_location(div4, file$k, 143, 16, 6597);
    			attr_dev(input3, "class", "uk-input");
    			attr_dev(input3, "id", "form-end_date");
    			attr_dev(input3, "name", "end_date");
    			attr_dev(input3, "type", "text");
    			attr_dev(input3, "placeholder", "End");
    			input3.readOnly = true;
    			set_style(input3, "color", "black");
    			toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[5].end_date && /*$touched*/ ctx[6].end_date);
    			add_location(input3, file$k, 149, 20, 7057);
    			attr_dev(div5, "class", "uk-width-1-2@s");
    			add_location(div5, file$k, 148, 16, 7008);
    			attr_dev(div6, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div6, "id", "form-dates");
    			attr_dev(div6, "uk-grid", "");
    			add_location(div6, file$k, 142, 12, 6488);
    			attr_dev(div7, "class", "uk-margin-small");
    			add_location(div7, file$k, 140, 8, 6374);
    			attr_dev(label2, "class", "uk-form-label");
    			attr_dev(label2, "for", "form-orga");
    			add_location(label2, file$k, 156, 12, 7476);
    			attr_dev(input4, "class", "uk-input");
    			attr_dev(input4, "id", "form-announcement_link");
    			attr_dev(input4, "name", "announcement_link");
    			attr_dev(input4, "type", "text");
    			attr_dev(input4, "placeholder", "Announcement link");
    			set_style(input4, "color", "black");
    			toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[5].announcement_link && /*$touched*/ ctx[6].announcement_link);
    			add_location(input4, file$k, 159, 20, 7711);
    			attr_dev(div8, "class", "uk-width-1-1@s");
    			add_location(div8, file$k, 158, 16, 7662);
    			attr_dev(input5, "class", "uk-input");
    			attr_dev(input5, "id", "form-contact_email");
    			attr_dev(input5, "name", "contact_email");
    			attr_dev(input5, "type", "text");
    			attr_dev(input5, "placeholder", "Contact email");
    			set_style(input5, "color", "black");
    			toggle_class(input5, "uk-form-danger", /*$errors*/ ctx[5].contact_email && /*$touched*/ ctx[6].contact_email);
    			add_location(input5, file$k, 164, 20, 8160);
    			attr_dev(div9, "class", "uk-width-1-2@s");
    			add_location(div9, file$k, 163, 16, 8111);
    			attr_dev(input6, "class", "uk-input");
    			attr_dev(input6, "id", "form-max_participants");
    			attr_dev(input6, "name", "max_participants");
    			attr_dev(input6, "type", "text");
    			attr_dev(input6, "placeholder", "Max participants");
    			set_style(input6, "color", "black");
    			toggle_class(input6, "uk-form-danger", /*$errors*/ ctx[5].max_participants && /*$touched*/ ctx[6].max_participants);
    			add_location(input6, file$k, 169, 20, 8585);
    			attr_dev(div10, "class", "uk-width-1-2@s");
    			add_location(div10, file$k, 168, 16, 8536);
    			attr_dev(div11, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div11, "id", "form-orga");
    			attr_dev(div11, "uk-grid", "");
    			add_location(div11, file$k, 157, 12, 7554);
    			attr_dev(div12, "class", "uk-margin-medium");
    			add_location(div12, file$k, 155, 8, 7433);
    			attr_dev(label3, "class", "uk-form-label");
    			attr_dev(label3, "for", "form-info");
    			add_location(label3, file$k, 176, 12, 9048);
    			attr_dev(textarea, "class", "uk-textarea");
    			attr_dev(textarea, "name", "info");
    			attr_dev(textarea, "rows", "3");
    			set_style(textarea, "color", "black");
    			toggle_class(textarea, "uk-form-danger", /*$errors*/ ctx[5].info && /*$touched*/ ctx[6].info);
    			add_location(textarea, file$k, 179, 16, 9270);
    			attr_dev(div13, "class", "uk-width-1-1");
    			add_location(div13, file$k, 178, 16, 9227);
    			attr_dev(div14, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div14, "id", "form-info");
    			attr_dev(div14, "uk-grid", "");
    			add_location(div14, file$k, 177, 12, 9119);
    			attr_dev(div15, "class", "uk-margin-medium");
    			add_location(div15, file$k, 175, 8, 9005);
    			attr_dev(label4, "class", "uk-form-label");
    			attr_dev(label4, "for", "form-prices");
    			add_location(label4, file$k, 186, 12, 9638);
    			attr_dev(input7, "class", "uk-input");
    			attr_dev(input7, "id", "form-meal_price_day");
    			attr_dev(input7, "name", "meal_price_day");
    			attr_dev(input7, "type", "text");
    			attr_dev(input7, "placeholder", "Meal price / day");
    			set_style(input7, "color", "black");
    			toggle_class(input7, "uk-form-danger", /*$errors*/ ctx[5].meal_price_day && /*$touched*/ ctx[6].meal_price_day);
    			add_location(input7, file$k, 189, 20, 9875);
    			attr_dev(div16, "class", "uk-width-1-2@s");
    			add_location(div16, file$k, 188, 16, 9826);
    			attr_dev(div17, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div17, "id", "form-prices");
    			attr_dev(div17, "uk-grid", "");
    			add_location(div17, file$k, 187, 12, 9716);
    			attr_dev(div18, "class", "uk-margin-medium");
    			add_location(div18, file$k, 185, 8, 9595);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$k, 196, 12, 10371);
    			attr_dev(button1, "class", "uk-button uk-margin-large-left");
    			attr_dev(button1, "id", "submit");
    			attr_dev(button1, "type", "submit");
    			button1.disabled = button1_disabled_value = !/*$isValid*/ ctx[7];
    			toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[7]);
    			add_location(button1, file$k, 197, 12, 10475);
    			attr_dev(div19, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div19, file$k, 195, 8, 10285);
    			attr_dev(form_1, "class", "uk-form");
    			toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[4]);
    			add_location(form_1, file$k, 123, 4, 5226);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form_1, anchor);
    			append_dev(form_1, div3);
    			append_dev(div3, label0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$form*/ ctx[2].name);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, input1);
    			set_input_value(input1, /*$form*/ ctx[2].abbreviation);
    			append_dev(form_1, t3);
    			append_dev(form_1, div7);
    			append_dev(div7, label1);
    			append_dev(div7, t5);
    			append_dev(div7, div6);
    			append_dev(div6, div4);
    			append_dev(div4, input2);
    			set_input_value(input2, /*$form*/ ctx[2].start_date);
    			append_dev(div6, t6);
    			append_dev(div6, div5);
    			append_dev(div5, input3);
    			set_input_value(input3, /*$form*/ ctx[2].end_date);
    			append_dev(form_1, t7);
    			append_dev(form_1, div12);
    			append_dev(div12, label2);
    			append_dev(div12, t9);
    			append_dev(div12, div11);
    			append_dev(div11, div8);
    			append_dev(div8, input4);
    			set_input_value(input4, /*$form*/ ctx[2].announcement_link);
    			append_dev(div11, t10);
    			append_dev(div11, div9);
    			append_dev(div9, input5);
    			set_input_value(input5, /*$form*/ ctx[2].contact_email);
    			append_dev(div11, t11);
    			append_dev(div11, div10);
    			append_dev(div10, input6);
    			set_input_value(input6, /*$form*/ ctx[2].max_participants);
    			append_dev(form_1, t12);
    			append_dev(form_1, div15);
    			append_dev(div15, label3);
    			append_dev(div15, t14);
    			append_dev(div15, div14);
    			append_dev(div14, div13);
    			append_dev(div13, textarea);
    			set_input_value(textarea, /*$form*/ ctx[2].info);
    			append_dev(form_1, t15);
    			append_dev(form_1, div18);
    			append_dev(div18, label4);
    			append_dev(div18, t17);
    			append_dev(div18, div17);
    			append_dev(div17, div16);
    			append_dev(div16, input7);
    			set_input_value(input7, /*$form*/ ctx[2].meal_price_day);
    			append_dev(form_1, t18);
    			append_dev(form_1, div19);
    			append_dev(div19, button0);
    			append_dev(div19, t20);
    			append_dev(div19, button1);
    			append_dev(button1, t21);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keyup", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input0, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[17]),
    					listen_dev(input1, "change", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input1, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[18]),
    					listen_dev(input2, "change", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input2, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[19]),
    					listen_dev(input3, "change", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input3, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[20]),
    					listen_dev(input4, "change", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input4, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[21]),
    					listen_dev(input5, "change", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input5, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[22]),
    					listen_dev(input6, "change", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input6, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[23]),
    					listen_dev(textarea, "keyup", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(textarea, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[24]),
    					listen_dev(input7, "change", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input7, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[25]),
    					listen_dev(button0, "click", /*cancel*/ ctx[15], false, false, false),
    					listen_dev(form_1, "submit", /*handleSubmit*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$form*/ 4 && input0.value !== /*$form*/ ctx[2].name) {
    				set_input_value(input0, /*$form*/ ctx[2].name);
    			}

    			if (dirty & /*$errors, $touched*/ 96) {
    				toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[5].name && /*$touched*/ ctx[6].name);
    			}

    			if (dirty & /*$form*/ 4 && input1.value !== /*$form*/ ctx[2].abbreviation) {
    				set_input_value(input1, /*$form*/ ctx[2].abbreviation);
    			}

    			if (dirty & /*$errors, $touched*/ 96) {
    				toggle_class(input1, "uk-form-danger", /*$errors*/ ctx[5].abbreviation && /*$touched*/ ctx[6].abbreviation);
    			}

    			if (dirty & /*$form*/ 4 && input2.value !== /*$form*/ ctx[2].start_date) {
    				set_input_value(input2, /*$form*/ ctx[2].start_date);
    			}

    			if (dirty & /*$errors, $touched*/ 96) {
    				toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[5].start_date && /*$touched*/ ctx[6].start_date);
    			}

    			if (dirty & /*$form*/ 4 && input3.value !== /*$form*/ ctx[2].end_date) {
    				set_input_value(input3, /*$form*/ ctx[2].end_date);
    			}

    			if (dirty & /*$errors, $touched*/ 96) {
    				toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[5].end_date && /*$touched*/ ctx[6].end_date);
    			}

    			if (dirty & /*$form*/ 4 && input4.value !== /*$form*/ ctx[2].announcement_link) {
    				set_input_value(input4, /*$form*/ ctx[2].announcement_link);
    			}

    			if (dirty & /*$errors, $touched*/ 96) {
    				toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[5].announcement_link && /*$touched*/ ctx[6].announcement_link);
    			}

    			if (dirty & /*$form*/ 4 && input5.value !== /*$form*/ ctx[2].contact_email) {
    				set_input_value(input5, /*$form*/ ctx[2].contact_email);
    			}

    			if (dirty & /*$errors, $touched*/ 96) {
    				toggle_class(input5, "uk-form-danger", /*$errors*/ ctx[5].contact_email && /*$touched*/ ctx[6].contact_email);
    			}

    			if (dirty & /*$form*/ 4 && input6.value !== /*$form*/ ctx[2].max_participants) {
    				set_input_value(input6, /*$form*/ ctx[2].max_participants);
    			}

    			if (dirty & /*$errors, $touched*/ 96) {
    				toggle_class(input6, "uk-form-danger", /*$errors*/ ctx[5].max_participants && /*$touched*/ ctx[6].max_participants);
    			}

    			if (dirty & /*$form*/ 4) {
    				set_input_value(textarea, /*$form*/ ctx[2].info);
    			}

    			if (dirty & /*$errors, $touched*/ 96) {
    				toggle_class(textarea, "uk-form-danger", /*$errors*/ ctx[5].info && /*$touched*/ ctx[6].info);
    			}

    			if (dirty & /*$form*/ 4 && input7.value !== /*$form*/ ctx[2].meal_price_day) {
    				set_input_value(input7, /*$form*/ ctx[2].meal_price_day);
    			}

    			if (dirty & /*$errors, $touched*/ 96) {
    				toggle_class(input7, "uk-form-danger", /*$errors*/ ctx[5].meal_price_day && /*$touched*/ ctx[6].meal_price_day);
    			}

    			if (dirty & /*edit*/ 1 && t21_value !== (t21_value = (/*edit*/ ctx[0] ? 'Update' : 'Create') + "")) set_data_dev(t21, t21_value);

    			if (dirty & /*$isValid*/ 128 && button1_disabled_value !== (button1_disabled_value = !/*$isValid*/ ctx[7])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*$isValid*/ 128) {
    				toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[7]);
    			}

    			if (dirty & /*$screenWidthL*/ 16) {
    				toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form_1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(123:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (119:0) {#if dispatched}
    function create_if_block$j(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$k, 120, 8, 5169);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-xlarge-top");
    			add_location(div1, file$k, 119, 4, 5103);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(119:0) {#if dispatched}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let h4;
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (!/*edit*/ ctx[0] && !/*dispatched*/ ctx[1]) return create_if_block_1$a;
    		if (!/*dispatched*/ ctx[1]) return create_if_block_2$a;
    		if (/*edit*/ ctx[0]) return create_if_block_3$9;
    		return create_else_block_1$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*dispatched*/ ctx[1]) return create_if_block$j;
    		return create_else_block$i;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			if_block0.c();
    			t = space();
    			if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-inline uk-width-1-1");
    			add_location(h4, file$k, 106, 0, 4585);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			if_block0.m(h4, null);
    			insert_dev(target, t, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h4, null);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if_block0.d();
    			if (detaching) detach_dev(t);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $form;
    	let $settings;
    	let $screenWidthS;
    	let $screenWidthL;
    	let $errors;
    	let $touched;
    	let $isValid;
    	validate_store(settings, 'settings');
    	component_subscribe($$self, settings, $$value => $$invalidate(26, $settings = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(3, $screenWidthS = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(4, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EventForm', slots, []);
    	let { event = undefined } = $$props;
    	let { edit = false } = $$props;
    	let dispatched = false;
    	const dispatch = createEventDispatcher();

    	const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    		initialValues: {
    			name: '',
    			abbreviation: '',
    			start_date: '',
    			end_date: '',
    			contact_email: '',
    			announcement_link: '',
    			max_participants: '',
    			info: '',
    			meal_price_day: ''
    		},
    		onSubmit: values => {
    			$$invalidate(1, dispatched = true);
    			if (event === null) $$invalidate(16, event = {});
    			Object.entries(values).forEach(e => $$invalidate(16, event[e[0]] = e[1], event));

    			$$invalidate(
    				16,
    				event.max_participants = event.max_participants === '' || event.max_participants === 0
    				? null
    				: Number(event.max_participants),
    				event
    			);

    			$$invalidate(
    				16,
    				event.meal_price_day = event.meal_price_day === ''
    				? 0
    				: Number(event.meal_price_day),
    				event
    			);

    			dispatch('message', { goto: 'save' });
    		},
    		validationSchema: create$4().shape({
    			name: create$7().min(3).required(),
    			abbreviation: create$7().min(3).required(),
    			start_date: create$5().min(DateTime_1.now().minus({ years: 1 }).toJSDate()).max(DateTime_1.now().plus({ years: 2 }).toJSDate()).transform((date, string) => DateTime_1.fromSQL(string).toJSDate()).required(),
    			end_date: create$5().min(DateTime_1.now().minus({ years: 1 }).toJSDate()).max(DateTime_1.now().plus({ years: 2 }).toJSDate()).transform((date, string) => DateTime_1.fromSQL(string).toJSDate()).required(),
    			contact_email: create$7().email(),
    			announcement_link: create$7(),
    			max_participants: create$6().transform((number, string) => string === '' ? 0 : Number(string)),
    			info: create$7(),
    			meal_price_day: create$6().transform((number, string) => string === '' ? 0 : Number(string))
    		})
    	});

    	validate_store(form, 'form');
    	component_subscribe($$self, form, value => $$invalidate(2, $form = value));
    	validate_store(errors, 'errors');
    	component_subscribe($$self, errors, value => $$invalidate(5, $errors = value));
    	validate_store(touched, 'touched');
    	component_subscribe($$self, touched, value => $$invalidate(6, $touched = value));
    	validate_store(isValid, 'isValid');
    	component_subscribe($$self, isValid, value => $$invalidate(7, $isValid = value));

    	onMount(async () => {
    		if (event !== undefined) {
    			set_store_value(form, $form.name = event !== null && event.name !== null ? event.name : '', $form);

    			set_store_value(
    				form,
    				$form.abbreviation = event !== null && event.abbreviation !== null
    				? event.abbreviation
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.start_date = event !== null && event.start_date !== null
    				? event.start_date
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.end_date = event !== null && event.end_date !== null
    				? event.end_date
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.contact_email = event !== null && event.contact_email !== null
    				? event.contact_email
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.announcement_link = event !== null && event.announcement_link !== null
    				? event.announcement_link
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.max_participants = event !== null && event.max_participants !== null
    				? event.max_participants
    				: $settings.house_capacity,
    				$form
    			);

    			set_store_value(form, $form.info = event !== null && event.info !== null ? event.info : '', $form);

    			set_store_value(
    				form,
    				$form.meal_price_day = event !== null && event.meal_price_day !== null && event.meal_price_day !== 0
    				? event.meal_price_day
    				: '',
    				$form
    			);

    			// ugly hack to get force evaluate isValid
    			if (event === null) handleSubmit(null);
    		}

    		flatpickr('#form-date', { monthSelectorType: 'static' });

    		flatpickr('#form-dates', {
    			monthSelectorType: 'static',
    			mode: 'range',
    			defaultDate: [$form.start_date, $form.end_date],
    			onChange(selectedDates, dateStr) {
    				set_store_value(form, $form.start_date = dateStr.substring(0, 10), $form);
    				set_store_value(form, $form.end_date = dateStr.substring(14), $form);
    				if ($form.start_date !== '') document.getElementById('form-start_date').focus();

    				if ($form.end_date !== '') {
    					document.getElementById('form-end_date').focus();
    					setTimeout(() => document.getElementById('form-end_date').blur(), 0);
    				}
    			}
    		});
    	});

    	async function deleteMe() {
    		if (event !== null && event.id !== null && confirm("Are you sure to delete this event?")) {
    			dispatch('message', { goto: 'delete' });
    		}
    	}

    	function cancel() {
    		dispatch('message', { goto: 'cancel' });
    	}

    	const writable_props = ['event', 'edit'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EventForm> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		$form.name = this.value;
    		form.set($form);
    	}

    	function input1_input_handler() {
    		$form.abbreviation = this.value;
    		form.set($form);
    	}

    	function input2_input_handler() {
    		$form.start_date = this.value;
    		form.set($form);
    	}

    	function input3_input_handler() {
    		$form.end_date = this.value;
    		form.set($form);
    	}

    	function input4_input_handler() {
    		$form.announcement_link = this.value;
    		form.set($form);
    	}

    	function input5_input_handler() {
    		$form.contact_email = this.value;
    		form.set($form);
    	}

    	function input6_input_handler() {
    		$form.max_participants = this.value;
    		form.set($form);
    	}

    	function textarea_input_handler() {
    		$form.info = this.value;
    		form.set($form);
    	}

    	function input7_input_handler() {
    		$form.meal_price_day = this.value;
    		form.set($form);
    	}

    	$$self.$$set = $$props => {
    		if ('event' in $$props) $$invalidate(16, event = $$props.event);
    		if ('edit' in $$props) $$invalidate(0, edit = $$props.edit);
    	};

    	$$self.$capture_state = () => ({
    		DateTime: DateTime_1,
    		createEventDispatcher,
    		onMount,
    		createForm,
    		yup,
    		flatpickr,
    		screenWidthL,
    		screenWidthS,
    		settings,
    		event,
    		edit,
    		dispatched,
    		dispatch,
    		form,
    		errors,
    		touched,
    		state,
    		isValid,
    		handleChange,
    		handleSubmit,
    		deleteMe,
    		cancel,
    		$form,
    		$settings,
    		$screenWidthS,
    		$screenWidthL,
    		$errors,
    		$touched,
    		$isValid
    	});

    	$$self.$inject_state = $$props => {
    		if ('event' in $$props) $$invalidate(16, event = $$props.event);
    		if ('edit' in $$props) $$invalidate(0, edit = $$props.edit);
    		if ('dispatched' in $$props) $$invalidate(1, dispatched = $$props.dispatched);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		edit,
    		dispatched,
    		$form,
    		$screenWidthS,
    		$screenWidthL,
    		$errors,
    		$touched,
    		$isValid,
    		form,
    		errors,
    		touched,
    		isValid,
    		handleChange,
    		handleSubmit,
    		deleteMe,
    		cancel,
    		event,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		textarea_input_handler,
    		input7_input_handler
    	];
    }

    class EventForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$k, create_fragment$k, safe_not_equal, { event: 16, edit: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventForm",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get event() {
    		throw new Error("<EventForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set event(value) {
    		throw new Error("<EventForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get edit() {
    		throw new Error("<EventForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set edit(value) {
    		throw new Error("<EventForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/EventParticipants.svelte generated by Svelte v3.45.0 */
    const file$j = "src/components/EventParticipants.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (74:0) {#if event !== undefined && event !== null}
    function create_if_block$i(ctx) {
    	let h4;
    	let t0_value = /*event*/ ctx[0].name + "";
    	let t0;
    	let t1;
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*dispatched*/ ctx[4]) return create_if_block_1$9;
    		return create_else_block$h;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if_block.c();
    			if_block_anchor = empty$3();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom");
    			add_location(h4, file$j, 74, 4, 2289);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			append_dev(h4, t0);
    			insert_dev(target, t1, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*event*/ 1 && t0_value !== (t0_value = /*event*/ ctx[0].name + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(74:0) {#if event !== undefined && event !== null}",
    		ctx
    	});

    	return block;
    }

    // (80:4) {:else}
    function create_else_block$h(ctx) {
    	let div5;
    	let div4;
    	let div0;
    	let span0;
    	let t1;

    	let t2_value = (/*event*/ ctx[0].contact_email !== null && /*event*/ ctx[0].contact_email.length > 0
    	? /*event*/ ctx[0].contact_email
    	: '') + "";

    	let t2;
    	let br0;
    	let t3;
    	let span1;
    	let t5;

    	let t6_value = (/*event*/ ctx[0].announcement_link !== null && /*event*/ ctx[0].announcement_link.length > 0
    	? /*event*/ ctx[0].announcement_link
    	: '') + "";

    	let t6;
    	let t7;
    	let div1;
    	let span3;
    	let t8_value = DateTime_1.fromSQL(/*event*/ ctx[0].start_date).toFormat('dd LLL yyyy') + "";
    	let t8;
    	let t9;
    	let t10_value = DateTime_1.fromSQL(/*event*/ ctx[0].end_date).toFormat('dd LLL yyyy') + "";
    	let t10;
    	let br1;
    	let t11;
    	let span2;
    	let t13;
    	let t14;
    	let div3;
    	let div2;
    	let textarea;
    	let t15;
    	let if_block1_anchor;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*event*/ ctx[0].max_participants !== null && /*event*/ ctx[0].max_participants > 0) return create_if_block_6$3;
    		return create_else_block_2$4;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*event*/ ctx[0].bookings !== undefined && /*event*/ ctx[0].bookings?.length > 0 && /*bookings*/ ctx[1].length > 0) return create_if_block_2$9;
    		return create_else_block_1$7;
    	}

    	let current_block_type_1 = select_block_type_2(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "Contact:";
    			t1 = space();
    			t2 = text$1(t2_value);
    			br0 = element("br");
    			t3 = space();
    			span1 = element("span");
    			span1.textContent = "Announcement:";
    			t5 = space();
    			t6 = text$1(t6_value);
    			t7 = space();
    			div1 = element("div");
    			span3 = element("span");
    			t8 = text$1(t8_value);
    			t9 = text$1(" - ");
    			t10 = text$1(t10_value);
    			br1 = element("br");
    			t11 = space();
    			span2 = element("span");
    			span2.textContent = "Participants:";
    			t13 = space();
    			if_block0.c();
    			t14 = space();
    			div3 = element("div");
    			div2 = element("div");
    			textarea = element("textarea");
    			t15 = space();
    			if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(span0, "class", "uk-text-muted");
    			add_location(span0, file$j, 83, 20, 2751);
    			add_location(br0, file$j, 83, 155, 2886);
    			attr_dev(span1, "class", "uk-text-muted");
    			add_location(span1, file$j, 84, 20, 2911);
    			attr_dev(div0, "class", "uk-width-2-3");
    			add_location(div0, file$j, 82, 16, 2704);
    			add_location(br1, file$j, 88, 141, 3317);
    			attr_dev(span2, "class", "uk-text-muted");
    			add_location(span2, file$j, 89, 20, 3342);
    			attr_dev(span3, "class", "uk-align-right");
    			add_location(span3, file$j, 87, 16, 3146);
    			attr_dev(div1, "class", "uk-width-1-3");
    			add_location(div1, file$j, 86, 16, 3103);
    			attr_dev(textarea, "class", "uk-textarea");
    			attr_dev(textarea, "rows", "3");
    			attr_dev(textarea, "placeholder", "Notes");
    			add_location(textarea, file$j, 102, 24, 4174);
    			attr_dev(div2, "class", "uk-form-controls");
    			attr_dev(div2, "id", "form-info");
    			add_location(div2, file$j, 101, 20, 4104);
    			attr_dev(div3, "class", "uk-width-1-1");
    			add_location(div3, file$j, 100, 16, 4057);
    			attr_dev(div4, "class", "uk-grid-small");
    			attr_dev(div4, "uk-grid", "");
    			add_location(div4, file$j, 81, 12, 2652);
    			attr_dev(div5, "class", "uk-margin-medium uk-padding uk-background-muted uk-text-emphasis");
    			add_location(div5, file$j, 80, 8, 2561);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, span0);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			append_dev(div0, br0);
    			append_dev(div0, t3);
    			append_dev(div0, span1);
    			append_dev(div0, t5);
    			append_dev(div0, t6);
    			append_dev(div4, t7);
    			append_dev(div4, div1);
    			append_dev(div1, span3);
    			append_dev(span3, t8);
    			append_dev(span3, t9);
    			append_dev(span3, t10);
    			append_dev(span3, br1);
    			append_dev(span3, t11);
    			append_dev(span3, span2);
    			append_dev(span3, t13);
    			if_block0.m(span3, null);
    			append_dev(div4, t14);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, textarea);
    			set_input_value(textarea, /*event*/ ctx[0].info);
    			insert_dev(target, t15, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[8]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*event*/ 1 && t2_value !== (t2_value = (/*event*/ ctx[0].contact_email !== null && /*event*/ ctx[0].contact_email.length > 0
    			? /*event*/ ctx[0].contact_email
    			: '') + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*event*/ 1 && t6_value !== (t6_value = (/*event*/ ctx[0].announcement_link !== null && /*event*/ ctx[0].announcement_link.length > 0
    			? /*event*/ ctx[0].announcement_link
    			: '') + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*event*/ 1 && t8_value !== (t8_value = DateTime_1.fromSQL(/*event*/ ctx[0].start_date).toFormat('dd LLL yyyy') + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*event*/ 1 && t10_value !== (t10_value = DateTime_1.fromSQL(/*event*/ ctx[0].end_date).toFormat('dd LLL yyyy') + "")) set_data_dev(t10, t10_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span3, null);
    				}
    			}

    			if (dirty & /*event*/ 1) {
    				set_input_value(textarea, /*event*/ ctx[0].info);
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_2(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if_block0.d();
    			if (detaching) detach_dev(t15);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(80:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (76:4) {#if dispatched}
    function create_if_block_1$9(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$j, 77, 12, 2492);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-xlarge-top");
    			add_location(div1, file$j, 76, 8, 2422);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(76:4) {#if dispatched}",
    		ctx
    	});

    	return block;
    }

    // (96:20) {:else}
    function create_else_block_2$4(ctx) {
    	let span;
    	let t_value = /*event*/ ctx[0].participant_count + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "class", "uk-text-bold");
    			add_location(span, file$j, 96, 24, 3908);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*event*/ 1 && t_value !== (t_value = /*event*/ ctx[0].participant_count + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$4.name,
    		type: "else",
    		source: "(96:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (91:20) {#if event.max_participants !== null && event.max_participants > 0}
    function create_if_block_6$3(ctx) {
    	let span0;
    	let t0_value = /*event*/ ctx[0].participant_count + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2;
    	let t3_value = /*event*/ ctx[0].max_participants + "";
    	let t3;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text$1("/ ");
    			t3 = text$1(t3_value);
    			attr_dev(span0, "class", "uk-text-bold");
    			toggle_class(span0, "uk-text-success", /*event*/ ctx[0].participant_count <= /*event*/ ctx[0].max_participants);
    			toggle_class(span0, "uk-text-danger", /*event*/ ctx[0].participant_count > /*event*/ ctx[0].max_participants);
    			add_location(span0, file$j, 91, 24, 3504);
    			attr_dev(span1, "class", "uk-text-bold");
    			add_location(span1, file$j, 94, 24, 3794);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			append_dev(span0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t2);
    			append_dev(span1, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*event*/ 1 && t0_value !== (t0_value = /*event*/ ctx[0].participant_count + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*event*/ 1) {
    				toggle_class(span0, "uk-text-success", /*event*/ ctx[0].participant_count <= /*event*/ ctx[0].max_participants);
    			}

    			if (dirty & /*event*/ 1) {
    				toggle_class(span0, "uk-text-danger", /*event*/ ctx[0].participant_count > /*event*/ ctx[0].max_participants);
    			}

    			if (dirty & /*event*/ 1 && t3_value !== (t3_value = /*event*/ ctx[0].max_participants + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(91:20) {#if event.max_participants !== null && event.max_participants > 0}",
    		ctx
    	});

    	return block;
    }

    // (179:8) {:else}
    function create_else_block_1$7(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "No bookings so far :(";
    			t1 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Cancel";
    			attr_dev(div0, "class", "uk-flex uk-flex-center uk-margin-medium");
    			add_location(div0, file$j, 179, 12, 9104);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			attr_dev(button, "type", "button");
    			add_location(button, file$j, 183, 16, 9317);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div1, file$j, 182, 12, 9227);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*cancel*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$7.name,
    		type: "else",
    		source: "(179:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (108:8) {#if event.bookings !== undefined && event.bookings?.length > 0 && bookings.length > 0}
    function create_if_block_2$9(ctx) {
    	let previous_key = /*bookingsConfirmed*/ ctx[2];
    	let t0;
    	let div;
    	let button0;
    	let t2;
    	let button1;
    	let mounted;
    	let dispose;
    	let key_block = create_key_block$6(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			t0 = space();
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Cancel";
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "Save";
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$j, 174, 16, 8823);
    			attr_dev(button1, "class", "uk-button uk-margin-large-left uk-button-primary");
    			attr_dev(button1, "type", "button");
    			add_location(button1, file$j, 175, 16, 8931);
    			attr_dev(div, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div, file$j, 173, 12, 8733);
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*cancel*/ ctx[6], false, false, false),
    					listen_dev(button1, "click", /*save*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bookingsConfirmed*/ 4 && safe_not_equal(previous_key, previous_key = /*bookingsConfirmed*/ ctx[2])) {
    				key_block.d(1);
    				key_block = create_key_block$6(ctx);
    				key_block.c();
    				key_block.m(t0.parentNode, t0);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		d: function destroy(detaching) {
    			key_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(108:8) {#if event.bookings !== undefined && event.bookings?.length > 0 && bookings.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (128:28) {#if booking.confirmed}
    function create_if_block_5$4(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*booking*/ ctx[13].name + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*booking*/ ctx[13].people_count + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = DateTime_1.fromSQL(/*booking*/ ctx[13].booking_date).toFormat('dd LLL yyyy') + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = DateTime_1.fromSQL(/*booking*/ ctx[13].arrival).toFormat('dd LLL yyyy') + "";
    	let t6;
    	let t7;
    	let t8_value = DateTime_1.fromSQL(/*booking*/ ctx[13].departure).toFormat('dd LLL yyyy') + "";
    	let t8;
    	let t9;
    	let td4;
    	let t10_value = /*booking*/ ctx[13].stay_days + "";
    	let t10;
    	let t11;
    	let td5;
    	let a;
    	let t12;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[9](/*booking*/ ctx[13]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = text$1(" - ");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td4 = element("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			td5 = element("td");
    			a = element("a");
    			t12 = space();
    			add_location(td0, file$j, 129, 36, 5734);
    			add_location(td1, file$j, 130, 36, 5794);
    			attr_dev(td2, "class", "uk-visible@s uk-text-nowrap");
    			add_location(td2, file$j, 131, 36, 5862);
    			attr_dev(td3, "class", "uk-visible@s uk-text-nowrap");
    			add_location(td3, file$j, 132, 36, 6008);
    			attr_dev(td4, "class", "uk-visible@s");
    			add_location(td4, file$j, 133, 36, 6213);
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "minus-circle");
    			add_location(a, file$j, 134, 64, 6327);
    			attr_dev(td5, "class", "uk-text-primary");
    			add_location(td5, file$j, 134, 36, 6299);
    			attr_dev(tr, "class", "uk-table-link");
    			add_location(tr, file$j, 128, 32, 5670);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(td3, t7);
    			append_dev(td3, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td4);
    			append_dev(td4, t10);
    			append_dev(tr, t11);
    			append_dev(tr, td5);
    			append_dev(td5, a);
    			append_dev(tr, t12);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*bookings*/ 2 && t0_value !== (t0_value = /*booking*/ ctx[13].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*bookings*/ 2 && t2_value !== (t2_value = /*booking*/ ctx[13].people_count + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*bookings*/ 2 && t4_value !== (t4_value = DateTime_1.fromSQL(/*booking*/ ctx[13].booking_date).toFormat('dd LLL yyyy') + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*bookings*/ 2 && t6_value !== (t6_value = DateTime_1.fromSQL(/*booking*/ ctx[13].arrival).toFormat('dd LLL yyyy') + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*bookings*/ 2 && t8_value !== (t8_value = DateTime_1.fromSQL(/*booking*/ ctx[13].departure).toFormat('dd LLL yyyy') + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*bookings*/ 2 && t10_value !== (t10_value = /*booking*/ ctx[13].stay_days + "")) set_data_dev(t10, t10_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(128:28) {#if booking.confirmed}",
    		ctx
    	});

    	return block;
    }

    // (127:24) {#each bookings as booking}
    function create_each_block_1$4(ctx) {
    	let if_block_anchor;
    	let if_block = /*booking*/ ctx[13].confirmed && create_if_block_5$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*booking*/ ctx[13].confirmed) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_5$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(127:24) {#each bookings as booking}",
    		ctx
    	});

    	return block;
    }

    // (142:16) {#if bookingsWaiting > 0}
    function create_if_block_3$8(ctx) {
    	let div;
    	let h3;
    	let span1;
    	let t0;
    	let span0;
    	let t1;
    	let t2;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t4;
    	let th1;
    	let t6;
    	let th2;
    	let t8;
    	let th3;
    	let t10;
    	let th4;
    	let t12;
    	let th5;
    	let t14;
    	let tbody;
    	let each_value = /*bookings*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			span1 = element("span");
    			t0 = text$1("Waiting list: ");
    			span0 = element("span");
    			t1 = text$1(/*bookingsWaiting*/ ctx[3]);
    			t2 = space();
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name";
    			t4 = space();
    			th1 = element("th");
    			th1.textContent = "People";
    			t6 = space();
    			th2 = element("th");
    			th2.textContent = "Booking date";
    			t8 = space();
    			th3 = element("th");
    			th3.textContent = "Stay";
    			t10 = space();
    			th4 = element("th");
    			th4.textContent = "Days";
    			t12 = space();
    			th5 = element("th");
    			th5.textContent = "Action";
    			t14 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span0, "class", "uk-text-light");
    			add_location(span0, file$j, 143, 101, 6803);
    			add_location(span1, file$j, 143, 81, 6783);
    			attr_dev(h3, "class", "uk-heading-line uk-text-center uk-text-light");
    			add_location(h3, file$j, 143, 24, 6726);
    			add_location(th0, file$j, 147, 32, 7080);
    			add_location(th1, file$j, 148, 32, 7126);
    			attr_dev(th2, "class", "uk-visible@m uk-text-nowrap");
    			add_location(th2, file$j, 149, 32, 7174);
    			attr_dev(th3, "class", "uk-visible@s");
    			add_location(th3, file$j, 150, 32, 7264);
    			attr_dev(th4, "class", "uk-visible@m");
    			add_location(th4, file$j, 151, 32, 7331);
    			attr_dev(th5, "class", "uk-table-shrink");
    			add_location(th5, file$j, 152, 32, 7398);
    			add_location(tr, file$j, 146, 28, 7043);
    			add_location(thead, file$j, 145, 28, 7007);
    			add_location(tbody, file$j, 155, 28, 7537);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$j, 144, 24, 6893);
    			attr_dev(div, "class", "uk-margin-medium");
    			add_location(div, file$j, 142, 20, 6671);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(h3, span1);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    			append_dev(div, t2);
    			append_dev(div, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t4);
    			append_dev(tr, th1);
    			append_dev(tr, t6);
    			append_dev(tr, th2);
    			append_dev(tr, t8);
    			append_dev(tr, th3);
    			append_dev(tr, t10);
    			append_dev(tr, th4);
    			append_dev(tr, t12);
    			append_dev(tr, th5);
    			append_dev(table, t14);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bookingsWaiting*/ 8) set_data_dev(t1, /*bookingsWaiting*/ ctx[3]);

    			if (dirty & /*toggleBooking, bookings, DateTime*/ 34) {
    				each_value = /*bookings*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$8.name,
    		type: "if",
    		source: "(142:16) {#if bookingsWaiting > 0}",
    		ctx
    	});

    	return block;
    }

    // (158:32) {#if !booking.confirmed}
    function create_if_block_4$5(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*booking*/ ctx[13].name + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*booking*/ ctx[13].people_count + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = DateTime_1.fromSQL(/*booking*/ ctx[13].booking_date).toFormat('dd LLL yyyy') + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = DateTime_1.fromSQL(/*booking*/ ctx[13].arrival).toFormat('dd LLL yyyy') + "";
    	let t6;
    	let t7;
    	let t8_value = DateTime_1.fromSQL(/*booking*/ ctx[13].departure).toFormat('dd LLL yyyy') + "";
    	let t8;
    	let t9;
    	let td4;
    	let t10_value = /*booking*/ ctx[13].stay_days + "";
    	let t10;
    	let t11;
    	let td5;
    	let a;
    	let t12;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[10](/*booking*/ ctx[13]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = text$1(" - ");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td4 = element("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			td5 = element("td");
    			a = element("a");
    			t12 = space();
    			add_location(td0, file$j, 159, 40, 7762);
    			add_location(td1, file$j, 160, 40, 7826);
    			attr_dev(td2, "class", "uk-visible@m uk-text-nowrap");
    			add_location(td2, file$j, 161, 40, 7898);
    			attr_dev(td3, "class", "uk-visible@s uk-text-nowrap");
    			add_location(td3, file$j, 162, 40, 8048);
    			attr_dev(td4, "class", "uk-visible@m");
    			add_location(td4, file$j, 163, 40, 8257);
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "plus-circle");
    			add_location(a, file$j, 164, 68, 8375);
    			attr_dev(td5, "class", "uk-text-primary");
    			add_location(td5, file$j, 164, 40, 8347);
    			attr_dev(tr, "class", "uk-table-link");
    			add_location(tr, file$j, 158, 36, 7694);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(td3, t7);
    			append_dev(td3, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td4);
    			append_dev(td4, t10);
    			append_dev(tr, t11);
    			append_dev(tr, td5);
    			append_dev(td5, a);
    			append_dev(tr, t12);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*bookings*/ 2 && t0_value !== (t0_value = /*booking*/ ctx[13].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*bookings*/ 2 && t2_value !== (t2_value = /*booking*/ ctx[13].people_count + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*bookings*/ 2 && t4_value !== (t4_value = DateTime_1.fromSQL(/*booking*/ ctx[13].booking_date).toFormat('dd LLL yyyy') + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*bookings*/ 2 && t6_value !== (t6_value = DateTime_1.fromSQL(/*booking*/ ctx[13].arrival).toFormat('dd LLL yyyy') + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*bookings*/ 2 && t8_value !== (t8_value = DateTime_1.fromSQL(/*booking*/ ctx[13].departure).toFormat('dd LLL yyyy') + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*bookings*/ 2 && t10_value !== (t10_value = /*booking*/ ctx[13].stay_days + "")) set_data_dev(t10, t10_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(158:32) {#if !booking.confirmed}",
    		ctx
    	});

    	return block;
    }

    // (157:28) {#each bookings as booking}
    function create_each_block$c(ctx) {
    	let if_block_anchor;
    	let if_block = !/*booking*/ ctx[13].confirmed && create_if_block_4$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*booking*/ ctx[13].confirmed) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$5(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(157:28) {#each bookings as booking}",
    		ctx
    	});

    	return block;
    }

    // (109:12) {#key bookingsConfirmed}
    function create_key_block$6(ctx) {
    	let div;
    	let h3;
    	let span1;
    	let t0;
    	let span0;
    	let t1;
    	let t2;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t4;
    	let th1;
    	let t6;
    	let th2;
    	let t8;
    	let th3;
    	let t10;
    	let th4;
    	let t12;
    	let th5;
    	let t14;
    	let tbody;
    	let t15;
    	let if_block_anchor;
    	let each_value_1 = /*bookings*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	let if_block = /*bookingsWaiting*/ ctx[3] > 0 && create_if_block_3$8(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			span1 = element("span");
    			t0 = text$1("Confirmed bookings:\n                    ");
    			span0 = element("span");
    			t1 = text$1(/*bookingsConfirmed*/ ctx[2]);
    			t2 = space();
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name";
    			t4 = space();
    			th1 = element("th");
    			th1.textContent = "People";
    			t6 = space();
    			th2 = element("th");
    			th2.textContent = "Booking date";
    			t8 = space();
    			th3 = element("th");
    			th3.textContent = "Stay";
    			t10 = space();
    			th4 = element("th");
    			th4.textContent = "Days";
    			t12 = space();
    			th5 = element("th");
    			th5.textContent = "Action";
    			t14 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t15 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    			attr_dev(span0, "class", "uk-text-light");
    			toggle_class(span0, "uk-text-bold", /*bookingsConfirmed*/ ctx[2] > /*event*/ ctx[0].max_participants);
    			toggle_class(span0, "uk-text-danger", /*bookingsConfirmed*/ ctx[2] > /*event*/ ctx[0].max_participants);
    			add_location(span0, file$j, 111, 20, 4656);
    			add_location(span1, file$j, 110, 77, 4610);
    			attr_dev(h3, "class", "uk-heading-line uk-text-center uk-text-light");
    			add_location(h3, file$j, 110, 20, 4553);
    			add_location(th0, file$j, 117, 28, 5101);
    			add_location(th1, file$j, 118, 28, 5143);
    			attr_dev(th2, "class", "uk-visible@s uk-text-nowrap");
    			add_location(th2, file$j, 119, 28, 5187);
    			attr_dev(th3, "class", "uk-visible@s");
    			add_location(th3, file$j, 120, 28, 5273);
    			attr_dev(th4, "class", "uk-visible@s");
    			add_location(th4, file$j, 121, 28, 5336);
    			attr_dev(th5, "class", "uk-table-shrink");
    			add_location(th5, file$j, 122, 28, 5399);
    			add_location(tr, file$j, 116, 24, 5068);
    			add_location(thead, file$j, 115, 24, 5036);
    			add_location(tbody, file$j, 125, 24, 5526);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$j, 114, 20, 4926);
    			attr_dev(div, "class", "uk-margin-medium");
    			add_location(div, file$j, 109, 16, 4502);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(h3, span1);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    			append_dev(div, t2);
    			append_dev(div, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t4);
    			append_dev(tr, th1);
    			append_dev(tr, t6);
    			append_dev(tr, th2);
    			append_dev(tr, t8);
    			append_dev(tr, th3);
    			append_dev(tr, t10);
    			append_dev(tr, th4);
    			append_dev(tr, t12);
    			append_dev(tr, th5);
    			append_dev(table, t14);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			insert_dev(target, t15, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bookingsConfirmed*/ 4) set_data_dev(t1, /*bookingsConfirmed*/ ctx[2]);

    			if (dirty & /*bookingsConfirmed, event*/ 5) {
    				toggle_class(span0, "uk-text-bold", /*bookingsConfirmed*/ ctx[2] > /*event*/ ctx[0].max_participants);
    			}

    			if (dirty & /*bookingsConfirmed, event*/ 5) {
    				toggle_class(span0, "uk-text-danger", /*bookingsConfirmed*/ ctx[2] > /*event*/ ctx[0].max_participants);
    			}

    			if (dirty & /*toggleBooking, bookings, DateTime*/ 34) {
    				each_value_1 = /*bookings*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*bookingsWaiting*/ ctx[3] > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$8(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t15);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$6.name,
    		type: "key",
    		source: "(109:12) {#key bookingsConfirmed}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let if_block_anchor;
    	let if_block = /*event*/ ctx[0] !== undefined && /*event*/ ctx[0] !== null && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*event*/ ctx[0] !== undefined && /*event*/ ctx[0] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EventParticipants', slots, []);
    	let { event = undefined } = $$props;
    	let bookings = [];
    	let bookingsConfirmed = 0;
    	let bookingsWaiting = 0;
    	let dispatched = false;
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		if (event !== undefined && event !== null && event.bookings !== null && event.bookings.length > 0) {
    			$$invalidate(1, bookings = await getBookingsByIds(event.bookings.map(b => b.id)));
    			if (bookings === null) $$invalidate(1, bookings = []);

    			bookings.forEach(b => {
    				let eventBooking = event.bookings.find(eb => eb.id === b.id);

    				b.confirmed = eventBooking !== undefined
    				? eventBooking.confirmed
    				: false;

    				if (b.confirmed) $$invalidate(2, bookingsConfirmed += b.people_count); else $$invalidate(3, bookingsWaiting += b.people_count);
    			});
    		}
    	});

    	function updateEventConfirmations() {
    		if (event !== undefined && event !== null && event.bookings !== null && event.bookings.length > 0) {
    			event.bookings.forEach(eb => {
    				let booking = bookings.find(b => b.id === eb.id);
    				if (booking !== undefined) eb.confirmed = booking.confirmed;
    			});
    		}
    	}

    	function toggleBooking(id) {
    		bookings.forEach(b => {
    			if (b.id === id) {
    				b.confirmed = !b.confirmed;

    				if (b.confirmed) {
    					$$invalidate(2, bookingsConfirmed += b.people_count);
    					$$invalidate(3, bookingsWaiting -= b.people_count);
    				} else {
    					$$invalidate(2, bookingsConfirmed -= b.people_count);
    					$$invalidate(3, bookingsWaiting += b.people_count);
    				}
    			}
    		});
    	}

    	function cancel() {
    		dispatch('message', { goto: 'cancel' });
    	}

    	async function save() {
    		$$invalidate(4, dispatched = true);
    		updateEventConfirmations();
    		await updateEvent(event);
    		dispatch('message', { goto: 'participants' });
    	}

    	const writable_props = ['event'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EventParticipants> was created with unknown prop '${key}'`);
    	});

    	function textarea_input_handler() {
    		event.info = this.value;
    		$$invalidate(0, event);
    	}

    	const click_handler = booking => toggleBooking(booking.id);
    	const click_handler_1 = booking => toggleBooking(booking.id);

    	$$self.$$set = $$props => {
    		if ('event' in $$props) $$invalidate(0, event = $$props.event);
    	};

    	$$self.$capture_state = () => ({
    		DateTime: DateTime_1,
    		createEventDispatcher,
    		onMount,
    		getBookingsByIds,
    		updateEvent,
    		event,
    		bookings,
    		bookingsConfirmed,
    		bookingsWaiting,
    		dispatched,
    		dispatch,
    		updateEventConfirmations,
    		toggleBooking,
    		cancel,
    		save
    	});

    	$$self.$inject_state = $$props => {
    		if ('event' in $$props) $$invalidate(0, event = $$props.event);
    		if ('bookings' in $$props) $$invalidate(1, bookings = $$props.bookings);
    		if ('bookingsConfirmed' in $$props) $$invalidate(2, bookingsConfirmed = $$props.bookingsConfirmed);
    		if ('bookingsWaiting' in $$props) $$invalidate(3, bookingsWaiting = $$props.bookingsWaiting);
    		if ('dispatched' in $$props) $$invalidate(4, dispatched = $$props.dispatched);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		event,
    		bookings,
    		bookingsConfirmed,
    		bookingsWaiting,
    		dispatched,
    		toggleBooking,
    		cancel,
    		save,
    		textarea_input_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class EventParticipants extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$j, create_fragment$j, safe_not_equal, { event: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventParticipants",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get event() {
    		throw new Error("<EventParticipants>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set event(value) {
    		throw new Error("<EventParticipants>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/EventEmails.svelte generated by Svelte v3.45.0 */
    const file$i = "src/components/EventEmails.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (40:0) {#if event !== undefined && event !== null}
    function create_if_block$h(ctx) {
    	let h4;
    	let t0_value = /*event*/ ctx[0].name + "";
    	let t0;
    	let t1;
    	let div5;
    	let div4;
    	let div0;
    	let span0;
    	let t3;

    	let t4_value = (/*event*/ ctx[0].contact_email !== null && /*event*/ ctx[0].contact_email.length > 0
    	? /*event*/ ctx[0].contact_email
    	: '') + "";

    	let t4;
    	let br0;
    	let t5;
    	let span1;
    	let t7;

    	let t8_value = (/*event*/ ctx[0].announcement_link !== null && /*event*/ ctx[0].announcement_link.length > 0
    	? /*event*/ ctx[0].announcement_link
    	: '') + "";

    	let t8;
    	let t9;
    	let div1;
    	let span3;
    	let t10_value = DateTime_1.fromSQL(/*event*/ ctx[0].start_date).toFormat('dd LLL yyyy') + "";
    	let t10;
    	let t11;
    	let t12_value = DateTime_1.fromSQL(/*event*/ ctx[0].end_date).toFormat('dd LLL yyyy') + "";
    	let t12;
    	let br1;
    	let t13;
    	let span2;
    	let t15;
    	let t16;
    	let div3;
    	let div2;
    	let textarea;
    	let t17;
    	let if_block1_anchor;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*event*/ ctx[0].max_participants !== null && /*event*/ ctx[0].max_participants > 0) return create_if_block_5$3;
    		return create_else_block_1$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*event*/ ctx[0].bookings !== undefined && /*event*/ ctx[0].bookings?.length > 0 && /*bookings*/ ctx[1].length > 0) return create_if_block_1$8;
    		return create_else_block$g;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			t0 = text$1(t0_value);
    			t1 = space();
    			div5 = element("div");
    			div4 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "Contact:";
    			t3 = space();
    			t4 = text$1(t4_value);
    			br0 = element("br");
    			t5 = space();
    			span1 = element("span");
    			span1.textContent = "Announcement:";
    			t7 = space();
    			t8 = text$1(t8_value);
    			t9 = space();
    			div1 = element("div");
    			span3 = element("span");
    			t10 = text$1(t10_value);
    			t11 = text$1(" - ");
    			t12 = text$1(t12_value);
    			br1 = element("br");
    			t13 = space();
    			span2 = element("span");
    			span2.textContent = "Participants:";
    			t15 = space();
    			if_block0.c();
    			t16 = space();
    			div3 = element("div");
    			div2 = element("div");
    			textarea = element("textarea");
    			t17 = space();
    			if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom");
    			add_location(h4, file$i, 40, 4, 1231);
    			attr_dev(span0, "class", "uk-text-muted");
    			add_location(span0, file$i, 44, 16, 1517);
    			add_location(br0, file$i, 44, 151, 1652);
    			attr_dev(span1, "class", "uk-text-muted");
    			add_location(span1, file$i, 45, 16, 1673);
    			attr_dev(div0, "class", "uk-width-2-3");
    			add_location(div0, file$i, 43, 12, 1474);
    			add_location(br1, file$i, 49, 141, 2071);
    			attr_dev(span2, "class", "uk-text-muted");
    			add_location(span2, file$i, 50, 20, 2096);
    			attr_dev(span3, "class", "uk-align-right");
    			add_location(span3, file$i, 48, 16, 1900);
    			attr_dev(div1, "class", "uk-width-1-3");
    			add_location(div1, file$i, 47, 12, 1857);
    			attr_dev(textarea, "class", "uk-textarea");
    			attr_dev(textarea, "rows", "3");
    			attr_dev(textarea, "placeholder", "Notes");
    			textarea.readOnly = true;
    			add_location(textarea, file$i, 63, 20, 2912);
    			attr_dev(div2, "class", "uk-form-controls");
    			attr_dev(div2, "id", "form-info");
    			add_location(div2, file$i, 62, 16, 2846);
    			attr_dev(div3, "class", "uk-width-1-1");
    			add_location(div3, file$i, 61, 12, 2803);
    			attr_dev(div4, "class", "uk-grid-small");
    			attr_dev(div4, "uk-grid", "");
    			add_location(div4, file$i, 42, 8, 1426);
    			attr_dev(div5, "class", "uk-margin-medium uk-padding uk-background-muted uk-text-emphasis");
    			add_location(div5, file$i, 41, 4, 1339);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			append_dev(h4, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, span0);
    			append_dev(div0, t3);
    			append_dev(div0, t4);
    			append_dev(div0, br0);
    			append_dev(div0, t5);
    			append_dev(div0, span1);
    			append_dev(div0, t7);
    			append_dev(div0, t8);
    			append_dev(div4, t9);
    			append_dev(div4, div1);
    			append_dev(div1, span3);
    			append_dev(span3, t10);
    			append_dev(span3, t11);
    			append_dev(span3, t12);
    			append_dev(span3, br1);
    			append_dev(span3, t13);
    			append_dev(span3, span2);
    			append_dev(span3, t15);
    			if_block0.m(span3, null);
    			append_dev(div4, t16);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, textarea);
    			set_input_value(textarea, /*event*/ ctx[0].info);
    			insert_dev(target, t17, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[5]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*event*/ 1 && t0_value !== (t0_value = /*event*/ ctx[0].name + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*event*/ 1 && t4_value !== (t4_value = (/*event*/ ctx[0].contact_email !== null && /*event*/ ctx[0].contact_email.length > 0
    			? /*event*/ ctx[0].contact_email
    			: '') + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*event*/ 1 && t8_value !== (t8_value = (/*event*/ ctx[0].announcement_link !== null && /*event*/ ctx[0].announcement_link.length > 0
    			? /*event*/ ctx[0].announcement_link
    			: '') + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*event*/ 1 && t10_value !== (t10_value = DateTime_1.fromSQL(/*event*/ ctx[0].start_date).toFormat('dd LLL yyyy') + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*event*/ 1 && t12_value !== (t12_value = DateTime_1.fromSQL(/*event*/ ctx[0].end_date).toFormat('dd LLL yyyy') + "")) set_data_dev(t12, t12_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span3, null);
    				}
    			}

    			if (dirty & /*event*/ 1) {
    				set_input_value(textarea, /*event*/ ctx[0].info);
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div5);
    			if_block0.d();
    			if (detaching) detach_dev(t17);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(40:0) {#if event !== undefined && event !== null}",
    		ctx
    	});

    	return block;
    }

    // (57:20) {:else}
    function create_else_block_1$6(ctx) {
    	let span;
    	let t_value = /*event*/ ctx[0].participant_count + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "class", "uk-text-bold");
    			add_location(span, file$i, 57, 24, 2662);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*event*/ 1 && t_value !== (t_value = /*event*/ ctx[0].participant_count + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$6.name,
    		type: "else",
    		source: "(57:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (52:20) {#if event.max_participants !== null && event.max_participants > 0}
    function create_if_block_5$3(ctx) {
    	let span0;
    	let t0_value = /*event*/ ctx[0].participant_count + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2;
    	let t3_value = /*event*/ ctx[0].max_participants + "";
    	let t3;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text$1("/ ");
    			t3 = text$1(t3_value);
    			attr_dev(span0, "class", "uk-text-bold");
    			toggle_class(span0, "uk-text-success", /*event*/ ctx[0].participant_count <= /*event*/ ctx[0].max_participants);
    			toggle_class(span0, "uk-text-danger", /*event*/ ctx[0].participant_count > /*event*/ ctx[0].max_participants);
    			add_location(span0, file$i, 52, 24, 2258);
    			attr_dev(span1, "class", "uk-text-bold");
    			add_location(span1, file$i, 55, 24, 2548);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			append_dev(span0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, span1, anchor);
    			append_dev(span1, t2);
    			append_dev(span1, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*event*/ 1 && t0_value !== (t0_value = /*event*/ ctx[0].participant_count + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*event*/ 1) {
    				toggle_class(span0, "uk-text-success", /*event*/ ctx[0].participant_count <= /*event*/ ctx[0].max_participants);
    			}

    			if (dirty & /*event*/ 1) {
    				toggle_class(span0, "uk-text-danger", /*event*/ ctx[0].participant_count > /*event*/ ctx[0].max_participants);
    			}

    			if (dirty & /*event*/ 1 && t3_value !== (t3_value = /*event*/ ctx[0].max_participants + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(52:20) {#if event.max_participants !== null && event.max_participants > 0}",
    		ctx
    	});

    	return block;
    }

    // (100:4) {:else}
    function create_else_block$g(ctx) {
    	let div0;
    	let t1;
    	let div1;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "No bookings so far :(";
    			t1 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Cancel";
    			attr_dev(div0, "class", "uk-flex uk-flex-center uk-margin-medium");
    			add_location(div0, file$i, 100, 8, 4720);
    			attr_dev(button, "class", "uk-button uk-button-default");
    			attr_dev(button, "type", "button");
    			add_location(button, file$i, 104, 12, 4917);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div1, file$i, 103, 8, 4831);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*cancel*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(100:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (69:4) {#if event.bookings !== undefined && event.bookings?.length > 0 && bookings.length > 0}
    function create_if_block_1$8(ctx) {
    	let previous_key = /*bookingsConfirmed*/ ctx[2];
    	let t0;
    	let div;
    	let button;
    	let mounted;
    	let dispose;
    	let key_block = create_key_block$5(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			t0 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Cancel";
    			attr_dev(button, "class", "uk-button uk-button-default");
    			attr_dev(button, "type", "button");
    			add_location(button, file$i, 97, 12, 4593);
    			attr_dev(div, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div, file$i, 96, 8, 4507);
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*cancel*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bookingsConfirmed*/ 4 && safe_not_equal(previous_key, previous_key = /*bookingsConfirmed*/ ctx[2])) {
    				key_block.d(1);
    				key_block = create_key_block$5(ctx);
    				key_block.c();
    				key_block.m(t0.parentNode, t0);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		d: function destroy(detaching) {
    			key_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(69:4) {#if event.bookings !== undefined && event.bookings?.length > 0 && bookings.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (78:20) {#if booking.confirmed}
    function create_if_block_4$4(ctx) {
    	let li;
    	let t_value = /*booking*/ ctx[8].email + "";
    	let t;

    	const block = {
    		c: function create() {
    			li = element("li");
    			t = text$1(t_value);
    			add_location(li, file$i, 78, 24, 3787);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bookings*/ 2 && t_value !== (t_value = /*booking*/ ctx[8].email + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(78:20) {#if booking.confirmed}",
    		ctx
    	});

    	return block;
    }

    // (77:16) {#each bookings as booking}
    function create_each_block_1$3(ctx) {
    	let if_block_anchor;
    	let if_block = /*booking*/ ctx[8].confirmed && create_if_block_4$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*booking*/ ctx[8].confirmed) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_4$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(77:16) {#each bookings as booking}",
    		ctx
    	});

    	return block;
    }

    // (84:12) {#if bookingsWaiting > 0}
    function create_if_block_2$8(ctx) {
    	let div;
    	let h3;
    	let span1;
    	let t0;
    	let span0;
    	let t1;
    	let t2;
    	let ul;
    	let each_value = /*bookings*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			span1 = element("span");
    			t0 = text$1("Waiting list: ");
    			span0 = element("span");
    			t1 = text$1(/*bookingsWaiting*/ ctx[3]);
    			t2 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span0, "class", "uk-text-light");
    			add_location(span0, file$i, 85, 97, 4085);
    			add_location(span1, file$i, 85, 77, 4065);
    			attr_dev(h3, "class", "uk-heading-line uk-text-center uk-text-light");
    			add_location(h3, file$i, 85, 20, 4008);
    			attr_dev(ul, "class", "uk-list uk-list-collapse");
    			add_location(ul, file$i, 86, 20, 4171);
    			attr_dev(div, "class", "uk-margin-medium");
    			add_location(div, file$i, 84, 16, 3957);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(h3, span1);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    			append_dev(div, t2);
    			append_dev(div, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bookingsWaiting*/ 8) set_data_dev(t1, /*bookingsWaiting*/ ctx[3]);

    			if (dirty & /*bookings*/ 2) {
    				each_value = /*bookings*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(84:12) {#if bookingsWaiting > 0}",
    		ctx
    	});

    	return block;
    }

    // (89:24) {#if !booking.confirmed}
    function create_if_block_3$7(ctx) {
    	let li;
    	let t_value = /*booking*/ ctx[8].email + "";
    	let t;

    	const block = {
    		c: function create() {
    			li = element("li");
    			t = text$1(t_value);
    			add_location(li, file$i, 89, 28, 4334);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bookings*/ 2 && t_value !== (t_value = /*booking*/ ctx[8].email + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(89:24) {#if !booking.confirmed}",
    		ctx
    	});

    	return block;
    }

    // (88:20) {#each bookings as booking}
    function create_each_block$b(ctx) {
    	let if_block_anchor;
    	let if_block = !/*booking*/ ctx[8].confirmed && create_if_block_3$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*booking*/ ctx[8].confirmed) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$7(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(88:20) {#each bookings as booking}",
    		ctx
    	});

    	return block;
    }

    // (70:8) {#key bookingsConfirmed}
    function create_key_block$5(ctx) {
    	let div;
    	let h3;
    	let span1;
    	let t0;
    	let span0;
    	let t1;
    	let t2;
    	let ul;
    	let t3;
    	let if_block_anchor;
    	let each_value_1 = /*bookings*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	let if_block = /*bookingsWaiting*/ ctx[3] > 0 && create_if_block_2$8(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			span1 = element("span");
    			t0 = text$1("Confirmed bookings:\n                    ");
    			span0 = element("span");
    			t1 = text$1(/*bookingsConfirmed*/ ctx[2]);
    			t2 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    			attr_dev(span0, "class", "uk-text-light");
    			toggle_class(span0, "uk-text-bold", /*bookingsConfirmed*/ ctx[2] > /*event*/ ctx[0].max_participants);
    			toggle_class(span0, "uk-text-danger", /*bookingsConfirmed*/ ctx[2] > /*event*/ ctx[0].max_participants);
    			add_location(span0, file$i, 72, 20, 3371);
    			add_location(span1, file$i, 71, 73, 3325);
    			attr_dev(h3, "class", "uk-heading-line uk-text-center uk-text-light");
    			add_location(h3, file$i, 71, 16, 3268);
    			attr_dev(ul, "class", "uk-list uk-list-collapse");
    			add_location(ul, file$i, 75, 16, 3637);
    			attr_dev(div, "class", "uk-margin-medium");
    			add_location(div, file$i, 70, 12, 3221);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(h3, span1);
    			append_dev(span1, t0);
    			append_dev(span1, span0);
    			append_dev(span0, t1);
    			append_dev(div, t2);
    			append_dev(div, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			insert_dev(target, t3, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bookingsConfirmed*/ 4) set_data_dev(t1, /*bookingsConfirmed*/ ctx[2]);

    			if (dirty & /*bookingsConfirmed, event*/ 5) {
    				toggle_class(span0, "uk-text-bold", /*bookingsConfirmed*/ ctx[2] > /*event*/ ctx[0].max_participants);
    			}

    			if (dirty & /*bookingsConfirmed, event*/ 5) {
    				toggle_class(span0, "uk-text-danger", /*bookingsConfirmed*/ ctx[2] > /*event*/ ctx[0].max_participants);
    			}

    			if (dirty & /*bookings*/ 2) {
    				each_value_1 = /*bookings*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (/*bookingsWaiting*/ ctx[3] > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$8(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$5.name,
    		type: "key",
    		source: "(70:8) {#key bookingsConfirmed}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let if_block_anchor;
    	let if_block = /*event*/ ctx[0] !== undefined && /*event*/ ctx[0] !== null && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*event*/ ctx[0] !== undefined && /*event*/ ctx[0] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EventEmails', slots, []);
    	let { event = undefined } = $$props;
    	let bookings = [];
    	let bookingsConfirmed = 0;
    	let bookingsWaiting = 0;
    	let dispatched = false;
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		if (event !== undefined && event !== null && event.bookings !== null && event.bookings.length > 0) {
    			$$invalidate(1, bookings = await getBookingsByIds(event.bookings.map(b => b.id)));
    			if (bookings === null) $$invalidate(1, bookings = []);

    			bookings.forEach(b => {
    				let eventBooking = event.bookings.find(eb => eb.id === b.id);

    				b.confirmed = eventBooking !== undefined
    				? eventBooking.confirmed
    				: false;

    				if (b.confirmed) $$invalidate(2, bookingsConfirmed += b.people_count); else $$invalidate(3, bookingsWaiting += b.people_count);
    			});
    		}
    	});

    	function cancel() {
    		dispatch('message', { goto: 'cancel' });
    	}

    	const writable_props = ['event'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EventEmails> was created with unknown prop '${key}'`);
    	});

    	function textarea_input_handler() {
    		event.info = this.value;
    		$$invalidate(0, event);
    	}

    	$$self.$$set = $$props => {
    		if ('event' in $$props) $$invalidate(0, event = $$props.event);
    	};

    	$$self.$capture_state = () => ({
    		DateTime: DateTime_1,
    		createEventDispatcher,
    		onMount,
    		getBookingsByIds,
    		updateEvent,
    		event,
    		bookings,
    		bookingsConfirmed,
    		bookingsWaiting,
    		dispatched,
    		dispatch,
    		cancel
    	});

    	$$self.$inject_state = $$props => {
    		if ('event' in $$props) $$invalidate(0, event = $$props.event);
    		if ('bookings' in $$props) $$invalidate(1, bookings = $$props.bookings);
    		if ('bookingsConfirmed' in $$props) $$invalidate(2, bookingsConfirmed = $$props.bookingsConfirmed);
    		if ('bookingsWaiting' in $$props) $$invalidate(3, bookingsWaiting = $$props.bookingsWaiting);
    		if ('dispatched' in $$props) dispatched = $$props.dispatched;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		event,
    		bookings,
    		bookingsConfirmed,
    		bookingsWaiting,
    		cancel,
    		textarea_input_handler
    	];
    }

    class EventEmails extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$i, create_fragment$i, safe_not_equal, { event: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EventEmails",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get event() {
    		throw new Error("<EventEmails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set event(value) {
    		throw new Error("<EventEmails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Event.svelte generated by Svelte v3.45.0 */
    const file$h = "src/components/Event.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[27] = list[i];
    	return child_ctx;
    }

    // (161:8) {:else }
    function create_else_block$f(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t6_value = (/*$screenWidthS*/ ctx[5] ? 'Party' : 'Participants') + "";
    	let t6;
    	let t7;
    	let th4;
    	let t9;
    	let th5;
    	let t11;
    	let th6;
    	let t13;
    	let tbody;
    	let each_value = /*data*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Short";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Name";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Period";
    			t5 = space();
    			th3 = element("th");
    			t6 = text$1(t6_value);
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Bookings";
    			t9 = space();
    			th5 = element("th");
    			th5.textContent = "Capacity";
    			t11 = space();
    			th6 = element("th");
    			th6.textContent = "Emails";
    			t13 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$h, 164, 20, 6528);
    			attr_dev(th1, "class", "uk-visible@m");
    			add_location(th1, file$h, 165, 20, 6563);
    			add_location(th2, file$h, 166, 20, 6618);
    			attr_dev(th3, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(th3, file$h, 167, 20, 6654);
    			attr_dev(th4, "class", "uk-table-shrink uk-text-nowrap uk-visible@m");
    			add_location(th4, file$h, 168, 20, 6765);
    			attr_dev(th5, "class", "uk-table-shrink uk-text-nowrap uk-visible@m");
    			add_location(th5, file$h, 169, 20, 6855);
    			attr_dev(th6, "class", "uk-table-shrink uk-text-nowrap uk-visible@s");
    			add_location(th6, file$h, 170, 20, 6945);
    			add_location(tr, file$h, 163, 16, 6503);
    			add_location(thead, file$h, 162, 16, 6479);
    			add_location(tbody, file$h, 173, 16, 7076);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$h, 161, 12, 6377);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(th3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(table, t13);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$screenWidthS*/ 32 && t6_value !== (t6_value = (/*$screenWidthS*/ ctx[5] ? 'Party' : 'Participants') + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*openEmails, data, openForm, openList, DateTime*/ 1793) {
    				each_value = /*data*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(161:8) {:else }",
    		ctx
    	});

    	return block;
    }

    // (159:8) {#if data.length === 0}
    function create_if_block$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading events...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(159:8) {#if data.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (175:16) {#each data as event}
    function create_each_block$a(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*event*/ ctx[27].abbreviation + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*event*/ ctx[27].name + "";
    	let t2;
    	let t3;
    	let td2;

    	let t4_value = (/*event*/ ctx[27].start_date !== null && /*event*/ ctx[27].end_date !== null
    	? DateTime_1.fromSQL(/*event*/ ctx[27].start_date).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*event*/ ctx[27].end_date).toFormat('dd LLL yyyy')
    	: '  ') + "";

    	let t4;
    	let t5;
    	let td3;
    	let a0;
    	let t6;
    	let td4;
    	let t7_value = /*event*/ ctx[27].participant_count + "";
    	let t7;
    	let t8;
    	let td5;

    	let t9_value = (/*event*/ ctx[27].max_participants !== null
    	? /*event*/ ctx[27].max_participants
    	: '') + "";

    	let t9;
    	let t10;
    	let td6;
    	let a1;
    	let t11;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[12](/*event*/ ctx[27]);
    	}

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[13](/*event*/ ctx[27]);
    	}

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[14](/*event*/ ctx[27]);
    	}

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[15](/*event*/ ctx[27]);
    	}

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[16](/*event*/ ctx[27]);
    	}

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[17](/*event*/ ctx[27]);
    	}

    	function click_handler_6() {
    		return /*click_handler_6*/ ctx[18](/*event*/ ctx[27]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			a0 = element("a");
    			t6 = space();
    			td4 = element("td");
    			t7 = text$1(t7_value);
    			t8 = space();
    			td5 = element("td");
    			t9 = text$1(t9_value);
    			t10 = space();
    			td6 = element("td");
    			a1 = element("a");
    			t11 = space();
    			add_location(td0, file$h, 176, 24, 7193);
    			attr_dev(td1, "class", "uk-visible@m");
    			add_location(td1, file$h, 177, 24, 7280);
    			add_location(td2, file$h, 178, 24, 7380);
    			attr_dev(a0, "href", '#');
    			attr_dev(a0, "uk-icon", "list");
    			toggle_class(a0, "uk-text-warning", /*event*/ ctx[27].bookings !== null && /*event*/ ctx[27].bookings.some(func));
    			toggle_class(a0, "uk-text-danger", /*event*/ ctx[27].max_participants !== null && /*event*/ ctx[27].max_participants < /*event*/ ctx[27].participant_count);
    			add_location(a0, file$h, 179, 52, 7667);
    			attr_dev(td3, "class", "uk-text-success");
    			add_location(td3, file$h, 179, 24, 7639);
    			attr_dev(td4, "class", "uk-visible@m");
    			add_location(td4, file$h, 182, 24, 8073);
    			attr_dev(td5, "class", "uk-visible@m");
    			add_location(td5, file$h, 183, 24, 8186);
    			attr_dev(a1, "href", '#');
    			attr_dev(a1, "uk-icon", "list");
    			add_location(a1, file$h, 184, 49, 8362);
    			attr_dev(td6, "class", "uk-visible@s");
    			add_location(td6, file$h, 184, 24, 8337);
    			attr_dev(tr, "class", "uk-table-link");
    			add_location(tr, file$h, 175, 20, 7142);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, a0);
    			append_dev(tr, t6);
    			append_dev(tr, td4);
    			append_dev(td4, t7);
    			append_dev(tr, t8);
    			append_dev(tr, td5);
    			append_dev(td5, t9);
    			append_dev(tr, t10);
    			append_dev(tr, td6);
    			append_dev(td6, a1);
    			append_dev(tr, t11);

    			if (!mounted) {
    				dispose = [
    					listen_dev(td0, "click", click_handler, false, false, false),
    					listen_dev(td1, "click", click_handler_1, false, false, false),
    					listen_dev(td2, "click", click_handler_2, false, false, false),
    					listen_dev(a0, "click", click_handler_3, false, false, false),
    					listen_dev(td4, "click", click_handler_4, false, false, false),
    					listen_dev(td5, "click", click_handler_5, false, false, false),
    					listen_dev(a1, "click", click_handler_6, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*event*/ ctx[27].abbreviation + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*data*/ 1 && t2_value !== (t2_value = /*event*/ ctx[27].name + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*data*/ 1 && t4_value !== (t4_value = (/*event*/ ctx[27].start_date !== null && /*event*/ ctx[27].end_date !== null
    			? DateTime_1.fromSQL(/*event*/ ctx[27].start_date).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*event*/ ctx[27].end_date).toFormat('dd LLL yyyy')
    			: '  ') + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*data*/ 1) {
    				toggle_class(a0, "uk-text-warning", /*event*/ ctx[27].bookings !== null && /*event*/ ctx[27].bookings.some(func));
    			}

    			if (dirty & /*data*/ 1) {
    				toggle_class(a0, "uk-text-danger", /*event*/ ctx[27].max_participants !== null && /*event*/ ctx[27].max_participants < /*event*/ ctx[27].participant_count);
    			}

    			if (dirty & /*data*/ 1 && t7_value !== (t7_value = /*event*/ ctx[27].participant_count + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*data*/ 1 && t9_value !== (t9_value = (/*event*/ ctx[27].max_participants !== null
    			? /*event*/ ctx[27].max_participants
    			: '') + "")) set_data_dev(t9, t9_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(175:16) {#each data as event}",
    		ctx
    	});

    	return block;
    }

    // (205:16) {#key recreateForm}
    function create_key_block_2$1(ctx) {
    	let eventform;
    	let updating_event;
    	let updating_edit;
    	let current;

    	function eventform_event_binding(value) {
    		/*eventform_event_binding*/ ctx[19](value);
    	}

    	function eventform_edit_binding(value) {
    		/*eventform_edit_binding*/ ctx[20](value);
    	}

    	let eventform_props = {};

    	if (/*selectedEvent*/ ctx[1] !== void 0) {
    		eventform_props.event = /*selectedEvent*/ ctx[1];
    	}

    	if (/*editEvent*/ ctx[2] !== void 0) {
    		eventform_props.edit = /*editEvent*/ ctx[2];
    	}

    	eventform = new EventForm({ props: eventform_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(eventform, 'event', eventform_event_binding));
    	binding_callbacks.push(() => bind$1(eventform, 'edit', eventform_edit_binding));
    	eventform.$on("message", /*processEvent*/ ctx[11]);

    	const block = {
    		c: function create() {
    			create_component(eventform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(eventform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const eventform_changes = {};

    			if (!updating_event && dirty & /*selectedEvent*/ 2) {
    				updating_event = true;
    				eventform_changes.event = /*selectedEvent*/ ctx[1];
    				add_flush_callback(() => updating_event = false);
    			}

    			if (!updating_edit && dirty & /*editEvent*/ 4) {
    				updating_edit = true;
    				eventform_changes.edit = /*editEvent*/ ctx[2];
    				add_flush_callback(() => updating_edit = false);
    			}

    			eventform.$set(eventform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(eventform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(eventform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(eventform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_2$1.name,
    		type: "key",
    		source: "(205:16) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    // (224:16) {#key recreateList}
    function create_key_block_1$1(ctx) {
    	let eventparticipants;
    	let updating_event;
    	let current;

    	function eventparticipants_event_binding(value) {
    		/*eventparticipants_event_binding*/ ctx[21](value);
    	}

    	let eventparticipants_props = {};

    	if (/*selectedEvent*/ ctx[1] !== void 0) {
    		eventparticipants_props.event = /*selectedEvent*/ ctx[1];
    	}

    	eventparticipants = new EventParticipants({
    			props: eventparticipants_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$1(eventparticipants, 'event', eventparticipants_event_binding));
    	eventparticipants.$on("message", /*processEvent*/ ctx[11]);

    	const block = {
    		c: function create() {
    			create_component(eventparticipants.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(eventparticipants, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const eventparticipants_changes = {};

    			if (!updating_event && dirty & /*selectedEvent*/ 2) {
    				updating_event = true;
    				eventparticipants_changes.event = /*selectedEvent*/ ctx[1];
    				add_flush_callback(() => updating_event = false);
    			}

    			eventparticipants.$set(eventparticipants_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(eventparticipants.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(eventparticipants.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(eventparticipants, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_1$1.name,
    		type: "key",
    		source: "(224:16) {#key recreateList}",
    		ctx
    	});

    	return block;
    }

    // (243:16) {#key recreateList}
    function create_key_block$4(ctx) {
    	let eventemails;
    	let updating_event;
    	let current;

    	function eventemails_event_binding(value) {
    		/*eventemails_event_binding*/ ctx[22](value);
    	}

    	let eventemails_props = {};

    	if (/*selectedEvent*/ ctx[1] !== void 0) {
    		eventemails_props.event = /*selectedEvent*/ ctx[1];
    	}

    	eventemails = new EventEmails({ props: eventemails_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(eventemails, 'event', eventemails_event_binding));
    	eventemails.$on("message", /*processEvent*/ ctx[11]);

    	const block = {
    		c: function create() {
    			create_component(eventemails.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(eventemails, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const eventemails_changes = {};

    			if (!updating_event && dirty & /*selectedEvent*/ 2) {
    				updating_event = true;
    				eventemails_changes.event = /*selectedEvent*/ ctx[1];
    				add_flush_callback(() => updating_event = false);
    			}

    			eventemails.$set(eventemails_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(eventemails.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(eventemails.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(eventemails, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$4.name,
    		type: "key",
    		source: "(243:16) {#key recreateList}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let input;
    	let input_class_value;
    	let t0;
    	let button0;
    	let span;

    	let t1_value = (/*$screenWidthS*/ ctx[5]
    	? ''
    	: /*$screenWidthM*/ ctx[6] ? '\xa0event' : '\xa0New event') + "";

    	let t1;
    	let t2;
    	let div4;
    	let div3;
    	let t3;
    	let div8;
    	let div7;
    	let button1;
    	let t4;
    	let div6;
    	let div5;
    	let previous_key = /*recreateForm*/ ctx[3];
    	let t5;
    	let div12;
    	let div11;
    	let button2;
    	let t6;
    	let div10;
    	let div9;
    	let previous_key_1 = /*recreateList*/ ctx[4];
    	let t7;
    	let div16;
    	let div15;
    	let button3;
    	let t8;
    	let div14;
    	let div13;
    	let previous_key_2 = /*recreateList*/ ctx[4];
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0) return create_if_block$g;
    		return create_else_block$f;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);
    	let key_block0 = create_key_block_2$1(ctx);
    	let key_block1 = create_key_block_1$1(ctx);
    	let key_block2 = create_key_block$4(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			button0 = element("button");
    			span = element("span");
    			t1 = text$1(t1_value);
    			t2 = space();
    			div4 = element("div");
    			div3 = element("div");
    			if_block.c();
    			t3 = space();
    			div8 = element("div");
    			div7 = element("div");
    			button1 = element("button");
    			t4 = space();
    			div6 = element("div");
    			div5 = element("div");
    			key_block0.c();
    			t5 = space();
    			div12 = element("div");
    			div11 = element("div");
    			button2 = element("button");
    			t6 = space();
    			div10 = element("div");
    			div9 = element("div");
    			key_block1.c();
    			t7 = space();
    			div16 = element("div");
    			div15 = element("div");
    			button3 = element("button");
    			t8 = space();
    			div14 = element("div");
    			div13 = element("div");
    			key_block2.c();

    			attr_dev(input, "class", input_class_value = "uk-input " + (/*$screenWidthS*/ ctx[5]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[6] || /*$screenWidthL*/ ctx[7]
    				? 'uk-width-medium'
    				: 'uk-width-large'));

    			attr_dev(input, "id", "autocomplete");
    			attr_dev(input, "type", "search");
    			attr_dev(input, "spellcheck", "false");
    			attr_dev(input, "autocorrect", "off");
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "autocapitalize", "off");
    			attr_dev(input, "maxlength", "256");
    			add_location(input, file$h, 150, 12, 5600);
    			attr_dev(span, "uk-icon", "icon: plus; ratio: 0.6");
    			add_location(span, file$h, 151, 114, 5972);
    			attr_dev(button0, "class", "uk-button uk-button-small uk-button-primary uk-margin-large-left");
    			add_location(button0, file$h, 151, 12, 5870);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$h, 149, 8, 5551);
    			attr_dev(div1, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6 paf-top-section-bg");
    			add_location(div1, file$h, 148, 4, 5453);
    			attr_dev(div2, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div2, file$h, 147, 0, 5375);
    			attr_dev(div3, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6");
    			add_location(div3, file$h, 157, 4, 6215);
    			attr_dev(div4, "class", "uk-flex uk-flex-center");
    			set_style(div4, "max-height", "75%");
    			set_style(div4, "overflow-x", "scroll");
    			add_location(div4, file$h, 156, 0, 6129);
    			attr_dev(button1, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "uk-close", "");
    			add_location(button1, file$h, 200, 8, 8816);
    			attr_dev(div5, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div5, "uk-height-viewport", "");
    			add_location(div5, file$h, 202, 12, 8957);
    			attr_dev(div6, "class", "uk-flex uk-flex-center");
    			add_location(div6, file$h, 201, 8, 8908);
    			attr_dev(div7, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div7, file$h, 199, 4, 8746);
    			attr_dev(div8, "id", "modal-full");
    			attr_dev(div8, "class", "uk-modal-full");
    			attr_dev(div8, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div8, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[6]);
    			add_location(div8, file$h, 195, 0, 8595);
    			attr_dev(button2, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button2, "type", "button");
    			attr_dev(button2, "uk-close", "");
    			add_location(button2, file$h, 219, 8, 9528);
    			attr_dev(div9, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div9, "uk-height-viewport", "");
    			add_location(div9, file$h, 221, 12, 9669);
    			attr_dev(div10, "class", "uk-flex uk-flex-center");
    			add_location(div10, file$h, 220, 8, 9620);
    			attr_dev(div11, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div11, file$h, 218, 4, 9458);
    			attr_dev(div12, "id", "modal-list");
    			attr_dev(div12, "class", "uk-modal-full");
    			attr_dev(div12, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div12, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[6]);
    			add_location(div12, file$h, 214, 0, 9307);
    			attr_dev(button3, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button3, "type", "button");
    			attr_dev(button3, "uk-close", "");
    			add_location(button3, file$h, 238, 8, 10222);
    			attr_dev(div13, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div13, "uk-height-viewport", "");
    			add_location(div13, file$h, 240, 12, 10363);
    			attr_dev(div14, "class", "uk-flex uk-flex-center");
    			add_location(div14, file$h, 239, 8, 10314);
    			attr_dev(div15, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div15, file$h, 237, 4, 10152);
    			attr_dev(div16, "id", "modal-emails");
    			attr_dev(div16, "class", "uk-modal-full");
    			attr_dev(div16, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div16, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[6]);
    			add_location(div16, file$h, 233, 0, 9999);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			append_dev(div0, t0);
    			append_dev(div0, button0);
    			append_dev(button0, span);
    			append_dev(button0, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div3);
    			if_block.m(div3, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div7);
    			append_dev(div7, button1);
    			append_dev(div7, t4);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			key_block0.m(div5, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div12, anchor);
    			append_dev(div12, div11);
    			append_dev(div11, button2);
    			append_dev(div11, t6);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			key_block1.m(div9, null);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div16, anchor);
    			append_dev(div16, div15);
    			append_dev(div15, button3);
    			append_dev(div15, t8);
    			append_dev(div15, div14);
    			append_dev(div14, div13);
    			key_block2.m(div13, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*openForm*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$screenWidthS, $screenWidthM, $screenWidthL*/ 224 && input_class_value !== (input_class_value = "uk-input " + (/*$screenWidthS*/ ctx[5]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[6] || /*$screenWidthL*/ ctx[7]
    				? 'uk-width-medium'
    				: 'uk-width-large'))) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if ((!current || dirty & /*$screenWidthS, $screenWidthM*/ 96) && t1_value !== (t1_value = (/*$screenWidthS*/ ctx[5]
    			? ''
    			: /*$screenWidthM*/ ctx[6] ? '\xa0event' : '\xa0New event') + "")) set_data_dev(t1, t1_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			}

    			if (dirty & /*recreateForm*/ 8 && safe_not_equal(previous_key, previous_key = /*recreateForm*/ ctx[3])) {
    				group_outros();
    				transition_out(key_block0, 1, 1, noop$4);
    				check_outros();
    				key_block0 = create_key_block_2$1(ctx);
    				key_block0.c();
    				transition_in(key_block0);
    				key_block0.m(div5, null);
    			} else {
    				key_block0.p(ctx, dirty);
    			}

    			if (dirty & /*$screenWidthM*/ 64) {
    				toggle_class(div8, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[6]);
    			}

    			if (dirty & /*recreateList*/ 16 && safe_not_equal(previous_key_1, previous_key_1 = /*recreateList*/ ctx[4])) {
    				group_outros();
    				transition_out(key_block1, 1, 1, noop$4);
    				check_outros();
    				key_block1 = create_key_block_1$1(ctx);
    				key_block1.c();
    				transition_in(key_block1);
    				key_block1.m(div9, null);
    			} else {
    				key_block1.p(ctx, dirty);
    			}

    			if (dirty & /*$screenWidthM*/ 64) {
    				toggle_class(div12, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[6]);
    			}

    			if (dirty & /*recreateList*/ 16 && safe_not_equal(previous_key_2, previous_key_2 = /*recreateList*/ ctx[4])) {
    				group_outros();
    				transition_out(key_block2, 1, 1, noop$4);
    				check_outros();
    				key_block2 = create_key_block$4(ctx);
    				key_block2.c();
    				transition_in(key_block2);
    				key_block2.m(div13, null);
    			} else {
    				key_block2.p(ctx, dirty);
    			}

    			if (dirty & /*$screenWidthM*/ 64) {
    				toggle_class(div16, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block0);
    			transition_in(key_block1);
    			transition_in(key_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block0);
    			transition_out(key_block1);
    			transition_out(key_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div4);
    			if_block.d();
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div8);
    			key_block0.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div12);
    			key_block1.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div16);
    			key_block2.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = b => !b.confirmed;

    function instance$h($$self, $$props, $$invalidate) {
    	let $events;
    	let $screenWidthS;
    	let $screenWidthM;
    	let $screenWidthL;
    	validate_store(events, 'events');
    	component_subscribe($$self, events, $$value => $$invalidate(23, $events = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(5, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(6, $screenWidthM = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(7, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Event', slots, []);
    	let data = [];
    	let selectedEvent;
    	let editEvent = false;
    	let recreateForm = false;
    	let recreateList = false;

    	// $: $events && initAutoComplete()
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		assignData(null);

    		const autoCompleteJS = new autoComplete({
    				selector: "#autocomplete",
    				placeHolder: "Search events...",
    				diacritics: true,
    				searchEngine: 'strict',
    				data: {
    					src: $events,
    					keys: ['name', 'abbreviation'],
    					cache: true
    				},
    				resultsList: {
    					element: (list, data) => {
    						if (!data.results.length) {
    							const message = document.createElement("div");
    							message.setAttribute("class", "no_result");
    							message.innerHTML = `<span>No Member for "${data.query}"</span>`;
    							list.prepend(message);
    						}
    					},
    					maxResults: 50,
    					noResults: true
    				},
    				resultItem: { highlight: true },
    				events: {
    					input: {
    						selection: event => {
    							autoCompleteJS.input.value = event.detail.selection.value.name;
    							assignData(event.detail.selection.value.name);
    						},
    						keyup: () => {
    							if (autoCompleteJS.input.value === '') assignData(null);
    						}
    					}
    				}
    			});
    	});

    	function assignData(name) {
    		if (name !== undefined && name !== null) $$invalidate(0, data = $events.filter(e => e.name === name)); else if (data.length <= 1) $$invalidate(0, data = $events);
    	}

    	function dispatchReload() {
    		dispatch('message', { reload: 'event' });
    	}

    	function openForm(event) {
    		$$invalidate(1, selectedEvent = event instanceof MouseEvent
    		? null
    		: JSON.parse(JSON.stringify(event)));

    		$$invalidate(2, editEvent = selectedEvent !== null);
    		$$invalidate(3, recreateForm = !recreateForm);
    		uikit.modal("#modal-full").show();
    	}

    	function openList(event) {
    		$$invalidate(1, selectedEvent = event instanceof MouseEvent
    		? null
    		: JSON.parse(JSON.stringify(event)));

    		$$invalidate(4, recreateList = !recreateList);
    		uikit.modal("#modal-list").show();
    	}

    	function openEmails(event) {
    		$$invalidate(1, selectedEvent = event instanceof MouseEvent
    		? null
    		: JSON.parse(JSON.stringify(event)));

    		$$invalidate(4, recreateList = !recreateList);
    		uikit.modal("#modal-emails").show();
    	}

    	async function processEvent(event) {
    		if (event.detail.goto !== undefined) {
    			let success = false;

    			switch (event.detail.goto) {
    				case 'cancel':
    					uikit.modal("#modal-full").hide();
    					uikit.modal("#modal-list").hide();
    					uikit.modal("#modal-emails").hide();
    					break;
    				case 'save':
    					if (!editEvent) success = await createEvent(selectedEvent); else if (selectedEvent.id !== undefined && selectedEvent.id !== null) success = await updateEvent(selectedEvent);
    					if (success) uikit.notification('<span uk-icon="icon: check"></span> Event ' + (editEvent ? 'updated!' : 'created!'), { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    					uikit.modal("#modal-full").hide();
    					dispatchReload();
    					break;
    				case 'delete':
    					success = await deleteEvent(selectedEvent.id);
    					if (success) uikit.notification('<span uk-icon="icon: check"></span> Event deleted!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    				case 'participants':
    					uikit.modal("#modal-full").hide();
    					uikit.modal("#modal-list").hide();
    					dispatchReload();
    					break;
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Event> was created with unknown prop '${key}'`);
    	});

    	const click_handler = event => openForm(event);
    	const click_handler_1 = event => openForm(event);
    	const click_handler_2 = event => openForm(event);
    	const click_handler_3 = event => openList(event);
    	const click_handler_4 = event => openForm(event);
    	const click_handler_5 = event => openForm(event);
    	const click_handler_6 = event => openEmails(event);

    	function eventform_event_binding(value) {
    		selectedEvent = value;
    		$$invalidate(1, selectedEvent);
    	}

    	function eventform_edit_binding(value) {
    		editEvent = value;
    		$$invalidate(2, editEvent);
    	}

    	function eventparticipants_event_binding(value) {
    		selectedEvent = value;
    		$$invalidate(1, selectedEvent);
    	}

    	function eventemails_event_binding(value) {
    		selectedEvent = value;
    		$$invalidate(1, selectedEvent);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		UIkit: uikit,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		autoComplete,
    		DateTime: DateTime_1,
    		createEvent,
    		deleteEvent,
    		events,
    		updateEvent,
    		EventForm,
    		EventParticipants,
    		EventEmails,
    		data,
    		selectedEvent,
    		editEvent,
    		recreateForm,
    		recreateList,
    		dispatch,
    		assignData,
    		dispatchReload,
    		openForm,
    		openList,
    		openEmails,
    		processEvent,
    		$events,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL
    	});

    	$$self.$inject_state = $$props => {
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('selectedEvent' in $$props) $$invalidate(1, selectedEvent = $$props.selectedEvent);
    		if ('editEvent' in $$props) $$invalidate(2, editEvent = $$props.editEvent);
    		if ('recreateForm' in $$props) $$invalidate(3, recreateForm = $$props.recreateForm);
    		if ('recreateList' in $$props) $$invalidate(4, recreateList = $$props.recreateList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		data,
    		selectedEvent,
    		editEvent,
    		recreateForm,
    		recreateList,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		openForm,
    		openList,
    		openEmails,
    		processEvent,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		eventform_event_binding,
    		eventform_edit_binding,
    		eventparticipants_event_binding,
    		eventemails_event_binding
    	];
    }

    class Event$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Event",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src/components/Settings.svelte generated by Svelte v3.45.0 */
    const file$g = "src/components/Settings.svelte";

    // (158:20) {#if $role === 'root'}
    function create_if_block$f(ctx) {
    	let div1;
    	let label;
    	let t1;
    	let div0;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			label = element("label");
    			label.textContent = "App version";
    			t1 = space();
    			div0 = element("div");
    			input = element("input");
    			attr_dev(label, "class", "uk-form-label");
    			attr_dev(label, "for", "form-app_version");
    			add_location(label, file$g, 159, 28, 9338);
    			attr_dev(input, "class", "uk-input uk-form-width-small");
    			attr_dev(input, "id", "form-app_version");
    			attr_dev(input, "name", "app_version");
    			attr_dev(input, "type", "text");
    			set_style(input, "color", "black");
    			toggle_class(input, "uk-form-danger", /*$errors*/ ctx[2].app_version && /*$touched*/ ctx[3].app_version);
    			add_location(input, file$g, 161, 32, 9501);
    			attr_dev(div0, "class", "uk-form-controls");
    			add_location(div0, file$g, 160, 28, 9438);
    			attr_dev(div1, "class", "uk-width-1-2@s");
    			add_location(div1, file$g, 158, 24, 9281);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, label);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*$form*/ ctx[0].app_version);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[22])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$form*/ 1 && input.value !== /*$form*/ ctx[0].app_version) {
    				set_input_value(input, /*$form*/ ctx[0].app_version);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input, "uk-form-danger", /*$errors*/ ctx[2].app_version && /*$touched*/ ctx[3].app_version);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(158:20) {#if $role === 'root'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div30;
    	let div29;
    	let h4;
    	let t1;
    	let form_1;
    	let div19;
    	let div18;
    	let div1;
    	let label0;
    	let t3;
    	let div0;
    	let input0;
    	let t4;
    	let div3;
    	let label1;
    	let t6;
    	let div2;
    	let input1;
    	let t7;
    	let div5;
    	let label2;
    	let t9;
    	let div4;
    	let input2;
    	let t10;
    	let div7;
    	let label3;
    	let t12;
    	let div6;
    	let input3;
    	let t13;
    	let div9;
    	let label4;
    	let t15;
    	let div8;
    	let input4;
    	let t16;
    	let div11;
    	let label5;
    	let t18;
    	let div10;
    	let input5;
    	let t19;
    	let div13;
    	let label6;
    	let t21;
    	let div12;
    	let input6;
    	let t22;
    	let div15;
    	let label7;
    	let t24;
    	let div14;
    	let input7;
    	let t25;
    	let div17;
    	let label8;
    	let t27;
    	let div16;
    	let input8;
    	let t28;
    	let t29;
    	let div27;
    	let div26;
    	let div21;
    	let label9;
    	let t31;
    	let div20;
    	let input9;
    	let t32;
    	let div23;
    	let label10;
    	let t34;
    	let div22;
    	let input10;
    	let t35;
    	let div25;
    	let label11;
    	let t37;
    	let div24;
    	let input11;
    	let t38;
    	let div28;
    	let button0;
    	let t40;
    	let button1;
    	let t41;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;
    	let if_block = /*$role*/ ctx[4] === 'root' && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			div30 = element("div");
    			div29 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Default settings";
    			t1 = space();
    			form_1 = element("form");
    			div19 = element("div");
    			div18 = element("div");
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Short stay days";
    			t3 = space();
    			div0 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div3 = element("div");
    			label1 = element("label");
    			label1.textContent = "SCI free days";
    			t6 = space();
    			div2 = element("div");
    			input1 = element("input");
    			t7 = space();
    			div5 = element("div");
    			label2 = element("label");
    			label2.textContent = "Daily price regular stay";
    			t9 = space();
    			div4 = element("div");
    			input2 = element("input");
    			t10 = space();
    			div7 = element("div");
    			label3 = element("label");
    			label3.textContent = "Daily price short stay";
    			t12 = space();
    			div6 = element("div");
    			input3 = element("input");
    			t13 = space();
    			div9 = element("div");
    			label4 = element("label");
    			label4.textContent = "Membership price";
    			t15 = space();
    			div8 = element("div");
    			input4 = element("input");
    			t16 = space();
    			div11 = element("div");
    			label5 = element("label");
    			label5.textContent = "Monthly price (per day)";
    			t18 = space();
    			div10 = element("div");
    			input5 = element("input");
    			t19 = space();
    			div13 = element("div");
    			label6 = element("label");
    			label6.textContent = "Mattress membership cut";
    			t21 = space();
    			div12 = element("div");
    			input6 = element("input");
    			t22 = space();
    			div15 = element("div");
    			label7 = element("label");
    			label7.textContent = "House capacity";
    			t24 = space();
    			div14 = element("div");
    			input7 = element("input");
    			t25 = space();
    			div17 = element("div");
    			label8 = element("label");
    			label8.textContent = "Meal price (PAF events)";
    			t27 = space();
    			div16 = element("div");
    			input8 = element("input");
    			t28 = space();
    			if (if_block) if_block.c();
    			t29 = space();
    			div27 = element("div");
    			div26 = element("div");
    			div21 = element("div");
    			label9 = element("label");
    			label9.textContent = "Invoice text stay";
    			t31 = space();
    			div20 = element("div");
    			input9 = element("input");
    			t32 = space();
    			div23 = element("div");
    			label10 = element("label");
    			label10.textContent = "Invoice text membership";
    			t34 = space();
    			div22 = element("div");
    			input10 = element("input");
    			t35 = space();
    			div25 = element("div");
    			label11 = element("label");
    			label11.textContent = "Invoice text meal";
    			t37 = space();
    			div24 = element("div");
    			input11 = element("input");
    			t38 = space();
    			div28 = element("div");
    			button0 = element("button");
    			button0.textContent = "Reset";
    			t40 = space();
    			button1 = element("button");
    			t41 = text$1("Update");
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-width-1-1");
    			add_location(h4, file$g, 81, 8, 3026);
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-short_stay_duration");
    			add_location(label0, file$g, 86, 24, 3435);
    			attr_dev(input0, "class", "uk-input uk-form-width-small");
    			attr_dev(input0, "id", "form-short_stay_duration");
    			attr_dev(input0, "name", "short_stay_duration");
    			attr_dev(input0, "type", "text");
    			set_style(input0, "color", "black");
    			toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[2].short_stay_duration && /*$touched*/ ctx[3].short_stay_duration);
    			add_location(input0, file$g, 88, 28, 3602);
    			attr_dev(div0, "class", "uk-form-controls");
    			add_location(div0, file$g, 87, 24, 3543);
    			attr_dev(div1, "class", "uk-width-1-2@s");
    			add_location(div1, file$g, 85, 20, 3382);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "form-sci_days");
    			add_location(label1, file$g, 94, 24, 4109);
    			attr_dev(input1, "class", "uk-input uk-form-width-small");
    			attr_dev(input1, "id", "form-sci_days");
    			attr_dev(input1, "name", "sci_days");
    			attr_dev(input1, "type", "text");
    			set_style(input1, "color", "black");
    			toggle_class(input1, "uk-form-danger", /*$errors*/ ctx[2].sci_days && /*$touched*/ ctx[3].sci_days);
    			add_location(input1, file$g, 96, 28, 4263);
    			attr_dev(div2, "class", "uk-form-controls");
    			add_location(div2, file$g, 95, 24, 4204);
    			attr_dev(div3, "class", "uk-width-1-2@s");
    			add_location(div3, file$g, 93, 20, 4056);
    			attr_dev(label2, "class", "uk-form-label");
    			attr_dev(label2, "for", "form-price_stay");
    			add_location(label2, file$g, 102, 24, 4715);
    			attr_dev(input2, "class", "uk-input uk-form-width-small");
    			attr_dev(input2, "id", "form-price_stay");
    			attr_dev(input2, "name", "price_stay");
    			attr_dev(input2, "type", "text");
    			set_style(input2, "color", "black");
    			toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[2].price_stay && /*$touched*/ ctx[3].price_stay);
    			add_location(input2, file$g, 104, 28, 4882);
    			attr_dev(div4, "class", "uk-form-controls");
    			add_location(div4, file$g, 103, 24, 4823);
    			attr_dev(div5, "class", "uk-width-1-2@s");
    			add_location(div5, file$g, 101, 20, 4662);
    			attr_dev(label3, "class", "uk-form-label");
    			attr_dev(label3, "for", "form-price_stay_short");
    			add_location(label3, file$g, 110, 24, 5344);
    			attr_dev(input3, "class", "uk-input uk-form-width-small");
    			attr_dev(input3, "id", "form-price_stay_short");
    			attr_dev(input3, "name", "price_stay_short");
    			attr_dev(input3, "type", "text");
    			set_style(input3, "color", "black");
    			toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[2].price_stay_short && /*$touched*/ ctx[3].price_stay_short);
    			add_location(input3, file$g, 112, 28, 5515);
    			attr_dev(div6, "class", "uk-form-controls");
    			add_location(div6, file$g, 111, 24, 5456);
    			attr_dev(div7, "class", "uk-width-1-2@s");
    			add_location(div7, file$g, 109, 20, 5291);
    			attr_dev(label4, "class", "uk-form-label");
    			attr_dev(label4, "for", "form-price_membership");
    			add_location(label4, file$g, 118, 24, 6007);
    			attr_dev(input4, "class", "uk-input uk-form-width-small");
    			attr_dev(input4, "id", "form-price_membership");
    			attr_dev(input4, "name", "price_membership");
    			attr_dev(input4, "type", "text");
    			set_style(input4, "color", "black");
    			toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[2].price_membership && /*$touched*/ ctx[3].price_membership);
    			add_location(input4, file$g, 120, 28, 6172);
    			attr_dev(div8, "class", "uk-form-controls");
    			add_location(div8, file$g, 119, 24, 6113);
    			attr_dev(div9, "class", "uk-width-1-2@s");
    			add_location(div9, file$g, 117, 20, 5954);
    			attr_dev(label5, "class", "uk-form-label");
    			attr_dev(label5, "for", "form-price_stay_month");
    			add_location(label5, file$g, 126, 24, 6664);
    			attr_dev(input5, "class", "uk-input uk-form-width-small");
    			attr_dev(input5, "id", "form-price_stay_month");
    			attr_dev(input5, "name", "price_stay_month");
    			attr_dev(input5, "type", "text");
    			set_style(input5, "color", "black");
    			toggle_class(input5, "uk-form-danger", /*$errors*/ ctx[2].price_stay_month && /*$touched*/ ctx[3].price_stay_month);
    			add_location(input5, file$g, 128, 28, 6836);
    			attr_dev(div10, "class", "uk-form-controls");
    			add_location(div10, file$g, 127, 24, 6777);
    			attr_dev(div11, "class", "uk-width-1-2@s");
    			add_location(div11, file$g, 125, 20, 6611);
    			attr_dev(label6, "class", "uk-form-label");
    			attr_dev(label6, "for", "form-mattress_membership");
    			add_location(label6, file$g, 134, 24, 7328);
    			attr_dev(input6, "class", "uk-input uk-form-width-small");
    			attr_dev(input6, "id", "form-mattress_membership");
    			attr_dev(input6, "name", "mattress_membership");
    			attr_dev(input6, "type", "text");
    			set_style(input6, "color", "black");
    			toggle_class(input6, "uk-form-danger", /*$errors*/ ctx[2].mattress_membership && /*$touched*/ ctx[3].mattress_membership);
    			add_location(input6, file$g, 136, 28, 7503);
    			attr_dev(div12, "class", "uk-form-controls");
    			add_location(div12, file$g, 135, 24, 7444);
    			attr_dev(div13, "class", "uk-width-1-2@s");
    			add_location(div13, file$g, 133, 20, 7275);
    			attr_dev(label7, "class", "uk-form-label");
    			attr_dev(label7, "for", "form-house_capacity");
    			add_location(label7, file$g, 142, 24, 8010);
    			attr_dev(input7, "class", "uk-input uk-form-width-small");
    			attr_dev(input7, "id", "form-house_capacity");
    			attr_dev(input7, "name", "house_capacity");
    			attr_dev(input7, "type", "text");
    			set_style(input7, "color", "black");
    			toggle_class(input7, "uk-form-danger", /*$errors*/ ctx[2].house_capacity && /*$touched*/ ctx[3].house_capacity);
    			add_location(input7, file$g, 144, 28, 8171);
    			attr_dev(div14, "class", "uk-form-controls");
    			add_location(div14, file$g, 143, 24, 8112);
    			attr_dev(div15, "class", "uk-width-1-2@s");
    			add_location(div15, file$g, 141, 20, 7957);
    			attr_dev(label8, "class", "uk-form-label");
    			attr_dev(label8, "for", "form-price_meals");
    			add_location(label8, file$g, 150, 24, 8653);
    			attr_dev(input8, "class", "uk-input uk-form-width-small");
    			attr_dev(input8, "id", "form-price_meals");
    			attr_dev(input8, "name", "price_meals");
    			attr_dev(input8, "type", "text");
    			set_style(input8, "color", "black");
    			toggle_class(input8, "uk-form-danger", /*$errors*/ ctx[2].price_meals && /*$touched*/ ctx[3].price_meals);
    			add_location(input8, file$g, 152, 28, 8820);
    			attr_dev(div16, "class", "uk-form-controls");
    			add_location(div16, file$g, 151, 24, 8761);
    			attr_dev(div17, "class", "uk-width-1-2@s");
    			add_location(div17, file$g, 149, 20, 8600);
    			attr_dev(div18, "class", "uk-grid-small uk-margin-remove-left");
    			attr_dev(div18, "uk-grid", "");
    			add_location(div18, file$g, 84, 16, 3304);
    			attr_dev(div19, "class", "uk-margin-medium");
    			add_location(div19, file$g, 83, 12, 3257);
    			attr_dev(label9, "class", "uk-form-label");
    			attr_dev(label9, "for", "form-text_stay");
    			add_location(label9, file$g, 172, 24, 10169);
    			attr_dev(input9, "class", "uk-input");
    			attr_dev(input9, "id", "form-text_stay");
    			attr_dev(input9, "name", "text_stay");
    			attr_dev(input9, "type", "text");
    			set_style(input9, "color", "black");
    			toggle_class(input9, "uk-form-danger", /*$errors*/ ctx[2].text_stay && /*$touched*/ ctx[3].text_stay);
    			add_location(input9, file$g, 174, 28, 10328);
    			attr_dev(div20, "class", "uk-form-controls");
    			add_location(div20, file$g, 173, 24, 10269);
    			attr_dev(div21, "class", "uk-width-1-1@s");
    			add_location(div21, file$g, 171, 20, 10116);
    			attr_dev(label10, "class", "uk-form-label");
    			attr_dev(label10, "for", "form-text_membership");
    			add_location(label10, file$g, 180, 24, 10765);
    			attr_dev(input10, "class", "uk-input");
    			attr_dev(input10, "id", "form-text_membership");
    			attr_dev(input10, "name", "text_membership");
    			attr_dev(input10, "type", "text");
    			set_style(input10, "color", "black");
    			toggle_class(input10, "uk-form-danger", /*$errors*/ ctx[2].text_membership && /*$touched*/ ctx[3].text_membership);
    			add_location(input10, file$g, 182, 28, 10936);
    			attr_dev(div22, "class", "uk-form-controls");
    			add_location(div22, file$g, 181, 24, 10877);
    			attr_dev(div23, "class", "uk-width-1-1@s");
    			add_location(div23, file$g, 179, 20, 10712);
    			attr_dev(label11, "class", "uk-form-label");
    			attr_dev(label11, "for", "form-text_stay");
    			add_location(label11, file$g, 188, 24, 11403);
    			attr_dev(input11, "class", "uk-input");
    			attr_dev(input11, "id", "form-text_meals");
    			attr_dev(input11, "name", "text_meals");
    			attr_dev(input11, "type", "text");
    			set_style(input11, "color", "black");
    			toggle_class(input11, "uk-form-danger", /*$errors*/ ctx[2].text_meals && /*$touched*/ ctx[3].text_meals);
    			add_location(input11, file$g, 190, 28, 11562);
    			attr_dev(div24, "class", "uk-form-controls");
    			add_location(div24, file$g, 189, 24, 11503);
    			attr_dev(div25, "class", "uk-width-1-1@s");
    			add_location(div25, file$g, 187, 20, 11350);
    			attr_dev(div26, "class", "uk-grid-small uk-margin-remove-left");
    			attr_dev(div26, "uk-grid", "");
    			add_location(div26, file$g, 170, 16, 10038);
    			attr_dev(div27, "class", "uk-margin-medium");
    			add_location(div27, file$g, 169, 12, 9991);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$g, 198, 16, 12075);
    			attr_dev(button1, "class", "uk-button uk-margin-large-left");
    			attr_dev(button1, "id", "submit");
    			attr_dev(button1, "type", "submit");
    			button1.disabled = button1_disabled_value = !/*$isValid*/ ctx[5];
    			toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[5]);
    			add_location(button1, file$g, 199, 16, 12185);
    			attr_dev(div28, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div28, file$g, 197, 12, 11985);
    			attr_dev(form_1, "class", "uk-form");
    			toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[1]);
    			add_location(form_1, file$g, 82, 8, 3155);
    			attr_dev(div29, "class", "uk-section uk-section-xsmall uk-margin-medium-top uk-margin-bottom uk-width-2-3@m uk-width-5-6");
    			add_location(div29, file$g, 80, 4, 2909);
    			attr_dev(div30, "class", "uk-flex uk-flex-center");
    			add_location(div30, file$g, 79, 0, 2868);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div30, anchor);
    			append_dev(div30, div29);
    			append_dev(div29, h4);
    			append_dev(div29, t1);
    			append_dev(div29, form_1);
    			append_dev(form_1, div19);
    			append_dev(div19, div18);
    			append_dev(div18, div1);
    			append_dev(div1, label0);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$form*/ ctx[0].short_stay_duration);
    			append_dev(div18, t4);
    			append_dev(div18, div3);
    			append_dev(div3, label1);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			append_dev(div2, input1);
    			set_input_value(input1, /*$form*/ ctx[0].sci_days);
    			append_dev(div18, t7);
    			append_dev(div18, div5);
    			append_dev(div5, label2);
    			append_dev(div5, t9);
    			append_dev(div5, div4);
    			append_dev(div4, input2);
    			set_input_value(input2, /*$form*/ ctx[0].price_stay);
    			append_dev(div18, t10);
    			append_dev(div18, div7);
    			append_dev(div7, label3);
    			append_dev(div7, t12);
    			append_dev(div7, div6);
    			append_dev(div6, input3);
    			set_input_value(input3, /*$form*/ ctx[0].price_stay_short);
    			append_dev(div18, t13);
    			append_dev(div18, div9);
    			append_dev(div9, label4);
    			append_dev(div9, t15);
    			append_dev(div9, div8);
    			append_dev(div8, input4);
    			set_input_value(input4, /*$form*/ ctx[0].price_membership);
    			append_dev(div18, t16);
    			append_dev(div18, div11);
    			append_dev(div11, label5);
    			append_dev(div11, t18);
    			append_dev(div11, div10);
    			append_dev(div10, input5);
    			set_input_value(input5, /*$form*/ ctx[0].price_stay_month);
    			append_dev(div18, t19);
    			append_dev(div18, div13);
    			append_dev(div13, label6);
    			append_dev(div13, t21);
    			append_dev(div13, div12);
    			append_dev(div12, input6);
    			set_input_value(input6, /*$form*/ ctx[0].mattress_membership);
    			append_dev(div18, t22);
    			append_dev(div18, div15);
    			append_dev(div15, label7);
    			append_dev(div15, t24);
    			append_dev(div15, div14);
    			append_dev(div14, input7);
    			set_input_value(input7, /*$form*/ ctx[0].house_capacity);
    			append_dev(div18, t25);
    			append_dev(div18, div17);
    			append_dev(div17, label8);
    			append_dev(div17, t27);
    			append_dev(div17, div16);
    			append_dev(div16, input8);
    			set_input_value(input8, /*$form*/ ctx[0].price_meals);
    			append_dev(div18, t28);
    			if (if_block) if_block.m(div18, null);
    			append_dev(form_1, t29);
    			append_dev(form_1, div27);
    			append_dev(div27, div26);
    			append_dev(div26, div21);
    			append_dev(div21, label9);
    			append_dev(div21, t31);
    			append_dev(div21, div20);
    			append_dev(div20, input9);
    			set_input_value(input9, /*$form*/ ctx[0].text_stay);
    			append_dev(div26, t32);
    			append_dev(div26, div23);
    			append_dev(div23, label10);
    			append_dev(div23, t34);
    			append_dev(div23, div22);
    			append_dev(div22, input10);
    			set_input_value(input10, /*$form*/ ctx[0].text_membership);
    			append_dev(div26, t35);
    			append_dev(div26, div25);
    			append_dev(div25, label11);
    			append_dev(div25, t37);
    			append_dev(div25, div24);
    			append_dev(div24, input11);
    			set_input_value(input11, /*$form*/ ctx[0].text_meals);
    			append_dev(form_1, t38);
    			append_dev(form_1, div28);
    			append_dev(div28, button0);
    			append_dev(div28, t40);
    			append_dev(div28, button1);
    			append_dev(button1, t41);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input0, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[13]),
    					listen_dev(input1, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input1, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[14]),
    					listen_dev(input2, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input2, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[15]),
    					listen_dev(input3, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input3, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[16]),
    					listen_dev(input4, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input4, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[17]),
    					listen_dev(input5, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input5, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[18]),
    					listen_dev(input6, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input6, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[19]),
    					listen_dev(input7, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input7, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[20]),
    					listen_dev(input8, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input8, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input8, "input", /*input8_input_handler*/ ctx[21]),
    					listen_dev(input9, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input9, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input9, "input", /*input9_input_handler*/ ctx[23]),
    					listen_dev(input10, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input10, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input10, "input", /*input10_input_handler*/ ctx[24]),
    					listen_dev(input11, "keyup", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input11, "blur", /*handleChange*/ ctx[10], false, false, false),
    					listen_dev(input11, "input", /*input11_input_handler*/ ctx[25]),
    					listen_dev(button0, "click", /*resetForm*/ ctx[12], false, false, false),
    					listen_dev(form_1, "submit", /*handleSubmit*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$form*/ 1 && input0.value !== /*$form*/ ctx[0].short_stay_duration) {
    				set_input_value(input0, /*$form*/ ctx[0].short_stay_duration);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[2].short_stay_duration && /*$touched*/ ctx[3].short_stay_duration);
    			}

    			if (dirty & /*$form*/ 1 && input1.value !== /*$form*/ ctx[0].sci_days) {
    				set_input_value(input1, /*$form*/ ctx[0].sci_days);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input1, "uk-form-danger", /*$errors*/ ctx[2].sci_days && /*$touched*/ ctx[3].sci_days);
    			}

    			if (dirty & /*$form*/ 1 && input2.value !== /*$form*/ ctx[0].price_stay) {
    				set_input_value(input2, /*$form*/ ctx[0].price_stay);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input2, "uk-form-danger", /*$errors*/ ctx[2].price_stay && /*$touched*/ ctx[3].price_stay);
    			}

    			if (dirty & /*$form*/ 1 && input3.value !== /*$form*/ ctx[0].price_stay_short) {
    				set_input_value(input3, /*$form*/ ctx[0].price_stay_short);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input3, "uk-form-danger", /*$errors*/ ctx[2].price_stay_short && /*$touched*/ ctx[3].price_stay_short);
    			}

    			if (dirty & /*$form*/ 1 && input4.value !== /*$form*/ ctx[0].price_membership) {
    				set_input_value(input4, /*$form*/ ctx[0].price_membership);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input4, "uk-form-danger", /*$errors*/ ctx[2].price_membership && /*$touched*/ ctx[3].price_membership);
    			}

    			if (dirty & /*$form*/ 1 && input5.value !== /*$form*/ ctx[0].price_stay_month) {
    				set_input_value(input5, /*$form*/ ctx[0].price_stay_month);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input5, "uk-form-danger", /*$errors*/ ctx[2].price_stay_month && /*$touched*/ ctx[3].price_stay_month);
    			}

    			if (dirty & /*$form*/ 1 && input6.value !== /*$form*/ ctx[0].mattress_membership) {
    				set_input_value(input6, /*$form*/ ctx[0].mattress_membership);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input6, "uk-form-danger", /*$errors*/ ctx[2].mattress_membership && /*$touched*/ ctx[3].mattress_membership);
    			}

    			if (dirty & /*$form*/ 1 && input7.value !== /*$form*/ ctx[0].house_capacity) {
    				set_input_value(input7, /*$form*/ ctx[0].house_capacity);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input7, "uk-form-danger", /*$errors*/ ctx[2].house_capacity && /*$touched*/ ctx[3].house_capacity);
    			}

    			if (dirty & /*$form*/ 1 && input8.value !== /*$form*/ ctx[0].price_meals) {
    				set_input_value(input8, /*$form*/ ctx[0].price_meals);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input8, "uk-form-danger", /*$errors*/ ctx[2].price_meals && /*$touched*/ ctx[3].price_meals);
    			}

    			if (/*$role*/ ctx[4] === 'root') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					if_block.m(div18, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*$form*/ 1 && input9.value !== /*$form*/ ctx[0].text_stay) {
    				set_input_value(input9, /*$form*/ ctx[0].text_stay);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input9, "uk-form-danger", /*$errors*/ ctx[2].text_stay && /*$touched*/ ctx[3].text_stay);
    			}

    			if (dirty & /*$form*/ 1 && input10.value !== /*$form*/ ctx[0].text_membership) {
    				set_input_value(input10, /*$form*/ ctx[0].text_membership);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input10, "uk-form-danger", /*$errors*/ ctx[2].text_membership && /*$touched*/ ctx[3].text_membership);
    			}

    			if (dirty & /*$form*/ 1 && input11.value !== /*$form*/ ctx[0].text_meals) {
    				set_input_value(input11, /*$form*/ ctx[0].text_meals);
    			}

    			if (dirty & /*$errors, $touched*/ 12) {
    				toggle_class(input11, "uk-form-danger", /*$errors*/ ctx[2].text_meals && /*$touched*/ ctx[3].text_meals);
    			}

    			if (dirty & /*$isValid*/ 32 && button1_disabled_value !== (button1_disabled_value = !/*$isValid*/ ctx[5])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*$isValid*/ 32) {
    				toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[5]);
    			}

    			if (dirty & /*$screenWidthL*/ 2) {
    				toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[1]);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div30);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $settings;
    	let $form;
    	let $screenWidthL;
    	let $errors;
    	let $touched;
    	let $role;
    	let $isValid;
    	validate_store(settings, 'settings');
    	component_subscribe($$self, settings, $$value => $$invalidate(26, $settings = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(1, $screenWidthL = $$value));
    	validate_store(role, 'role');
    	component_subscribe($$self, role, $$value => $$invalidate(4, $role = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Settings', slots, []);
    	const dispatch = createEventDispatcher();

    	const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    		initialValues: {
    			price_meals: 0,
    			price_membership: 0,
    			short_stay_duration: 0,
    			price_stay_month: 0,
    			price_stay: 0,
    			price_stay_short: 0,
    			mattress_membership: 0,
    			house_capacity: 0,
    			text_meals: '',
    			text_membership: '',
    			text_stay: '',
    			sci_days: 0,
    			app_version: ''
    		},
    		onSubmit: () => save(),
    		validationSchema: create$4().shape({
    			price_meals: create$6().min(0),
    			price_membership: create$6().min(0),
    			short_stay_duration: create$6().min(0),
    			price_stay_month: create$6(),
    			price_stay: create$6().min(0),
    			price_stay_short: create$6().min(0),
    			mattress_membership: create$6().min(0),
    			house_capacity: create$6().min(0),
    			text_meals: create$7(),
    			text_membership: create$7(),
    			text_stay: create$7(),
    			sci_days: create$6().min(0),
    			app_version: create$7()
    		})
    	});

    	validate_store(form, 'form');
    	component_subscribe($$self, form, value => $$invalidate(0, $form = value));
    	validate_store(errors, 'errors');
    	component_subscribe($$self, errors, value => $$invalidate(2, $errors = value));
    	validate_store(touched, 'touched');
    	component_subscribe($$self, touched, value => $$invalidate(3, $touched = value));
    	validate_store(isValid, 'isValid');
    	component_subscribe($$self, isValid, value => $$invalidate(5, $isValid = value));
    	onMount(() => resetForm());

    	async function save() {
    		let success = await updateSettings($form);
    		if (success) uikit.notification('<span uk-icon="icon: check"></span> Default settings updated!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    		dispatchReload();
    	}

    	function resetForm() {
    		set_store_value(form, $form.price_meals = $settings.price_meals, $form);
    		set_store_value(form, $form.price_membership = $settings.price_membership, $form);
    		set_store_value(form, $form.short_stay_duration = $settings.short_stay_duration, $form);
    		set_store_value(form, $form.price_stay = $settings.price_stay, $form);
    		set_store_value(form, $form.price_stay_short = $settings.price_stay_short, $form);
    		set_store_value(form, $form.price_stay_month = $settings.price_stay_month, $form);
    		set_store_value(form, $form.mattress_membership = $settings.mattress_membership, $form);
    		set_store_value(form, $form.house_capacity = $settings.house_capacity, $form);
    		set_store_value(form, $form.text_meals = $settings.text_meals, $form);
    		set_store_value(form, $form.text_membership = $settings.text_membership, $form);
    		set_store_value(form, $form.text_stay = $settings.text_stay, $form);
    		set_store_value(form, $form.sci_days = $settings.sci_days, $form);
    		set_store_value(form, $form.app_version = $settings.app_version, $form);
    	}

    	function dispatchReload() {
    		dispatch('message', { reload: 'settings' });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Settings> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		$form.short_stay_duration = this.value;
    		form.set($form);
    	}

    	function input1_input_handler() {
    		$form.sci_days = this.value;
    		form.set($form);
    	}

    	function input2_input_handler() {
    		$form.price_stay = this.value;
    		form.set($form);
    	}

    	function input3_input_handler() {
    		$form.price_stay_short = this.value;
    		form.set($form);
    	}

    	function input4_input_handler() {
    		$form.price_membership = this.value;
    		form.set($form);
    	}

    	function input5_input_handler() {
    		$form.price_stay_month = this.value;
    		form.set($form);
    	}

    	function input6_input_handler() {
    		$form.mattress_membership = this.value;
    		form.set($form);
    	}

    	function input7_input_handler() {
    		$form.house_capacity = this.value;
    		form.set($form);
    	}

    	function input8_input_handler() {
    		$form.price_meals = this.value;
    		form.set($form);
    	}

    	function input_input_handler() {
    		$form.app_version = this.value;
    		form.set($form);
    	}

    	function input9_input_handler() {
    		$form.text_stay = this.value;
    		form.set($form);
    	}

    	function input10_input_handler() {
    		$form.text_membership = this.value;
    		form.set($form);
    	}

    	function input11_input_handler() {
    		$form.text_meals = this.value;
    		form.set($form);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		screenWidthL,
    		createForm,
    		yup,
    		role,
    		settings,
    		updateSettings,
    		UIkit: uikit,
    		dispatch,
    		form,
    		errors,
    		touched,
    		state,
    		isValid,
    		handleChange,
    		handleSubmit,
    		save,
    		resetForm,
    		dispatchReload,
    		$settings,
    		$form,
    		$screenWidthL,
    		$errors,
    		$touched,
    		$role,
    		$isValid
    	});

    	return [
    		$form,
    		$screenWidthL,
    		$errors,
    		$touched,
    		$role,
    		$isValid,
    		form,
    		errors,
    		touched,
    		isValid,
    		handleChange,
    		handleSubmit,
    		resetForm,
    		input0_input_handler,
    		input1_input_handler,
    		input2_input_handler,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		input7_input_handler,
    		input8_input_handler,
    		input_input_handler,
    		input9_input_handler,
    		input10_input_handler,
    		input11_input_handler
    	];
    }

    class Settings extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Settings",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    async function getUsers() {
        try {
            const result = await api.get('/users/');
            return result.data
        } catch (error) {}
    }

    async function registerUser(user) {
        try {
            user.password_confirmation = user.password;
            const result = await api.post('/user/', user);
            return result.status === 200
        } catch (error) {}
    }

    async function deleteUser(id) {
        try {
            const result = await api.delete('/user/'+id);
            return result.status === 200
        } catch (error) {}
    }

    function passwordStrengthMeter(opts) {

    	// Add styles inside body
    	const customStyles = document.createElement('style');
    	document.body.prepend(customStyles);
    	customStyles.innerHTML = `
		${opts.containerElement} {
			height: ${opts.height || 4}px;
			background-color: #eee;
			position: relative;
			overflow: hidden;
			border-radius: ${opts.borderRadius?.toString() || 2}px;
		}
    ${opts.containerElement} .password-strength-meter-score {
      height: inherit;
      width: 0%;
      transition: .3s ease-in-out;
      background: ${opts.colorScore1 || '#ff7700'};
    }
    ${opts.containerElement} .password-strength-meter-score.psms-25 {width: 25%; background: ${opts.colorScore1 || '#ff7700'};}
    ${opts.containerElement} .password-strength-meter-score.psms-50 {width: 50%; background: ${opts.colorScore2 || '#ffff00'};}
    ${opts.containerElement} .password-strength-meter-score.psms-75 {width: 75%; background: ${opts.colorScore3 || '#aeff00'};}
    ${opts.containerElement} .password-strength-meter-score.psms-100 {width: 100%; background: ${opts.colorScore4 || '#00ff00'};}`;

    	// Container Element
    	const containerElement = document.getElementById(opts.containerElement.slice(1));
    	containerElement.classList.add('password-strength-meter');

    	// Score Bar
    	let scoreBar = document.createElement('div');
    	scoreBar.classList.add('password-strength-meter-score');

    	// Append score bar to container element
    	containerElement.appendChild(scoreBar);

    	// Password input
    	const passwordInput = document.getElementById(opts.passwordInput.slice(1));
    	let passwordInputValue = '';
    	passwordInput.addEventListener('keyup', function() {
    		passwordInputValue = this.value;
    		checkPassword();
    	});

    	// Chosen Min Length
    	let pswMinLength = opts.pswMinLength || 8;

    	// Score Message
    	let scoreMessage = opts.showMessage ? document.getElementById(opts.messageContainer.slice(1)) : null;
    	let messagesList = opts.messagesList === undefined ? ['No data', 'Too simple', 'Simple', 'That\'s OK', 'Great password!'] : opts.messagesList;
    	if (scoreMessage) { scoreMessage.textContent = messagesList[0] || 'No data';}

    	// Check Password Function
    	function checkPassword() {
    	  let score = getScore();
    	  updateScore(score);
    	}

    	// Get Score Function
    	function getScore() {

    		let score = 0;

    	  let regexLower = new RegExp('(?=.*[a-z])');
    	  let regexUpper = new RegExp('(?=.*[A-Z])');
    	  let regexDigits = new RegExp('(?=.*[0-9])');
    	  // For length score print user selection or default value
    	  let regexLength = new RegExp('(?=.{' + pswMinLength + ',})');

    	  if (passwordInputValue.match(regexLower)) { ++score; }
    	  if (passwordInputValue.match(regexUpper)) { ++score; }
    	  if (passwordInputValue.match(regexDigits)) { ++score; }
    	  if (passwordInputValue.match(regexLength)) { ++score; }

    	  if (score === 0 && passwordInputValue.length > 0) { ++score; }

    	  return score
    	}

    	// Show Score Function
    	function updateScore(score) {
        switch(score) {
          case 1:
            scoreBar.className = 'password-strength-meter-score psms-25';
            if (scoreMessage) { scoreMessage.textContent = messagesList[1] || 'Too simple'; }
            containerElement.dispatchEvent(new Event('onScore1', { bubbles: true }));
            break
          case 2:
            scoreBar.className = 'password-strength-meter-score psms-50';
            if (scoreMessage) { scoreMessage.textContent = messagesList[2] || 'Simple'; }
            containerElement.dispatchEvent(new Event('onScore2', { bubbles: true }));
            break
          case 3:
            scoreBar.className = 'password-strength-meter-score psms-75';
            if (scoreMessage) { scoreMessage.textContent = messagesList[3] || 'That\'s OK'; }
            containerElement.dispatchEvent(new Event('onScore3', { bubbles: true }));
            break
          case 4:
            scoreBar.className = 'password-strength-meter-score psms-100';
            if (scoreMessage) { scoreMessage.textContent = messagesList[4] || 'Great password!'; }
            containerElement.dispatchEvent(new Event('onScore4', { bubbles: true }));
            break
          default:
            scoreBar.className = 'password-strength-meter-score';
            if (scoreMessage) { scoreMessage.textContent = messagesList[0] || 'No data'; }
            containerElement.dispatchEvent(new Event('onScore0', { bubbles: true }));
        }
      }

      // Return anonymous object with properties
      return {
      	containerElement,
      	getScore
      }

    }

    /* src/components/Users.svelte generated by Svelte v3.45.0 */
    const file$f = "src/components/Users.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	return child_ctx;
    }

    // (129:12) {:else }
    function create_else_block$e(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let tbody;
    	let each_value = /*users*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Role";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Delete";
    			t5 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$f, 132, 24, 6399);
    			add_location(th1, file$f, 133, 24, 6437);
    			attr_dev(th2, "class", "uk-table-shrink");
    			add_location(th2, file$f, 134, 24, 6475);
    			add_location(tr, file$f, 131, 20, 6370);
    			add_location(thead, file$f, 130, 20, 6342);
    			add_location(tbody, file$f, 137, 20, 6590);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$f, 129, 16, 6236);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(table, t5);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*deleteMe, users*/ 8194) {
    				each_value = /*users*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(129:12) {:else }",
    		ctx
    	});

    	return block;
    }

    // (127:12) {#if users.length === 0}
    function create_if_block$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading Users...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(127:12) {#if users.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (139:20) {#each users as user}
    function create_each_block$9(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*user*/ ctx[24].user + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*user*/ ctx[24].role + "";
    	let t2;
    	let t3;
    	let td2;
    	let button;
    	let t5;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[16](/*user*/ ctx[24]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			button = element("button");
    			button.textContent = "Delete";
    			t5 = space();
    			attr_dev(td0, "class", "uk-text-nowrap");
    			add_location(td0, file$f, 140, 28, 6697);
    			attr_dev(td1, "class", "uk-text-nowrap");
    			add_location(td1, file$f, 141, 28, 6769);
    			attr_dev(button, "class", "uk-button uk-button-small uk-button-danger");
    			add_location(button, file$f, 142, 56, 6869);
    			attr_dev(td2, "class", "uk-table-shrink");
    			add_location(td2, file$f, 142, 28, 6841);
    			add_location(tr, file$f, 139, 24, 6664);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, button);
    			append_dev(tr, t5);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*users*/ 2 && t0_value !== (t0_value = /*user*/ ctx[24].user + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*users*/ 2 && t2_value !== (t2_value = /*user*/ ctx[24].role + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(139:20) {#each users as user}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div13;
    	let div12;
    	let h4;
    	let t1;
    	let div10;
    	let form_1;
    	let label;
    	let t3;
    	let div9;
    	let div0;
    	let input0;
    	let t4;
    	let div1;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let t9;
    	let div2;
    	let button;
    	let t10;
    	let button_disabled_value;
    	let t11;
    	let div3;
    	let input1;
    	let t12;
    	let div4;
    	let t13;
    	let div6;
    	let div5;
    	let t14;
    	let div7;
    	let t16;
    	let div8;
    	let b;
    	let t18;
    	let i;
    	let t20;
    	let t21;
    	let div11;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*users*/ ctx[1].length === 0) return create_if_block$e;
    		return create_else_block$e;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div13 = element("div");
    			div12 = element("div");
    			h4 = element("h4");
    			h4.textContent = "User management";
    			t1 = space();
    			div10 = element("div");
    			form_1 = element("form");
    			label = element("label");
    			label.textContent = "New user";
    			t3 = space();
    			div9 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div1 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Select role";
    			option1 = element("option");
    			option1.textContent = "Booking";
    			option2 = element("option");
    			option2.textContent = "Administrator";
    			option3 = element("option");
    			option3.textContent = "Mattress";
    			t9 = space();
    			div2 = element("div");
    			button = element("button");
    			t10 = text$1("Create");
    			t11 = space();
    			div3 = element("div");
    			input1 = element("input");
    			t12 = space();
    			div4 = element("div");
    			t13 = space();
    			div6 = element("div");
    			div5 = element("div");
    			t14 = space();
    			div7 = element("div");
    			div7.textContent = "Passwords are required to have at least: one lowercase character, one uppercase character, one numeric character and a length of 12 characters. Use a password manager when in doubt.";
    			t16 = space();
    			div8 = element("div");
    			b = element("b");
    			b.textContent = "Note";
    			t18 = text$1(": When creating a new user, make sure to ");
    			i = element("i");
    			i.textContent = "record the credentials/password safely";
    			t20 = text$1(", it cannot ever be displayed again afterwards!");
    			t21 = space();
    			div11 = element("div");
    			if_block.c();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-width-1-1");
    			add_location(h4, file$f, 88, 8, 3065);
    			attr_dev(label, "class", "uk-form-label");
    			attr_dev(label, "for", "form-personals");
    			add_location(label, file$f, 91, 16, 3342);
    			attr_dev(input0, "class", "uk-input uk-form-width-large");
    			attr_dev(input0, "id", "form-user-no1pw-search");
    			attr_dev(input0, "name", "user");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "User");
    			attr_dev(input0, "autocomplete", "'off");
    			set_style(input0, "color", "black");
    			toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[4].user && /*$touched*/ ctx[5].user);
    			add_location(input0, file$f, 94, 24, 3595);
    			attr_dev(div0, "class", "uk-width-1-3@s");
    			add_location(div0, file$f, 93, 20, 3542);
    			option0.__value = "0";
    			option0.value = option0.__value;
    			option0.selected = true;
    			add_location(option0, file$f, 101, 28, 4242);
    			option1.__value = "booking";
    			option1.value = option1.__value;
    			add_location(option1, file$f, 102, 28, 4318);
    			option2.__value = "admin";
    			option2.value = option2.__value;
    			add_location(option2, file$f, 103, 28, 4387);
    			option3.__value = "mattress";
    			option3.value = option3.__value;
    			add_location(option3, file$f, 104, 28, 4460);
    			attr_dev(select, "class", "uk-select");
    			attr_dev(select, "id", "form-role");
    			attr_dev(select, "name", "role");
    			attr_dev(select, "type", "text");
    			toggle_class(select, "uk-form-danger", /*$errors*/ ctx[4].role && /*$touched*/ ctx[5].role);
    			add_location(select, file$f, 99, 24, 4038);
    			attr_dev(div1, "class", "uk-width-1-3@s");
    			add_location(div1, file$f, 98, 20, 3985);
    			attr_dev(button, "class", "uk-button uk-margin-large-left");
    			attr_dev(button, "id", "submit");
    			attr_dev(button, "type", "submit");
    			button.disabled = button_disabled_value = !/*$isValid*/ ctx[6] || !/*okPassword*/ ctx[2];
    			toggle_class(button, "uk-button-primary", /*$isValid*/ ctx[6] && /*okPassword*/ ctx[2]);
    			add_location(button, file$f, 108, 24, 4637);
    			attr_dev(div2, "class", "uk-width-1-3@s");
    			add_location(div2, file$f, 107, 20, 4584);
    			attr_dev(input1, "class", "uk-input");
    			attr_dev(input1, "id", "psw-input");
    			attr_dev(input1, "name", "password");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "Password");
    			attr_dev(input1, "autocomplete", "'off");
    			set_style(input1, "color", "black");
    			toggle_class(input1, "uk-form-danger", !/*okPassword*/ ctx[2] || /*$errors*/ ctx[4].password && /*$touched*/ ctx[5].password);
    			add_location(input1, file$f, 112, 24, 4943);
    			attr_dev(div3, "class", "uk-width-1-3@s");
    			add_location(div3, file$f, 111, 20, 4890);
    			attr_dev(div4, "class", "uk-width-2-3@s");
    			add_location(div4, file$f, 116, 20, 5337);
    			attr_dev(div5, "id", "pswmeter");
    			add_location(div5, file$f, 118, 24, 5511);
    			attr_dev(div6, "class", "uk-width-1-3@s uk-padding-small-left uk-margin-small-top uk-margin-small-bottom");
    			add_location(div6, file$f, 117, 20, 5393);
    			attr_dev(div7, "class", "uk-width-1-1 uk-margin-remove-top uk-text-meta");
    			add_location(div7, file$f, 120, 20, 5584);
    			add_location(b, file$f, 121, 46, 5878);
    			add_location(i, file$f, 121, 98, 5930);
    			attr_dev(div8, "class", "uk-width-1-1");
    			add_location(div8, file$f, 121, 20, 5852);
    			attr_dev(div9, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div9, "id", "form-personals");
    			attr_dev(div9, "uk-grid", "");
    			add_location(div9, file$f, 92, 16, 3425);
    			attr_dev(form_1, "class", "uk-form");
    			toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[3]);
    			add_location(form_1, file$f, 90, 12, 3236);
    			attr_dev(div10, "class", "uk-margin-medium");
    			add_location(div10, file$f, 89, 8, 3193);
    			attr_dev(div11, "class", "uk-margin-large-top");
    			add_location(div11, file$f, 125, 8, 6095);
    			attr_dev(div12, "class", "uk-section uk-section-xsmall uk-margin-medium-top uk-margin-bottom uk-width-2-3@m uk-width-5-6");
    			add_location(div12, file$f, 87, 4, 2948);
    			attr_dev(div13, "class", "uk-flex uk-flex-center");
    			add_location(div13, file$f, 86, 0, 2907);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div12);
    			append_dev(div12, h4);
    			append_dev(div12, t1);
    			append_dev(div12, div10);
    			append_dev(div10, form_1);
    			append_dev(form_1, label);
    			append_dev(form_1, t3);
    			append_dev(form_1, div9);
    			append_dev(div9, div0);
    			append_dev(div0, input0);
    			set_input_value(input0, /*$form*/ ctx[0].user);
    			append_dev(div9, t4);
    			append_dev(div9, div1);
    			append_dev(div1, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			append_dev(div9, t9);
    			append_dev(div9, div2);
    			append_dev(div2, button);
    			append_dev(button, t10);
    			append_dev(div9, t11);
    			append_dev(div9, div3);
    			append_dev(div3, input1);
    			set_input_value(input1, /*$form*/ ctx[0].password);
    			append_dev(div9, t12);
    			append_dev(div9, div4);
    			append_dev(div9, t13);
    			append_dev(div9, div6);
    			append_dev(div6, div5);
    			append_dev(div9, t14);
    			append_dev(div9, div7);
    			append_dev(div9, t16);
    			append_dev(div9, div8);
    			append_dev(div8, b);
    			append_dev(div8, t18);
    			append_dev(div8, i);
    			append_dev(div8, t20);
    			append_dev(div12, t21);
    			append_dev(div12, div11);
    			if_block.m(div11, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "keyup", /*handleChange*/ ctx[11], false, false, false),
    					listen_dev(input0, "blur", /*handleChange*/ ctx[11], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[14]),
    					listen_dev(select, "change", /*handleChange*/ ctx[11], false, false, false),
    					listen_dev(input1, "keyup", /*handleChange*/ ctx[11], false, false, false),
    					listen_dev(input1, "blur", /*handleChange*/ ctx[11], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[15]),
    					listen_dev(form_1, "submit", /*handleSubmit*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$form*/ 1 && input0.value !== /*$form*/ ctx[0].user) {
    				set_input_value(input0, /*$form*/ ctx[0].user);
    			}

    			if (dirty & /*$errors, $touched*/ 48) {
    				toggle_class(input0, "uk-form-danger", /*$errors*/ ctx[4].user && /*$touched*/ ctx[5].user);
    			}

    			if (dirty & /*$errors, $touched*/ 48) {
    				toggle_class(select, "uk-form-danger", /*$errors*/ ctx[4].role && /*$touched*/ ctx[5].role);
    			}

    			if (dirty & /*$isValid, okPassword*/ 68 && button_disabled_value !== (button_disabled_value = !/*$isValid*/ ctx[6] || !/*okPassword*/ ctx[2])) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (dirty & /*$isValid, okPassword*/ 68) {
    				toggle_class(button, "uk-button-primary", /*$isValid*/ ctx[6] && /*okPassword*/ ctx[2]);
    			}

    			if (dirty & /*$form*/ 1 && input1.value !== /*$form*/ ctx[0].password) {
    				set_input_value(input1, /*$form*/ ctx[0].password);
    			}

    			if (dirty & /*okPassword, $errors, $touched*/ 52) {
    				toggle_class(input1, "uk-form-danger", !/*okPassword*/ ctx[2] || /*$errors*/ ctx[4].password && /*$touched*/ ctx[5].password);
    			}

    			if (dirty & /*$screenWidthL*/ 8) {
    				toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[3]);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div11, null);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div13);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $form;
    	let $screenWidthL;
    	let $errors;
    	let $touched;
    	let $isValid;
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(3, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Users', slots, []);
    	let users = [];
    	let okPassword = true;
    	let myPassMeter = null;
    	const dispatch = createEventDispatcher();

    	const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    		initialValues: { user: '', password: '', role: '' },
    		onSubmit: () => save(),
    		validationSchema: create$4().shape({
    			user: create$7().min(3).required(),
    			password: create$7().min(12).required(),
    			role: create$7().min(5).required()
    		})
    	});

    	validate_store(form, 'form');
    	component_subscribe($$self, form, value => $$invalidate(0, $form = value));
    	validate_store(errors, 'errors');
    	component_subscribe($$self, errors, value => $$invalidate(4, $errors = value));
    	validate_store(touched, 'touched');
    	component_subscribe($$self, touched, value => $$invalidate(5, $touched = value));
    	validate_store(isValid, 'isValid');
    	component_subscribe($$self, isValid, value => $$invalidate(6, $isValid = value));

    	onMount(async () => {
    		$$invalidate(1, users = await getUsers());

    		myPassMeter = passwordStrengthMeter({
    			containerElement: '#pswmeter',
    			passwordInput: '#psw-input',
    			pswMinLength: 12
    		});
    	});

    	function dispatchReload() {
    		dispatch('message', { reload: 'users' });
    	}

    	function checkPwdStrength() {
    		if (myPassMeter !== null) $$invalidate(2, okPassword = myPassMeter.getScore() === 4);
    	}

    	function cancel() {
    		set_store_value(form, $form.user = '', $form);
    		set_store_value(form, $form.password = '', $form);
    		set_store_value(form, $form.role = '', $form);
    	}

    	async function save() {
    		if (users.find(u => u.user === $form.user)) {
    			alert('User ' + $form.user + ' already exists, please choose another name!');
    			return;
    		}

    		alert('Please note down the password for ' + $form.user + ': ' + $form.password);
    		let success = await registerUser($form);
    		if (success) uikit.notification('<span uk-icon="icon: check"></span> User registered!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    		dispatchReload();
    	}

    	async function deleteMe(user) {
    		if (users.length > 1) {
    			if (user !== null && user.id !== null && confirm('Are you sure to delete user ' + user.user + '?')) {
    				let success = await deleteUser(user.id);
    				if (success) uikit.notification('<span uk-icon="icon: check"></span> User deleted!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    				dispatchReload();
    			}
    		} else alert('You cannot delete the single last user.');
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Users> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		$form.user = this.value;
    		form.set($form);
    	}

    	function input1_input_handler() {
    		$form.password = this.value;
    		form.set($form);
    	}

    	const click_handler = user => deleteMe(user);

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		screenWidthL,
    		screenWidthS,
    		createForm,
    		yup,
    		UIkit: uikit,
    		deleteUser,
    		getUsers,
    		registerUser,
    		passwordStrengthMeter,
    		users,
    		okPassword,
    		myPassMeter,
    		dispatch,
    		form,
    		errors,
    		touched,
    		state,
    		isValid,
    		handleChange,
    		handleSubmit,
    		dispatchReload,
    		checkPwdStrength,
    		cancel,
    		save,
    		deleteMe,
    		$form,
    		$screenWidthL,
    		$errors,
    		$touched,
    		$isValid
    	});

    	$$self.$inject_state = $$props => {
    		if ('users' in $$props) $$invalidate(1, users = $$props.users);
    		if ('okPassword' in $$props) $$invalidate(2, okPassword = $$props.okPassword);
    		if ('myPassMeter' in $$props) myPassMeter = $$props.myPassMeter;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$form*/ 1) {
    			$form && checkPwdStrength();
    		}
    	};

    	return [
    		$form,
    		users,
    		okPassword,
    		$screenWidthL,
    		$errors,
    		$touched,
    		$isValid,
    		form,
    		errors,
    		touched,
    		isValid,
    		handleChange,
    		handleSubmit,
    		deleteMe,
    		input0_input_handler,
    		input1_input_handler,
    		click_handler
    	];
    }

    class Users extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Users",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* src/components/SciForm.svelte generated by Svelte v3.45.0 */
    const file$e = "src/components/SciForm.svelte";

    // (106:4) {:else}
    function create_else_block_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Replacing SCI member");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(106:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (104:4) {#if !dispatched}
    function create_if_block_2$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Replace SCI member");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(104:4) {#if !dispatched}",
    		ctx
    	});

    	return block;
    }

    // (114:0) {:else}
    function create_else_block$d(ctx) {
    	let form_1;
    	let div2;
    	let label;
    	let t1;
    	let div1;
    	let div0;
    	let input;
    	let t2;
    	let t3;
    	let div3;
    	let button0;
    	let t5;
    	let button1;
    	let t6;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;
    	let if_block = /*alreadySciMember*/ ctx[1] && create_if_block_1$7(ctx);

    	const block = {
    		c: function create() {
    			form_1 = element("form");
    			div2 = element("div");
    			label = element("label");
    			label.textContent = "New SCI member";
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t2 = space();
    			if (if_block) if_block.c();
    			t3 = space();
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "Cancel";
    			t5 = space();
    			button1 = element("button");
    			t6 = text$1("Save");
    			attr_dev(label, "class", "uk-form-label");
    			attr_dev(label, "for", "form-personals");
    			add_location(label, file$e, 117, 12, 4393);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "id", "form-name");
    			attr_dev(input, "name", "name");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "Name");
    			set_style(input, "color", "black");
    			toggle_class(input, "uk-form-danger", /*$errors*/ ctx[4].name && /*$touched*/ ctx[5].name);
    			add_location(input, file$e, 120, 20, 4638);
    			attr_dev(div0, "class", "uk-width-1-1");
    			add_location(div0, file$e, 119, 16, 4591);
    			attr_dev(div1, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div1, "id", "form-personals");
    			attr_dev(div1, "uk-grid", "");
    			add_location(div1, file$e, 118, 12, 4478);
    			attr_dev(div2, "class", "uk-margin-medium");
    			add_location(div2, file$e, 116, 8, 4350);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$e, 133, 12, 5284);
    			attr_dev(button1, "class", "uk-button uk-margin-large-left");
    			attr_dev(button1, "id", "submitBooking");
    			attr_dev(button1, "type", "submit");
    			button1.disabled = button1_disabled_value = !/*$isValid*/ ctx[7] || /*newSciMember*/ ctx[0] === null || /*alreadySciMember*/ ctx[1];
    			toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[7] && /*newSciMember*/ ctx[0] !== null && !/*alreadySciMember*/ ctx[1]);
    			add_location(button1, file$e, 134, 12, 5388);
    			attr_dev(div3, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div3, file$e, 132, 8, 5198);
    			attr_dev(form_1, "id", "sciMemberForm");
    			attr_dev(form_1, "class", "uk-form");
    			toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[3]);
    			add_location(form_1, file$e, 114, 4, 4232);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form_1, anchor);
    			append_dev(form_1, div2);
    			append_dev(div2, label);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*$form*/ ctx[6].name);
    			append_dev(div1, t2);
    			if (if_block) if_block.m(div1, null);
    			append_dev(form_1, t3);
    			append_dev(form_1, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t5);
    			append_dev(div3, button1);
    			append_dev(button1, t6);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "keyup", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input, "blur", /*handleChange*/ ctx[12], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[16]),
    					listen_dev(button0, "click", /*cancel*/ ctx[14], false, false, false),
    					listen_dev(form_1, "submit", /*handleSubmit*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$form*/ 64 && input.value !== /*$form*/ ctx[6].name) {
    				set_input_value(input, /*$form*/ ctx[6].name);
    			}

    			if (dirty & /*$errors, $touched*/ 48) {
    				toggle_class(input, "uk-form-danger", /*$errors*/ ctx[4].name && /*$touched*/ ctx[5].name);
    			}

    			if (/*alreadySciMember*/ ctx[1]) {
    				if (if_block) ; else {
    					if_block = create_if_block_1$7(ctx);
    					if_block.c();
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*$isValid, newSciMember, alreadySciMember*/ 131 && button1_disabled_value !== (button1_disabled_value = !/*$isValid*/ ctx[7] || /*newSciMember*/ ctx[0] === null || /*alreadySciMember*/ ctx[1])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*$isValid, newSciMember, alreadySciMember*/ 131) {
    				toggle_class(button1, "uk-button-primary", /*$isValid*/ ctx[7] && /*newSciMember*/ ctx[0] !== null && !/*alreadySciMember*/ ctx[1]);
    			}

    			if (dirty & /*$screenWidthL*/ 8) {
    				toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form_1);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(114:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (110:0) {#if dispatched}
    function create_if_block$d(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$e, 111, 8, 4175);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-xlarge-top");
    			add_location(div1, file$e, 110, 4, 4109);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(110:0) {#if dispatched}",
    		ctx
    	});

    	return block;
    }

    // (125:16) {#if alreadySciMember}
    function create_if_block_1$7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "This member is already an SCI member!";
    			attr_dev(div, "class", "uk-width-1-1 uk-text-danger");
    			add_location(div, file$e, 125, 20, 5002);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(125:16) {#if alreadySciMember}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let h4;
    	let t;
    	let if_block1_anchor;

    	function select_block_type(ctx, dirty) {
    		if (!/*dispatched*/ ctx[2]) return create_if_block_2$7;
    		return create_else_block_1$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*dispatched*/ ctx[2]) return create_if_block$d;
    		return create_else_block$d;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			if_block0.c();
    			t = space();
    			if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-inline uk-width-1-1");
    			add_location(h4, file$e, 102, 0, 3872);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			if_block0.m(h4, null);
    			insert_dev(target, t, anchor);
    			if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h4, null);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if_block0.d();
    			if (detaching) detach_dev(t);
    			if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $memberNames;
    	let $screenWidthL;
    	let $errors;
    	let $touched;
    	let $form;
    	let $isValid;
    	validate_store(memberNames, 'memberNames');
    	component_subscribe($$self, memberNames, $$value => $$invalidate(17, $memberNames = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(3, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SciForm', slots, []);
    	let { member = undefined } = $$props;
    	let newSciMember = null;
    	let alreadySciMember = false;
    	let dispatched = false;
    	const dispatch = createEventDispatcher();

    	const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    		initialValues: { name: '' },
    		onSubmit: async values => {
    			if (newSciMember !== null && !alreadySciMember && confirm('Are you sure to replace current SCI member ' + member.name + ' with ' + newSciMember.name + '?')) {
    				$$invalidate(2, dispatched = true);
    				$$invalidate(15, member.sci_member = false, member);
    				$$invalidate(0, newSciMember.sci_member = true, newSciMember);
    				if (await updateMember(member) && await updateMember(newSciMember)) uikit.notification('<span uk-icon="icon: check"></span> SCI member replaced!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    				dispatch('message', { goto: 'save' });
    			}
    		},
    		validationSchema: create$4().shape({ name: create$7().min(4).required() })
    	});

    	validate_store(form, 'form');
    	component_subscribe($$self, form, value => $$invalidate(6, $form = value));
    	validate_store(errors, 'errors');
    	component_subscribe($$self, errors, value => $$invalidate(4, $errors = value));
    	validate_store(touched, 'touched');
    	component_subscribe($$self, touched, value => $$invalidate(5, $touched = value));
    	validate_store(isValid, 'isValid');
    	component_subscribe($$self, isValid, value => $$invalidate(7, $isValid = value));

    	onMount(() => {
    		if (member !== undefined) {
    			const autoCompleteJS = new autoComplete({
    					selector: "#form-name",
    					placeHolder: "Search for member...",
    					diacritics: true,
    					searchEngine: 'strict',
    					data: { src: $memberNames, cache: true },
    					resultsList: {
    						element: (list, data) => {
    							if (!data.results.length) {
    								const message = document.createElement("div");
    								message.setAttribute("class", "no_result");
    								message.innerHTML = `<span>No Member for "${data.query}"</span>`;
    								list.prepend(message);
    							}
    						},
    						maxResults: 50,
    						noResults: true
    					},
    					resultItem: { highlight: true },
    					events: {
    						input: {
    							selection: event => {
    								autoCompleteJS.input.value = event.detail.selection.value;
    								getMemberData(event.detail.selection.value);
    							},
    							keyup: () => {
    								if (autoCompleteJS.input.value === '') getMemberData(null);
    							}
    						}
    					}
    				});
    		}
    	});

    	async function getMemberData(name) {
    		$$invalidate(0, newSciMember = null);

    		if (name !== null) {
    			$$invalidate(0, newSciMember = await getMemberByName(name));
    			if (newSciMember !== undefined && newSciMember !== null) $$invalidate(0, newSciMember = newSciMember[0]);
    		}

    		$$invalidate(1, alreadySciMember = newSciMember !== null && newSciMember.sci_member !== null
    		? newSciMember.sci_member
    		: false);

    		document.getElementById('form-name').focus();
    		setTimeout(() => document.getElementById('form-name').blur(), 0);
    	}

    	function cancel() {
    		dispatch('message', { goto: 'cancel' });
    	}

    	const writable_props = ['member'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SciForm> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		$form.name = this.value;
    		form.set($form);
    	}

    	$$self.$$set = $$props => {
    		if ('member' in $$props) $$invalidate(15, member = $$props.member);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		createForm,
    		yup,
    		screenWidthL,
    		getMemberByName,
    		memberNames,
    		updateMember,
    		autoComplete,
    		UIkit: uikit,
    		member,
    		newSciMember,
    		alreadySciMember,
    		dispatched,
    		dispatch,
    		form,
    		errors,
    		touched,
    		state,
    		isValid,
    		handleChange,
    		handleSubmit,
    		getMemberData,
    		cancel,
    		$memberNames,
    		$screenWidthL,
    		$errors,
    		$touched,
    		$form,
    		$isValid
    	});

    	$$self.$inject_state = $$props => {
    		if ('member' in $$props) $$invalidate(15, member = $$props.member);
    		if ('newSciMember' in $$props) $$invalidate(0, newSciMember = $$props.newSciMember);
    		if ('alreadySciMember' in $$props) $$invalidate(1, alreadySciMember = $$props.alreadySciMember);
    		if ('dispatched' in $$props) $$invalidate(2, dispatched = $$props.dispatched);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		newSciMember,
    		alreadySciMember,
    		dispatched,
    		$screenWidthL,
    		$errors,
    		$touched,
    		$form,
    		$isValid,
    		form,
    		errors,
    		touched,
    		isValid,
    		handleChange,
    		handleSubmit,
    		cancel,
    		member,
    		input_input_handler
    	];
    }

    class SciForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$e, create_fragment$e, safe_not_equal, { member: 15 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SciForm",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get member() {
    		throw new Error("<SciForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set member(value) {
    		throw new Error("<SciForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Sci.svelte generated by Svelte v3.45.0 */
    const file$d = "src/components/Sci.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (48:12) {:else }
    function create_else_block$c(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let tbody;
    	let each_value = /*$sciMembers*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Email";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Free days left";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Free days used";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Replace";
    			t9 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$d, 51, 24, 1760);
    			attr_dev(th1, "class", "uk-visible@m");
    			add_location(th1, file$d, 52, 24, 1798);
    			attr_dev(th2, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(th2, file$d, 53, 24, 1858);
    			attr_dev(th3, "class", "uk-visible@s uk-table-shrink uk-text-nowrap");
    			add_location(th3, file$d, 54, 24, 1945);
    			add_location(th4, file$d, 55, 24, 2045);
    			add_location(tr, file$d, 50, 20, 1731);
    			add_location(thead, file$d, 49, 20, 1703);
    			add_location(tbody, file$d, 58, 20, 2137);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$d, 48, 16, 1597);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(table, t9);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*openForm, $sciMembers, $settings*/ 88) {
    				each_value = /*$sciMembers*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(48:12) {:else }",
    		ctx
    	});

    	return block;
    }

    // (46:12) {#if $sciMembers.length === 0}
    function create_if_block$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading SCI members...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(46:12) {#if $sciMembers.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (60:20) {#each $sciMembers as member}
    function create_each_block$8(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*member*/ ctx[12].name + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*member*/ ctx[12].email + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*$settings*/ ctx[4].sci_days - /*member*/ ctx[12].sci_days_used + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*member*/ ctx[12].sci_days_used + "";
    	let t6;
    	let t7;
    	let td4;
    	let button;
    	let t9;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[8](/*member*/ ctx[12]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element("td");
    			button = element("button");
    			button.textContent = "Replace";
    			t9 = space();
    			add_location(td0, file$d, 61, 28, 2252);
    			attr_dev(td1, "class", "uk-visible@m");
    			add_location(td1, file$d, 62, 28, 2303);
    			add_location(td2, file$d, 63, 28, 2376);
    			attr_dev(td3, "class", "uk-visible@s");
    			add_location(td3, file$d, 64, 28, 2457);
    			attr_dev(button, "class", "uk-button uk-button-small uk-button-default");
    			add_location(button, file$d, 65, 56, 2566);
    			attr_dev(td4, "class", "uk-table-shrink");
    			add_location(td4, file$d, 65, 28, 2538);
    			add_location(tr, file$d, 60, 24, 2219);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, button);
    			append_dev(tr, t9);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$sciMembers*/ 8 && t0_value !== (t0_value = /*member*/ ctx[12].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$sciMembers*/ 8 && t2_value !== (t2_value = /*member*/ ctx[12].email + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*$settings, $sciMembers*/ 24 && t4_value !== (t4_value = /*$settings*/ ctx[4].sci_days - /*member*/ ctx[12].sci_days_used + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*$sciMembers*/ 8 && t6_value !== (t6_value = /*member*/ ctx[12].sci_days_used + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(60:20) {#each $sciMembers as member}",
    		ctx
    	});

    	return block;
    }

    // (87:16) {#key recreateForm}
    function create_key_block$3(ctx) {
    	let sciform;
    	let updating_member;
    	let current;

    	function sciform_member_binding(value) {
    		/*sciform_member_binding*/ ctx[9](value);
    	}

    	let sciform_props = {};

    	if (/*selectedMember*/ ctx[1] !== void 0) {
    		sciform_props.member = /*selectedMember*/ ctx[1];
    	}

    	sciform = new SciForm({ props: sciform_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(sciform, 'member', sciform_member_binding));
    	sciform.$on("message", /*processReplacement*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(sciform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(sciform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const sciform_changes = {};

    			if (!updating_member && dirty & /*selectedMember*/ 2) {
    				updating_member = true;
    				sciform_changes.member = /*selectedMember*/ ctx[1];
    				add_flush_callback(() => updating_member = false);
    			}

    			sciform.$set(sciform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sciform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sciform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(sciform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$3.name,
    		type: "key",
    		source: "(87:16) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div2;
    	let div1;
    	let h4;
    	let t0;
    	let t1_value = (/*$screenWidthS*/ ctx[2] ? '' : 'member') + "";
    	let t1;
    	let t2;
    	let t3;
    	let div0;
    	let t4;
    	let div6;
    	let div5;
    	let button;
    	let t5;
    	let div4;
    	let div3;
    	let previous_key = /*recreateForm*/ ctx[0];
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*$sciMembers*/ ctx[3].length === 0) return create_if_block$c;
    		return create_else_block$c;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);
    	let key_block = create_key_block$3(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t0 = text$1("SCI ");
    			t1 = text$1(t1_value);
    			t2 = text$1(" stats");
    			t3 = space();
    			div0 = element("div");
    			if_block.c();
    			t4 = space();
    			div6 = element("div");
    			div5 = element("div");
    			button = element("button");
    			t5 = space();
    			div4 = element("div");
    			div3 = element("div");
    			key_block.c();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-width-1-1");
    			add_location(h4, file$d, 43, 8, 1292);
    			attr_dev(div0, "class", "uk-margin-medium");
    			add_location(div0, file$d, 44, 8, 1447);
    			attr_dev(div1, "class", "uk-section uk-section-xsmall uk-margin-medium-top uk-margin-bottom uk-width-2-3@m uk-width-5-6");
    			add_location(div1, file$d, 42, 4, 1175);
    			attr_dev(div2, "class", "uk-flex uk-flex-center");
    			add_location(div2, file$d, 41, 0, 1134);
    			attr_dev(button, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button, "type", "button");
    			attr_dev(button, "uk-close", "");
    			add_location(button, file$d, 82, 8, 3107);
    			attr_dev(div3, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div3, "uk-height-viewport", "");
    			add_location(div3, file$d, 84, 12, 3248);
    			attr_dev(div4, "class", "uk-flex uk-flex-center");
    			add_location(div4, file$d, 83, 8, 3199);
    			attr_dev(div5, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div5, file$d, 81, 4, 3037);
    			attr_dev(div6, "id", "modal-form");
    			attr_dev(div6, "class", "uk-modal-full");
    			attr_dev(div6, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div6, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[5]);
    			add_location(div6, file$d, 77, 0, 2886);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t0);
    			append_dev(h4, t1);
    			append_dev(h4, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			if_block.m(div0, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, button);
    			append_dev(div5, t5);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			key_block.m(div3, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$screenWidthS*/ 4) && t1_value !== (t1_value = (/*$screenWidthS*/ ctx[2] ? '' : 'member') + "")) set_data_dev(t1, t1_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}

    			if (dirty & /*recreateForm*/ 1 && safe_not_equal(previous_key, previous_key = /*recreateForm*/ ctx[0])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block$3(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div3, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (dirty & /*$screenWidthM*/ 32) {
    				toggle_class(div6, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block.d();
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div6);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $screenWidthS;
    	let $sciMembers;
    	let $settings;
    	let $screenWidthM;
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(2, $screenWidthS = $$value));
    	validate_store(sciMembers, 'sciMembers');
    	component_subscribe($$self, sciMembers, $$value => $$invalidate(3, $sciMembers = $$value));
    	validate_store(settings, 'settings');
    	component_subscribe($$self, settings, $$value => $$invalidate(4, $settings = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(5, $screenWidthM = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Sci', slots, []);
    	let recreateForm = false;
    	let selectedMember;
    	const dispatch = createEventDispatcher();

    	function dispatchReload() {
    		dispatch('message', { reload: 'sci' });
    	}

    	function openForm(member) {
    		$$invalidate(1, selectedMember = member);
    		$$invalidate(0, recreateForm = !recreateForm);
    		uikit.modal("#modal-form").show();
    	}

    	async function processReplacement(event) {
    		if (event.detail.goto !== undefined) {

    			switch (event.detail.goto) {
    				case 'save':
    					uikit.modal("#modal-form").hide();
    					dispatchReload();
    					break;
    				case 'cancel':
    					uikit.modal("#modal-form").hide();
    					break;
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sci> was created with unknown prop '${key}'`);
    	});

    	const click_handler = member => openForm(member);

    	function sciform_member_binding(value) {
    		selectedMember = value;
    		$$invalidate(1, selectedMember);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		sciMembers,
    		UIkit: uikit,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		settings,
    		SciForm,
    		recreateForm,
    		selectedMember,
    		dispatch,
    		dispatchReload,
    		openForm,
    		processReplacement,
    		$screenWidthS,
    		$sciMembers,
    		$settings,
    		$screenWidthM
    	});

    	$$self.$inject_state = $$props => {
    		if ('recreateForm' in $$props) $$invalidate(0, recreateForm = $$props.recreateForm);
    		if ('selectedMember' in $$props) $$invalidate(1, selectedMember = $$props.selectedMember);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		recreateForm,
    		selectedMember,
    		$screenWidthS,
    		$sciMembers,
    		$settings,
    		$screenWidthM,
    		openForm,
    		processReplacement,
    		click_handler,
    		sciform_member_binding
    	];
    }

    class Sci extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Sci",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    async function getAccounting(year) {
        try {
            const result = await api.get('/accounting/'+year);
            return result.data
        } catch (error) {}
    }

    async function bookingsCSV(start, end) {
        try {
            return await api.post('/data/bookings/', {start_date: start, end_date: end}, {responseType: 'blob'})
                .then(response => {
                    let url = window.URL.createObjectURL(response.data);
                    let a = document.createElement('a');
                    a.href = url;
                    a.download = 'PAF bookings ' + start + ' - ' + end;
                    a.click();
                    a.remove();
                    setTimeout(() => window.URL.revokeObjectURL(url), 100);
                })
        } catch (error) {}
    }

    async function invoicesCSV(start, end) {
        try {
            return await api.post('/data/invoices/', {start_date: start, end_date: end}, {responseType: 'blob'})
                .then(response => {
                    let url = window.URL.createObjectURL(response.data);
                    let a = document.createElement('a');
                    a.href = url;
                    a.download = 'PAF invoices ' + start + ' - ' + end;
                    a.click();
                    a.remove();
                    setTimeout(() => window.URL.revokeObjectURL(url), 100);
                })
        } catch (error) {}
    }

    async function getStats(start, end) {
        try {
            const result = await api.post('/bookings/stats', {start_date: start, end_date: end});
            return result.data
        } catch (error) {}
    }

    async function getDayStats(date) {
        try {
            const result = await api.post('/bookings/stats', {date: date});
            return result.data
        } catch (error) {}
    }

    /* src/components/Accounting.svelte generated by Svelte v3.45.0 */
    const file$c = "src/components/Accounting.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (35:16) {:else}
    function create_else_block_3$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "icon: chevron-double-left; ratio: 2");
    			attr_dev(span, "class", "uk-text-muted");
    			add_location(span, file$c, 35, 20, 1234);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$2.name,
    		type: "else",
    		source: "(35:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (33:16) {#if year > minYear}
    function create_if_block_3$6(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "icon: chevron-double-left; ratio: 2");
    			add_location(a, file$c, 33, 20, 1086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(33:16) {#if year > minYear}",
    		ctx
    	});

    	return block;
    }

    // (41:16) {:else}
    function create_else_block_2$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "icon: chevron-double-right; ratio: 2");
    			attr_dev(span, "class", "uk-text-muted");
    			add_location(span, file$c, 41, 20, 1613);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$3.name,
    		type: "else",
    		source: "(41:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (39:16) {#if year < DateTime.now().year}
    function create_if_block_2$6(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "icon: chevron-double-right; ratio: 2");
    			add_location(a, file$c, 39, 20, 1464);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_1*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(39:16) {#if year < DateTime.now().year}",
    		ctx
    	});

    	return block;
    }

    // (48:12) {:else}
    function create_else_block$b(ctx) {
    	let each_1_anchor;
    	let each_value = /*stats*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*stats, DateTime*/ 2) {
    				each_value = /*stats*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(48:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (46:12) {#if stats.length === 0}
    function create_if_block$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading Accounting stats...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(46:12) {#if stats.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (56:24) {:else}
    function create_else_block_1$4(ctx) {
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let th5;
    	let t11;
    	let tbody;
    	let t12;
    	let tr1;
    	let td0;
    	let t13;
    	let td1;
    	let t14;
    	let td2;
    	let t15;
    	let td3;
    	let t17;
    	let td4;
    	let t18_value = /*month*/ ctx[9].total_baguette + "";
    	let t18;
    	let t19;
    	let td5;
    	let t20_value = /*month*/ ctx[9].total_squid + "";
    	let t20;
    	let each_value_1 = /*month*/ ctx[9].payments;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Paid";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Name";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Stay";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Invoice";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Baguette";
    			t9 = space();
    			th5 = element("th");
    			th5.textContent = "Squid";
    			t11 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t12 = space();
    			tr1 = element("tr");
    			td0 = element("td");
    			t13 = space();
    			td1 = element("td");
    			t14 = space();
    			td2 = element("td");
    			t15 = space();
    			td3 = element("td");
    			td3.textContent = "TOTAL";
    			t17 = space();
    			td4 = element("td");
    			t18 = text$1(t18_value);
    			t19 = space();
    			td5 = element("td");
    			t20 = text$1(t20_value);
    			add_location(th0, file$c, 59, 36, 2616);
    			add_location(th1, file$c, 60, 36, 2666);
    			add_location(th2, file$c, 61, 36, 2716);
    			add_location(th3, file$c, 62, 36, 2766);
    			add_location(th4, file$c, 63, 36, 2819);
    			add_location(th5, file$c, 64, 36, 2873);
    			add_location(tr0, file$c, 58, 32, 2575);
    			add_location(thead, file$c, 57, 32, 2535);
    			add_location(td0, file$c, 79, 36, 4161);
    			add_location(td1, file$c, 80, 36, 4207);
    			add_location(td2, file$c, 81, 36, 4253);
    			attr_dev(td3, "class", "uk-text-bold");
    			add_location(td3, file$c, 82, 36, 4299);
    			add_location(td4, file$c, 83, 36, 4371);
    			add_location(td5, file$c, 84, 36, 4439);
    			set_style(tr1, "border-top", "2px solid rgb(204, 204, 204)");
    			set_style(tr1, "border-bottom", "4px double");
    			add_location(tr1, file$c, 78, 32, 4043);
    			add_location(tbody, file$c, 67, 32, 2999);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$c, 56, 28, 2417);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t1);
    			append_dev(tr0, th1);
    			append_dev(tr0, t3);
    			append_dev(tr0, th2);
    			append_dev(tr0, t5);
    			append_dev(tr0, th3);
    			append_dev(tr0, t7);
    			append_dev(tr0, th4);
    			append_dev(tr0, t9);
    			append_dev(tr0, th5);
    			append_dev(table, t11);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t12);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t13);
    			append_dev(tr1, td1);
    			append_dev(tr1, t14);
    			append_dev(tr1, td2);
    			append_dev(tr1, t15);
    			append_dev(tr1, td3);
    			append_dev(tr1, t17);
    			append_dev(tr1, td4);
    			append_dev(td4, t18);
    			append_dev(tr1, t19);
    			append_dev(tr1, td5);
    			append_dev(td5, t20);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*stats, DateTime*/ 2) {
    				each_value_1 = /*month*/ ctx[9].payments;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, t12);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			if (dirty & /*stats*/ 2 && t18_value !== (t18_value = /*month*/ ctx[9].total_baguette + "")) set_data_dev(t18, t18_value);
    			if (dirty & /*stats*/ 2 && t20_value !== (t20_value = /*month*/ ctx[9].total_squid + "")) set_data_dev(t20, t20_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(56:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (54:24) {#if month.payments.length === 0}
    function create_if_block_1$6(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Nothing...";
    			attr_dev(span, "class", "uk-text-italic uk-text-muted");
    			add_location(span, file$c, 54, 28, 2296);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(54:24) {#if month.payments.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (69:32) {#each month.payments as payment}
    function create_each_block_1$2(ctx) {
    	let tr;
    	let td0;
    	let t0_value = DateTime_1.fromSQL(/*payment*/ ctx[12].date_paid).toFormat('d.L.') + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*payment*/ ctx[12].name + "";
    	let t2;
    	let t3;
    	let td2;

    	let t4_value = (/*payment*/ ctx[12].arrival !== null
    	? DateTime_1.fromSQL(/*payment*/ ctx[12].arrival).toFormat('d.L.')
    	: '') + "";

    	let t4;
    	let t5;

    	let t6_value = (/*payment*/ ctx[12].departure != null
    	? DateTime_1.fromSQL(/*payment*/ ctx[12].departure).toFormat('d.L.')
    	: '') + "";

    	let t6;
    	let t7;
    	let td3;

    	let t8_value = (/*payment*/ ctx[12].invoice !== null
    	? /*payment*/ ctx[12].invoice
    	: '') + "";

    	let t8;
    	let t9;
    	let td4;

    	let t10_value = (/*payment*/ ctx[12].baguette !== null
    	? /*payment*/ ctx[12].baguette
    	: '') + "";

    	let t10;
    	let t11;
    	let td5;

    	let t12_value = (/*payment*/ ctx[12].squid !== null
    	? /*payment*/ ctx[12].squid
    	: '') + "";

    	let t12;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = text$1("-");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td3 = element("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td4 = element("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			td5 = element("td");
    			t12 = text$1(t12_value);
    			attr_dev(td0, "class", "uk-table-shrink");
    			add_location(td0, file$c, 70, 40, 3154);
    			attr_dev(td1, "class", "");
    			add_location(td1, file$c, 71, 40, 3282);
    			attr_dev(td2, "class", "uk-table-shrink");
    			add_location(td2, file$c, 72, 40, 3355);
    			attr_dev(td3, "class", "uk-table-shrink");
    			add_location(td3, file$c, 73, 40, 3602);
    			attr_dev(td4, "class", "uk-table-shrink");
    			add_location(td4, file$c, 74, 40, 3725);
    			attr_dev(td5, "class", "uk-table-shrink");
    			add_location(td5, file$c, 75, 40, 3850);
    			add_location(tr, file$c, 69, 36, 3109);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(td2, t5);
    			append_dev(td2, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td3);
    			append_dev(td3, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td4);
    			append_dev(td4, t10);
    			append_dev(tr, t11);
    			append_dev(tr, td5);
    			append_dev(td5, t12);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*stats*/ 2 && t0_value !== (t0_value = DateTime_1.fromSQL(/*payment*/ ctx[12].date_paid).toFormat('d.L.') + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*stats*/ 2 && t2_value !== (t2_value = /*payment*/ ctx[12].name + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*stats*/ 2 && t4_value !== (t4_value = (/*payment*/ ctx[12].arrival !== null
    			? DateTime_1.fromSQL(/*payment*/ ctx[12].arrival).toFormat('d.L.')
    			: '') + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*stats*/ 2 && t6_value !== (t6_value = (/*payment*/ ctx[12].departure != null
    			? DateTime_1.fromSQL(/*payment*/ ctx[12].departure).toFormat('d.L.')
    			: '') + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*stats*/ 2 && t8_value !== (t8_value = (/*payment*/ ctx[12].invoice !== null
    			? /*payment*/ ctx[12].invoice
    			: '') + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*stats*/ 2 && t10_value !== (t10_value = (/*payment*/ ctx[12].baguette !== null
    			? /*payment*/ ctx[12].baguette
    			: '') + "")) set_data_dev(t10, t10_value);

    			if (dirty & /*stats*/ 2 && t12_value !== (t12_value = (/*payment*/ ctx[12].squid !== null
    			? /*payment*/ ctx[12].squid
    			: '') + "")) set_data_dev(t12, t12_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(69:32) {#each month.payments as payment}",
    		ctx
    	});

    	return block;
    }

    // (49:16) {#each stats as month}
    function create_each_block$7(ctx) {
    	let div;
    	let h3;
    	let span;
    	let t0_value = /*month*/ ctx[9].month + "";
    	let t0;
    	let t1;
    	let t2;

    	function select_block_type_3(ctx, dirty) {
    		if (/*month*/ ctx[9].payments.length === 0) return create_if_block_1$6;
    		return create_else_block_1$4;
    	}

    	let current_block_type = select_block_type_3(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			span = element("span");
    			t0 = text$1(t0_value);
    			t1 = space();
    			if_block.c();
    			t2 = space();
    			add_location(span, file$c, 51, 28, 2153);
    			attr_dev(h3, "class", "uk-heading-line uk-text-center uk-text-light");
    			toggle_class(h3, "uk-text-muted", /*month*/ ctx[9].payments.length === 0);
    			add_location(h3, file$c, 50, 24, 2017);
    			attr_dev(div, "class", "uk-margin-medium uk-margin-large-top");
    			add_location(div, file$c, 49, 20, 1942);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(h3, span);
    			append_dev(span, t0);
    			append_dev(div, t1);
    			if_block.m(div, null);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*stats*/ 2 && t0_value !== (t0_value = /*month*/ ctx[9].month + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*stats*/ 2) {
    				toggle_class(h3, "uk-text-muted", /*month*/ ctx[9].payments.length === 0);
    			}

    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t2);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(49:16) {#each stats as month}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div2;
    	let div1;
    	let h4;

    	let t0_value = (/*$screenWidthS*/ ctx[2]
    	? ''
    	: /*$screenWidthM*/ ctx[3]
    		? 'Accounting'
    		: 'Monthly accounting') + "";

    	let t0;
    	let t1;
    	let span1;
    	let t2;
    	let span0;
    	let t3;
    	let t4;
    	let show_if;
    	let t5;
    	let div0;

    	function select_block_type(ctx, dirty) {
    		if (/*year*/ ctx[0] > minYear$1) return create_if_block_3$6;
    		return create_else_block_3$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (dirty & /*year*/ 1) show_if = null;
    		if (show_if == null) show_if = !!(/*year*/ ctx[0] < DateTime_1.now().year);
    		if (show_if) return create_if_block_2$6;
    		return create_else_block_2$3;
    	}

    	let current_block_type_1 = select_block_type_1(ctx, -1);
    	let if_block1 = current_block_type_1(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*stats*/ ctx[1].length === 0) return create_if_block$b;
    		return create_else_block$b;
    	}

    	let current_block_type_2 = select_block_type_2(ctx);
    	let if_block2 = current_block_type_2(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span1 = element("span");
    			if_block0.c();
    			t2 = space();
    			span0 = element("span");
    			t3 = text$1(/*year*/ ctx[0]);
    			t4 = space();
    			if_block1.c();
    			t5 = space();
    			div0 = element("div");
    			if_block2.c();
    			attr_dev(span0, "class", "uk-text-bold");
    			add_location(span0, file$c, 37, 16, 1354);
    			attr_dev(span1, "class", "uk-position-right");
    			add_location(span1, file$c, 31, 12, 996);
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-inline uk-width-1-1");
    			add_location(h4, file$c, 30, 8, 797);
    			attr_dev(div0, "class", "uk-margin-medium");
    			add_location(div0, file$c, 44, 8, 1751);
    			attr_dev(div1, "class", "uk-section uk-section-xsmall uk-margin-medium-top uk-margin-bottom uk-width-2-3@m uk-width-5-6");
    			add_location(div1, file$c, 29, 4, 680);
    			attr_dev(div2, "class", "uk-flex uk-flex-center");
    			add_location(div2, file$c, 28, 0, 639);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t0);
    			append_dev(h4, t1);
    			append_dev(h4, span1);
    			if_block0.m(span1, null);
    			append_dev(span1, t2);
    			append_dev(span1, span0);
    			append_dev(span0, t3);
    			append_dev(span1, t4);
    			if_block1.m(span1, null);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			if_block2.m(div0, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$screenWidthS, $screenWidthM*/ 12 && t0_value !== (t0_value = (/*$screenWidthS*/ ctx[2]
    			? ''
    			: /*$screenWidthM*/ ctx[3]
    				? 'Accounting'
    				: 'Monthly accounting') + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span1, t2);
    				}
    			}

    			if (dirty & /*year*/ 1) set_data_dev(t3, /*year*/ ctx[0]);

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx, dirty)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(span1, null);
    				}
    			}

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_2(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block0.d();
    			if_block1.d();
    			if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const minYear$1 = 2022;

    function instance$c($$self, $$props, $$invalidate) {
    	let $screenWidthS;
    	let $screenWidthM;
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(2, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(3, $screenWidthM = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Accounting', slots, []);
    	let year = DateTime_1.now().year;
    	let stats = [];
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		$$invalidate(1, stats = await getAccounting(year));
    	});

    	async function changeYear(getYear) {
    		$$invalidate(1, stats = await getAccounting(getYear));
    	}

    	function dispatchReload() {
    		dispatch('message', { reload: 'accounting' });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Accounting> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => changeYear($$invalidate(0, --year));
    	const click_handler_1 = () => changeYear($$invalidate(0, ++year));

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		getAccounting,
    		DateTime: DateTime_1,
    		screenWidthM,
    		screenWidthS,
    		year,
    		minYear: minYear$1,
    		stats,
    		dispatch,
    		changeYear,
    		dispatchReload,
    		$screenWidthS,
    		$screenWidthM
    	});

    	$$self.$inject_state = $$props => {
    		if ('year' in $$props) $$invalidate(0, year = $$props.year);
    		if ('stats' in $$props) $$invalidate(1, stats = $$props.stats);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		year,
    		stats,
    		$screenWidthS,
    		$screenWidthM,
    		changeYear,
    		click_handler,
    		click_handler_1
    	];
    }

    class Accounting extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$c, create_fragment$c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Accounting",
    			options,
    			id: create_fragment$c.name
    		});
    	}
    }

    /* src/components/Reservations.svelte generated by Svelte v3.45.0 */
    const file$b = "src/components/Reservations.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (37:16) {:else}
    function create_else_block_2$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "icon: chevron-double-left; ratio: 2");
    			attr_dev(span, "class", "uk-text-muted");
    			add_location(span, file$b, 37, 20, 1403);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(37:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (35:16) {#if year > minYear}
    function create_if_block_3$5(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "icon: chevron-double-left; ratio: 2");
    			add_location(a, file$b, 35, 20, 1255);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(35:16) {#if year > minYear}",
    		ctx
    	});

    	return block;
    }

    // (43:16) {:else}
    function create_else_block_1$3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "icon: chevron-double-right; ratio: 2");
    			attr_dev(span, "class", "uk-text-muted");
    			add_location(span, file$b, 43, 20, 1783);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(43:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:16) {#if year <= DateTime.now().year}
    function create_if_block_2$5(ctx) {
    	let a;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			attr_dev(a, "href", '#');
    			attr_dev(a, "uk-icon", "icon: chevron-double-right; ratio: 2");
    			add_location(a, file$b, 41, 20, 1634);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*click_handler_1*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(41:16) {#if year <= DateTime.now().year}",
    		ctx
    	});

    	return block;
    }

    // (53:16) {:else }
    function create_else_block$a(ctx) {
    	let a;
    	let span;
    	let t;
    	let each_1_anchor;
    	let mounted;
    	let dispose;
    	let each_value = /*reservations*/ ctx[1].data;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			span = element("span");
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    			attr_dev(span, "class", "uk-position-top-right");
    			attr_dev(span, "uk-icon", "icon: copy");
    			attr_dev(span, "uk-tooltip", "Copy list");
    			add_location(span, file$b, 53, 56, 2262);
    			attr_dev(a, "href", '#');
    			add_location(a, file$b, 53, 20, 2226);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, span);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*copyList*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reservations*/ 2) {
    				each_value = /*reservations*/ ctx[1].data;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(53:16) {:else }",
    		ctx
    	});

    	return block;
    }

    // (51:16) {#if reservations.data.length === 0}
    function create_if_block_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("No reservations yet");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(51:16) {#if reservations.data.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (48:12) {#if reservations.data === undefined}
    function create_if_block$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading reservations...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(48:12) {#if reservations.data === undefined}",
    		ctx
    	});

    	return block;
    }

    // (55:20) {#each reservations.data as reservation}
    function create_each_block$6(ctx) {
    	let t_value = /*reservation*/ ctx[7] + "";
    	let t;
    	let br;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    			br = element("br");
    			add_location(br, file$b, 55, 37, 2452);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reservations*/ 2 && t_value !== (t_value = /*reservation*/ ctx[7] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(55:20) {#each reservations.data as reservation}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div2;
    	let div1;
    	let h4;
    	let t0_value = (/*$screenWidthS*/ ctx[2] ? 'List' : 'Reservations') + "";
    	let t0;
    	let t1;
    	let span1;
    	let t2;
    	let span0;
    	let t3;
    	let t4;
    	let show_if;
    	let t5;
    	let div0;

    	function select_block_type(ctx, dirty) {
    		if (/*year*/ ctx[0] > minYear) return create_if_block_3$5;
    		return create_else_block_2$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (dirty & /*year*/ 1) show_if = null;
    		if (show_if == null) show_if = !!(/*year*/ ctx[0] <= DateTime_1.now().year);
    		if (show_if) return create_if_block_2$5;
    		return create_else_block_1$3;
    	}

    	let current_block_type_1 = select_block_type_1(ctx, -1);
    	let if_block1 = current_block_type_1(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*reservations*/ ctx[1].data === undefined) return create_if_block$a;
    		if (/*reservations*/ ctx[1].data.length === 0) return create_if_block_1$5;
    		return create_else_block$a;
    	}

    	let current_block_type_2 = select_block_type_2(ctx);
    	let if_block2 = current_block_type_2(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span1 = element("span");
    			if_block0.c();
    			t2 = space();
    			span0 = element("span");
    			t3 = text$1(/*year*/ ctx[0]);
    			t4 = space();
    			if_block1.c();
    			t5 = space();
    			div0 = element("div");
    			if_block2.c();
    			attr_dev(span0, "class", "uk-text-bold");
    			add_location(span0, file$b, 39, 16, 1523);
    			attr_dev(span1, "class", "uk-position-right");
    			add_location(span1, file$b, 33, 12, 1165);
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-inline uk-width-1-1");
    			add_location(h4, file$b, 32, 8, 1001);
    			attr_dev(div0, "class", "uk-margin-medium uk-inline uk-width-expand");
    			add_location(div0, file$b, 46, 8, 1921);
    			attr_dev(div1, "class", "uk-section uk-section-xsmall uk-margin-medium-top uk-margin-bottom uk-width-2-3@m uk-width-5-6");
    			add_location(div1, file$b, 31, 4, 884);
    			attr_dev(div2, "class", "uk-flex uk-flex-center");
    			add_location(div2, file$b, 30, 0, 843);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t0);
    			append_dev(h4, t1);
    			append_dev(h4, span1);
    			if_block0.m(span1, null);
    			append_dev(span1, t2);
    			append_dev(span1, span0);
    			append_dev(span0, t3);
    			append_dev(span1, t4);
    			if_block1.m(span1, null);
    			append_dev(div1, t5);
    			append_dev(div1, div0);
    			if_block2.m(div0, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$screenWidthS*/ 4 && t0_value !== (t0_value = (/*$screenWidthS*/ ctx[2] ? 'List' : 'Reservations') + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span1, t2);
    				}
    			}

    			if (dirty & /*year*/ 1) set_data_dev(t3, /*year*/ ctx[0]);

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx, dirty)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(span1, null);
    				}
    			}

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_2(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div0, null);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block0.d();
    			if_block1.d();
    			if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const minYear = 2022;

    function instance$b($$self, $$props, $$invalidate) {
    	let $screenWidthS;
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(2, $screenWidthS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Reservations', slots, []);
    	let year = DateTime_1.now().year;
    	let reservations = {};

    	onMount(async () => {
    		$$invalidate(1, reservations = await getReservationList(year));
    	});

    	async function changeYear(getYear) {
    		$$invalidate(1, reservations = await getReservationList(getYear));
    	}

    	async function copyList() {
    		if (reservations.data) {
    			await navigator.clipboard.writeText(reservations.data.join('\n'));
    			uikit.notification('<span uk-icon="icon: check"></span> List copied!', { status: 'success', pos: 'bottom-center' });
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Reservations> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => changeYear($$invalidate(0, --year));
    	const click_handler_1 = () => changeYear($$invalidate(0, ++year));

    	$$self.$capture_state = () => ({
    		onMount,
    		getReservationList,
    		DateTime: DateTime_1,
    		screenWidthS,
    		UIkit: uikit,
    		year,
    		minYear,
    		reservations,
    		changeYear,
    		copyList,
    		$screenWidthS
    	});

    	$$self.$inject_state = $$props => {
    		if ('year' in $$props) $$invalidate(0, year = $$props.year);
    		if ('reservations' in $$props) $$invalidate(1, reservations = $$props.reservations);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		year,
    		reservations,
    		$screenWidthS,
    		changeYear,
    		copyList,
    		click_handler,
    		click_handler_1
    	];
    }

    class Reservations extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Reservations",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    function ascending$3(a, b) {
      return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function descending$2(a, b) {
      return a == null || b == null ? NaN
        : b < a ? -1
        : b > a ? 1
        : b >= a ? 0
        : NaN;
    }

    function bisector(f) {
      let compare1, compare2, delta;

      // If an accessor is specified, promote it to a comparator. In this case we
      // can test whether the search value is (self-) comparable. We cant do this
      // for a comparator (except for specific, known comparators) because we cant
      // tell if the comparator is symmetric, and an asymmetric comparator cant be
      // used to test whether a single value is comparable.
      if (f.length !== 2) {
        compare1 = ascending$3;
        compare2 = (d, x) => ascending$3(f(d), x);
        delta = (d, x) => f(d) - x;
      } else {
        compare1 = f === ascending$3 || f === descending$2 ? f : zero$1;
        compare2 = f;
        delta = f;
      }

      function left(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) < 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function right(a, x, lo = 0, hi = a.length) {
        if (lo < hi) {
          if (compare1(x, x) !== 0) return hi;
          do {
            const mid = (lo + hi) >>> 1;
            if (compare2(a[mid], x) <= 0) lo = mid + 1;
            else hi = mid;
          } while (lo < hi);
        }
        return lo;
      }

      function center(a, x, lo = 0, hi = a.length) {
        const i = left(a, x, lo, hi - 1);
        return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
      }

      return {left, center, right};
    }

    function zero$1() {
      return 0;
    }

    function number$3(x) {
      return x === null ? NaN : +x;
    }

    function* numbers(values, valueof) {
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            yield value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            yield value;
          }
        }
      }
    }

    const ascendingBisect = bisector(ascending$3);
    const bisectRight = ascendingBisect.right;
    const bisectLeft = ascendingBisect.left;
    const bisectCenter = bisector(number$3).center;
    var bisect = bisectRight;

    function count$1(values, valueof) {
      let count = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count;
          }
        }
      }
      return count;
    }

    function length$3(array) {
      return array.length | 0;
    }

    function empty$2(length) {
      return !(length > 0);
    }

    function arrayify(values) {
      return typeof values !== "object" || "length" in values ? values : Array.from(values);
    }

    function reducer(reduce) {
      return values => reduce(...values);
    }

    function cross$2(...values) {
      const reduce = typeof values[values.length - 1] === "function" && reducer(values.pop());
      values = values.map(arrayify);
      const lengths = values.map(length$3);
      const j = values.length - 1;
      const index = new Array(j + 1).fill(0);
      const product = [];
      if (j < 0 || lengths.some(empty$2)) return product;
      while (true) {
        product.push(index.map((j, i) => values[i][j]));
        let i = j;
        while (++index[i] === lengths[i]) {
          if (i === 0) return reduce ? product.map(reduce) : product;
          index[i--] = 0;
        }
      }
    }

    function cumsum(values, valueof) {
      var sum = 0, index = 0;
      return Float64Array.from(values, valueof === undefined
        ? v => (sum += +v || 0)
        : v => (sum += +valueof(v, index++, values) || 0));
    }

    function variance(values, valueof) {
      let count = 0;
      let delta;
      let mean = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            delta = value - mean;
            mean += delta / ++count;
            sum += delta * (value - mean);
          }
        }
      }
      if (count > 1) return sum / (count - 1);
    }

    function deviation(values, valueof) {
      const v = variance(values, valueof);
      return v ? Math.sqrt(v) : v;
    }

    function extent$1(values, valueof) {
      let min;
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null) {
            if (min === undefined) {
              if (value >= value) min = max = value;
            } else {
              if (min > value) min = value;
              if (max < value) max = value;
            }
          }
        }
      }
      return [min, max];
    }

    // https://github.com/python/cpython/blob/a74eea238f5baba15797e2e8b570d153bc8690a7/Modules/mathmodule.c#L1423
    class Adder {
      constructor() {
        this._partials = new Float64Array(32);
        this._n = 0;
      }
      add(x) {
        const p = this._partials;
        let i = 0;
        for (let j = 0; j < this._n && j < 32; j++) {
          const y = p[j],
            hi = x + y,
            lo = Math.abs(x) < Math.abs(y) ? x - (hi - y) : y - (hi - x);
          if (lo) p[i++] = lo;
          x = hi;
        }
        p[i] = x;
        this._n = i + 1;
        return this;
      }
      valueOf() {
        const p = this._partials;
        let n = this._n, x, y, lo, hi = 0;
        if (n > 0) {
          hi = p[--n];
          while (n > 0) {
            x = hi;
            y = p[--n];
            hi = x + y;
            lo = y - (hi - x);
            if (lo) break;
          }
          if (n > 0 && ((lo < 0 && p[n - 1] < 0) || (lo > 0 && p[n - 1] > 0))) {
            y = lo * 2;
            x = hi + y;
            if (y == x - hi) hi = x;
          }
        }
        return hi;
      }
    }

    function fsum(values, valueof) {
      const adder = new Adder();
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            adder.add(value);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            adder.add(value);
          }
        }
      }
      return +adder;
    }

    function fcumsum(values, valueof) {
      const adder = new Adder();
      let index = -1;
      return Float64Array.from(values, valueof === undefined
          ? v => adder.add(+v || 0)
          : v => adder.add(+valueof(v, ++index, values) || 0)
      );
    }

    class InternMap extends Map {
      constructor(entries, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (entries != null) for (const [key, value] of entries) this.set(key, value);
      }
      get(key) {
        return super.get(intern_get(this, key));
      }
      has(key) {
        return super.has(intern_get(this, key));
      }
      set(key, value) {
        return super.set(intern_set(this, key), value);
      }
      delete(key) {
        return super.delete(intern_delete(this, key));
      }
    }

    class InternSet extends Set {
      constructor(values, key = keyof) {
        super();
        Object.defineProperties(this, {_intern: {value: new Map()}, _key: {value: key}});
        if (values != null) for (const value of values) this.add(value);
      }
      has(value) {
        return super.has(intern_get(this, value));
      }
      add(value) {
        return super.add(intern_set(this, value));
      }
      delete(value) {
        return super.delete(intern_delete(this, value));
      }
    }

    function intern_get({_intern, _key}, value) {
      const key = _key(value);
      return _intern.has(key) ? _intern.get(key) : value;
    }

    function intern_set({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) return _intern.get(key);
      _intern.set(key, value);
      return value;
    }

    function intern_delete({_intern, _key}, value) {
      const key = _key(value);
      if (_intern.has(key)) {
        value = _intern.get(key);
        _intern.delete(key);
      }
      return value;
    }

    function keyof(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function identity$9(x) {
      return x;
    }

    function group(values, ...keys) {
      return nest(values, identity$9, identity$9, keys);
    }

    function groups(values, ...keys) {
      return nest(values, Array.from, identity$9, keys);
    }

    function flatten$1(groups, keys) {
      for (let i = 1, n = keys.length; i < n; ++i) {
        groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));
      }
      return groups;
    }

    function flatGroup(values, ...keys) {
      return flatten$1(groups(values, ...keys), keys);
    }

    function flatRollup(values, reduce, ...keys) {
      return flatten$1(rollups(values, reduce, ...keys), keys);
    }

    function rollup(values, reduce, ...keys) {
      return nest(values, identity$9, reduce, keys);
    }

    function rollups(values, reduce, ...keys) {
      return nest(values, Array.from, reduce, keys);
    }

    function index$4(values, ...keys) {
      return nest(values, identity$9, unique, keys);
    }

    function indexes(values, ...keys) {
      return nest(values, Array.from, unique, keys);
    }

    function unique(values) {
      if (values.length !== 1) throw new Error("duplicate key");
      return values[0];
    }

    function nest(values, map, reduce, keys) {
      return (function regroup(values, i) {
        if (i >= keys.length) return reduce(values);
        const groups = new InternMap();
        const keyof = keys[i++];
        let index = -1;
        for (const value of values) {
          const key = keyof(value, ++index, values);
          const group = groups.get(key);
          if (group) group.push(value);
          else groups.set(key, [value]);
        }
        for (const [key, values] of groups) {
          groups.set(key, regroup(values, i));
        }
        return map(groups);
      })(values, 0);
    }

    function permute(source, keys) {
      return Array.from(keys, key => source[key]);
    }

    function sort(values, ...F) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      values = Array.from(values);
      let [f] = F;
      if ((f && f.length !== 2) || F.length > 1) {
        const index = Uint32Array.from(values, (d, i) => i);
        if (F.length > 1) {
          F = F.map(f => values.map(f));
          index.sort((i, j) => {
            for (const f of F) {
              const c = ascendingDefined(f[i], f[j]);
              if (c) return c;
            }
          });
        } else {
          f = values.map(f);
          index.sort((i, j) => ascendingDefined(f[i], f[j]));
        }
        return permute(values, index);
      }
      return values.sort(compareDefined(f));
    }

    function compareDefined(compare = ascending$3) {
      if (compare === ascending$3) return ascendingDefined;
      if (typeof compare !== "function") throw new TypeError("compare is not a function");
      return (a, b) => {
        const x = compare(a, b);
        if (x || x === 0) return x;
        return (compare(b, b) === 0) - (compare(a, a) === 0);
      };
    }

    function ascendingDefined(a, b) {
      return (a == null || !(a >= a)) - (b == null || !(b >= b)) || (a < b ? -1 : a > b ? 1 : 0);
    }

    function groupSort(values, reduce, key) {
      return (reduce.length !== 2
        ? sort(rollup(values, reduce, key), (([ak, av], [bk, bv]) => ascending$3(av, bv) || ascending$3(ak, bk)))
        : sort(group(values, key), (([ak, av], [bk, bv]) => reduce(av, bv) || ascending$3(ak, bk))))
        .map(([key]) => key);
    }

    var array$5 = Array.prototype;

    var slice$3 = array$5.slice;

    function constant$b(x) {
      return () => x;
    }

    var e10 = Math.sqrt(50),
        e5 = Math.sqrt(10),
        e2 = Math.sqrt(2);

    function ticks(start, stop, count) {
      var reverse,
          i = -1,
          n,
          ticks,
          step;

      stop = +stop, start = +start, count = +count;
      if (start === stop && count > 0) return [start];
      if (reverse = stop < start) n = start, start = stop, stop = n;
      if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

      if (step > 0) {
        let r0 = Math.round(start / step), r1 = Math.round(stop / step);
        if (r0 * step < start) ++r0;
        if (r1 * step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) * step;
      } else {
        step = -step;
        let r0 = Math.round(start * step), r1 = Math.round(stop * step);
        if (r0 / step < start) ++r0;
        if (r1 / step > stop) --r1;
        ticks = new Array(n = r1 - r0 + 1);
        while (++i < n) ticks[i] = (r0 + i) / step;
      }

      if (reverse) ticks.reverse();

      return ticks;
    }

    function tickIncrement(start, stop, count) {
      var step = (stop - start) / Math.max(0, count),
          power = Math.floor(Math.log(step) / Math.LN10),
          error = step / Math.pow(10, power);
      return power >= 0
          ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power)
          : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
    }

    function tickStep(start, stop, count) {
      var step0 = Math.abs(stop - start) / Math.max(0, count),
          step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
          error = step0 / step1;
      if (error >= e10) step1 *= 10;
      else if (error >= e5) step1 *= 5;
      else if (error >= e2) step1 *= 2;
      return stop < start ? -step1 : step1;
    }

    function nice$1(start, stop, count) {
      let prestep;
      while (true) {
        const step = tickIncrement(start, stop, count);
        if (step === prestep || step === 0 || !isFinite(step)) {
          return [start, stop];
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        }
        prestep = step;
      }
    }

    function thresholdSturges(values) {
      return Math.ceil(Math.log(count$1(values)) / Math.LN2) + 1;
    }

    function bin() {
      var value = identity$9,
          domain = extent$1,
          threshold = thresholdSturges;

      function histogram(data) {
        if (!Array.isArray(data)) data = Array.from(data);

        var i,
            n = data.length,
            x,
            step,
            values = new Array(n);

        for (i = 0; i < n; ++i) {
          values[i] = value(data[i], i, data);
        }

        var xz = domain(values),
            x0 = xz[0],
            x1 = xz[1],
            tz = threshold(values, x0, x1);

        // Convert number of thresholds into uniform thresholds, and nice the
        // default domain accordingly.
        if (!Array.isArray(tz)) {
          const max = x1, tn = +tz;
          if (domain === extent$1) [x0, x1] = nice$1(x0, x1, tn);
          tz = ticks(x0, x1, tn);

          // If the domain is aligned with the first tick (which it will by
          // default), then we can use quantization rather than bisection to bin
          // values, which is substantially faster.
          if (tz[0] <= x0) step = tickIncrement(x0, x1, tn);

          // If the last threshold is coincident with the domains upper bound, the
          // last bin will be zero-width. If the default domain is used, and this
          // last threshold is coincident with the maximum input value, we can
          // extend the niced upper bound by one tick to ensure uniform bin widths;
          // otherwise, we simply remove the last threshold. Note that we dont
          // coerce values or the domain to numbers, and thus must be careful to
          // compare order (>=) rather than strict equality (===)!
          if (tz[tz.length - 1] >= x1) {
            if (max >= x1 && domain === extent$1) {
              const step = tickIncrement(x0, x1, tn);
              if (isFinite(step)) {
                if (step > 0) {
                  x1 = (Math.floor(x1 / step) + 1) * step;
                } else if (step < 0) {
                  x1 = (Math.ceil(x1 * -step) + 1) / -step;
                }
              }
            } else {
              tz.pop();
            }
          }
        }

        // Remove any thresholds outside the domain.
        var m = tz.length;
        while (tz[0] <= x0) tz.shift(), --m;
        while (tz[m - 1] > x1) tz.pop(), --m;

        var bins = new Array(m + 1),
            bin;

        // Initialize bins.
        for (i = 0; i <= m; ++i) {
          bin = bins[i] = [];
          bin.x0 = i > 0 ? tz[i - 1] : x0;
          bin.x1 = i < m ? tz[i] : x1;
        }

        // Assign data to bins by value, ignoring any outside the domain.
        if (isFinite(step)) {
          if (step > 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                bins[Math.min(m, Math.floor((x - x0) / step))].push(data[i]);
              }
            }
          } else if (step < 0) {
            for (i = 0; i < n; ++i) {
              if ((x = values[i]) != null && x0 <= x && x <= x1) {
                const j = Math.floor((x0 - x) * step);
                bins[Math.min(m, j + (tz[j] <= x))].push(data[i]); // handle off-by-one due to rounding
              }
            }
          }
        } else {
          for (i = 0; i < n; ++i) {
            if ((x = values[i]) != null && x0 <= x && x <= x1) {
              bins[bisect(tz, x, 0, m)].push(data[i]);
            }
          }
        }

        return bins;
      }

      histogram.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$b(_), histogram) : value;
      };

      histogram.domain = function(_) {
        return arguments.length ? (domain = typeof _ === "function" ? _ : constant$b([_[0], _[1]]), histogram) : domain;
      };

      histogram.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$b(slice$3.call(_)) : constant$b(_), histogram) : threshold;
      };

      return histogram;
    }

    function max$3(values, valueof) {
      let max;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value;
          }
        }
      }
      return max;
    }

    function min$2(values, valueof) {
      let min;
      if (valueof === undefined) {
        for (const value of values) {
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value;
          }
        }
      }
      return min;
    }

    // Based on https://github.com/mourner/quickselect
    // ISC license, Copyright 2018 Vladimir Agafonkin.
    function quickselect(array, k, left = 0, right = array.length - 1, compare) {
      compare = compare === undefined ? ascendingDefined : compareDefined(compare);

      while (right > left) {
        if (right - left > 600) {
          const n = right - left + 1;
          const m = k - left + 1;
          const z = Math.log(n);
          const s = 0.5 * Math.exp(2 * z / 3);
          const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
          const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
          const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
          quickselect(array, k, newLeft, newRight, compare);
        }

        const t = array[k];
        let i = left;
        let j = right;

        swap$1(array, left, k);
        if (compare(array[right], t) > 0) swap$1(array, left, right);

        while (i < j) {
          swap$1(array, i, j), ++i, --j;
          while (compare(array[i], t) < 0) ++i;
          while (compare(array[j], t) > 0) --j;
        }

        if (compare(array[left], t) === 0) swap$1(array, left, j);
        else ++j, swap$1(array, j, right);

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
      }
      return array;
    }

    function swap$1(array, i, j) {
      const t = array[i];
      array[i] = array[j];
      array[j] = t;
    }

    function quantile$1(values, p, valueof) {
      values = Float64Array.from(numbers(values, valueof));
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return min$2(values);
      if (p >= 1) return max$3(values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = max$3(quickselect(values, i0).subarray(0, i0 + 1)),
          value1 = min$2(values.subarray(i0 + 1));
      return value0 + (value1 - value0) * (i - i0);
    }

    function quantileSorted(values, p, valueof = number$3) {
      if (!(n = values.length)) return;
      if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
      if (p >= 1) return +valueof(values[n - 1], n - 1, values);
      var n,
          i = (n - 1) * p,
          i0 = Math.floor(i),
          value0 = +valueof(values[i0], i0, values),
          value1 = +valueof(values[i0 + 1], i0 + 1, values);
      return value0 + (value1 - value0) * (i - i0);
    }

    function thresholdFreedmanDiaconis(values, min, max) {
      return Math.ceil((max - min) / (2 * (quantile$1(values, 0.75) - quantile$1(values, 0.25)) * Math.pow(count$1(values), -1 / 3)));
    }

    function thresholdScott(values, min, max) {
      return Math.ceil((max - min) * Math.cbrt(count$1(values)) / (3.49 * deviation(values)));
    }

    function maxIndex(values, valueof) {
      let max;
      let maxIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (max < value || (max === undefined && value >= value))) {
            max = value, maxIndex = index;
          }
        }
      }
      return maxIndex;
    }

    function mean(values, valueof) {
      let count = 0;
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
            ++count, sum += value;
          }
        }
      }
      if (count) return sum / count;
    }

    function median(values, valueof) {
      return quantile$1(values, 0.5, valueof);
    }

    function* flatten(arrays) {
      for (const array of arrays) {
        yield* array;
      }
    }

    function merge(arrays) {
      return Array.from(flatten(arrays));
    }

    function minIndex(values, valueof) {
      let min;
      let minIndex = -1;
      let index = -1;
      if (valueof === undefined) {
        for (const value of values) {
          ++index;
          if (value != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      } else {
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null
              && (min > value || (min === undefined && value >= value))) {
            min = value, minIndex = index;
          }
        }
      }
      return minIndex;
    }

    function mode(values, valueof) {
      const counts = new InternMap();
      if (valueof === undefined) {
        for (let value of values) {
          if (value != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if ((value = valueof(value, ++index, values)) != null && value >= value) {
            counts.set(value, (counts.get(value) || 0) + 1);
          }
        }
      }
      let modeValue;
      let modeCount = 0;
      for (const [value, count] of counts) {
        if (count > modeCount) {
          modeCount = count;
          modeValue = value;
        }
      }
      return modeValue;
    }

    function pairs(values, pairof = pair) {
      const pairs = [];
      let previous;
      let first = false;
      for (const value of values) {
        if (first) pairs.push(pairof(previous, value));
        previous = value;
        first = true;
      }
      return pairs;
    }

    function pair(a, b) {
      return [a, b];
    }

    function range$2(start, stop, step) {
      start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

      var i = -1,
          n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
          range = new Array(n);

      while (++i < n) {
        range[i] = start + i * step;
      }

      return range;
    }

    function rank(values, valueof = ascending$3) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      let V = Array.from(values);
      const R = new Float64Array(V.length);
      if (valueof.length !== 2) V = V.map(valueof), valueof = ascending$3;
      const compareIndex = (i, j) => valueof(V[i], V[j]);
      let k, r;
      Uint32Array
        .from(V, (_, i) => i)
        .sort(valueof === ascending$3 ? (i, j) => ascendingDefined(V[i], V[j]) : compareDefined(compareIndex))
        .forEach((j, i) => {
          const c = compareIndex(j, k === undefined ? j : k);
          if (c >= 0) {
            if (k === undefined || c > 0) k = j, r = i;
            R[j] = r;
          } else {
            R[j] = NaN;
          }
        });
      return R;
    }

    function least(values, compare = ascending$3) {
      let min;
      let defined = false;
      if (compare.length === 1) {
        let minValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, minValue) < 0
              : ascending$3(value, value) === 0) {
            min = element;
            minValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, min) < 0
              : compare(value, value) === 0) {
            min = value;
            defined = true;
          }
        }
      }
      return min;
    }

    function leastIndex(values, compare = ascending$3) {
      if (compare.length === 1) return minIndex(values, compare);
      let minValue;
      let min = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (min < 0
            ? compare(value, value) === 0
            : compare(value, minValue) < 0) {
          minValue = value;
          min = index;
        }
      }
      return min;
    }

    function greatest(values, compare = ascending$3) {
      let max;
      let defined = false;
      if (compare.length === 1) {
        let maxValue;
        for (const element of values) {
          const value = compare(element);
          if (defined
              ? ascending$3(value, maxValue) > 0
              : ascending$3(value, value) === 0) {
            max = element;
            maxValue = value;
            defined = true;
          }
        }
      } else {
        for (const value of values) {
          if (defined
              ? compare(value, max) > 0
              : compare(value, value) === 0) {
            max = value;
            defined = true;
          }
        }
      }
      return max;
    }

    function greatestIndex(values, compare = ascending$3) {
      if (compare.length === 1) return maxIndex(values, compare);
      let maxValue;
      let max = -1;
      let index = -1;
      for (const value of values) {
        ++index;
        if (max < 0
            ? compare(value, value) === 0
            : compare(value, maxValue) > 0) {
          maxValue = value;
          max = index;
        }
      }
      return max;
    }

    function scan(values, compare) {
      const index = leastIndex(values, compare);
      return index < 0 ? undefined : index;
    }

    var shuffle$1 = shuffler(Math.random);

    function shuffler(random) {
      return function shuffle(array, i0 = 0, i1 = array.length) {
        let m = i1 - (i0 = +i0);
        while (m) {
          const i = random() * m-- | 0, t = array[m + i0];
          array[m + i0] = array[i + i0];
          array[i + i0] = t;
        }
        return array;
      };
    }

    function sum$2(values, valueof) {
      let sum = 0;
      if (valueof === undefined) {
        for (let value of values) {
          if (value = +value) {
            sum += value;
          }
        }
      } else {
        let index = -1;
        for (let value of values) {
          if (value = +valueof(value, ++index, values)) {
            sum += value;
          }
        }
      }
      return sum;
    }

    function transpose(matrix) {
      if (!(n = matrix.length)) return [];
      for (var i = -1, m = min$2(matrix, length$2), transpose = new Array(m); ++i < m;) {
        for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
          row[j] = matrix[j][i];
        }
      }
      return transpose;
    }

    function length$2(d) {
      return d.length;
    }

    function zip() {
      return transpose(arguments);
    }

    function every(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (!test(value, ++index, values)) {
          return false;
        }
      }
      return true;
    }

    function some(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          return true;
        }
      }
      return false;
    }

    function filter$1(values, test) {
      if (typeof test !== "function") throw new TypeError("test is not a function");
      const array = [];
      let index = -1;
      for (const value of values) {
        if (test(value, ++index, values)) {
          array.push(value);
        }
      }
      return array;
    }

    function map$1(values, mapper) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      if (typeof mapper !== "function") throw new TypeError("mapper is not a function");
      return Array.from(values, (value, index) => mapper(value, index, values));
    }

    function reduce(values, reducer, value) {
      if (typeof reducer !== "function") throw new TypeError("reducer is not a function");
      const iterator = values[Symbol.iterator]();
      let done, next, index = -1;
      if (arguments.length < 3) {
        ({done, value} = iterator.next());
        if (done) return;
        ++index;
      }
      while (({done, value: next} = iterator.next()), !done) {
        value = reducer(value, next, ++index, values);
      }
      return value;
    }

    function reverse$1(values) {
      if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
      return Array.from(values).reverse();
    }

    function difference(values, ...others) {
      values = new InternSet(values);
      for (const other of others) {
        for (const value of other) {
          values.delete(value);
        }
      }
      return values;
    }

    function disjoint(values, other) {
      const iterator = other[Symbol.iterator](), set = new InternSet();
      for (const v of values) {
        if (set.has(v)) return false;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) break;
          if (Object.is(v, value)) return false;
          set.add(value);
        }
      }
      return true;
    }

    function intersection(values, ...others) {
      values = new InternSet(values);
      others = others.map(set$2);
      out: for (const value of values) {
        for (const other of others) {
          if (!other.has(value)) {
            values.delete(value);
            continue out;
          }
        }
      }
      return values;
    }

    function set$2(values) {
      return values instanceof InternSet ? values : new InternSet(values);
    }

    function superset(values, other) {
      const iterator = values[Symbol.iterator](), set = new Set();
      for (const o of other) {
        const io = intern(o);
        if (set.has(io)) continue;
        let value, done;
        while (({value, done} = iterator.next())) {
          if (done) return false;
          const ivalue = intern(value);
          set.add(ivalue);
          if (Object.is(io, ivalue)) break;
        }
      }
      return true;
    }

    function intern(value) {
      return value !== null && typeof value === "object" ? value.valueOf() : value;
    }

    function subset(values, other) {
      return superset(other, values);
    }

    function union(...others) {
      const set = new InternSet();
      for (const other of others) {
        for (const o of other) {
          set.add(o);
        }
      }
      return set;
    }

    function identity$8(x) {
      return x;
    }

    var top = 1,
        right = 2,
        bottom = 3,
        left = 4,
        epsilon$6 = 1e-6;

    function translateX(x) {
      return "translate(" + x + ",0)";
    }

    function translateY(y) {
      return "translate(0," + y + ")";
    }

    function number$2(scale) {
      return d => +scale(d);
    }

    function center$1(scale, offset) {
      offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
      if (scale.round()) offset = Math.round(offset);
      return d => +scale(d) + offset;
    }

    function entering() {
      return !this.__axis;
    }

    function axis(orient, scale) {
      var tickArguments = [],
          tickValues = null,
          tickFormat = null,
          tickSizeInner = 6,
          tickSizeOuter = 6,
          tickPadding = 3,
          offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5,
          k = orient === top || orient === left ? -1 : 1,
          x = orient === left || orient === right ? "x" : "y",
          transform = orient === top || orient === bottom ? translateX : translateY;

      function axis(context) {
        var values = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain()) : tickValues,
            format = tickFormat == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8) : tickFormat,
            spacing = Math.max(tickSizeInner, 0) + tickPadding,
            range = scale.range(),
            range0 = +range[0] + offset,
            range1 = +range[range.length - 1] + offset,
            position = (scale.bandwidth ? center$1 : number$2)(scale.copy(), offset),
            selection = context.selection ? context.selection() : context,
            path = selection.selectAll(".domain").data([null]),
            tick = selection.selectAll(".tick").data(values, scale).order(),
            tickExit = tick.exit(),
            tickEnter = tick.enter().append("g").attr("class", "tick"),
            line = tick.select("line"),
            text = tick.select("text");

        path = path.merge(path.enter().insert("path", ".tick")
            .attr("class", "domain")
            .attr("stroke", "currentColor"));

        tick = tick.merge(tickEnter);

        line = line.merge(tickEnter.append("line")
            .attr("stroke", "currentColor")
            .attr(x + "2", k * tickSizeInner));

        text = text.merge(tickEnter.append("text")
            .attr("fill", "currentColor")
            .attr(x, k * spacing)
            .attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

        if (context !== selection) {
          path = path.transition(context);
          tick = tick.transition(context);
          line = line.transition(context);
          text = text.transition(context);

          tickExit = tickExit.transition(context)
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { return isFinite(d = position(d)) ? transform(d + offset) : this.getAttribute("transform"); });

          tickEnter
              .attr("opacity", epsilon$6)
              .attr("transform", function(d) { var p = this.parentNode.__axis; return transform((p && isFinite(p = p(d)) ? p : position(d)) + offset); });
        }

        tickExit.remove();

        path
            .attr("d", orient === left || orient === right
                ? (tickSizeOuter ? "M" + k * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1)
                : (tickSizeOuter ? "M" + range0 + "," + k * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1));

        tick
            .attr("opacity", 1)
            .attr("transform", function(d) { return transform(position(d) + offset); });

        line
            .attr(x + "2", k * tickSizeInner);

        text
            .attr(x, k * spacing)
            .text(format);

        selection.filter(entering)
            .attr("fill", "none")
            .attr("font-size", 10)
            .attr("font-family", "sans-serif")
            .attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");

        selection
            .each(function() { this.__axis = position; });
      }

      axis.scale = function(_) {
        return arguments.length ? (scale = _, axis) : scale;
      };

      axis.ticks = function() {
        return tickArguments = Array.from(arguments), axis;
      };

      axis.tickArguments = function(_) {
        return arguments.length ? (tickArguments = _ == null ? [] : Array.from(_), axis) : tickArguments.slice();
      };

      axis.tickValues = function(_) {
        return arguments.length ? (tickValues = _ == null ? null : Array.from(_), axis) : tickValues && tickValues.slice();
      };

      axis.tickFormat = function(_) {
        return arguments.length ? (tickFormat = _, axis) : tickFormat;
      };

      axis.tickSize = function(_) {
        return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
      };

      axis.tickSizeInner = function(_) {
        return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
      };

      axis.tickSizeOuter = function(_) {
        return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
      };

      axis.tickPadding = function(_) {
        return arguments.length ? (tickPadding = +_, axis) : tickPadding;
      };

      axis.offset = function(_) {
        return arguments.length ? (offset = +_, axis) : offset;
      };

      return axis;
    }

    function axisTop(scale) {
      return axis(top, scale);
    }

    function axisRight(scale) {
      return axis(right, scale);
    }

    function axisBottom(scale) {
      return axis(bottom, scale);
    }

    function axisLeft(scale) {
      return axis(left, scale);
    }

    var noop$3 = {value: () => {}};

    function dispatch() {
      for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
        if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
        _[t] = [];
      }
      return new Dispatch(_);
    }

    function Dispatch(_) {
      this._ = _;
    }

    function parseTypenames$1(typenames, types) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
        return {type: t, name: name};
      });
    }

    Dispatch.prototype = dispatch.prototype = {
      constructor: Dispatch,
      on: function(typename, callback) {
        var _ = this._,
            T = parseTypenames$1(typename + "", _),
            t,
            i = -1,
            n = T.length;

        // If no callback was specified, return the callback of the given type and name.
        if (arguments.length < 2) {
          while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
          return;
        }

        // If a type was specified, set the callback for the given type and name.
        // Otherwise, if a null callback was specified, remove callbacks of the given name.
        if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
        while (++i < n) {
          if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
          else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
        }

        return this;
      },
      copy: function() {
        var copy = {}, _ = this._;
        for (var t in _) copy[t] = _[t].slice();
        return new Dispatch(copy);
      },
      call: function(type, that) {
        if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      },
      apply: function(type, that, args) {
        if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
        for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
      }
    };

    function get$1(type, name) {
      for (var i = 0, n = type.length, c; i < n; ++i) {
        if ((c = type[i]).name === name) {
          return c.value;
        }
      }
    }

    function set$1(type, name, callback) {
      for (var i = 0, n = type.length; i < n; ++i) {
        if (type[i].name === name) {
          type[i] = noop$3, type = type.slice(0, i).concat(type.slice(i + 1));
          break;
        }
      }
      if (callback != null) type.push({name: name, value: callback});
      return type;
    }

    var xhtml = "http://www.w3.org/1999/xhtml";

    var namespaces = {
      svg: "http://www.w3.org/2000/svg",
      xhtml: xhtml,
      xlink: "http://www.w3.org/1999/xlink",
      xml: "http://www.w3.org/XML/1998/namespace",
      xmlns: "http://www.w3.org/2000/xmlns/"
    };

    function namespace(name) {
      var prefix = name += "", i = prefix.indexOf(":");
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
    }

    function creatorInherit(name) {
      return function() {
        var document = this.ownerDocument,
            uri = this.namespaceURI;
        return uri === xhtml && document.documentElement.namespaceURI === xhtml
            ? document.createElement(name)
            : document.createElementNS(uri, name);
      };
    }

    function creatorFixed(fullname) {
      return function() {
        return this.ownerDocument.createElementNS(fullname.space, fullname.local);
      };
    }

    function creator(name) {
      var fullname = namespace(name);
      return (fullname.local
          ? creatorFixed
          : creatorInherit)(fullname);
    }

    function none$2() {}

    function selector(selector) {
      return selector == null ? none$2 : function() {
        return this.querySelector(selector);
      };
    }

    function selection_select(select) {
      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    // Given something array like (or null), returns something that is strictly an
    // array. This is used to ensure that array-like objects passed to d3.selectAll
    // or selection.selectAll are converted into proper arrays when creating a
    // selection; we dont ever want to create a selection backed by a live
    // HTMLCollection or NodeList. However, note that selection.selectAll will use a
    // static NodeList as a group, since it safely derived from querySelectorAll.
    function array$4(x) {
      return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
    }

    function empty$1() {
      return [];
    }

    function selectorAll(selector) {
      return selector == null ? empty$1 : function() {
        return this.querySelectorAll(selector);
      };
    }

    function arrayAll(select) {
      return function() {
        return array$4(select.apply(this, arguments));
      };
    }

    function selection_selectAll(select) {
      if (typeof select === "function") select = arrayAll(select);
      else select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            subgroups.push(select.call(node, node.__data__, i, group));
            parents.push(node);
          }
        }
      }

      return new Selection$1(subgroups, parents);
    }

    function matcher(selector) {
      return function() {
        return this.matches(selector);
      };
    }

    function childMatcher(selector) {
      return function(node) {
        return node.matches(selector);
      };
    }

    var find$1 = Array.prototype.find;

    function childFind(match) {
      return function() {
        return find$1.call(this.children, match);
      };
    }

    function childFirst() {
      return this.firstElementChild;
    }

    function selection_selectChild(match) {
      return this.select(match == null ? childFirst
          : childFind(typeof match === "function" ? match : childMatcher(match)));
    }

    var filter = Array.prototype.filter;

    function children() {
      return Array.from(this.children);
    }

    function childrenFilter(match) {
      return function() {
        return filter.call(this.children, match);
      };
    }

    function selection_selectChildren(match) {
      return this.selectAll(match == null ? children
          : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
    }

    function selection_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Selection$1(subgroups, this._parents);
    }

    function sparse(update) {
      return new Array(update.length);
    }

    function selection_enter() {
      return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
    }

    function EnterNode(parent, datum) {
      this.ownerDocument = parent.ownerDocument;
      this.namespaceURI = parent.namespaceURI;
      this._next = null;
      this._parent = parent;
      this.__data__ = datum;
    }

    EnterNode.prototype = {
      constructor: EnterNode,
      appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
      insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
      querySelector: function(selector) { return this._parent.querySelector(selector); },
      querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
    };

    function constant$a(x) {
      return function() {
        return x;
      };
    }

    function bindIndex(parent, group, enter, update, exit, data) {
      var i = 0,
          node,
          groupLength = group.length,
          dataLength = data.length;

      // Put any non-null nodes that fit into update.
      // Put any null nodes into enter.
      // Put any remaining data into enter.
      for (; i < dataLength; ++i) {
        if (node = group[i]) {
          node.__data__ = data[i];
          update[i] = node;
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Put any non-null nodes that dont fit into exit.
      for (; i < groupLength; ++i) {
        if (node = group[i]) {
          exit[i] = node;
        }
      }
    }

    function bindKey(parent, group, enter, update, exit, data, key) {
      var i,
          node,
          nodeByKeyValue = new Map,
          groupLength = group.length,
          dataLength = data.length,
          keyValues = new Array(groupLength),
          keyValue;

      // Compute the key for each node.
      // If multiple nodes have the same key, the duplicates are added to exit.
      for (i = 0; i < groupLength; ++i) {
        if (node = group[i]) {
          keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
          if (nodeByKeyValue.has(keyValue)) {
            exit[i] = node;
          } else {
            nodeByKeyValue.set(keyValue, node);
          }
        }
      }

      // Compute the key for each datum.
      // If there a node associated with this key, join and add it to update.
      // If there is not (or the key is a duplicate), add it to enter.
      for (i = 0; i < dataLength; ++i) {
        keyValue = key.call(parent, data[i], i, data) + "";
        if (node = nodeByKeyValue.get(keyValue)) {
          update[i] = node;
          node.__data__ = data[i];
          nodeByKeyValue.delete(keyValue);
        } else {
          enter[i] = new EnterNode(parent, data[i]);
        }
      }

      // Add any remaining nodes that were not bound to data to exit.
      for (i = 0; i < groupLength; ++i) {
        if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
          exit[i] = node;
        }
      }
    }

    function datum(node) {
      return node.__data__;
    }

    function selection_data(value, key) {
      if (!arguments.length) return Array.from(this, datum);

      var bind = key ? bindKey : bindIndex,
          parents = this._parents,
          groups = this._groups;

      if (typeof value !== "function") value = constant$a(value);

      for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
        var parent = parents[j],
            group = groups[j],
            groupLength = group.length,
            data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
            dataLength = data.length,
            enterGroup = enter[j] = new Array(dataLength),
            updateGroup = update[j] = new Array(dataLength),
            exitGroup = exit[j] = new Array(groupLength);

        bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

        // Now connect the enter nodes to their following update node, such that
        // appendChild can insert the materialized enter node before this node,
        // rather than at the end of the parent node.
        for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
          if (previous = enterGroup[i0]) {
            if (i0 >= i1) i1 = i0 + 1;
            while (!(next = updateGroup[i1]) && ++i1 < dataLength);
            previous._next = next || null;
          }
        }
      }

      update = new Selection$1(update, parents);
      update._enter = enter;
      update._exit = exit;
      return update;
    }

    // Given some data, this returns an array-like view of it: an object that
    // exposes a length property and allows numeric indexing. Note that unlike
    // selectAll, this isnt worried about live collections because the resulting
    // array will only be used briefly while data is being bound. (It is possible to
    // cause the data to change while iterating by using a key function, but please
    // dont; wed rather avoid a gratuitous copy.)
    function arraylike(data) {
      return typeof data === "object" && "length" in data
        ? data // Array, TypedArray, NodeList, array-like
        : Array.from(data); // Map, Set, iterable, string, or anything else
    }

    function selection_exit() {
      return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
    }

    function selection_join(onenter, onupdate, onexit) {
      var enter = this.enter(), update = this, exit = this.exit();
      if (typeof onenter === "function") {
        enter = onenter(enter);
        if (enter) enter = enter.selection();
      } else {
        enter = enter.append(onenter + "");
      }
      if (onupdate != null) {
        update = onupdate(update);
        if (update) update = update.selection();
      }
      if (onexit == null) exit.remove(); else onexit(exit);
      return enter && update ? enter.merge(update).order() : update;
    }

    function selection_merge(context) {
      var selection = context.selection ? context.selection() : context;

      for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Selection$1(merges, this._parents);
    }

    function selection_order() {

      for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
        for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
          if (node = group[i]) {
            if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
            next = node;
          }
        }
      }

      return this;
    }

    function selection_sort(compare) {
      if (!compare) compare = ascending$2;

      function compareNode(a, b) {
        return a && b ? compare(a.__data__, b.__data__) : !a - !b;
      }

      for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            sortgroup[i] = node;
          }
        }
        sortgroup.sort(compareNode);
      }

      return new Selection$1(sortgroups, this._parents).order();
    }

    function ascending$2(a, b) {
      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
    }

    function selection_call() {
      var callback = arguments[0];
      arguments[0] = this;
      callback.apply(null, arguments);
      return this;
    }

    function selection_nodes() {
      return Array.from(this);
    }

    function selection_node() {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
          var node = group[i];
          if (node) return node;
        }
      }

      return null;
    }

    function selection_size() {
      let size = 0;
      for (const node of this) ++size; // eslint-disable-line no-unused-vars
      return size;
    }

    function selection_empty() {
      return !this.node();
    }

    function selection_each(callback) {

      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) callback.call(node, node.__data__, i, group);
        }
      }

      return this;
    }

    function attrRemove$1(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS$1(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant$1(name, value) {
      return function() {
        this.setAttribute(name, value);
      };
    }

    function attrConstantNS$1(fullname, value) {
      return function() {
        this.setAttributeNS(fullname.space, fullname.local, value);
      };
    }

    function attrFunction$1(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttribute(name);
        else this.setAttribute(name, v);
      };
    }

    function attrFunctionNS$1(fullname, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
        else this.setAttributeNS(fullname.space, fullname.local, v);
      };
    }

    function selection_attr(name, value) {
      var fullname = namespace(name);

      if (arguments.length < 2) {
        var node = this.node();
        return fullname.local
            ? node.getAttributeNS(fullname.space, fullname.local)
            : node.getAttribute(fullname);
      }

      return this.each((value == null
          ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
          ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
          : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
    }

    function defaultView(node) {
      return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
          || (node.document && node) // node is a Window
          || node.defaultView; // node is a Document
    }

    function styleRemove$1(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant$1(name, value, priority) {
      return function() {
        this.style.setProperty(name, value, priority);
      };
    }

    function styleFunction$1(name, value, priority) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) this.style.removeProperty(name);
        else this.style.setProperty(name, v, priority);
      };
    }

    function selection_style(name, value, priority) {
      return arguments.length > 1
          ? this.each((value == null
                ? styleRemove$1 : typeof value === "function"
                ? styleFunction$1
                : styleConstant$1)(name, value, priority == null ? "" : priority))
          : styleValue(this.node(), name);
    }

    function styleValue(node, name) {
      return node.style.getPropertyValue(name)
          || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
    }

    function propertyRemove(name) {
      return function() {
        delete this[name];
      };
    }

    function propertyConstant(name, value) {
      return function() {
        this[name] = value;
      };
    }

    function propertyFunction(name, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (v == null) delete this[name];
        else this[name] = v;
      };
    }

    function selection_property(name, value) {
      return arguments.length > 1
          ? this.each((value == null
              ? propertyRemove : typeof value === "function"
              ? propertyFunction
              : propertyConstant)(name, value))
          : this.node()[name];
    }

    function classArray(string) {
      return string.trim().split(/^|\s+/);
    }

    function classList(node) {
      return node.classList || new ClassList(node);
    }

    function ClassList(node) {
      this._node = node;
      this._names = classArray(node.getAttribute("class") || "");
    }

    ClassList.prototype = {
      add: function(name) {
        var i = this._names.indexOf(name);
        if (i < 0) {
          this._names.push(name);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      remove: function(name) {
        var i = this._names.indexOf(name);
        if (i >= 0) {
          this._names.splice(i, 1);
          this._node.setAttribute("class", this._names.join(" "));
        }
      },
      contains: function(name) {
        return this._names.indexOf(name) >= 0;
      }
    };

    function classedAdd(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.add(names[i]);
    }

    function classedRemove(node, names) {
      var list = classList(node), i = -1, n = names.length;
      while (++i < n) list.remove(names[i]);
    }

    function classedTrue(names) {
      return function() {
        classedAdd(this, names);
      };
    }

    function classedFalse(names) {
      return function() {
        classedRemove(this, names);
      };
    }

    function classedFunction(names, value) {
      return function() {
        (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
      };
    }

    function selection_classed(name, value) {
      var names = classArray(name + "");

      if (arguments.length < 2) {
        var list = classList(this.node()), i = -1, n = names.length;
        while (++i < n) if (!list.contains(names[i])) return false;
        return true;
      }

      return this.each((typeof value === "function"
          ? classedFunction : value
          ? classedTrue
          : classedFalse)(names, value));
    }

    function textRemove() {
      this.textContent = "";
    }

    function textConstant$1(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction$1(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.textContent = v == null ? "" : v;
      };
    }

    function selection_text(value) {
      return arguments.length
          ? this.each(value == null
              ? textRemove : (typeof value === "function"
              ? textFunction$1
              : textConstant$1)(value))
          : this.node().textContent;
    }

    function htmlRemove() {
      this.innerHTML = "";
    }

    function htmlConstant(value) {
      return function() {
        this.innerHTML = value;
      };
    }

    function htmlFunction(value) {
      return function() {
        var v = value.apply(this, arguments);
        this.innerHTML = v == null ? "" : v;
      };
    }

    function selection_html(value) {
      return arguments.length
          ? this.each(value == null
              ? htmlRemove : (typeof value === "function"
              ? htmlFunction
              : htmlConstant)(value))
          : this.node().innerHTML;
    }

    function raise() {
      if (this.nextSibling) this.parentNode.appendChild(this);
    }

    function selection_raise() {
      return this.each(raise);
    }

    function lower() {
      if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
    }

    function selection_lower() {
      return this.each(lower);
    }

    function selection_append(name) {
      var create = typeof name === "function" ? name : creator(name);
      return this.select(function() {
        return this.appendChild(create.apply(this, arguments));
      });
    }

    function constantNull() {
      return null;
    }

    function selection_insert(name, before) {
      var create = typeof name === "function" ? name : creator(name),
          select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
      return this.select(function() {
        return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
      });
    }

    function remove() {
      var parent = this.parentNode;
      if (parent) parent.removeChild(this);
    }

    function selection_remove() {
      return this.each(remove);
    }

    function selection_cloneShallow() {
      var clone = this.cloneNode(false), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_cloneDeep() {
      var clone = this.cloneNode(true), parent = this.parentNode;
      return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
    }

    function selection_clone(deep) {
      return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
    }

    function selection_datum(value) {
      return arguments.length
          ? this.property("__data__", value)
          : this.node().__data__;
    }

    function contextListener(listener) {
      return function(event) {
        listener.call(this, event, this.__data__);
      };
    }

    function parseTypenames(typenames) {
      return typenames.trim().split(/^|\s+/).map(function(t) {
        var name = "", i = t.indexOf(".");
        if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
        return {type: t, name: name};
      });
    }

    function onRemove(typename) {
      return function() {
        var on = this.__on;
        if (!on) return;
        for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
          if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
          } else {
            on[++i] = o;
          }
        }
        if (++i) on.length = i;
        else delete this.__on;
      };
    }

    function onAdd(typename, value, options) {
      return function() {
        var on = this.__on, o, listener = contextListener(value);
        if (on) for (var j = 0, m = on.length; j < m; ++j) {
          if ((o = on[j]).type === typename.type && o.name === typename.name) {
            this.removeEventListener(o.type, o.listener, o.options);
            this.addEventListener(o.type, o.listener = listener, o.options = options);
            o.value = value;
            return;
          }
        }
        this.addEventListener(typename.type, listener, options);
        o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
        if (!on) this.__on = [o];
        else on.push(o);
      };
    }

    function selection_on(typename, value, options) {
      var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

      if (arguments.length < 2) {
        var on = this.node().__on;
        if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
          for (i = 0, o = on[j]; i < n; ++i) {
            if ((t = typenames[i]).type === o.type && t.name === o.name) {
              return o.value;
            }
          }
        }
        return;
      }

      on = value ? onAdd : onRemove;
      for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
      return this;
    }

    function dispatchEvent(node, type, params) {
      var window = defaultView(node),
          event = window.CustomEvent;

      if (typeof event === "function") {
        event = new event(type, params);
      } else {
        event = window.document.createEvent("Event");
        if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
        else event.initEvent(type, false, false);
      }

      node.dispatchEvent(event);
    }

    function dispatchConstant(type, params) {
      return function() {
        return dispatchEvent(this, type, params);
      };
    }

    function dispatchFunction(type, params) {
      return function() {
        return dispatchEvent(this, type, params.apply(this, arguments));
      };
    }

    function selection_dispatch(type, params) {
      return this.each((typeof params === "function"
          ? dispatchFunction
          : dispatchConstant)(type, params));
    }

    function* selection_iterator() {
      for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
        for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
          if (node = group[i]) yield node;
        }
      }
    }

    var root$1 = [null];

    function Selection$1(groups, parents) {
      this._groups = groups;
      this._parents = parents;
    }

    function selection() {
      return new Selection$1([[document.documentElement]], root$1);
    }

    function selection_selection() {
      return this;
    }

    Selection$1.prototype = selection.prototype = {
      constructor: Selection$1,
      select: selection_select,
      selectAll: selection_selectAll,
      selectChild: selection_selectChild,
      selectChildren: selection_selectChildren,
      filter: selection_filter,
      data: selection_data,
      enter: selection_enter,
      exit: selection_exit,
      join: selection_join,
      merge: selection_merge,
      selection: selection_selection,
      order: selection_order,
      sort: selection_sort,
      call: selection_call,
      nodes: selection_nodes,
      node: selection_node,
      size: selection_size,
      empty: selection_empty,
      each: selection_each,
      attr: selection_attr,
      style: selection_style,
      property: selection_property,
      classed: selection_classed,
      text: selection_text,
      html: selection_html,
      raise: selection_raise,
      lower: selection_lower,
      append: selection_append,
      insert: selection_insert,
      remove: selection_remove,
      clone: selection_clone,
      datum: selection_datum,
      on: selection_on,
      dispatch: selection_dispatch,
      [Symbol.iterator]: selection_iterator
    };

    function select(selector) {
      return typeof selector === "string"
          ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
          : new Selection$1([[selector]], root$1);
    }

    function create$1(name) {
      return select(creator(name).call(document.documentElement));
    }

    var nextId = 0;

    function local$1() {
      return new Local;
    }

    function Local() {
      this._ = "@" + (++nextId).toString(36);
    }

    Local.prototype = local$1.prototype = {
      constructor: Local,
      get: function(node) {
        var id = this._;
        while (!(id in node)) if (!(node = node.parentNode)) return;
        return node[id];
      },
      set: function(node, value) {
        return node[this._] = value;
      },
      remove: function(node) {
        return this._ in node && delete node[this._];
      },
      toString: function() {
        return this._;
      }
    };

    function sourceEvent(event) {
      let sourceEvent;
      while (sourceEvent = event.sourceEvent) event = sourceEvent;
      return event;
    }

    function pointer(event, node) {
      event = sourceEvent(event);
      if (node === undefined) node = event.currentTarget;
      if (node) {
        var svg = node.ownerSVGElement || node;
        if (svg.createSVGPoint) {
          var point = svg.createSVGPoint();
          point.x = event.clientX, point.y = event.clientY;
          point = point.matrixTransform(node.getScreenCTM().inverse());
          return [point.x, point.y];
        }
        if (node.getBoundingClientRect) {
          var rect = node.getBoundingClientRect();
          return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }
      }
      return [event.pageX, event.pageY];
    }

    function pointers(events, node) {
      if (events.target) { // i.e., instanceof Event, not TouchList or iterable
        events = sourceEvent(events);
        if (node === undefined) node = events.currentTarget;
        events = events.touches || [events];
      }
      return Array.from(events, event => pointer(event, node));
    }

    function selectAll(selector) {
      return typeof selector === "string"
          ? new Selection$1([document.querySelectorAll(selector)], [document.documentElement])
          : new Selection$1([array$4(selector)], root$1);
    }

    // These are typically used in conjunction with noevent to ensure that we can
    // preventDefault on the event.
    const nonpassive = {passive: false};
    const nonpassivecapture = {capture: true, passive: false};

    function nopropagation$2(event) {
      event.stopImmediatePropagation();
    }

    function noevent$2(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    function dragDisable(view) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", noevent$2, nonpassivecapture);
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", noevent$2, nonpassivecapture);
      } else {
        root.__noselect = root.style.MozUserSelect;
        root.style.MozUserSelect = "none";
      }
    }

    function yesdrag(view, noclick) {
      var root = view.document.documentElement,
          selection = select(view).on("dragstart.drag", null);
      if (noclick) {
        selection.on("click.drag", noevent$2, nonpassivecapture);
        setTimeout(function() { selection.on("click.drag", null); }, 0);
      }
      if ("onselectstart" in root) {
        selection.on("selectstart.drag", null);
      } else {
        root.style.MozUserSelect = root.__noselect;
        delete root.__noselect;
      }
    }

    var constant$9 = x => () => x;

    function DragEvent(type, {
      sourceEvent,
      subject,
      target,
      identifier,
      active,
      x, y, dx, dy,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        subject: {value: subject, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        identifier: {value: identifier, enumerable: true, configurable: true},
        active: {value: active, enumerable: true, configurable: true},
        x: {value: x, enumerable: true, configurable: true},
        y: {value: y, enumerable: true, configurable: true},
        dx: {value: dx, enumerable: true, configurable: true},
        dy: {value: dy, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    DragEvent.prototype.on = function() {
      var value = this._.on.apply(this._, arguments);
      return value === this._ ? this : value;
    };

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$2(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultContainer() {
      return this.parentNode;
    }

    function defaultSubject(event, d) {
      return d == null ? {x: event.x, y: event.y} : d;
    }

    function defaultTouchable$2() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function drag() {
      var filter = defaultFilter$2,
          container = defaultContainer,
          subject = defaultSubject,
          touchable = defaultTouchable$2,
          gestures = {},
          listeners = dispatch("start", "drag", "end"),
          active = 0,
          mousedownx,
          mousedowny,
          mousemoving,
          touchending,
          clickDistance2 = 0;

      function drag(selection) {
        selection
            .on("mousedown.drag", mousedowned)
          .filter(touchable)
            .on("touchstart.drag", touchstarted)
            .on("touchmove.drag", touchmoved, nonpassive)
            .on("touchend.drag touchcancel.drag", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      function mousedowned(event, d) {
        if (touchending || !filter.call(this, event, d)) return;
        var gesture = beforestart(this, container.call(this, event, d), event, d, "mouse");
        if (!gesture) return;
        select(event.view)
          .on("mousemove.drag", mousemoved, nonpassivecapture)
          .on("mouseup.drag", mouseupped, nonpassivecapture);
        dragDisable(event.view);
        nopropagation$2(event);
        mousemoving = false;
        mousedownx = event.clientX;
        mousedowny = event.clientY;
        gesture("start", event);
      }

      function mousemoved(event) {
        noevent$2(event);
        if (!mousemoving) {
          var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
          mousemoving = dx * dx + dy * dy > clickDistance2;
        }
        gestures.mouse("drag", event);
      }

      function mouseupped(event) {
        select(event.view).on("mousemove.drag mouseup.drag", null);
        yesdrag(event.view, mousemoving);
        noevent$2(event);
        gestures.mouse("end", event);
      }

      function touchstarted(event, d) {
        if (!filter.call(this, event, d)) return;
        var touches = event.changedTouches,
            c = container.call(this, event, d),
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = beforestart(this, c, event, d, touches[i].identifier, touches[i])) {
            nopropagation$2(event);
            gesture("start", event, touches[i]);
          }
        }
      }

      function touchmoved(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            noevent$2(event);
            gesture("drag", event, touches[i]);
          }
        }
      }

      function touchended(event) {
        var touches = event.changedTouches,
            n = touches.length, i, gesture;

        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
        for (i = 0; i < n; ++i) {
          if (gesture = gestures[touches[i].identifier]) {
            nopropagation$2(event);
            gesture("end", event, touches[i]);
          }
        }
      }

      function beforestart(that, container, event, d, identifier, touch) {
        var dispatch = listeners.copy(),
            p = pointer(touch || event, container), dx, dy,
            s;

        if ((s = subject.call(that, new DragEvent("beforestart", {
            sourceEvent: event,
            target: drag,
            identifier,
            active,
            x: p[0],
            y: p[1],
            dx: 0,
            dy: 0,
            dispatch
          }), d)) == null) return;

        dx = s.x - p[0] || 0;
        dy = s.y - p[1] || 0;

        return function gesture(type, event, touch) {
          var p0 = p, n;
          switch (type) {
            case "start": gestures[identifier] = gesture, n = active++; break;
            case "end": delete gestures[identifier], --active; // falls through
            case "drag": p = pointer(touch || event, container), n = active; break;
          }
          dispatch.call(
            type,
            that,
            new DragEvent(type, {
              sourceEvent: event,
              subject: s,
              target: drag,
              identifier,
              active: n,
              x: p[0] + dx,
              y: p[1] + dy,
              dx: p[0] - p0[0],
              dy: p[1] - p0[1],
              dispatch
            }),
            d
          );
        };
      }

      drag.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$9(!!_), drag) : filter;
      };

      drag.container = function(_) {
        return arguments.length ? (container = typeof _ === "function" ? _ : constant$9(_), drag) : container;
      };

      drag.subject = function(_) {
        return arguments.length ? (subject = typeof _ === "function" ? _ : constant$9(_), drag) : subject;
      };

      drag.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$9(!!_), drag) : touchable;
      };

      drag.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? drag : value;
      };

      drag.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
      };

      return drag;
    }

    function define(constructor, factory, prototype) {
      constructor.prototype = factory.prototype = prototype;
      prototype.constructor = constructor;
    }

    function extend(parent, definition) {
      var prototype = Object.create(parent.prototype);
      for (var key in definition) prototype[key] = definition[key];
      return prototype;
    }

    function Color() {}

    var darker = 0.7;
    var brighter = 1 / darker;

    var reI = "\\s*([+-]?\\d+)\\s*",
        reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        reHex = /^#([0-9a-f]{3,8})$/,
        reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
        reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
        reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
        reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
        reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
        reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

    var named = {
      aliceblue: 0xf0f8ff,
      antiquewhite: 0xfaebd7,
      aqua: 0x00ffff,
      aquamarine: 0x7fffd4,
      azure: 0xf0ffff,
      beige: 0xf5f5dc,
      bisque: 0xffe4c4,
      black: 0x000000,
      blanchedalmond: 0xffebcd,
      blue: 0x0000ff,
      blueviolet: 0x8a2be2,
      brown: 0xa52a2a,
      burlywood: 0xdeb887,
      cadetblue: 0x5f9ea0,
      chartreuse: 0x7fff00,
      chocolate: 0xd2691e,
      coral: 0xff7f50,
      cornflowerblue: 0x6495ed,
      cornsilk: 0xfff8dc,
      crimson: 0xdc143c,
      cyan: 0x00ffff,
      darkblue: 0x00008b,
      darkcyan: 0x008b8b,
      darkgoldenrod: 0xb8860b,
      darkgray: 0xa9a9a9,
      darkgreen: 0x006400,
      darkgrey: 0xa9a9a9,
      darkkhaki: 0xbdb76b,
      darkmagenta: 0x8b008b,
      darkolivegreen: 0x556b2f,
      darkorange: 0xff8c00,
      darkorchid: 0x9932cc,
      darkred: 0x8b0000,
      darksalmon: 0xe9967a,
      darkseagreen: 0x8fbc8f,
      darkslateblue: 0x483d8b,
      darkslategray: 0x2f4f4f,
      darkslategrey: 0x2f4f4f,
      darkturquoise: 0x00ced1,
      darkviolet: 0x9400d3,
      deeppink: 0xff1493,
      deepskyblue: 0x00bfff,
      dimgray: 0x696969,
      dimgrey: 0x696969,
      dodgerblue: 0x1e90ff,
      firebrick: 0xb22222,
      floralwhite: 0xfffaf0,
      forestgreen: 0x228b22,
      fuchsia: 0xff00ff,
      gainsboro: 0xdcdcdc,
      ghostwhite: 0xf8f8ff,
      gold: 0xffd700,
      goldenrod: 0xdaa520,
      gray: 0x808080,
      green: 0x008000,
      greenyellow: 0xadff2f,
      grey: 0x808080,
      honeydew: 0xf0fff0,
      hotpink: 0xff69b4,
      indianred: 0xcd5c5c,
      indigo: 0x4b0082,
      ivory: 0xfffff0,
      khaki: 0xf0e68c,
      lavender: 0xe6e6fa,
      lavenderblush: 0xfff0f5,
      lawngreen: 0x7cfc00,
      lemonchiffon: 0xfffacd,
      lightblue: 0xadd8e6,
      lightcoral: 0xf08080,
      lightcyan: 0xe0ffff,
      lightgoldenrodyellow: 0xfafad2,
      lightgray: 0xd3d3d3,
      lightgreen: 0x90ee90,
      lightgrey: 0xd3d3d3,
      lightpink: 0xffb6c1,
      lightsalmon: 0xffa07a,
      lightseagreen: 0x20b2aa,
      lightskyblue: 0x87cefa,
      lightslategray: 0x778899,
      lightslategrey: 0x778899,
      lightsteelblue: 0xb0c4de,
      lightyellow: 0xffffe0,
      lime: 0x00ff00,
      limegreen: 0x32cd32,
      linen: 0xfaf0e6,
      magenta: 0xff00ff,
      maroon: 0x800000,
      mediumaquamarine: 0x66cdaa,
      mediumblue: 0x0000cd,
      mediumorchid: 0xba55d3,
      mediumpurple: 0x9370db,
      mediumseagreen: 0x3cb371,
      mediumslateblue: 0x7b68ee,
      mediumspringgreen: 0x00fa9a,
      mediumturquoise: 0x48d1cc,
      mediumvioletred: 0xc71585,
      midnightblue: 0x191970,
      mintcream: 0xf5fffa,
      mistyrose: 0xffe4e1,
      moccasin: 0xffe4b5,
      navajowhite: 0xffdead,
      navy: 0x000080,
      oldlace: 0xfdf5e6,
      olive: 0x808000,
      olivedrab: 0x6b8e23,
      orange: 0xffa500,
      orangered: 0xff4500,
      orchid: 0xda70d6,
      palegoldenrod: 0xeee8aa,
      palegreen: 0x98fb98,
      paleturquoise: 0xafeeee,
      palevioletred: 0xdb7093,
      papayawhip: 0xffefd5,
      peachpuff: 0xffdab9,
      peru: 0xcd853f,
      pink: 0xffc0cb,
      plum: 0xdda0dd,
      powderblue: 0xb0e0e6,
      purple: 0x800080,
      rebeccapurple: 0x663399,
      red: 0xff0000,
      rosybrown: 0xbc8f8f,
      royalblue: 0x4169e1,
      saddlebrown: 0x8b4513,
      salmon: 0xfa8072,
      sandybrown: 0xf4a460,
      seagreen: 0x2e8b57,
      seashell: 0xfff5ee,
      sienna: 0xa0522d,
      silver: 0xc0c0c0,
      skyblue: 0x87ceeb,
      slateblue: 0x6a5acd,
      slategray: 0x708090,
      slategrey: 0x708090,
      snow: 0xfffafa,
      springgreen: 0x00ff7f,
      steelblue: 0x4682b4,
      tan: 0xd2b48c,
      teal: 0x008080,
      thistle: 0xd8bfd8,
      tomato: 0xff6347,
      turquoise: 0x40e0d0,
      violet: 0xee82ee,
      wheat: 0xf5deb3,
      white: 0xffffff,
      whitesmoke: 0xf5f5f5,
      yellow: 0xffff00,
      yellowgreen: 0x9acd32
    };

    define(Color, color, {
      copy(channels) {
        return Object.assign(new this.constructor, this, channels);
      },
      displayable() {
        return this.rgb().displayable();
      },
      hex: color_formatHex, // Deprecated! Use color.formatHex.
      formatHex: color_formatHex,
      formatHex8: color_formatHex8,
      formatHsl: color_formatHsl,
      formatRgb: color_formatRgb,
      toString: color_formatRgb
    });

    function color_formatHex() {
      return this.rgb().formatHex();
    }

    function color_formatHex8() {
      return this.rgb().formatHex8();
    }

    function color_formatHsl() {
      return hslConvert(this).formatHsl();
    }

    function color_formatRgb() {
      return this.rgb().formatRgb();
    }

    function color(format) {
      var m, l;
      format = (format + "").trim().toLowerCase();
      return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
          : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
          : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
          : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
          : null) // invalid hex
          : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
          : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
          : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
          : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
          : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
          : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
          : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
          : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
          : null;
    }

    function rgbn(n) {
      return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
    }

    function rgba(r, g, b, a) {
      if (a <= 0) r = g = b = NaN;
      return new Rgb(r, g, b, a);
    }

    function rgbConvert(o) {
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Rgb;
      o = o.rgb();
      return new Rgb(o.r, o.g, o.b, o.opacity);
    }

    function rgb(r, g, b, opacity) {
      return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
    }

    function Rgb(r, g, b, opacity) {
      this.r = +r;
      this.g = +g;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Rgb, rgb, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
      },
      rgb() {
        return this;
      },
      clamp() {
        return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
      },
      displayable() {
        return (-0.5 <= this.r && this.r < 255.5)
            && (-0.5 <= this.g && this.g < 255.5)
            && (-0.5 <= this.b && this.b < 255.5)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      hex: rgb_formatHex, // Deprecated! Use color.formatHex.
      formatHex: rgb_formatHex,
      formatHex8: rgb_formatHex8,
      formatRgb: rgb_formatRgb,
      toString: rgb_formatRgb
    }));

    function rgb_formatHex() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
    }

    function rgb_formatHex8() {
      return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }

    function rgb_formatRgb() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
    }

    function clampa(opacity) {
      return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
    }

    function clampi(value) {
      return Math.max(0, Math.min(255, Math.round(value) || 0));
    }

    function hex(value) {
      value = clampi(value);
      return (value < 16 ? "0" : "") + value.toString(16);
    }

    function hsla(h, s, l, a) {
      if (a <= 0) h = s = l = NaN;
      else if (l <= 0 || l >= 1) h = s = NaN;
      else if (s <= 0) h = NaN;
      return new Hsl(h, s, l, a);
    }

    function hslConvert(o) {
      if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Color)) o = color(o);
      if (!o) return new Hsl;
      if (o instanceof Hsl) return o;
      o = o.rgb();
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          min = Math.min(r, g, b),
          max = Math.max(r, g, b),
          h = NaN,
          s = max - min,
          l = (max + min) / 2;
      if (s) {
        if (r === max) h = (g - b) / s + (g < b) * 6;
        else if (g === max) h = (b - r) / s + 2;
        else h = (r - g) / s + 4;
        s /= l < 0.5 ? max + min : 2 - max - min;
        h *= 60;
      } else {
        s = l > 0 && l < 1 ? 0 : h;
      }
      return new Hsl(h, s, l, o.opacity);
    }

    function hsl$2(h, s, l, opacity) {
      return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
    }

    function Hsl(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Hsl, hsl$2, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Hsl(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = this.h % 360 + (this.h < 0) * 360,
            s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
            l = this.l,
            m2 = l + (l < 0.5 ? l : 1 - l) * s,
            m1 = 2 * l - m2;
        return new Rgb(
          hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
          hsl2rgb(h, m1, m2),
          hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
          this.opacity
        );
      },
      clamp() {
        return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
      },
      displayable() {
        return (0 <= this.s && this.s <= 1 || isNaN(this.s))
            && (0 <= this.l && this.l <= 1)
            && (0 <= this.opacity && this.opacity <= 1);
      },
      formatHsl() {
        const a = clampa(this.opacity);
        return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
      }
    }));

    function clamph(value) {
      value = (value || 0) % 360;
      return value < 0 ? value + 360 : value;
    }

    function clampt(value) {
      return Math.max(0, Math.min(1, value || 0));
    }

    /* From FvD 13.37, CSS Color Module Level 3 */
    function hsl2rgb(h, m1, m2) {
      return (h < 60 ? m1 + (m2 - m1) * h / 60
          : h < 180 ? m2
          : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
          : m1) * 255;
    }

    const radians$1 = Math.PI / 180;
    const degrees$2 = 180 / Math.PI;

    // https://observablehq.com/@mbostock/lab-and-rgb
    const K = 18,
        Xn = 0.96422,
        Yn = 1,
        Zn = 0.82521,
        t0$1 = 4 / 29,
        t1$1 = 6 / 29,
        t2 = 3 * t1$1 * t1$1,
        t3 = t1$1 * t1$1 * t1$1;

    function labConvert(o) {
      if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
      if (o instanceof Hcl) return hcl2lab(o);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = rgb2lrgb(o.r),
          g = rgb2lrgb(o.g),
          b = rgb2lrgb(o.b),
          y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
      if (r === g && g === b) x = z = y; else {
        x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
        z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
      }
      return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
    }

    function gray(l, opacity) {
      return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
    }

    function lab$1(l, a, b, opacity) {
      return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
    }

    function Lab(l, a, b, opacity) {
      this.l = +l;
      this.a = +a;
      this.b = +b;
      this.opacity = +opacity;
    }

    define(Lab, lab$1, extend(Color, {
      brighter(k) {
        return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      darker(k) {
        return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
      },
      rgb() {
        var y = (this.l + 16) / 116,
            x = isNaN(this.a) ? y : y + this.a / 500,
            z = isNaN(this.b) ? y : y - this.b / 200;
        x = Xn * lab2xyz(x);
        y = Yn * lab2xyz(y);
        z = Zn * lab2xyz(z);
        return new Rgb(
          lrgb2rgb( 3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
          lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.0334540 * z),
          lrgb2rgb( 0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
          this.opacity
        );
      }
    }));

    function xyz2lab(t) {
      return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
    }

    function lab2xyz(t) {
      return t > t1$1 ? t * t * t : t2 * (t - t0$1);
    }

    function lrgb2rgb(x) {
      return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
    }

    function rgb2lrgb(x) {
      return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
    }

    function hclConvert(o) {
      if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
      if (!(o instanceof Lab)) o = labConvert(o);
      if (o.a === 0 && o.b === 0) return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
      var h = Math.atan2(o.b, o.a) * degrees$2;
      return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
    }

    function lch(l, c, h, opacity) {
      return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function hcl$2(h, c, l, opacity) {
      return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
    }

    function Hcl(h, c, l, opacity) {
      this.h = +h;
      this.c = +c;
      this.l = +l;
      this.opacity = +opacity;
    }

    function hcl2lab(o) {
      if (isNaN(o.h)) return new Lab(o.l, 0, 0, o.opacity);
      var h = o.h * radians$1;
      return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
    }

    define(Hcl, hcl$2, extend(Color, {
      brighter(k) {
        return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
      },
      darker(k) {
        return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
      },
      rgb() {
        return hcl2lab(this).rgb();
      }
    }));

    var A = -0.14861,
        B$1 = +1.78277,
        C = -0.29227,
        D$1 = -0.90649,
        E = +1.97294,
        ED = E * D$1,
        EB = E * B$1,
        BC_DA = B$1 * C - D$1 * A;

    function cubehelixConvert(o) {
      if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
      if (!(o instanceof Rgb)) o = rgbConvert(o);
      var r = o.r / 255,
          g = o.g / 255,
          b = o.b / 255,
          l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
          bl = b - l,
          k = (E * (g - l) - C * bl) / D$1,
          s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
          h = s ? Math.atan2(k, bl) * degrees$2 - 120 : NaN;
      return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
    }

    function cubehelix$3(h, s, l, opacity) {
      return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
    }

    function Cubehelix(h, s, l, opacity) {
      this.h = +h;
      this.s = +s;
      this.l = +l;
      this.opacity = +opacity;
    }

    define(Cubehelix, cubehelix$3, extend(Color, {
      brighter(k) {
        k = k == null ? brighter : Math.pow(brighter, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      darker(k) {
        k = k == null ? darker : Math.pow(darker, k);
        return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
      },
      rgb() {
        var h = isNaN(this.h) ? 0 : (this.h + 120) * radians$1,
            l = +this.l,
            a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
            cosh = Math.cos(h),
            sinh = Math.sin(h);
        return new Rgb(
          255 * (l + a * (A * cosh + B$1 * sinh)),
          255 * (l + a * (C * cosh + D$1 * sinh)),
          255 * (l + a * (E * cosh)),
          this.opacity
        );
      }
    }));

    function basis$1(t1, v0, v1, v2, v3) {
      var t2 = t1 * t1, t3 = t2 * t1;
      return ((1 - 3 * t1 + 3 * t2 - t3) * v0
          + (4 - 6 * t2 + 3 * t3) * v1
          + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
          + t3 * v3) / 6;
    }

    function basis$2(values) {
      var n = values.length - 1;
      return function(t) {
        var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
            v1 = values[i],
            v2 = values[i + 1],
            v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
            v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    function basisClosed$1(values) {
      var n = values.length;
      return function(t) {
        var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
            v0 = values[(i + n - 1) % n],
            v1 = values[i % n],
            v2 = values[(i + 1) % n],
            v3 = values[(i + 2) % n];
        return basis$1((t - i / n) * n, v0, v1, v2, v3);
      };
    }

    var constant$8 = x => () => x;

    function linear$2(a, d) {
      return function(t) {
        return a + t * d;
      };
    }

    function exponential$1(a, b, y) {
      return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
        return Math.pow(a + t * b, y);
      };
    }

    function hue$1(a, b) {
      var d = b - a;
      return d ? linear$2(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$8(isNaN(a) ? b : a);
    }

    function gamma$1(y) {
      return (y = +y) === 1 ? nogamma : function(a, b) {
        return b - a ? exponential$1(a, b, y) : constant$8(isNaN(a) ? b : a);
      };
    }

    function nogamma(a, b) {
      var d = b - a;
      return d ? linear$2(a, d) : constant$8(isNaN(a) ? b : a);
    }

    var interpolateRgb = (function rgbGamma(y) {
      var color = gamma$1(y);

      function rgb$1(start, end) {
        var r = color((start = rgb(start)).r, (end = rgb(end)).r),
            g = color(start.g, end.g),
            b = color(start.b, end.b),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.r = r(t);
          start.g = g(t);
          start.b = b(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }

      rgb$1.gamma = rgbGamma;

      return rgb$1;
    })(1);

    function rgbSpline(spline) {
      return function(colors) {
        var n = colors.length,
            r = new Array(n),
            g = new Array(n),
            b = new Array(n),
            i, color;
        for (i = 0; i < n; ++i) {
          color = rgb(colors[i]);
          r[i] = color.r || 0;
          g[i] = color.g || 0;
          b[i] = color.b || 0;
        }
        r = spline(r);
        g = spline(g);
        b = spline(b);
        color.opacity = 1;
        return function(t) {
          color.r = r(t);
          color.g = g(t);
          color.b = b(t);
          return color + "";
        };
      };
    }

    var rgbBasis = rgbSpline(basis$2);
    var rgbBasisClosed = rgbSpline(basisClosed$1);

    function numberArray(a, b) {
      if (!b) b = [];
      var n = a ? Math.min(b.length, a.length) : 0,
          c = b.slice(),
          i;
      return function(t) {
        for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
        return c;
      };
    }

    function isNumberArray(x) {
      return ArrayBuffer.isView(x) && !(x instanceof DataView);
    }

    function array$3(a, b) {
      return (isNumberArray(b) ? numberArray : genericArray)(a, b);
    }

    function genericArray(a, b) {
      var nb = b ? b.length : 0,
          na = a ? Math.min(nb, a.length) : 0,
          x = new Array(na),
          c = new Array(nb),
          i;

      for (i = 0; i < na; ++i) x[i] = interpolate$2(a[i], b[i]);
      for (; i < nb; ++i) c[i] = b[i];

      return function(t) {
        for (i = 0; i < na; ++i) c[i] = x[i](t);
        return c;
      };
    }

    function date$1(a, b) {
      var d = new Date;
      return a = +a, b = +b, function(t) {
        return d.setTime(a * (1 - t) + b * t), d;
      };
    }

    function interpolateNumber(a, b) {
      return a = +a, b = +b, function(t) {
        return a * (1 - t) + b * t;
      };
    }

    function object$1(a, b) {
      var i = {},
          c = {},
          k;

      if (a === null || typeof a !== "object") a = {};
      if (b === null || typeof b !== "object") b = {};

      for (k in b) {
        if (k in a) {
          i[k] = interpolate$2(a[k], b[k]);
        } else {
          c[k] = b[k];
        }
      }

      return function(t) {
        for (k in i) c[k] = i[k](t);
        return c;
      };
    }

    var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
        reB = new RegExp(reA.source, "g");

    function zero(b) {
      return function() {
        return b;
      };
    }

    function one(b) {
      return function(t) {
        return b(t) + "";
      };
    }

    function interpolateString(a, b) {
      var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
          am, // current match in a
          bm, // current match in b
          bs, // string preceding current number in b, if any
          i = -1, // index in s
          s = [], // string constants and placeholders
          q = []; // number interpolators

      // Coerce inputs to strings.
      a = a + "", b = b + "";

      // Interpolate pairs of numbers in a & b.
      while ((am = reA.exec(a))
          && (bm = reB.exec(b))) {
        if ((bs = bm.index) > bi) { // a string precedes the next number in b
          bs = b.slice(bi, bs);
          if (s[i]) s[i] += bs; // coalesce with previous string
          else s[++i] = bs;
        }
        if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
          if (s[i]) s[i] += bm; // coalesce with previous string
          else s[++i] = bm;
        } else { // interpolate non-matching numbers
          s[++i] = null;
          q.push({i: i, x: interpolateNumber(am, bm)});
        }
        bi = reB.lastIndex;
      }

      // Add remains of b.
      if (bi < b.length) {
        bs = b.slice(bi);
        if (s[i]) s[i] += bs; // coalesce with previous string
        else s[++i] = bs;
      }

      // Special optimization for only a single match.
      // Otherwise, interpolate each of the numbers and rejoin the string.
      return s.length < 2 ? (q[0]
          ? one(q[0].x)
          : zero(b))
          : (b = q.length, function(t) {
              for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
              return s.join("");
            });
    }

    function interpolate$2(a, b) {
      var t = typeof b, c;
      return b == null || t === "boolean" ? constant$8(b)
          : (t === "number" ? interpolateNumber
          : t === "string" ? ((c = color(b)) ? (b = c, interpolateRgb) : interpolateString)
          : b instanceof color ? interpolateRgb
          : b instanceof Date ? date$1
          : isNumberArray(b) ? numberArray
          : Array.isArray(b) ? genericArray
          : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1
          : interpolateNumber)(a, b);
    }

    function discrete(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    function hue(a, b) {
      var i = hue$1(+a, +b);
      return function(t) {
        var x = i(t);
        return x - 360 * Math.floor(x / 360);
      };
    }

    function interpolateRound(a, b) {
      return a = +a, b = +b, function(t) {
        return Math.round(a * (1 - t) + b * t);
      };
    }

    var degrees$1 = 180 / Math.PI;

    var identity$7 = {
      translateX: 0,
      translateY: 0,
      rotate: 0,
      skewX: 0,
      scaleX: 1,
      scaleY: 1
    };

    function decompose(a, b, c, d, e, f) {
      var scaleX, scaleY, skewX;
      if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
      if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
      if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
      if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
      return {
        translateX: e,
        translateY: f,
        rotate: Math.atan2(b, a) * degrees$1,
        skewX: Math.atan(skewX) * degrees$1,
        scaleX: scaleX,
        scaleY: scaleY
      };
    }

    var svgNode;

    /* eslint-disable no-undef */
    function parseCss(value) {
      const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
      return m.isIdentity ? identity$7 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
    }

    function parseSvg(value) {
      if (value == null) return identity$7;
      if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svgNode.setAttribute("transform", value);
      if (!(value = svgNode.transform.baseVal.consolidate())) return identity$7;
      value = value.matrix;
      return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
    }

    function interpolateTransform(parse, pxComma, pxParen, degParen) {

      function pop(s) {
        return s.length ? s.pop() + " " : "";
      }

      function translate(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push("translate(", null, pxComma, null, pxParen);
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb || yb) {
          s.push("translate(" + xb + pxComma + yb + pxParen);
        }
      }

      function rotate(a, b, s, q) {
        if (a !== b) {
          if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
          q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "rotate(" + b + degParen);
        }
      }

      function skewX(a, b, s, q) {
        if (a !== b) {
          q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
        } else if (b) {
          s.push(pop(s) + "skewX(" + b + degParen);
        }
      }

      function scale(xa, ya, xb, yb, s, q) {
        if (xa !== xb || ya !== yb) {
          var i = s.push(pop(s) + "scale(", null, ",", null, ")");
          q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
        } else if (xb !== 1 || yb !== 1) {
          s.push(pop(s) + "scale(" + xb + "," + yb + ")");
        }
      }

      return function(a, b) {
        var s = [], // string constants and placeholders
            q = []; // number interpolators
        a = parse(a), b = parse(b);
        translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
        rotate(a.rotate, b.rotate, s, q);
        skewX(a.skewX, b.skewX, s, q);
        scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
        a = b = null; // gc
        return function(t) {
          var i = -1, n = q.length, o;
          while (++i < n) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        };
      };
    }

    var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
    var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

    var epsilon2$1 = 1e-12;

    function cosh(x) {
      return ((x = Math.exp(x)) + 1 / x) / 2;
    }

    function sinh(x) {
      return ((x = Math.exp(x)) - 1 / x) / 2;
    }

    function tanh(x) {
      return ((x = Math.exp(2 * x)) - 1) / (x + 1);
    }

    var interpolateZoom = (function zoomRho(rho, rho2, rho4) {

      // p0 = [ux0, uy0, w0]
      // p1 = [ux1, uy1, w1]
      function zoom(p0, p1) {
        var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
            ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
            dx = ux1 - ux0,
            dy = uy1 - uy0,
            d2 = dx * dx + dy * dy,
            i,
            S;

        // Special case for u0  u1.
        if (d2 < epsilon2$1) {
          S = Math.log(w1 / w0) / rho;
          i = function(t) {
            return [
              ux0 + t * dx,
              uy0 + t * dy,
              w0 * Math.exp(rho * t * S)
            ];
          };
        }

        // General case.
        else {
          var d1 = Math.sqrt(d2),
              b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
              b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
              r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
              r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
          S = (r1 - r0) / rho;
          i = function(t) {
            var s = t * S,
                coshr0 = cosh(r0),
                u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
            return [
              ux0 + u * dx,
              uy0 + u * dy,
              w0 * coshr0 / cosh(rho * s + r0)
            ];
          };
        }

        i.duration = S * 1000 * rho / Math.SQRT2;

        return i;
      }

      zoom.rho = function(_) {
        var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
        return zoomRho(_1, _2, _4);
      };

      return zoom;
    })(Math.SQRT2, 2, 4);

    function hsl(hue) {
      return function(start, end) {
        var h = hue((start = hsl$2(start)).h, (end = hsl$2(end)).h),
            s = nogamma(start.s, end.s),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.s = s(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hsl$1 = hsl(hue$1);
    var hslLong = hsl(nogamma);

    function lab(start, end) {
      var l = nogamma((start = lab$1(start)).l, (end = lab$1(end)).l),
          a = nogamma(start.a, end.a),
          b = nogamma(start.b, end.b),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.l = l(t);
        start.a = a(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }

    function hcl(hue) {
      return function(start, end) {
        var h = hue((start = hcl$2(start)).h, (end = hcl$2(end)).h),
            c = nogamma(start.c, end.c),
            l = nogamma(start.l, end.l),
            opacity = nogamma(start.opacity, end.opacity);
        return function(t) {
          start.h = h(t);
          start.c = c(t);
          start.l = l(t);
          start.opacity = opacity(t);
          return start + "";
        };
      }
    }

    var hcl$1 = hcl(hue$1);
    var hclLong = hcl(nogamma);

    function cubehelix$1(hue) {
      return (function cubehelixGamma(y) {
        y = +y;

        function cubehelix(start, end) {
          var h = hue((start = cubehelix$3(start)).h, (end = cubehelix$3(end)).h),
              s = nogamma(start.s, end.s),
              l = nogamma(start.l, end.l),
              opacity = nogamma(start.opacity, end.opacity);
          return function(t) {
            start.h = h(t);
            start.s = s(t);
            start.l = l(Math.pow(t, y));
            start.opacity = opacity(t);
            return start + "";
          };
        }

        cubehelix.gamma = cubehelixGamma;

        return cubehelix;
      })(1);
    }

    var cubehelix$2 = cubehelix$1(hue$1);
    var cubehelixLong = cubehelix$1(nogamma);

    function piecewise(interpolate, values) {
      if (values === undefined) values = interpolate, interpolate = interpolate$2;
      var i = 0, n = values.length - 1, v = values[0], I = new Array(n < 0 ? 0 : n);
      while (i < n) I[i] = interpolate(v, v = values[++i]);
      return function(t) {
        var i = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
        return I[i](t - i);
      };
    }

    function quantize$1(interpolator, n) {
      var samples = new Array(n);
      for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
      return samples;
    }

    var frame = 0, // is an animation frame pending?
        timeout$1 = 0, // is a timeout pending?
        interval$1 = 0, // are any timers active?
        pokeDelay = 1000, // how frequently we check for clock skew
        taskHead,
        taskTail,
        clockLast = 0,
        clockNow = 0,
        clockSkew = 0,
        clock = typeof performance === "object" && performance.now ? performance : Date,
        setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

    function now() {
      return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
    }

    function clearNow() {
      clockNow = 0;
    }

    function Timer() {
      this._call =
      this._time =
      this._next = null;
    }

    Timer.prototype = timer.prototype = {
      constructor: Timer,
      restart: function(callback, delay, time) {
        if (typeof callback !== "function") throw new TypeError("callback is not a function");
        time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
        if (!this._next && taskTail !== this) {
          if (taskTail) taskTail._next = this;
          else taskHead = this;
          taskTail = this;
        }
        this._call = callback;
        this._time = time;
        sleep();
      },
      stop: function() {
        if (this._call) {
          this._call = null;
          this._time = Infinity;
          sleep();
        }
      }
    };

    function timer(callback, delay, time) {
      var t = new Timer;
      t.restart(callback, delay, time);
      return t;
    }

    function timerFlush() {
      now(); // Get the current time, if not already set.
      ++frame; // Pretend weve set an alarm, if we havent already.
      var t = taskHead, e;
      while (t) {
        if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
        t = t._next;
      }
      --frame;
    }

    function wake() {
      clockNow = (clockLast = clock.now()) + clockSkew;
      frame = timeout$1 = 0;
      try {
        timerFlush();
      } finally {
        frame = 0;
        nap();
        clockNow = 0;
      }
    }

    function poke() {
      var now = clock.now(), delay = now - clockLast;
      if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
    }

    function nap() {
      var t0, t1 = taskHead, t2, time = Infinity;
      while (t1) {
        if (t1._call) {
          if (time > t1._time) time = t1._time;
          t0 = t1, t1 = t1._next;
        } else {
          t2 = t1._next, t1._next = null;
          t1 = t0 ? t0._next = t2 : taskHead = t2;
        }
      }
      taskTail = t0;
      sleep(time);
    }

    function sleep(time) {
      if (frame) return; // Soonest alarm already set, or will be.
      if (timeout$1) timeout$1 = clearTimeout(timeout$1);
      var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
      if (delay > 24) {
        if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
        if (interval$1) interval$1 = clearInterval(interval$1);
      } else {
        if (!interval$1) clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
        frame = 1, setFrame(wake);
      }
    }

    function timeout(callback, delay, time) {
      var t = new Timer;
      delay = delay == null ? 0 : +delay;
      t.restart(elapsed => {
        t.stop();
        callback(elapsed + delay);
      }, delay, time);
      return t;
    }

    function interval(callback, delay, time) {
      var t = new Timer, total = delay;
      if (delay == null) return t.restart(callback, delay, time), t;
      t._restart = t.restart;
      t.restart = function(callback, delay, time) {
        delay = +delay, time = time == null ? now() : +time;
        t._restart(function tick(elapsed) {
          elapsed += total;
          t._restart(tick, total += delay, time);
          callback(elapsed);
        }, delay, time);
      };
      t.restart(callback, delay, time);
      return t;
    }

    var emptyOn = dispatch("start", "end", "cancel", "interrupt");
    var emptyTween = [];

    var CREATED = 0;
    var SCHEDULED = 1;
    var STARTING = 2;
    var STARTED = 3;
    var RUNNING = 4;
    var ENDING = 5;
    var ENDED = 6;

    function schedule(node, name, id, index, group, timing) {
      var schedules = node.__transition;
      if (!schedules) node.__transition = {};
      else if (id in schedules) return;
      create(node, id, {
        name: name,
        index: index, // For context during callback.
        group: group, // For context during callback.
        on: emptyOn,
        tween: emptyTween,
        time: timing.time,
        delay: timing.delay,
        duration: timing.duration,
        ease: timing.ease,
        timer: null,
        state: CREATED
      });
    }

    function init(node, id) {
      var schedule = get(node, id);
      if (schedule.state > CREATED) throw new Error("too late; already scheduled");
      return schedule;
    }

    function set(node, id) {
      var schedule = get(node, id);
      if (schedule.state > STARTED) throw new Error("too late; already running");
      return schedule;
    }

    function get(node, id) {
      var schedule = node.__transition;
      if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
      return schedule;
    }

    function create(node, id, self) {
      var schedules = node.__transition,
          tween;

      // Initialize the self timer when the transition is created.
      // Note the actual delay is not known until the first callback!
      schedules[id] = self;
      self.timer = timer(schedule, 0, self.time);

      function schedule(elapsed) {
        self.state = SCHEDULED;
        self.timer.restart(start, self.delay, self.time);

        // If the elapsed delay is less than our first sleep, start immediately.
        if (self.delay <= elapsed) start(elapsed - self.delay);
      }

      function start(elapsed) {
        var i, j, n, o;

        // If the state is not SCHEDULED, then we previously errored on start.
        if (self.state !== SCHEDULED) return stop();

        for (i in schedules) {
          o = schedules[i];
          if (o.name !== self.name) continue;

          // While this element already has a starting transition during this frame,
          // defer starting an interrupting transition until that transition has a
          // chance to tick (and possibly end); see d3/d3-transition#54!
          if (o.state === STARTED) return timeout(start);

          // Interrupt the active transition, if any.
          if (o.state === RUNNING) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("interrupt", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }

          // Cancel any pre-empted transitions.
          else if (+i < id) {
            o.state = ENDED;
            o.timer.stop();
            o.on.call("cancel", node, node.__data__, o.index, o.group);
            delete schedules[i];
          }
        }

        // Defer the first tick to end of the current frame; see d3/d3#1576.
        // Note the transition may be canceled after start and before the first tick!
        // Note this must be scheduled before the start event; see d3/d3-transition#16!
        // Assuming this is successful, subsequent callbacks go straight to tick.
        timeout(function() {
          if (self.state === STARTED) {
            self.state = RUNNING;
            self.timer.restart(tick, self.delay, self.time);
            tick(elapsed);
          }
        });

        // Dispatch the start event.
        // Note this must be done before the tween are initialized.
        self.state = STARTING;
        self.on.call("start", node, node.__data__, self.index, self.group);
        if (self.state !== STARTING) return; // interrupted
        self.state = STARTED;

        // Initialize the tween, deleting null tween.
        tween = new Array(n = self.tween.length);
        for (i = 0, j = -1; i < n; ++i) {
          if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
            tween[++j] = o;
          }
        }
        tween.length = j + 1;
      }

      function tick(elapsed) {
        var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
            i = -1,
            n = tween.length;

        while (++i < n) {
          tween[i].call(node, t);
        }

        // Dispatch the end event.
        if (self.state === ENDING) {
          self.on.call("end", node, node.__data__, self.index, self.group);
          stop();
        }
      }

      function stop() {
        self.state = ENDED;
        self.timer.stop();
        delete schedules[id];
        for (var i in schedules) return; // eslint-disable-line no-unused-vars
        delete node.__transition;
      }
    }

    function interrupt(node, name) {
      var schedules = node.__transition,
          schedule,
          active,
          empty = true,
          i;

      if (!schedules) return;

      name = name == null ? null : name + "";

      for (i in schedules) {
        if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
        active = schedule.state > STARTING && schedule.state < ENDING;
        schedule.state = ENDED;
        schedule.timer.stop();
        schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
        delete schedules[i];
      }

      if (empty) delete node.__transition;
    }

    function selection_interrupt(name) {
      return this.each(function() {
        interrupt(this, name);
      });
    }

    function tweenRemove(id, name) {
      var tween0, tween1;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = tween0 = tween;
          for (var i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1 = tween1.slice();
              tween1.splice(i, 1);
              break;
            }
          }
        }

        schedule.tween = tween1;
      };
    }

    function tweenFunction(id, name, value) {
      var tween0, tween1;
      if (typeof value !== "function") throw new Error;
      return function() {
        var schedule = set(this, id),
            tween = schedule.tween;

        // If this node shared tween with the previous node,
        // just assign the updated shared tween and were done!
        // Otherwise, copy-on-write.
        if (tween !== tween0) {
          tween1 = (tween0 = tween).slice();
          for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
            if (tween1[i].name === name) {
              tween1[i] = t;
              break;
            }
          }
          if (i === n) tween1.push(t);
        }

        schedule.tween = tween1;
      };
    }

    function transition_tween(name, value) {
      var id = this._id;

      name += "";

      if (arguments.length < 2) {
        var tween = get(this.node(), id).tween;
        for (var i = 0, n = tween.length, t; i < n; ++i) {
          if ((t = tween[i]).name === name) {
            return t.value;
          }
        }
        return null;
      }

      return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
    }

    function tweenValue(transition, name, value) {
      var id = transition._id;

      transition.each(function() {
        var schedule = set(this, id);
        (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
      });

      return function(node) {
        return get(node, id).value[name];
      };
    }

    function interpolate$1(a, b) {
      var c;
      return (typeof b === "number" ? interpolateNumber
          : b instanceof color ? interpolateRgb
          : (c = color(b)) ? (b = c, interpolateRgb)
          : interpolateString)(a, b);
    }

    function attrRemove(name) {
      return function() {
        this.removeAttribute(name);
      };
    }

    function attrRemoveNS(fullname) {
      return function() {
        this.removeAttributeNS(fullname.space, fullname.local);
      };
    }

    function attrConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttribute(name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrConstantNS(fullname, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = this.getAttributeNS(fullname.space, fullname.local);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function attrFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttribute(name);
        string0 = this.getAttribute(name);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function attrFunctionNS(fullname, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0, value1 = value(this), string1;
        if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
        string0 = this.getAttributeNS(fullname.space, fullname.local);
        string1 = value1 + "";
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function transition_attr(name, value) {
      var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
      return this.attrTween(name, typeof value === "function"
          ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
          : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
          : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
    }

    function attrInterpolate(name, i) {
      return function(t) {
        this.setAttribute(name, i.call(this, t));
      };
    }

    function attrInterpolateNS(fullname, i) {
      return function(t) {
        this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
      };
    }

    function attrTweenNS(fullname, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function attrTween(name, value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_attrTween(name, value) {
      var key = "attr." + name;
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      var fullname = namespace(name);
      return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
    }

    function delayFunction(id, value) {
      return function() {
        init(this, id).delay = +value.apply(this, arguments);
      };
    }

    function delayConstant(id, value) {
      return value = +value, function() {
        init(this, id).delay = value;
      };
    }

    function transition_delay(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? delayFunction
              : delayConstant)(id, value))
          : get(this.node(), id).delay;
    }

    function durationFunction(id, value) {
      return function() {
        set(this, id).duration = +value.apply(this, arguments);
      };
    }

    function durationConstant(id, value) {
      return value = +value, function() {
        set(this, id).duration = value;
      };
    }

    function transition_duration(value) {
      var id = this._id;

      return arguments.length
          ? this.each((typeof value === "function"
              ? durationFunction
              : durationConstant)(id, value))
          : get(this.node(), id).duration;
    }

    function easeConstant(id, value) {
      if (typeof value !== "function") throw new Error;
      return function() {
        set(this, id).ease = value;
      };
    }

    function transition_ease(value) {
      var id = this._id;

      return arguments.length
          ? this.each(easeConstant(id, value))
          : get(this.node(), id).ease;
    }

    function easeVarying(id, value) {
      return function() {
        var v = value.apply(this, arguments);
        if (typeof v !== "function") throw new Error;
        set(this, id).ease = v;
      };
    }

    function transition_easeVarying(value) {
      if (typeof value !== "function") throw new Error;
      return this.each(easeVarying(this._id, value));
    }

    function transition_filter(match) {
      if (typeof match !== "function") match = matcher(match);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
          if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
            subgroup.push(node);
          }
        }
      }

      return new Transition(subgroups, this._parents, this._name, this._id);
    }

    function transition_merge(transition) {
      if (transition._id !== this._id) throw new Error;

      for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
        for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
          if (node = group0[i] || group1[i]) {
            merge[i] = node;
          }
        }
      }

      for (; j < m0; ++j) {
        merges[j] = groups0[j];
      }

      return new Transition(merges, this._parents, this._name, this._id);
    }

    function start(name) {
      return (name + "").trim().split(/^|\s+/).every(function(t) {
        var i = t.indexOf(".");
        if (i >= 0) t = t.slice(0, i);
        return !t || t === "start";
      });
    }

    function onFunction(id, name, listener) {
      var on0, on1, sit = start(name) ? init : set;
      return function() {
        var schedule = sit(this, id),
            on = schedule.on;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

        schedule.on = on1;
      };
    }

    function transition_on(name, listener) {
      var id = this._id;

      return arguments.length < 2
          ? get(this.node(), id).on.on(name)
          : this.each(onFunction(id, name, listener));
    }

    function removeFunction(id) {
      return function() {
        var parent = this.parentNode;
        for (var i in this.__transition) if (+i !== id) return;
        if (parent) parent.removeChild(this);
      };
    }

    function transition_remove() {
      return this.on("end.remove", removeFunction(this._id));
    }

    function transition_select(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selector(select);

      for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
          if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
            if ("__data__" in node) subnode.__data__ = node.__data__;
            subgroup[i] = subnode;
            schedule(subgroup[i], name, id, i, subgroup, get(node, id));
          }
        }
      }

      return new Transition(subgroups, this._parents, name, id);
    }

    function transition_selectAll(select) {
      var name = this._name,
          id = this._id;

      if (typeof select !== "function") select = selectorAll(select);

      for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
              if (child = children[k]) {
                schedule(child, name, id, k, children, inherit);
              }
            }
            subgroups.push(children);
            parents.push(node);
          }
        }
      }

      return new Transition(subgroups, parents, name, id);
    }

    var Selection = selection.prototype.constructor;

    function transition_selection() {
      return new Selection(this._groups, this._parents);
    }

    function styleNull(name, interpolate) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            string1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, string10 = string1);
      };
    }

    function styleRemove(name) {
      return function() {
        this.style.removeProperty(name);
      };
    }

    function styleConstant(name, interpolate, value1) {
      var string00,
          string1 = value1 + "",
          interpolate0;
      return function() {
        var string0 = styleValue(this, name);
        return string0 === string1 ? null
            : string0 === string00 ? interpolate0
            : interpolate0 = interpolate(string00 = string0, value1);
      };
    }

    function styleFunction(name, interpolate, value) {
      var string00,
          string10,
          interpolate0;
      return function() {
        var string0 = styleValue(this, name),
            value1 = value(this),
            string1 = value1 + "";
        if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
        return string0 === string1 ? null
            : string0 === string00 && string1 === string10 ? interpolate0
            : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
      };
    }

    function styleMaybeRemove(id, name) {
      var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
      return function() {
        var schedule = set(this, id),
            on = schedule.on,
            listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

        // If this node shared a dispatch with the previous node,
        // just assign the updated shared dispatch and were done!
        // Otherwise, copy-on-write.
        if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

        schedule.on = on1;
      };
    }

    function transition_style(name, value, priority) {
      var i = (name += "") === "transform" ? interpolateTransformCss : interpolate$1;
      return value == null ? this
          .styleTween(name, styleNull(name, i))
          .on("end.style." + name, styleRemove(name))
        : typeof value === "function" ? this
          .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
          .each(styleMaybeRemove(this._id, name))
        : this
          .styleTween(name, styleConstant(name, i, value), priority)
          .on("end.style." + name, null);
    }

    function styleInterpolate(name, i, priority) {
      return function(t) {
        this.style.setProperty(name, i.call(this, t), priority);
      };
    }

    function styleTween(name, value, priority) {
      var t, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
        return t;
      }
      tween._value = value;
      return tween;
    }

    function transition_styleTween(name, value, priority) {
      var key = "style." + (name += "");
      if (arguments.length < 2) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
    }

    function textConstant(value) {
      return function() {
        this.textContent = value;
      };
    }

    function textFunction(value) {
      return function() {
        var value1 = value(this);
        this.textContent = value1 == null ? "" : value1;
      };
    }

    function transition_text(value) {
      return this.tween("text", typeof value === "function"
          ? textFunction(tweenValue(this, "text", value))
          : textConstant(value == null ? "" : value + ""));
    }

    function textInterpolate(i) {
      return function(t) {
        this.textContent = i.call(this, t);
      };
    }

    function textTween(value) {
      var t0, i0;
      function tween() {
        var i = value.apply(this, arguments);
        if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
        return t0;
      }
      tween._value = value;
      return tween;
    }

    function transition_textTween(value) {
      var key = "text";
      if (arguments.length < 1) return (key = this.tween(key)) && key._value;
      if (value == null) return this.tween(key, null);
      if (typeof value !== "function") throw new Error;
      return this.tween(key, textTween(value));
    }

    function transition_transition() {
      var name = this._name,
          id0 = this._id,
          id1 = newId();

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            var inherit = get(node, id0);
            schedule(node, name, id1, i, group, {
              time: inherit.time + inherit.delay + inherit.duration,
              delay: 0,
              duration: inherit.duration,
              ease: inherit.ease
            });
          }
        }
      }

      return new Transition(groups, this._parents, name, id1);
    }

    function transition_end() {
      var on0, on1, that = this, id = that._id, size = that.size();
      return new Promise(function(resolve, reject) {
        var cancel = {value: reject},
            end = {value: function() { if (--size === 0) resolve(); }};

        that.each(function() {
          var schedule = set(this, id),
              on = schedule.on;

          // If this node shared a dispatch with the previous node,
          // just assign the updated shared dispatch and were done!
          // Otherwise, copy-on-write.
          if (on !== on0) {
            on1 = (on0 = on).copy();
            on1._.cancel.push(cancel);
            on1._.interrupt.push(cancel);
            on1._.end.push(end);
          }

          schedule.on = on1;
        });

        // The selection was empty, resolve end immediately
        if (size === 0) resolve();
      });
    }

    var id = 0;

    function Transition(groups, parents, name, id) {
      this._groups = groups;
      this._parents = parents;
      this._name = name;
      this._id = id;
    }

    function transition(name) {
      return selection().transition(name);
    }

    function newId() {
      return ++id;
    }

    var selection_prototype = selection.prototype;

    Transition.prototype = transition.prototype = {
      constructor: Transition,
      select: transition_select,
      selectAll: transition_selectAll,
      selectChild: selection_prototype.selectChild,
      selectChildren: selection_prototype.selectChildren,
      filter: transition_filter,
      merge: transition_merge,
      selection: transition_selection,
      transition: transition_transition,
      call: selection_prototype.call,
      nodes: selection_prototype.nodes,
      node: selection_prototype.node,
      size: selection_prototype.size,
      empty: selection_prototype.empty,
      each: selection_prototype.each,
      on: transition_on,
      attr: transition_attr,
      attrTween: transition_attrTween,
      style: transition_style,
      styleTween: transition_styleTween,
      text: transition_text,
      textTween: transition_textTween,
      remove: transition_remove,
      tween: transition_tween,
      delay: transition_delay,
      duration: transition_duration,
      ease: transition_ease,
      easeVarying: transition_easeVarying,
      end: transition_end,
      [Symbol.iterator]: selection_prototype[Symbol.iterator]
    };

    const linear$1 = t => +t;

    function quadIn(t) {
      return t * t;
    }

    function quadOut(t) {
      return t * (2 - t);
    }

    function quadInOut(t) {
      return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
    }

    function cubicIn(t) {
      return t * t * t;
    }

    function cubicOut(t) {
      return --t * t * t + 1;
    }

    function cubicInOut(t) {
      return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
    }

    var exponent$1 = 3;

    var polyIn = (function custom(e) {
      e = +e;

      function polyIn(t) {
        return Math.pow(t, e);
      }

      polyIn.exponent = custom;

      return polyIn;
    })(exponent$1);

    var polyOut = (function custom(e) {
      e = +e;

      function polyOut(t) {
        return 1 - Math.pow(1 - t, e);
      }

      polyOut.exponent = custom;

      return polyOut;
    })(exponent$1);

    var polyInOut = (function custom(e) {
      e = +e;

      function polyInOut(t) {
        return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
      }

      polyInOut.exponent = custom;

      return polyInOut;
    })(exponent$1);

    var pi$4 = Math.PI,
        halfPi$3 = pi$4 / 2;

    function sinIn(t) {
      return (+t === 1) ? 1 : 1 - Math.cos(t * halfPi$3);
    }

    function sinOut(t) {
      return Math.sin(t * halfPi$3);
    }

    function sinInOut(t) {
      return (1 - Math.cos(pi$4 * t)) / 2;
    }

    // tpmt is two power minus ten times t scaled to [0,1]
    function tpmt(x) {
      return (Math.pow(2, -10 * x) - 0.0009765625) * 1.0009775171065494;
    }

    function expIn(t) {
      return tpmt(1 - +t);
    }

    function expOut(t) {
      return 1 - tpmt(t);
    }

    function expInOut(t) {
      return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
    }

    function circleIn(t) {
      return 1 - Math.sqrt(1 - t * t);
    }

    function circleOut(t) {
      return Math.sqrt(1 - --t * t);
    }

    function circleInOut(t) {
      return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
    }

    var b1 = 4 / 11,
        b2 = 6 / 11,
        b3 = 8 / 11,
        b4 = 3 / 4,
        b5 = 9 / 11,
        b6 = 10 / 11,
        b7 = 15 / 16,
        b8 = 21 / 22,
        b9 = 63 / 64,
        b0 = 1 / b1 / b1;

    function bounceIn(t) {
      return 1 - bounceOut(1 - t);
    }

    function bounceOut(t) {
      return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
    }

    function bounceInOut(t) {
      return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
    }

    var overshoot = 1.70158;

    var backIn = (function custom(s) {
      s = +s;

      function backIn(t) {
        return (t = +t) * t * (s * (t - 1) + t);
      }

      backIn.overshoot = custom;

      return backIn;
    })(overshoot);

    var backOut = (function custom(s) {
      s = +s;

      function backOut(t) {
        return --t * t * ((t + 1) * s + t) + 1;
      }

      backOut.overshoot = custom;

      return backOut;
    })(overshoot);

    var backInOut = (function custom(s) {
      s = +s;

      function backInOut(t) {
        return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
      }

      backInOut.overshoot = custom;

      return backInOut;
    })(overshoot);

    var tau$5 = 2 * Math.PI,
        amplitude = 1,
        period = 0.3;

    var elasticIn = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticIn(t) {
        return a * tpmt(-(--t)) * Math.sin((s - t) / p);
      }

      elasticIn.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticIn.period = function(p) { return custom(a, p); };

      return elasticIn;
    })(amplitude, period);

    var elasticOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticOut(t) {
        return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
      }

      elasticOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticOut.period = function(p) { return custom(a, p); };

      return elasticOut;
    })(amplitude, period);

    var elasticInOut = (function custom(a, p) {
      var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau$5);

      function elasticInOut(t) {
        return ((t = t * 2 - 1) < 0
            ? a * tpmt(-t) * Math.sin((s - t) / p)
            : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
      }

      elasticInOut.amplitude = function(a) { return custom(a, p * tau$5); };
      elasticInOut.period = function(p) { return custom(a, p); };

      return elasticInOut;
    })(amplitude, period);

    var defaultTiming = {
      time: null, // Set on use.
      delay: 0,
      duration: 250,
      ease: cubicInOut
    };

    function inherit(node, id) {
      var timing;
      while (!(timing = node.__transition) || !(timing = timing[id])) {
        if (!(node = node.parentNode)) {
          throw new Error(`transition ${id} not found`);
        }
      }
      return timing;
    }

    function selection_transition(name) {
      var id,
          timing;

      if (name instanceof Transition) {
        id = name._id, name = name._name;
      } else {
        id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
      }

      for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
        for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
          if (node = group[i]) {
            schedule(node, name, id, i, group, timing || inherit(node, id));
          }
        }
      }

      return new Transition(groups, this._parents, name, id);
    }

    selection.prototype.interrupt = selection_interrupt;
    selection.prototype.transition = selection_transition;

    var root = [null];

    function active(node, name) {
      var schedules = node.__transition,
          schedule,
          i;

      if (schedules) {
        name = name == null ? null : name + "";
        for (i in schedules) {
          if ((schedule = schedules[i]).state > SCHEDULED && schedule.name === name) {
            return new Transition([[node]], root, name, +i);
          }
        }
      }

      return null;
    }

    var constant$7 = x => () => x;

    function BrushEvent(type, {
      sourceEvent,
      target,
      selection,
      mode,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        selection: {value: selection, enumerable: true, configurable: true},
        mode: {value: mode, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function nopropagation$1(event) {
      event.stopImmediatePropagation();
    }

    function noevent$1(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    var MODE_DRAG = {name: "drag"},
        MODE_SPACE = {name: "space"},
        MODE_HANDLE = {name: "handle"},
        MODE_CENTER = {name: "center"};

    const {abs: abs$3, max: max$2, min: min$1} = Math;

    function number1(e) {
      return [+e[0], +e[1]];
    }

    function number2(e) {
      return [number1(e[0]), number1(e[1])];
    }

    var X = {
      name: "x",
      handles: ["w", "e"].map(type),
      input: function(x, e) { return x == null ? null : [[+x[0], e[0][1]], [+x[1], e[1][1]]]; },
      output: function(xy) { return xy && [xy[0][0], xy[1][0]]; }
    };

    var Y = {
      name: "y",
      handles: ["n", "s"].map(type),
      input: function(y, e) { return y == null ? null : [[e[0][0], +y[0]], [e[1][0], +y[1]]]; },
      output: function(xy) { return xy && [xy[0][1], xy[1][1]]; }
    };

    var XY = {
      name: "xy",
      handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type),
      input: function(xy) { return xy == null ? null : number2(xy); },
      output: function(xy) { return xy; }
    };

    var cursors = {
      overlay: "crosshair",
      selection: "move",
      n: "ns-resize",
      e: "ew-resize",
      s: "ns-resize",
      w: "ew-resize",
      nw: "nwse-resize",
      ne: "nesw-resize",
      se: "nwse-resize",
      sw: "nesw-resize"
    };

    var flipX = {
      e: "w",
      w: "e",
      nw: "ne",
      ne: "nw",
      se: "sw",
      sw: "se"
    };

    var flipY = {
      n: "s",
      s: "n",
      nw: "sw",
      ne: "se",
      se: "ne",
      sw: "nw"
    };

    var signsX = {
      overlay: +1,
      selection: +1,
      n: null,
      e: +1,
      s: null,
      w: -1,
      nw: -1,
      ne: +1,
      se: +1,
      sw: -1
    };

    var signsY = {
      overlay: +1,
      selection: +1,
      n: -1,
      e: null,
      s: +1,
      w: null,
      nw: -1,
      ne: -1,
      se: +1,
      sw: +1
    };

    function type(t) {
      return {type: t};
    }

    // Ignore right-click, since that should open the context menu.
    function defaultFilter$1(event) {
      return !event.ctrlKey && !event.button;
    }

    function defaultExtent$1() {
      var svg = this.ownerSVGElement || this;
      if (svg.hasAttribute("viewBox")) {
        svg = svg.viewBox.baseVal;
        return [[svg.x, svg.y], [svg.x + svg.width, svg.y + svg.height]];
      }
      return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
    }

    function defaultTouchable$1() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    // Like d3.local, but with the name __brush rather than auto-generated.
    function local(node) {
      while (!node.__brush) if (!(node = node.parentNode)) return;
      return node.__brush;
    }

    function empty(extent) {
      return extent[0][0] === extent[1][0]
          || extent[0][1] === extent[1][1];
    }

    function brushSelection(node) {
      var state = node.__brush;
      return state ? state.dim.output(state.selection) : null;
    }

    function brushX() {
      return brush$1(X);
    }

    function brushY() {
      return brush$1(Y);
    }

    function brush() {
      return brush$1(XY);
    }

    function brush$1(dim) {
      var extent = defaultExtent$1,
          filter = defaultFilter$1,
          touchable = defaultTouchable$1,
          keys = true,
          listeners = dispatch("start", "brush", "end"),
          handleSize = 6,
          touchending;

      function brush(group) {
        var overlay = group
            .property("__brush", initialize)
          .selectAll(".overlay")
          .data([type("overlay")]);

        overlay.enter().append("rect")
            .attr("class", "overlay")
            .attr("pointer-events", "all")
            .attr("cursor", cursors.overlay)
          .merge(overlay)
            .each(function() {
              var extent = local(this).extent;
              select(this)
                  .attr("x", extent[0][0])
                  .attr("y", extent[0][1])
                  .attr("width", extent[1][0] - extent[0][0])
                  .attr("height", extent[1][1] - extent[0][1]);
            });

        group.selectAll(".selection")
          .data([type("selection")])
          .enter().append("rect")
            .attr("class", "selection")
            .attr("cursor", cursors.selection)
            .attr("fill", "#777")
            .attr("fill-opacity", 0.3)
            .attr("stroke", "#fff")
            .attr("shape-rendering", "crispEdges");

        var handle = group.selectAll(".handle")
          .data(dim.handles, function(d) { return d.type; });

        handle.exit().remove();

        handle.enter().append("rect")
            .attr("class", function(d) { return "handle handle--" + d.type; })
            .attr("cursor", function(d) { return cursors[d.type]; });

        group
            .each(redraw)
            .attr("fill", "none")
            .attr("pointer-events", "all")
            .on("mousedown.brush", started)
          .filter(touchable)
            .on("touchstart.brush", started)
            .on("touchmove.brush", touchmoved)
            .on("touchend.brush touchcancel.brush", touchended)
            .style("touch-action", "none")
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      brush.move = function(group, selection, event) {
        if (group.tween) {
          group
              .on("start.brush", function(event) { emitter(this, arguments).beforestart().start(event); })
              .on("interrupt.brush end.brush", function(event) { emitter(this, arguments).end(event); })
              .tween("brush", function() {
                var that = this,
                    state = that.__brush,
                    emit = emitter(that, arguments),
                    selection0 = state.selection,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
                    i = interpolate$2(selection0, selection1);

                function tween(t) {
                  state.selection = t === 1 && selection1 === null ? null : i(t);
                  redraw.call(that);
                  emit.brush();
                }

                return selection0 !== null && selection1 !== null ? tween : tween(1);
              });
        } else {
          group
              .each(function() {
                var that = this,
                    args = arguments,
                    state = that.__brush,
                    selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
                    emit = emitter(that, args).beforestart();

                interrupt(that);
                state.selection = selection1 === null ? null : selection1;
                redraw.call(that);
                emit.start(event).brush(event).end(event);
              });
        }
      };

      brush.clear = function(group, event) {
        brush.move(group, null, event);
      };

      function redraw() {
        var group = select(this),
            selection = local(this).selection;

        if (selection) {
          group.selectAll(".selection")
              .style("display", null)
              .attr("x", selection[0][0])
              .attr("y", selection[0][1])
              .attr("width", selection[1][0] - selection[0][0])
              .attr("height", selection[1][1] - selection[0][1]);

          group.selectAll(".handle")
              .style("display", null)
              .attr("x", function(d) { return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2; })
              .attr("y", function(d) { return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2; })
              .attr("width", function(d) { return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize; })
              .attr("height", function(d) { return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize; });
        }

        else {
          group.selectAll(".selection,.handle")
              .style("display", "none")
              .attr("x", null)
              .attr("y", null)
              .attr("width", null)
              .attr("height", null);
        }
      }

      function emitter(that, args, clean) {
        var emit = that.__brush.emitter;
        return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
      }

      function Emitter(that, args, clean) {
        this.that = that;
        this.args = args;
        this.state = that.__brush;
        this.active = 0;
        this.clean = clean;
      }

      Emitter.prototype = {
        beforestart: function() {
          if (++this.active === 1) this.state.emitter = this, this.starting = true;
          return this;
        },
        start: function(event, mode) {
          if (this.starting) this.starting = false, this.emit("start", event, mode);
          else this.emit("brush", event);
          return this;
        },
        brush: function(event, mode) {
          this.emit("brush", event, mode);
          return this;
        },
        end: function(event, mode) {
          if (--this.active === 0) delete this.state.emitter, this.emit("end", event, mode);
          return this;
        },
        emit: function(type, event, mode) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new BrushEvent(type, {
              sourceEvent: event,
              target: brush,
              selection: dim.output(this.state.selection),
              mode,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function started(event) {
        if (touchending && !event.touches) return;
        if (!filter.apply(this, arguments)) return;

        var that = this,
            type = event.target.__data__.type,
            mode = (keys && event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : (keys && event.altKey ? MODE_CENTER : MODE_HANDLE),
            signX = dim === Y ? null : signsX[type],
            signY = dim === X ? null : signsY[type],
            state = local(that),
            extent = state.extent,
            selection = state.selection,
            W = extent[0][0], w0, w1,
            N = extent[0][1], n0, n1,
            E = extent[1][0], e0, e1,
            S = extent[1][1], s0, s1,
            dx = 0,
            dy = 0,
            moving,
            shifting = signX && signY && keys && event.shiftKey,
            lockX,
            lockY,
            points = Array.from(event.touches || [event], t => {
              const i = t.identifier;
              t = pointer(t, that);
              t.point0 = t.slice();
              t.identifier = i;
              return t;
            });

        interrupt(that);
        var emit = emitter(that, arguments, true).beforestart();

        if (type === "overlay") {
          if (selection) moving = true;
          const pts = [points[0], points[1] || points[0]];
          state.selection = selection = [[
              w0 = dim === Y ? W : min$1(pts[0][0], pts[1][0]),
              n0 = dim === X ? N : min$1(pts[0][1], pts[1][1])
            ], [
              e0 = dim === Y ? E : max$2(pts[0][0], pts[1][0]),
              s0 = dim === X ? S : max$2(pts[0][1], pts[1][1])
            ]];
          if (points.length > 1) move(event);
        } else {
          w0 = selection[0][0];
          n0 = selection[0][1];
          e0 = selection[1][0];
          s0 = selection[1][1];
        }

        w1 = w0;
        n1 = n0;
        e1 = e0;
        s1 = s0;

        var group = select(that)
            .attr("pointer-events", "none");

        var overlay = group.selectAll(".overlay")
            .attr("cursor", cursors[type]);

        if (event.touches) {
          emit.moved = moved;
          emit.ended = ended;
        } else {
          var view = select(event.view)
              .on("mousemove.brush", moved, true)
              .on("mouseup.brush", ended, true);
          if (keys) view
              .on("keydown.brush", keydowned, true)
              .on("keyup.brush", keyupped, true);

          dragDisable(event.view);
        }

        redraw.call(that);
        emit.start(event, mode.name);

        function moved(event) {
          for (const p of event.changedTouches || [event]) {
            for (const d of points)
              if (d.identifier === p.identifier) d.cur = pointer(p, that);
          }
          if (shifting && !lockX && !lockY && points.length === 1) {
            const point = points[0];
            if (abs$3(point.cur[0] - point[0]) > abs$3(point.cur[1] - point[1]))
              lockY = true;
            else
              lockX = true;
          }
          for (const point of points)
            if (point.cur) point[0] = point.cur[0], point[1] = point.cur[1];
          moving = true;
          noevent$1(event);
          move(event);
        }

        function move(event) {
          const point = points[0], point0 = point.point0;
          var t;

          dx = point[0] - point0[0];
          dy = point[1] - point0[1];

          switch (mode) {
            case MODE_SPACE:
            case MODE_DRAG: {
              if (signX) dx = max$2(W - w0, min$1(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
              if (signY) dy = max$2(N - n0, min$1(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
              break;
            }
            case MODE_HANDLE: {
              if (points[1]) {
                if (signX) w1 = max$2(W, min$1(E, points[0][0])), e1 = max$2(W, min$1(E, points[1][0])), signX = 1;
                if (signY) n1 = max$2(N, min$1(S, points[0][1])), s1 = max$2(N, min$1(S, points[1][1])), signY = 1;
              } else {
                if (signX < 0) dx = max$2(W - w0, min$1(E - w0, dx)), w1 = w0 + dx, e1 = e0;
                else if (signX > 0) dx = max$2(W - e0, min$1(E - e0, dx)), w1 = w0, e1 = e0 + dx;
                if (signY < 0) dy = max$2(N - n0, min$1(S - n0, dy)), n1 = n0 + dy, s1 = s0;
                else if (signY > 0) dy = max$2(N - s0, min$1(S - s0, dy)), n1 = n0, s1 = s0 + dy;
              }
              break;
            }
            case MODE_CENTER: {
              if (signX) w1 = max$2(W, min$1(E, w0 - dx * signX)), e1 = max$2(W, min$1(E, e0 + dx * signX));
              if (signY) n1 = max$2(N, min$1(S, n0 - dy * signY)), s1 = max$2(N, min$1(S, s0 + dy * signY));
              break;
            }
          }

          if (e1 < w1) {
            signX *= -1;
            t = w0, w0 = e0, e0 = t;
            t = w1, w1 = e1, e1 = t;
            if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
          }

          if (s1 < n1) {
            signY *= -1;
            t = n0, n0 = s0, s0 = t;
            t = n1, n1 = s1, s1 = t;
            if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
          }

          if (state.selection) selection = state.selection; // May be set by brush.move!
          if (lockX) w1 = selection[0][0], e1 = selection[1][0];
          if (lockY) n1 = selection[0][1], s1 = selection[1][1];

          if (selection[0][0] !== w1
              || selection[0][1] !== n1
              || selection[1][0] !== e1
              || selection[1][1] !== s1) {
            state.selection = [[w1, n1], [e1, s1]];
            redraw.call(that);
            emit.brush(event, mode.name);
          }
        }

        function ended(event) {
          nopropagation$1(event);
          if (event.touches) {
            if (event.touches.length) return;
            if (touchending) clearTimeout(touchending);
            touchending = setTimeout(function() { touchending = null; }, 500); // Ghost clicks are delayed!
          } else {
            yesdrag(event.view, moving);
            view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
          }
          group.attr("pointer-events", "all");
          overlay.attr("cursor", cursors.overlay);
          if (state.selection) selection = state.selection; // May be set by brush.move (on start)!
          if (empty(selection)) state.selection = null, redraw.call(that);
          emit.end(event, mode.name);
        }

        function keydowned(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              shifting = signX && signY;
              break;
            }
            case 18: { // ALT
              if (mode === MODE_HANDLE) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
                move(event);
              }
              break;
            }
            case 32: { // SPACE; takes priority over ALT
              if (mode === MODE_HANDLE || mode === MODE_CENTER) {
                if (signX < 0) e0 = e1 - dx; else if (signX > 0) w0 = w1 - dx;
                if (signY < 0) s0 = s1 - dy; else if (signY > 0) n0 = n1 - dy;
                mode = MODE_SPACE;
                overlay.attr("cursor", cursors.selection);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }

        function keyupped(event) {
          switch (event.keyCode) {
            case 16: { // SHIFT
              if (shifting) {
                lockX = lockY = shifting = false;
                move(event);
              }
              break;
            }
            case 18: { // ALT
              if (mode === MODE_CENTER) {
                if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
                move(event);
              }
              break;
            }
            case 32: { // SPACE
              if (mode === MODE_SPACE) {
                if (event.altKey) {
                  if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                  if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                  mode = MODE_CENTER;
                } else {
                  if (signX < 0) e0 = e1; else if (signX > 0) w0 = w1;
                  if (signY < 0) s0 = s1; else if (signY > 0) n0 = n1;
                  mode = MODE_HANDLE;
                }
                overlay.attr("cursor", cursors[type]);
                move(event);
              }
              break;
            }
            default: return;
          }
          noevent$1(event);
        }
      }

      function touchmoved(event) {
        emitter(this, arguments).moved(event);
      }

      function touchended(event) {
        emitter(this, arguments).ended(event);
      }

      function initialize() {
        var state = this.__brush || {selection: null};
        state.extent = number2(extent.apply(this, arguments));
        state.dim = dim;
        return state;
      }

      brush.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant$7(number2(_)), brush) : extent;
      };

      brush.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant$7(!!_), brush) : filter;
      };

      brush.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant$7(!!_), brush) : touchable;
      };

      brush.handleSize = function(_) {
        return arguments.length ? (handleSize = +_, brush) : handleSize;
      };

      brush.keyModifiers = function(_) {
        return arguments.length ? (keys = !!_, brush) : keys;
      };

      brush.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? brush : value;
      };

      return brush;
    }

    var abs$2 = Math.abs;
    var cos$2 = Math.cos;
    var sin$2 = Math.sin;
    var pi$3 = Math.PI;
    var halfPi$2 = pi$3 / 2;
    var tau$4 = pi$3 * 2;
    var max$1 = Math.max;
    var epsilon$5 = 1e-12;

    function range$1(i, j) {
      return Array.from({length: j - i}, (_, k) => i + k);
    }

    function compareValue(compare) {
      return function(a, b) {
        return compare(
          a.source.value + a.target.value,
          b.source.value + b.target.value
        );
      };
    }

    function chord() {
      return chord$1(false, false);
    }

    function chordTranspose() {
      return chord$1(false, true);
    }

    function chordDirected() {
      return chord$1(true, false);
    }

    function chord$1(directed, transpose) {
      var padAngle = 0,
          sortGroups = null,
          sortSubgroups = null,
          sortChords = null;

      function chord(matrix) {
        var n = matrix.length,
            groupSums = new Array(n),
            groupIndex = range$1(0, n),
            chords = new Array(n * n),
            groups = new Array(n),
            k = 0, dx;

        matrix = Float64Array.from({length: n * n}, transpose
            ? (_, i) => matrix[i % n][i / n | 0]
            : (_, i) => matrix[i / n | 0][i % n]);

        // Compute the scaling factor from value to angle in [0, 2pi].
        for (let i = 0; i < n; ++i) {
          let x = 0;
          for (let j = 0; j < n; ++j) x += matrix[i * n + j] + directed * matrix[j * n + i];
          k += groupSums[i] = x;
        }
        k = max$1(0, tau$4 - padAngle * n) / k;
        dx = k ? padAngle : tau$4 / n;

        // Compute the angles for each group and constituent chord.
        {
          let x = 0;
          if (sortGroups) groupIndex.sort((a, b) => sortGroups(groupSums[a], groupSums[b]));
          for (const i of groupIndex) {
            const x0 = x;
            if (directed) {
              const subgroupIndex = range$1(~n + 1, n).filter(j => j < 0 ? matrix[~j * n + i] : matrix[i * n + j]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(a < 0 ? -matrix[~a * n + i] : matrix[i * n + a], b < 0 ? -matrix[~b * n + i] : matrix[i * n + b]));
              for (const j of subgroupIndex) {
                if (j < 0) {
                  const chord = chords[~j * n + i] || (chords[~j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[~j * n + i] * k, value: matrix[~j * n + i]};
                } else {
                  const chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            } else {
              const subgroupIndex = range$1(0, n).filter(j => matrix[i * n + j] || matrix[j * n + i]);
              if (sortSubgroups) subgroupIndex.sort((a, b) => sortSubgroups(matrix[i * n + a], matrix[i * n + b]));
              for (const j of subgroupIndex) {
                let chord;
                if (i < j) {
                  chord = chords[i * n + j] || (chords[i * n + j] = {source: null, target: null});
                  chord.source = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                } else {
                  chord = chords[j * n + i] || (chords[j * n + i] = {source: null, target: null});
                  chord.target = {index: i, startAngle: x, endAngle: x += matrix[i * n + j] * k, value: matrix[i * n + j]};
                  if (i === j) chord.source = chord.target;
                }
                if (chord.source && chord.target && chord.source.value < chord.target.value) {
                  const source = chord.source;
                  chord.source = chord.target;
                  chord.target = source;
                }
              }
              groups[i] = {index: i, startAngle: x0, endAngle: x, value: groupSums[i]};
            }
            x += dx;
          }
        }

        // Remove empty chords.
        chords = Object.values(chords);
        chords.groups = groups;
        return sortChords ? chords.sort(sortChords) : chords;
      }

      chord.padAngle = function(_) {
        return arguments.length ? (padAngle = max$1(0, _), chord) : padAngle;
      };

      chord.sortGroups = function(_) {
        return arguments.length ? (sortGroups = _, chord) : sortGroups;
      };

      chord.sortSubgroups = function(_) {
        return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
      };

      chord.sortChords = function(_) {
        return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
      };

      return chord;
    }

    const pi$2 = Math.PI,
        tau$3 = 2 * pi$2,
        epsilon$4 = 1e-6,
        tauEpsilon = tau$3 - epsilon$4;

    function Path$1() {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null; // end of current subpath
      this._ = "";
    }

    function path() {
      return new Path$1;
    }

    Path$1.prototype = path.prototype = {
      constructor: Path$1,
      moveTo: function(x, y) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
      },
      closePath: function() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      },
      lineTo: function(x, y) {
        this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      quadraticCurveTo: function(x1, y1, x, y) {
        this._ += "Q" + (+x1) + "," + (+y1) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) {
        this._ += "C" + (+x1) + "," + (+y1) + "," + (+x2) + "," + (+y2) + "," + (this._x1 = +x) + "," + (this._y1 = +y);
      },
      arcTo: function(x1, y1, x2, y2, r) {
        x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
        var x0 = this._x1,
            y0 = this._y1,
            x21 = x2 - x1,
            y21 = y2 - y1,
            x01 = x0 - x1,
            y01 = y0 - y1,
            l01_2 = x01 * x01 + y01 * y01;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x1,y1).
        if (this._x1 === null) {
          this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
        else if (!(l01_2 > epsilon$4));

        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
        // Equivalently, is (x1,y1) coincident with (x2,y2)?
        // Or, is the radius zero? Line to (x1,y1).
        else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$4) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        }

        // Otherwise, draw an arc!
        else {
          var x20 = x2 - x0,
              y20 = y2 - y0,
              l21_2 = x21 * x21 + y21 * y21,
              l20_2 = x20 * x20 + y20 * y20,
              l21 = Math.sqrt(l21_2),
              l01 = Math.sqrt(l01_2),
              l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
              t01 = l / l01,
              t21 = l / l21;

          // If the start tangent is not coincident with (x0,y0), line to.
          if (Math.abs(t01 - 1) > epsilon$4) {
            this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
          }

          this._ += "A" + r + "," + r + ",0,0," + (+(y01 * x20 > x01 * y20)) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
        }
      },
      arc: function(x, y, r, a0, a1, ccw) {
        x = +x, y = +y, r = +r, ccw = !!ccw;
        var dx = r * Math.cos(a0),
            dy = r * Math.sin(a0),
            x0 = x + dx,
            y0 = y + dy,
            cw = 1 ^ ccw,
            da = ccw ? a0 - a1 : a1 - a0;

        // Is the radius negative? Error.
        if (r < 0) throw new Error("negative radius: " + r);

        // Is this path empty? Move to (x0,y0).
        if (this._x1 === null) {
          this._ += "M" + x0 + "," + y0;
        }

        // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
        else if (Math.abs(this._x1 - x0) > epsilon$4 || Math.abs(this._y1 - y0) > epsilon$4) {
          this._ += "L" + x0 + "," + y0;
        }

        // Is this arc empty? Were done.
        if (!r) return;

        // Does the angle go the wrong way? Flip the direction.
        if (da < 0) da = da % tau$3 + tau$3;

        // Is this a complete circle? Draw two arcs to complete the circle.
        if (da > tauEpsilon) {
          this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
        }

        // Is this arc non-empty? Draw an arc!
        else if (da > epsilon$4) {
          this._ += "A" + r + "," + r + ",0," + (+(da >= pi$2)) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
        }
      },
      rect: function(x, y, w, h) {
        this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + (+w) + "v" + (+h) + "h" + (-w) + "Z";
      },
      toString: function() {
        return this._;
      }
    };

    var slice$2 = Array.prototype.slice;

    function constant$6(x) {
      return function() {
        return x;
      };
    }

    function defaultSource$1(d) {
      return d.source;
    }

    function defaultTarget(d) {
      return d.target;
    }

    function defaultRadius$1(d) {
      return d.radius;
    }

    function defaultStartAngle(d) {
      return d.startAngle;
    }

    function defaultEndAngle(d) {
      return d.endAngle;
    }

    function defaultPadAngle() {
      return 0;
    }

    function defaultArrowheadRadius() {
      return 10;
    }

    function ribbon(headRadius) {
      var source = defaultSource$1,
          target = defaultTarget,
          sourceRadius = defaultRadius$1,
          targetRadius = defaultRadius$1,
          startAngle = defaultStartAngle,
          endAngle = defaultEndAngle,
          padAngle = defaultPadAngle,
          context = null;

      function ribbon() {
        var buffer,
            s = source.apply(this, arguments),
            t = target.apply(this, arguments),
            ap = padAngle.apply(this, arguments) / 2,
            argv = slice$2.call(arguments),
            sr = +sourceRadius.apply(this, (argv[0] = s, argv)),
            sa0 = startAngle.apply(this, argv) - halfPi$2,
            sa1 = endAngle.apply(this, argv) - halfPi$2,
            tr = +targetRadius.apply(this, (argv[0] = t, argv)),
            ta0 = startAngle.apply(this, argv) - halfPi$2,
            ta1 = endAngle.apply(this, argv) - halfPi$2;

        if (!context) context = buffer = path();

        if (ap > epsilon$5) {
          if (abs$2(sa1 - sa0) > ap * 2 + epsilon$5) sa1 > sa0 ? (sa0 += ap, sa1 -= ap) : (sa0 -= ap, sa1 += ap);
          else sa0 = sa1 = (sa0 + sa1) / 2;
          if (abs$2(ta1 - ta0) > ap * 2 + epsilon$5) ta1 > ta0 ? (ta0 += ap, ta1 -= ap) : (ta0 -= ap, ta1 += ap);
          else ta0 = ta1 = (ta0 + ta1) / 2;
        }

        context.moveTo(sr * cos$2(sa0), sr * sin$2(sa0));
        context.arc(0, 0, sr, sa0, sa1);
        if (sa0 !== ta0 || sa1 !== ta1) {
          if (headRadius) {
            var hr = +headRadius.apply(this, arguments), tr2 = tr - hr, ta2 = (ta0 + ta1) / 2;
            context.quadraticCurveTo(0, 0, tr2 * cos$2(ta0), tr2 * sin$2(ta0));
            context.lineTo(tr * cos$2(ta2), tr * sin$2(ta2));
            context.lineTo(tr2 * cos$2(ta1), tr2 * sin$2(ta1));
          } else {
            context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
            context.arc(0, 0, tr, ta0, ta1);
          }
        }
        context.quadraticCurveTo(0, 0, sr * cos$2(sa0), sr * sin$2(sa0));
        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      if (headRadius) ribbon.headRadius = function(_) {
        return arguments.length ? (headRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : headRadius;
      };

      ribbon.radius = function(_) {
        return arguments.length ? (sourceRadius = targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.sourceRadius = function(_) {
        return arguments.length ? (sourceRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : sourceRadius;
      };

      ribbon.targetRadius = function(_) {
        return arguments.length ? (targetRadius = typeof _ === "function" ? _ : constant$6(+_), ribbon) : targetRadius;
      };

      ribbon.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : startAngle;
      };

      ribbon.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : endAngle;
      };

      ribbon.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$6(+_), ribbon) : padAngle;
      };

      ribbon.source = function(_) {
        return arguments.length ? (source = _, ribbon) : source;
      };

      ribbon.target = function(_) {
        return arguments.length ? (target = _, ribbon) : target;
      };

      ribbon.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), ribbon) : context;
      };

      return ribbon;
    }

    function ribbon$1() {
      return ribbon();
    }

    function ribbonArrow() {
      return ribbon(defaultArrowheadRadius);
    }

    var array$2 = Array.prototype;

    var slice$1 = array$2.slice;

    function ascending$1(a, b) {
      return a - b;
    }

    function area$3(ring) {
      var i = 0, n = ring.length, area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
      while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
      return area;
    }

    var constant$5 = x => () => x;

    function contains$2(ring, hole) {
      var i = -1, n = hole.length, c;
      while (++i < n) if (c = ringContains(ring, hole[i])) return c;
      return 0;
    }

    function ringContains(ring, point) {
      var x = point[0], y = point[1], contains = -1;
      for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
        var pi = ring[i], xi = pi[0], yi = pi[1], pj = ring[j], xj = pj[0], yj = pj[1];
        if (segmentContains(pi, pj, point)) return 0;
        if (((yi > y) !== (yj > y)) && ((x < (xj - xi) * (y - yi) / (yj - yi) + xi))) contains = -contains;
      }
      return contains;
    }

    function segmentContains(a, b, c) {
      var i; return collinear$1(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
    }

    function collinear$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
    }

    function within(p, q, r) {
      return p <= q && q <= r || r <= q && q <= p;
    }

    function noop$2() {}

    var cases = [
      [],
      [[[1.0, 1.5], [0.5, 1.0]]],
      [[[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [0.5, 1.0]]],
      [[[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]],
      [[[1.0, 0.5], [1.0, 1.5]]],
      [[[1.0, 0.5], [0.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 0.5]]],
      [[[1.0, 1.5], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]],
      [[[1.5, 1.0], [1.0, 0.5]]],
      [[[0.5, 1.0], [1.5, 1.0]]],
      [[[1.0, 1.5], [1.5, 1.0]]],
      [[[0.5, 1.0], [1.0, 1.5]]],
      []
    ];

    function contours() {
      var dx = 1,
          dy = 1,
          threshold = thresholdSturges,
          smooth = smoothLinear;

      function contours(values) {
        var tz = threshold(values);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          const e = extent$1(values), ts = tickStep(e[0], e[1], tz);
          tz = ticks(Math.floor(e[0] / ts) * ts, Math.floor(e[1] / ts - 1) * ts, tz);
        } else {
          tz = tz.slice().sort(ascending$1);
        }

        return tz.map(value => contour(values, value));
      }

      // Accumulate, smooth contour rings, assign holes to exterior rings.
      // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
      function contour(values, value) {
        var polygons = [],
            holes = [];

        isorings(values, value, function(ring) {
          smooth(ring, values, value);
          if (area$3(ring) > 0) polygons.push([ring]);
          else holes.push(ring);
        });

        holes.forEach(function(hole) {
          for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
            if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
              polygon.push(hole);
              return;
            }
          }
        });

        return {
          type: "MultiPolygon",
          value: value,
          coordinates: polygons
        };
      }

      // Marching squares with isolines stitched into rings.
      // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
      function isorings(values, value, callback) {
        var fragmentByStart = new Array,
            fragmentByEnd = new Array,
            x, y, t0, t1, t2, t3;

        // Special case for the first row (y = -1, t2 = t3 = 0).
        x = y = -1;
        t1 = values[0] >= value;
        cases[t1 << 1].forEach(stitch);
        while (++x < dx - 1) {
          t0 = t1, t1 = values[x + 1] >= value;
          cases[t0 | t1 << 1].forEach(stitch);
        }
        cases[t1 << 0].forEach(stitch);

        // General case for the intermediate rows.
        while (++y < dy - 1) {
          x = -1;
          t1 = values[y * dx + dx] >= value;
          t2 = values[y * dx] >= value;
          cases[t1 << 1 | t2 << 2].forEach(stitch);
          while (++x < dx - 1) {
            t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
            t3 = t2, t2 = values[y * dx + x + 1] >= value;
            cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
          }
          cases[t1 | t2 << 3].forEach(stitch);
        }

        // Special case for the last row (y = dy - 1, t0 = t1 = 0).
        x = -1;
        t2 = values[y * dx] >= value;
        cases[t2 << 2].forEach(stitch);
        while (++x < dx - 1) {
          t3 = t2, t2 = values[y * dx + x + 1] >= value;
          cases[t2 << 2 | t3 << 3].forEach(stitch);
        }
        cases[t2 << 3].forEach(stitch);

        function stitch(line) {
          var start = [line[0][0] + x, line[0][1] + y],
              end = [line[1][0] + x, line[1][1] + y],
              startIndex = index(start),
              endIndex = index(end),
              f, g;
          if (f = fragmentByEnd[startIndex]) {
            if (g = fragmentByStart[endIndex]) {
              delete fragmentByEnd[f.end];
              delete fragmentByStart[g.start];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[f.start] = fragmentByEnd[g.end] = {start: f.start, end: g.end, ring: f.ring.concat(g.ring)};
              }
            } else {
              delete fragmentByEnd[f.end];
              f.ring.push(end);
              fragmentByEnd[f.end = endIndex] = f;
            }
          } else if (f = fragmentByStart[endIndex]) {
            if (g = fragmentByEnd[startIndex]) {
              delete fragmentByStart[f.start];
              delete fragmentByEnd[g.end];
              if (f === g) {
                f.ring.push(end);
                callback(f.ring);
              } else {
                fragmentByStart[g.start] = fragmentByEnd[f.end] = {start: g.start, end: f.end, ring: g.ring.concat(f.ring)};
              }
            } else {
              delete fragmentByStart[f.start];
              f.ring.unshift(start);
              fragmentByStart[f.start = startIndex] = f;
            }
          } else {
            fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {start: startIndex, end: endIndex, ring: [start, end]};
          }
        }
      }

      function index(point) {
        return point[0] * 2 + point[1] * (dx + 1) * 4;
      }

      function smoothLinear(ring, values, value) {
        ring.forEach(function(point) {
          var x = point[0],
              y = point[1],
              xt = x | 0,
              yt = y | 0,
              v0,
              v1 = values[yt * dx + xt];
          if (x > 0 && x < dx && xt === x) {
            v0 = values[yt * dx + xt - 1];
            point[0] = x + (value - v0) / (v1 - v0) - 0.5;
          }
          if (y > 0 && y < dy && yt === y) {
            v0 = values[(yt - 1) * dx + xt];
            point[1] = y + (value - v0) / (v1 - v0) - 0.5;
          }
        });
      }

      contours.contour = contour;

      contours.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = Math.floor(_[0]), _1 = Math.floor(_[1]);
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, contours;
      };

      contours.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), contours) : threshold;
      };

      contours.smooth = function(_) {
        return arguments.length ? (smooth = _ ? smoothLinear : noop$2, contours) : smooth === smoothLinear;
      };

      return contours;
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurX(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var j = 0; j < m; ++j) {
        for (var i = 0, sr = 0; i < n + r; ++i) {
          if (i < n) {
            sr += source.data[i + j * n];
          }
          if (i >= r) {
            if (i >= w) {
              sr -= source.data[i - w + j * n];
            }
            target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
          }
        }
      }
    }

    // TODO Optimize edge cases.
    // TODO Optimize index calculation.
    // TODO Optimize arguments.
    function blurY(source, target, r) {
      var n = source.width,
          m = source.height,
          w = (r << 1) + 1;
      for (var i = 0; i < n; ++i) {
        for (var j = 0, sr = 0; j < m + r; ++j) {
          if (j < m) {
            sr += source.data[i + j * n];
          }
          if (j >= r) {
            if (j >= w) {
              sr -= source.data[i + (j - w) * n];
            }
            target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
          }
        }
      }
    }

    function defaultX$1(d) {
      return d[0];
    }

    function defaultY$1(d) {
      return d[1];
    }

    function defaultWeight() {
      return 1;
    }

    function density() {
      var x = defaultX$1,
          y = defaultY$1,
          weight = defaultWeight,
          dx = 960,
          dy = 500,
          r = 20, // blur radius
          k = 2, // log2(grid cell size)
          o = r * 3, // grid offset, to pad for blur
          n = (dx + o * 2) >> k, // grid width
          m = (dy + o * 2) >> k, // grid height
          threshold = constant$5(20);

      function density(data) {
        var values0 = new Float32Array(n * m),
            values1 = new Float32Array(n * m),
            pow2k = Math.pow(2, -k);

        data.forEach(function(d, i, data) {
          var xi = (x(d, i, data) + o) * pow2k,
              yi = (y(d, i, data) + o) * pow2k,
              wi = +weight(d, i, data);
          if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
            var x0 = Math.floor(xi),
                y0 = Math.floor(yi),
                xt = xi - x0 - 0.5,
                yt = yi - y0 - 0.5;
            values0[x0 + y0 * n] += (1 - xt) * (1 - yt) * wi;
            values0[x0 + 1 + y0 * n] += xt * (1 - yt) * wi;
            values0[x0 + 1 + (y0 + 1) * n] += xt * yt * wi;
            values0[x0 + (y0 + 1) * n] += (1 - xt) * yt * wi;
          }
        });

        // TODO Optimize.
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);
        blurX({width: n, height: m, data: values0}, {width: n, height: m, data: values1}, r >> k);
        blurY({width: n, height: m, data: values1}, {width: n, height: m, data: values0}, r >> k);

        var tz = threshold(values0);

        // Convert number of thresholds into uniform thresholds.
        if (!Array.isArray(tz)) {
          var stop = max$3(values0);
          tz = tickStep(0, stop, tz);
          tz = range$2(0, Math.floor(stop / tz) * tz, tz);
          tz.shift();
        }

        return contours()
            .thresholds(tz)
            .size([n, m])
          (values0)
            .map(transform);
      }

      function transform(geometry) {
        geometry.value *= Math.pow(2, -2 * k); // Density in points per square pixel.
        geometry.coordinates.forEach(transformPolygon);
        return geometry;
      }

      function transformPolygon(coordinates) {
        coordinates.forEach(transformRing);
      }

      function transformRing(coordinates) {
        coordinates.forEach(transformPoint);
      }

      // TODO Optimize.
      function transformPoint(coordinates) {
        coordinates[0] = coordinates[0] * Math.pow(2, k) - o;
        coordinates[1] = coordinates[1] * Math.pow(2, k) - o;
      }

      function resize() {
        o = r * 3;
        n = (dx + o * 2) >> k;
        m = (dy + o * 2) >> k;
        return density;
      }

      density.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$5(+_), density) : x;
      };

      density.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$5(+_), density) : y;
      };

      density.weight = function(_) {
        return arguments.length ? (weight = typeof _ === "function" ? _ : constant$5(+_), density) : weight;
      };

      density.size = function(_) {
        if (!arguments.length) return [dx, dy];
        var _0 = +_[0], _1 = +_[1];
        if (!(_0 >= 0 && _1 >= 0)) throw new Error("invalid size");
        return dx = _0, dy = _1, resize();
      };

      density.cellSize = function(_) {
        if (!arguments.length) return 1 << k;
        if (!((_ = +_) >= 1)) throw new Error("invalid cell size");
        return k = Math.floor(Math.log(_) / Math.LN2), resize();
      };

      density.thresholds = function(_) {
        return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant$5(slice$1.call(_)) : constant$5(_), density) : threshold;
      };

      density.bandwidth = function(_) {
        if (!arguments.length) return Math.sqrt(r * (r + 1));
        if (!((_ = +_) >= 0)) throw new Error("invalid bandwidth");
        return r = Math.round((Math.sqrt(4 * _ * _ + 1) - 1) / 2), resize();
      };

      return density;
    }

    const epsilon$3 = 1.1102230246251565e-16;
    const splitter = 134217729;
    const resulterrbound = (3 + 8 * epsilon$3) * epsilon$3;

    // fast_expansion_sum_zeroelim routine from oritinal code
    function sum$1(elen, e, flen, f, h) {
        let Q, Qnew, hh, bvirt;
        let enow = e[0];
        let fnow = f[0];
        let eindex = 0;
        let findex = 0;
        if ((fnow > enow) === (fnow > -enow)) {
            Q = enow;
            enow = e[++eindex];
        } else {
            Q = fnow;
            fnow = f[++findex];
        }
        let hindex = 0;
        if (eindex < elen && findex < flen) {
            if ((fnow > enow) === (fnow > -enow)) {
                Qnew = enow + Q;
                hh = Q - (Qnew - enow);
                enow = e[++eindex];
            } else {
                Qnew = fnow + Q;
                hh = Q - (Qnew - fnow);
                fnow = f[++findex];
            }
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
            while (eindex < elen && findex < flen) {
                if ((fnow > enow) === (fnow > -enow)) {
                    Qnew = Q + enow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (enow - bvirt);
                    enow = e[++eindex];
                } else {
                    Qnew = Q + fnow;
                    bvirt = Qnew - Q;
                    hh = Q - (Qnew - bvirt) + (fnow - bvirt);
                    fnow = f[++findex];
                }
                Q = Qnew;
                if (hh !== 0) {
                    h[hindex++] = hh;
                }
            }
        }
        while (eindex < elen) {
            Qnew = Q + enow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (enow - bvirt);
            enow = e[++eindex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        while (findex < flen) {
            Qnew = Q + fnow;
            bvirt = Qnew - Q;
            hh = Q - (Qnew - bvirt) + (fnow - bvirt);
            fnow = f[++findex];
            Q = Qnew;
            if (hh !== 0) {
                h[hindex++] = hh;
            }
        }
        if (Q !== 0 || hindex === 0) {
            h[hindex++] = Q;
        }
        return hindex;
    }

    function estimate(elen, e) {
        let Q = e[0];
        for (let i = 1; i < elen; i++) Q += e[i];
        return Q;
    }

    function vec(n) {
        return new Float64Array(n);
    }

    const ccwerrboundA = (3 + 16 * epsilon$3) * epsilon$3;
    const ccwerrboundB = (2 + 12 * epsilon$3) * epsilon$3;
    const ccwerrboundC = (9 + 64 * epsilon$3) * epsilon$3 * epsilon$3;

    const B = vec(4);
    const C1 = vec(8);
    const C2 = vec(12);
    const D = vec(16);
    const u = vec(4);

    function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
        let acxtail, acytail, bcxtail, bcytail;
        let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u3;

        const acx = ax - cx;
        const bcx = bx - cx;
        const acy = ay - cy;
        const bcy = by - cy;

        s1 = acx * bcy;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcx;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        B[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        B[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        B[2] = _j - (u3 - bvirt) + (_i - bvirt);
        B[3] = u3;

        let det = estimate(4, B);
        let errbound = ccwerrboundB * detsum;
        if (det >= errbound || -det >= errbound) {
            return det;
        }

        bvirt = ax - acx;
        acxtail = ax - (acx + bvirt) + (bvirt - cx);
        bvirt = bx - bcx;
        bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
        bvirt = ay - acy;
        acytail = ay - (acy + bvirt) + (bvirt - cy);
        bvirt = by - bcy;
        bcytail = by - (bcy + bvirt) + (bvirt - cy);

        if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
            return det;
        }

        errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
        det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
        if (det >= errbound || -det >= errbound) return det;

        s1 = acxtail * bcy;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcy;
        bhi = c - (c - bcy);
        blo = bcy - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcx;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcx;
        bhi = c - (c - bcx);
        blo = bcx - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C1len = sum$1(4, B, 4, u, C1);

        s1 = acx * bcytail;
        c = splitter * acx;
        ahi = c - (c - acx);
        alo = acx - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acy * bcxtail;
        c = splitter * acy;
        ahi = c - (c - acy);
        alo = acy - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const C2len = sum$1(C1len, C1, 4, u, C2);

        s1 = acxtail * bcytail;
        c = splitter * acxtail;
        ahi = c - (c - acxtail);
        alo = acxtail - ahi;
        c = splitter * bcytail;
        bhi = c - (c - bcytail);
        blo = bcytail - bhi;
        s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
        t1 = acytail * bcxtail;
        c = splitter * acytail;
        ahi = c - (c - acytail);
        alo = acytail - ahi;
        c = splitter * bcxtail;
        bhi = c - (c - bcxtail);
        blo = bcxtail - bhi;
        t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
        _i = s0 - t0;
        bvirt = s0 - _i;
        u[0] = s0 - (_i + bvirt) + (bvirt - t0);
        _j = s1 + _i;
        bvirt = _j - s1;
        _0 = s1 - (_j - bvirt) + (_i - bvirt);
        _i = _0 - t1;
        bvirt = _0 - _i;
        u[1] = _0 - (_i + bvirt) + (bvirt - t1);
        u3 = _j + _i;
        bvirt = u3 - _j;
        u[2] = _j - (u3 - bvirt) + (_i - bvirt);
        u[3] = u3;
        const Dlen = sum$1(C2len, C2, 4, u, D);

        return D[Dlen - 1];
    }

    function orient2d(ax, ay, bx, by, cx, cy) {
        const detleft = (ay - cy) * (bx - cx);
        const detright = (ax - cx) * (by - cy);
        const det = detleft - detright;

        if (detleft === 0 || detright === 0 || (detleft > 0) !== (detright > 0)) return det;

        const detsum = Math.abs(detleft + detright);
        if (Math.abs(det) >= ccwerrboundA * detsum) return det;

        return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
    }

    const EPSILON = Math.pow(2, -52);
    const EDGE_STACK = new Uint32Array(512);

    class Delaunator {

        static from(points, getX = defaultGetX, getY = defaultGetY) {
            const n = points.length;
            const coords = new Float64Array(n * 2);

            for (let i = 0; i < n; i++) {
                const p = points[i];
                coords[2 * i] = getX(p);
                coords[2 * i + 1] = getY(p);
            }

            return new Delaunator(coords);
        }

        constructor(coords) {
            const n = coords.length >> 1;
            if (n > 0 && typeof coords[0] !== 'number') throw new Error('Expected coords to contain numbers.');

            this.coords = coords;

            // arrays that will store the triangulation graph
            const maxTriangles = Math.max(2 * n - 5, 0);
            this._triangles = new Uint32Array(maxTriangles * 3);
            this._halfedges = new Int32Array(maxTriangles * 3);

            // temporary arrays for tracking the edges of the advancing convex hull
            this._hashSize = Math.ceil(Math.sqrt(n));
            this._hullPrev = new Uint32Array(n); // edge to prev edge
            this._hullNext = new Uint32Array(n); // edge to next edge
            this._hullTri = new Uint32Array(n); // edge to adjacent triangle
            this._hullHash = new Int32Array(this._hashSize).fill(-1); // angular edge hash

            // temporary arrays for sorting points
            this._ids = new Uint32Array(n);
            this._dists = new Float64Array(n);

            this.update();
        }

        update() {
            const {coords, _hullPrev: hullPrev, _hullNext: hullNext, _hullTri: hullTri, _hullHash: hullHash} =  this;
            const n = coords.length >> 1;

            // populate an array of point indices; calculate input data bbox
            let minX = Infinity;
            let minY = Infinity;
            let maxX = -Infinity;
            let maxY = -Infinity;

            for (let i = 0; i < n; i++) {
                const x = coords[2 * i];
                const y = coords[2 * i + 1];
                if (x < minX) minX = x;
                if (y < minY) minY = y;
                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                this._ids[i] = i;
            }
            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            let minDist = Infinity;
            let i0, i1, i2;

            // pick a seed point close to the center
            for (let i = 0; i < n; i++) {
                const d = dist(cx, cy, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist) {
                    i0 = i;
                    minDist = d;
                }
            }
            const i0x = coords[2 * i0];
            const i0y = coords[2 * i0 + 1];

            minDist = Infinity;

            // find the point closest to the seed
            for (let i = 0; i < n; i++) {
                if (i === i0) continue;
                const d = dist(i0x, i0y, coords[2 * i], coords[2 * i + 1]);
                if (d < minDist && d > 0) {
                    i1 = i;
                    minDist = d;
                }
            }
            let i1x = coords[2 * i1];
            let i1y = coords[2 * i1 + 1];

            let minRadius = Infinity;

            // find the third point which forms the smallest circumcircle with the first two
            for (let i = 0; i < n; i++) {
                if (i === i0 || i === i1) continue;
                const r = circumradius(i0x, i0y, i1x, i1y, coords[2 * i], coords[2 * i + 1]);
                if (r < minRadius) {
                    i2 = i;
                    minRadius = r;
                }
            }
            let i2x = coords[2 * i2];
            let i2y = coords[2 * i2 + 1];

            if (minRadius === Infinity) {
                // order collinear points by dx (or dy if all x are identical)
                // and return the list as a hull
                for (let i = 0; i < n; i++) {
                    this._dists[i] = (coords[2 * i] - coords[0]) || (coords[2 * i + 1] - coords[1]);
                }
                quicksort(this._ids, this._dists, 0, n - 1);
                const hull = new Uint32Array(n);
                let j = 0;
                for (let i = 0, d0 = -Infinity; i < n; i++) {
                    const id = this._ids[i];
                    if (this._dists[id] > d0) {
                        hull[j++] = id;
                        d0 = this._dists[id];
                    }
                }
                this.hull = hull.subarray(0, j);
                this.triangles = new Uint32Array(0);
                this.halfedges = new Uint32Array(0);
                return;
            }

            // swap the order of the seed points for counter-clockwise orientation
            if (orient2d(i0x, i0y, i1x, i1y, i2x, i2y) < 0) {
                const i = i1;
                const x = i1x;
                const y = i1y;
                i1 = i2;
                i1x = i2x;
                i1y = i2y;
                i2 = i;
                i2x = x;
                i2y = y;
            }

            const center = circumcenter(i0x, i0y, i1x, i1y, i2x, i2y);
            this._cx = center.x;
            this._cy = center.y;

            for (let i = 0; i < n; i++) {
                this._dists[i] = dist(coords[2 * i], coords[2 * i + 1], center.x, center.y);
            }

            // sort the points by distance from the seed triangle circumcenter
            quicksort(this._ids, this._dists, 0, n - 1);

            // set up the seed triangle as the starting hull
            this._hullStart = i0;
            let hullSize = 3;

            hullNext[i0] = hullPrev[i2] = i1;
            hullNext[i1] = hullPrev[i0] = i2;
            hullNext[i2] = hullPrev[i1] = i0;

            hullTri[i0] = 0;
            hullTri[i1] = 1;
            hullTri[i2] = 2;

            hullHash.fill(-1);
            hullHash[this._hashKey(i0x, i0y)] = i0;
            hullHash[this._hashKey(i1x, i1y)] = i1;
            hullHash[this._hashKey(i2x, i2y)] = i2;

            this.trianglesLen = 0;
            this._addTriangle(i0, i1, i2, -1, -1, -1);

            for (let k = 0, xp, yp; k < this._ids.length; k++) {
                const i = this._ids[k];
                const x = coords[2 * i];
                const y = coords[2 * i + 1];

                // skip near-duplicate points
                if (k > 0 && Math.abs(x - xp) <= EPSILON && Math.abs(y - yp) <= EPSILON) continue;
                xp = x;
                yp = y;

                // skip seed triangle points
                if (i === i0 || i === i1 || i === i2) continue;

                // find a visible edge on the convex hull using edge hash
                let start = 0;
                for (let j = 0, key = this._hashKey(x, y); j < this._hashSize; j++) {
                    start = hullHash[(key + j) % this._hashSize];
                    if (start !== -1 && start !== hullNext[start]) break;
                }

                start = hullPrev[start];
                let e = start, q;
                while (q = hullNext[e], orient2d(x, y, coords[2 * e], coords[2 * e + 1], coords[2 * q], coords[2 * q + 1]) >= 0) {
                    e = q;
                    if (e === start) {
                        e = -1;
                        break;
                    }
                }
                if (e === -1) continue; // likely a near-duplicate point; skip it

                // add the first triangle from the point
                let t = this._addTriangle(e, i, hullNext[e], -1, -1, hullTri[e]);

                // recursively flip triangles from the point until they satisfy the Delaunay condition
                hullTri[i] = this._legalize(t + 2);
                hullTri[e] = t; // keep track of boundary triangles on the hull
                hullSize++;

                // walk forward through the hull, adding more triangles and flipping recursively
                let n = hullNext[e];
                while (q = hullNext[n], orient2d(x, y, coords[2 * n], coords[2 * n + 1], coords[2 * q], coords[2 * q + 1]) < 0) {
                    t = this._addTriangle(n, i, q, hullTri[i], -1, hullTri[n]);
                    hullTri[i] = this._legalize(t + 2);
                    hullNext[n] = n; // mark as removed
                    hullSize--;
                    n = q;
                }

                // walk backward from the other side, adding more triangles and flipping
                if (e === start) {
                    while (q = hullPrev[e], orient2d(x, y, coords[2 * q], coords[2 * q + 1], coords[2 * e], coords[2 * e + 1]) < 0) {
                        t = this._addTriangle(q, i, e, -1, hullTri[e], hullTri[q]);
                        this._legalize(t + 2);
                        hullTri[q] = t;
                        hullNext[e] = e; // mark as removed
                        hullSize--;
                        e = q;
                    }
                }

                // update the hull indices
                this._hullStart = hullPrev[i] = e;
                hullNext[e] = hullPrev[n] = i;
                hullNext[i] = n;

                // save the two new edges in the hash table
                hullHash[this._hashKey(x, y)] = i;
                hullHash[this._hashKey(coords[2 * e], coords[2 * e + 1])] = e;
            }

            this.hull = new Uint32Array(hullSize);
            for (let i = 0, e = this._hullStart; i < hullSize; i++) {
                this.hull[i] = e;
                e = hullNext[e];
            }

            // trim typed triangle mesh arrays
            this.triangles = this._triangles.subarray(0, this.trianglesLen);
            this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
        }

        _hashKey(x, y) {
            return Math.floor(pseudoAngle(x - this._cx, y - this._cy) * this._hashSize) % this._hashSize;
        }

        _legalize(a) {
            const {_triangles: triangles, _halfedges: halfedges, coords} = this;

            let i = 0;
            let ar = 0;

            // recursion eliminated with a fixed-size stack
            while (true) {
                const b = halfedges[a];

                /* if the pair of triangles doesn't satisfy the Delaunay condition
                 * (p1 is inside the circumcircle of [p0, pl, pr]), flip them,
                 * then do the same check/flip recursively for the new pair of triangles
                 *
                 *           pl                    pl
                 *          /||\                  /  \
                 *       al/ || \bl            al/    \a
                 *        /  ||  \              /      \
                 *       /  a||b  \    flip    /___ar___\
                 *     p0\   ||   /p1   =>   p0\---bl---/p1
                 *        \  ||  /              \      /
                 *       ar\ || /br             b\    /br
                 *          \||/                  \  /
                 *           pr                    pr
                 */
                const a0 = a - a % 3;
                ar = a0 + (a + 2) % 3;

                if (b === -1) { // convex hull edge
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                    continue;
                }

                const b0 = b - b % 3;
                const al = a0 + (a + 1) % 3;
                const bl = b0 + (b + 2) % 3;

                const p0 = triangles[ar];
                const pr = triangles[a];
                const pl = triangles[al];
                const p1 = triangles[bl];

                const illegal = inCircle(
                    coords[2 * p0], coords[2 * p0 + 1],
                    coords[2 * pr], coords[2 * pr + 1],
                    coords[2 * pl], coords[2 * pl + 1],
                    coords[2 * p1], coords[2 * p1 + 1]);

                if (illegal) {
                    triangles[a] = p1;
                    triangles[b] = p0;

                    const hbl = halfedges[bl];

                    // edge swapped on the other side of the hull (rare); fix the halfedge reference
                    if (hbl === -1) {
                        let e = this._hullStart;
                        do {
                            if (this._hullTri[e] === bl) {
                                this._hullTri[e] = a;
                                break;
                            }
                            e = this._hullPrev[e];
                        } while (e !== this._hullStart);
                    }
                    this._link(a, hbl);
                    this._link(b, halfedges[ar]);
                    this._link(ar, bl);

                    const br = b0 + (b + 1) % 3;

                    // don't worry about hitting the cap: it can only happen on extremely degenerate input
                    if (i < EDGE_STACK.length) {
                        EDGE_STACK[i++] = br;
                    }
                } else {
                    if (i === 0) break;
                    a = EDGE_STACK[--i];
                }
            }

            return ar;
        }

        _link(a, b) {
            this._halfedges[a] = b;
            if (b !== -1) this._halfedges[b] = a;
        }

        // add a new triangle given vertex indices and adjacent half-edge ids
        _addTriangle(i0, i1, i2, a, b, c) {
            const t = this.trianglesLen;

            this._triangles[t] = i0;
            this._triangles[t + 1] = i1;
            this._triangles[t + 2] = i2;

            this._link(t, a);
            this._link(t + 1, b);
            this._link(t + 2, c);

            this.trianglesLen += 3;

            return t;
        }
    }

    // monotonically increases with real angle, but doesn't need expensive trigonometry
    function pseudoAngle(dx, dy) {
        const p = dx / (Math.abs(dx) + Math.abs(dy));
        return (dy > 0 ? 3 - p : 1 + p) / 4; // [0..1]
    }

    function dist(ax, ay, bx, by) {
        const dx = ax - bx;
        const dy = ay - by;
        return dx * dx + dy * dy;
    }

    function inCircle(ax, ay, bx, by, cx, cy, px, py) {
        const dx = ax - px;
        const dy = ay - py;
        const ex = bx - px;
        const ey = by - py;
        const fx = cx - px;
        const fy = cy - py;

        const ap = dx * dx + dy * dy;
        const bp = ex * ex + ey * ey;
        const cp = fx * fx + fy * fy;

        return dx * (ey * cp - bp * fy) -
               dy * (ex * cp - bp * fx) +
               ap * (ex * fy - ey * fx) < 0;
    }

    function circumradius(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = (ey * bl - dy * cl) * d;
        const y = (dx * cl - ex * bl) * d;

        return x * x + y * y;
    }

    function circumcenter(ax, ay, bx, by, cx, cy) {
        const dx = bx - ax;
        const dy = by - ay;
        const ex = cx - ax;
        const ey = cy - ay;

        const bl = dx * dx + dy * dy;
        const cl = ex * ex + ey * ey;
        const d = 0.5 / (dx * ey - dy * ex);

        const x = ax + (ey * bl - dy * cl) * d;
        const y = ay + (dx * cl - ex * bl) * d;

        return {x, y};
    }

    function quicksort(ids, dists, left, right) {
        if (right - left <= 20) {
            for (let i = left + 1; i <= right; i++) {
                const temp = ids[i];
                const tempDist = dists[temp];
                let j = i - 1;
                while (j >= left && dists[ids[j]] > tempDist) ids[j + 1] = ids[j--];
                ids[j + 1] = temp;
            }
        } else {
            const median = (left + right) >> 1;
            let i = left + 1;
            let j = right;
            swap(ids, median, i);
            if (dists[ids[left]] > dists[ids[right]]) swap(ids, left, right);
            if (dists[ids[i]] > dists[ids[right]]) swap(ids, i, right);
            if (dists[ids[left]] > dists[ids[i]]) swap(ids, left, i);

            const temp = ids[i];
            const tempDist = dists[temp];
            while (true) {
                do i++; while (dists[ids[i]] < tempDist);
                do j--; while (dists[ids[j]] > tempDist);
                if (j < i) break;
                swap(ids, i, j);
            }
            ids[left + 1] = ids[j];
            ids[j] = temp;

            if (right - i + 1 >= j - left) {
                quicksort(ids, dists, i, right);
                quicksort(ids, dists, left, j - 1);
            } else {
                quicksort(ids, dists, left, j - 1);
                quicksort(ids, dists, i, right);
            }
        }
    }

    function swap(arr, i, j) {
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }

    function defaultGetX(p) {
        return p[0];
    }
    function defaultGetY(p) {
        return p[1];
    }

    const epsilon$2 = 1e-6;

    class Path {
      constructor() {
        this._x0 = this._y0 = // start of current subpath
        this._x1 = this._y1 = null; // end of current subpath
        this._ = "";
      }
      moveTo(x, y) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
      }
      closePath() {
        if (this._x1 !== null) {
          this._x1 = this._x0, this._y1 = this._y0;
          this._ += "Z";
        }
      }
      lineTo(x, y) {
        this._ += `L${this._x1 = +x},${this._y1 = +y}`;
      }
      arc(x, y, r) {
        x = +x, y = +y, r = +r;
        const x0 = x + r;
        const y0 = y;
        if (r < 0) throw new Error("negative radius");
        if (this._x1 === null) this._ += `M${x0},${y0}`;
        else if (Math.abs(this._x1 - x0) > epsilon$2 || Math.abs(this._y1 - y0) > epsilon$2) this._ += "L" + x0 + "," + y0;
        if (!r) return;
        this._ += `A${r},${r},0,1,1,${x - r},${y}A${r},${r},0,1,1,${this._x1 = x0},${this._y1 = y0}`;
      }
      rect(x, y, w, h) {
        this._ += `M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${+w}v${+h}h${-w}Z`;
      }
      value() {
        return this._ || null;
      }
    }

    class Polygon {
      constructor() {
        this._ = [];
      }
      moveTo(x, y) {
        this._.push([x, y]);
      }
      closePath() {
        this._.push(this._[0].slice());
      }
      lineTo(x, y) {
        this._.push([x, y]);
      }
      value() {
        return this._.length ? this._ : null;
      }
    }

    class Voronoi {
      constructor(delaunay, [xmin, ymin, xmax, ymax] = [0, 0, 960, 500]) {
        if (!((xmax = +xmax) >= (xmin = +xmin)) || !((ymax = +ymax) >= (ymin = +ymin))) throw new Error("invalid bounds");
        this.delaunay = delaunay;
        this._circumcenters = new Float64Array(delaunay.points.length * 2);
        this.vectors = new Float64Array(delaunay.points.length * 2);
        this.xmax = xmax, this.xmin = xmin;
        this.ymax = ymax, this.ymin = ymin;
        this._init();
      }
      update() {
        this.delaunay.update();
        this._init();
        return this;
      }
      _init() {
        const {delaunay: {points, hull, triangles}, vectors} = this;

        // Compute circumcenters.
        const circumcenters = this.circumcenters = this._circumcenters.subarray(0, triangles.length / 3 * 2);
        for (let i = 0, j = 0, n = triangles.length, x, y; i < n; i += 3, j += 2) {
          const t1 = triangles[i] * 2;
          const t2 = triangles[i + 1] * 2;
          const t3 = triangles[i + 2] * 2;
          const x1 = points[t1];
          const y1 = points[t1 + 1];
          const x2 = points[t2];
          const y2 = points[t2 + 1];
          const x3 = points[t3];
          const y3 = points[t3 + 1];

          const dx = x2 - x1;
          const dy = y2 - y1;
          const ex = x3 - x1;
          const ey = y3 - y1;
          const ab = (dx * ey - dy * ex) * 2;

          if (Math.abs(ab) < 1e-9) {
            // degenerate case (collinear diagram)
            // almost equal points (degenerate triangle)
            // the circumcenter is at the infinity, in a
            // direction that is:
            // 1. orthogonal to the halfedge.
            let a = 1e9;
            // 2. points away from the center; since the list of triangles starts
            // in the center, the first point of the first triangle
            // will be our reference
            const r = triangles[0] * 2;
            a *= Math.sign((points[r] - x1) * ey - (points[r + 1] - y1) * ex);
            x = (x1 + x3) / 2 - a * ey;
            y = (y1 + y3) / 2 + a * ex;
          } else {
            const d = 1 / ab;
            const bl = dx * dx + dy * dy;
            const cl = ex * ex + ey * ey;
            x = x1 + (ey * bl - dy * cl) * d;
            y = y1 + (dx * cl - ex * bl) * d;
          }
          circumcenters[j] = x;
          circumcenters[j + 1] = y;
        }

        // Compute exterior cell rays.
        let h = hull[hull.length - 1];
        let p0, p1 = h * 4;
        let x0, x1 = points[2 * h];
        let y0, y1 = points[2 * h + 1];
        vectors.fill(0);
        for (let i = 0; i < hull.length; ++i) {
          h = hull[i];
          p0 = p1, x0 = x1, y0 = y1;
          p1 = h * 4, x1 = points[2 * h], y1 = points[2 * h + 1];
          vectors[p0 + 2] = vectors[p1] = y0 - y1;
          vectors[p0 + 3] = vectors[p1 + 1] = x1 - x0;
        }
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {delaunay: {halfedges, inedges, hull}, circumcenters, vectors} = this;
        if (hull.length <= 1) return null;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = Math.floor(i / 3) * 2;
          const tj = Math.floor(j / 3) * 2;
          const xi = circumcenters[ti];
          const yi = circumcenters[ti + 1];
          const xj = circumcenters[tj];
          const yj = circumcenters[tj + 1];
          this._renderSegment(xi, yi, xj, yj, context);
        }
        let h0, h1 = hull[hull.length - 1];
        for (let i = 0; i < hull.length; ++i) {
          h0 = h1, h1 = hull[i];
          const t = Math.floor(inedges[h1] / 3) * 2;
          const x = circumcenters[t];
          const y = circumcenters[t + 1];
          const v = h0 * 4;
          const p = this._project(x, y, vectors[v + 2], vectors[v + 3]);
          if (p) this._renderSegment(x, y, p[0], p[1], context);
        }
        return buffer && buffer.value();
      }
      renderBounds(context) {
        const buffer = context == null ? context = new Path : undefined;
        context.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin);
        return buffer && buffer.value();
      }
      renderCell(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const points = this._clip(i);
        if (points === null || !points.length) return;
        context.moveTo(points[0], points[1]);
        let n = points.length;
        while (points[0] === points[n-2] && points[1] === points[n-1] && n > 1) n -= 2;
        for (let i = 2; i < n; i += 2) {
          if (points[i] !== points[i-2] || points[i+1] !== points[i-1])
            context.lineTo(points[i], points[i + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      *cellPolygons() {
        const {delaunay: {points}} = this;
        for (let i = 0, n = points.length / 2; i < n; ++i) {
          const cell = this.cellPolygon(i);
          if (cell) cell.index = i, yield cell;
        }
      }
      cellPolygon(i) {
        const polygon = new Polygon;
        this.renderCell(i, polygon);
        return polygon.value();
      }
      _renderSegment(x0, y0, x1, y1, context) {
        let S;
        const c0 = this._regioncode(x0, y0);
        const c1 = this._regioncode(x1, y1);
        if (c0 === 0 && c1 === 0) {
          context.moveTo(x0, y0);
          context.lineTo(x1, y1);
        } else if (S = this._clipSegment(x0, y0, x1, y1, c0, c1)) {
          context.moveTo(S[0], S[1]);
          context.lineTo(S[2], S[3]);
        }
      }
      contains(i, x, y) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return false;
        return this.delaunay._step(i, x, y) === i;
      }
      *neighbors(i) {
        const ci = this._clip(i);
        if (ci) for (const j of this.delaunay.neighbors(i)) {
          const cj = this._clip(j);
          // find the common edge
          if (cj) loop: for (let ai = 0, li = ci.length; ai < li; ai += 2) {
            for (let aj = 0, lj = cj.length; aj < lj; aj += 2) {
              if (ci[ai] == cj[aj]
              && ci[ai + 1] == cj[aj + 1]
              && ci[(ai + 2) % li] == cj[(aj + lj - 2) % lj]
              && ci[(ai + 3) % li] == cj[(aj + lj - 1) % lj]
              ) {
                yield j;
                break loop;
              }
            }
          }
        }
      }
      _cell(i) {
        const {circumcenters, delaunay: {inedges, halfedges, triangles}} = this;
        const e0 = inedges[i];
        if (e0 === -1) return null; // coincident point
        const points = [];
        let e = e0;
        do {
          const t = Math.floor(e / 3);
          points.push(circumcenters[t * 2], circumcenters[t * 2 + 1]);
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
        } while (e !== e0 && e !== -1);
        return points;
      }
      _clip(i) {
        // degenerate case (1 valid point: return the box)
        if (i === 0 && this.delaunay.hull.length === 1) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        const points = this._cell(i);
        if (points === null) return null;
        const {vectors: V} = this;
        const v = i * 4;
        return V[v] || V[v + 1]
            ? this._clipInfinite(i, points, V[v], V[v + 1], V[v + 2], V[v + 3])
            : this._clipFinite(i, points);
      }
      _clipFinite(i, points) {
        const n = points.length;
        let P = null;
        let x0, y0, x1 = points[n - 2], y1 = points[n - 1];
        let c0, c1 = this._regioncode(x1, y1);
        let e0, e1 = 0;
        for (let j = 0; j < n; j += 2) {
          x0 = x1, y0 = y1, x1 = points[j], y1 = points[j + 1];
          c0 = c1, c1 = this._regioncode(x1, y1);
          if (c0 === 0 && c1 === 0) {
            e0 = e1, e1 = 0;
            if (P) P.push(x1, y1);
            else P = [x1, y1];
          } else {
            let S, sx0, sy0, sx1, sy1;
            if (c0 === 0) {
              if ((S = this._clipSegment(x0, y0, x1, y1, c0, c1)) === null) continue;
              [sx0, sy0, sx1, sy1] = S;
            } else {
              if ((S = this._clipSegment(x1, y1, x0, y0, c1, c0)) === null) continue;
              [sx1, sy1, sx0, sy0] = S;
              e0 = e1, e1 = this._edgecode(sx0, sy0);
              if (e0 && e1) this._edge(i, e0, e1, P, P.length);
              if (P) P.push(sx0, sy0);
              else P = [sx0, sy0];
            }
            e0 = e1, e1 = this._edgecode(sx1, sy1);
            if (e0 && e1) this._edge(i, e0, e1, P, P.length);
            if (P) P.push(sx1, sy1);
            else P = [sx1, sy1];
          }
        }
        if (P) {
          e0 = e1, e1 = this._edgecode(P[0], P[1]);
          if (e0 && e1) this._edge(i, e0, e1, P, P.length);
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
        }
        return P;
      }
      _clipSegment(x0, y0, x1, y1, c0, c1) {
        while (true) {
          if (c0 === 0 && c1 === 0) return [x0, y0, x1, y1];
          if (c0 & c1) return null;
          let x, y, c = c0 || c1;
          if (c & 0b1000) x = x0 + (x1 - x0) * (this.ymax - y0) / (y1 - y0), y = this.ymax;
          else if (c & 0b0100) x = x0 + (x1 - x0) * (this.ymin - y0) / (y1 - y0), y = this.ymin;
          else if (c & 0b0010) y = y0 + (y1 - y0) * (this.xmax - x0) / (x1 - x0), x = this.xmax;
          else y = y0 + (y1 - y0) * (this.xmin - x0) / (x1 - x0), x = this.xmin;
          if (c0) x0 = x, y0 = y, c0 = this._regioncode(x0, y0);
          else x1 = x, y1 = y, c1 = this._regioncode(x1, y1);
        }
      }
      _clipInfinite(i, points, vx0, vy0, vxn, vyn) {
        let P = Array.from(points), p;
        if (p = this._project(P[0], P[1], vx0, vy0)) P.unshift(p[0], p[1]);
        if (p = this._project(P[P.length - 2], P[P.length - 1], vxn, vyn)) P.push(p[0], p[1]);
        if (P = this._clipFinite(i, P)) {
          for (let j = 0, n = P.length, c0, c1 = this._edgecode(P[n - 2], P[n - 1]); j < n; j += 2) {
            c0 = c1, c1 = this._edgecode(P[j], P[j + 1]);
            if (c0 && c1) j = this._edge(i, c0, c1, P, j), n = P.length;
          }
        } else if (this.contains(i, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2)) {
          P = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax];
        }
        return P;
      }
      _edge(i, e0, e1, P, j) {
        while (e0 !== e1) {
          let x, y;
          switch (e0) {
            case 0b0101: e0 = 0b0100; continue; // top-left
            case 0b0100: e0 = 0b0110, x = this.xmax, y = this.ymin; break; // top
            case 0b0110: e0 = 0b0010; continue; // top-right
            case 0b0010: e0 = 0b1010, x = this.xmax, y = this.ymax; break; // right
            case 0b1010: e0 = 0b1000; continue; // bottom-right
            case 0b1000: e0 = 0b1001, x = this.xmin, y = this.ymax; break; // bottom
            case 0b1001: e0 = 0b0001; continue; // bottom-left
            case 0b0001: e0 = 0b0101, x = this.xmin, y = this.ymin; break; // left
          }
          // Note: this implicitly checks for out of bounds: if P[j] or P[j+1] are
          // undefined, the conditional statement will be executed.
          if ((P[j] !== x || P[j + 1] !== y) && this.contains(i, x, y)) {
            P.splice(j, 0, x, y), j += 2;
          }
        }
        if (P.length > 4) {
          for (let i = 0; i < P.length; i+= 2) {
            const j = (i + 2) % P.length, k = (i + 4) % P.length;
            if (P[i] === P[j] && P[j] === P[k]
            || P[i + 1] === P[j + 1] && P[j + 1] === P[k + 1])
              P.splice(j, 2), i -= 2;
          }
        }
        return j;
      }
      _project(x0, y0, vx, vy) {
        let t = Infinity, c, x, y;
        if (vy < 0) { // top
          if (y0 <= this.ymin) return null;
          if ((c = (this.ymin - y0) / vy) < t) y = this.ymin, x = x0 + (t = c) * vx;
        } else if (vy > 0) { // bottom
          if (y0 >= this.ymax) return null;
          if ((c = (this.ymax - y0) / vy) < t) y = this.ymax, x = x0 + (t = c) * vx;
        }
        if (vx > 0) { // right
          if (x0 >= this.xmax) return null;
          if ((c = (this.xmax - x0) / vx) < t) x = this.xmax, y = y0 + (t = c) * vy;
        } else if (vx < 0) { // left
          if (x0 <= this.xmin) return null;
          if ((c = (this.xmin - x0) / vx) < t) x = this.xmin, y = y0 + (t = c) * vy;
        }
        return [x, y];
      }
      _edgecode(x, y) {
        return (x === this.xmin ? 0b0001
            : x === this.xmax ? 0b0010 : 0b0000)
            | (y === this.ymin ? 0b0100
            : y === this.ymax ? 0b1000 : 0b0000);
      }
      _regioncode(x, y) {
        return (x < this.xmin ? 0b0001
            : x > this.xmax ? 0b0010 : 0b0000)
            | (y < this.ymin ? 0b0100
            : y > this.ymax ? 0b1000 : 0b0000);
      }
    }

    const tau$2 = 2 * Math.PI, pow$2 = Math.pow;

    function pointX(p) {
      return p[0];
    }

    function pointY(p) {
      return p[1];
    }

    // A triangulation is collinear if all its triangles have a non-null area
    function collinear(d) {
      const {triangles, coords} = d;
      for (let i = 0; i < triangles.length; i += 3) {
        const a = 2 * triangles[i],
              b = 2 * triangles[i + 1],
              c = 2 * triangles[i + 2],
              cross = (coords[c] - coords[a]) * (coords[b + 1] - coords[a + 1])
                    - (coords[b] - coords[a]) * (coords[c + 1] - coords[a + 1]);
        if (cross > 1e-10) return false;
      }
      return true;
    }

    function jitter(x, y, r) {
      return [x + Math.sin(x + y) * r, y + Math.cos(x - y) * r];
    }

    class Delaunay {
      static from(points, fx = pointX, fy = pointY, that) {
        return new Delaunay("length" in points
            ? flatArray(points, fx, fy, that)
            : Float64Array.from(flatIterable(points, fx, fy, that)));
      }
      constructor(points) {
        this._delaunator = new Delaunator(points);
        this.inedges = new Int32Array(points.length / 2);
        this._hullIndex = new Int32Array(points.length / 2);
        this.points = this._delaunator.coords;
        this._init();
      }
      update() {
        this._delaunator.update();
        this._init();
        return this;
      }
      _init() {
        const d = this._delaunator, points = this.points;

        // check for collinear
        if (d.hull && d.hull.length > 2 && collinear(d)) {
          this.collinear = Int32Array.from({length: points.length/2}, (_,i) => i)
            .sort((i, j) => points[2 * i] - points[2 * j] || points[2 * i + 1] - points[2 * j + 1]); // for exact neighbors
          const e = this.collinear[0], f = this.collinear[this.collinear.length - 1],
            bounds = [ points[2 * e], points[2 * e + 1], points[2 * f], points[2 * f + 1] ],
            r = 1e-8 * Math.hypot(bounds[3] - bounds[1], bounds[2] - bounds[0]);
          for (let i = 0, n = points.length / 2; i < n; ++i) {
            const p = jitter(points[2 * i], points[2 * i + 1], r);
            points[2 * i] = p[0];
            points[2 * i + 1] = p[1];
          }
          this._delaunator = new Delaunator(points);
        } else {
          delete this.collinear;
        }

        const halfedges = this.halfedges = this._delaunator.halfedges;
        const hull = this.hull = this._delaunator.hull;
        const triangles = this.triangles = this._delaunator.triangles;
        const inedges = this.inedges.fill(-1);
        const hullIndex = this._hullIndex.fill(-1);

        // Compute an index from each point to an (arbitrary) incoming halfedge
        // Used to give the first neighbor of each point; for this reason,
        // on the hull we give priority to exterior halfedges
        for (let e = 0, n = halfedges.length; e < n; ++e) {
          const p = triangles[e % 3 === 2 ? e - 2 : e + 1];
          if (halfedges[e] === -1 || inedges[p] === -1) inedges[p] = e;
        }
        for (let i = 0, n = hull.length; i < n; ++i) {
          hullIndex[hull[i]] = i;
        }

        // degenerate case: 1 or 2 (distinct) points
        if (hull.length <= 2 && hull.length > 0) {
          this.triangles = new Int32Array(3).fill(-1);
          this.halfedges = new Int32Array(3).fill(-1);
          this.triangles[0] = hull[0];
          inedges[hull[0]] = 1;
          if (hull.length === 2) {
            inedges[hull[1]] = 0;
            this.triangles[1] = hull[1];
            this.triangles[2] = hull[1];
          }
        }
      }
      voronoi(bounds) {
        return new Voronoi(this, bounds);
      }
      *neighbors(i) {
        const {inedges, hull, _hullIndex, halfedges, triangles, collinear} = this;

        // degenerate case with several collinear points
        if (collinear) {
          const l = collinear.indexOf(i);
          if (l > 0) yield collinear[l - 1];
          if (l < collinear.length - 1) yield collinear[l + 1];
          return;
        }

        const e0 = inedges[i];
        if (e0 === -1) return; // coincident point
        let e = e0, p0 = -1;
        do {
          yield p0 = triangles[e];
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) return; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            const p = hull[(_hullIndex[i] + 1) % hull.length];
            if (p !== p0) yield p;
            return;
          }
        } while (e !== e0);
      }
      find(x, y, i = 0) {
        if ((x = +x, x !== x) || (y = +y, y !== y)) return -1;
        const i0 = i;
        let c;
        while ((c = this._step(i, x, y)) >= 0 && c !== i && c !== i0) i = c;
        return c;
      }
      _step(i, x, y) {
        const {inedges, hull, _hullIndex, halfedges, triangles, points} = this;
        if (inedges[i] === -1 || !points.length) return (i + 1) % (points.length >> 1);
        let c = i;
        let dc = pow$2(x - points[i * 2], 2) + pow$2(y - points[i * 2 + 1], 2);
        const e0 = inedges[i];
        let e = e0;
        do {
          let t = triangles[e];
          const dt = pow$2(x - points[t * 2], 2) + pow$2(y - points[t * 2 + 1], 2);
          if (dt < dc) dc = dt, c = t;
          e = e % 3 === 2 ? e - 2 : e + 1;
          if (triangles[e] !== i) break; // bad triangulation
          e = halfedges[e];
          if (e === -1) {
            e = hull[(_hullIndex[i] + 1) % hull.length];
            if (e !== t) {
              if (pow$2(x - points[e * 2], 2) + pow$2(y - points[e * 2 + 1], 2) < dc) return e;
            }
            break;
          }
        } while (e !== e0);
        return c;
      }
      render(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, halfedges, triangles} = this;
        for (let i = 0, n = halfedges.length; i < n; ++i) {
          const j = halfedges[i];
          if (j < i) continue;
          const ti = triangles[i] * 2;
          const tj = triangles[j] * 2;
          context.moveTo(points[ti], points[ti + 1]);
          context.lineTo(points[tj], points[tj + 1]);
        }
        this.renderHull(context);
        return buffer && buffer.value();
      }
      renderPoints(context, r) {
        if (r === undefined && (!context || typeof context.moveTo !== "function")) r = context, context = null;
        r = r == undefined ? 2 : +r;
        const buffer = context == null ? context = new Path : undefined;
        const {points} = this;
        for (let i = 0, n = points.length; i < n; i += 2) {
          const x = points[i], y = points[i + 1];
          context.moveTo(x + r, y);
          context.arc(x, y, r, 0, tau$2);
        }
        return buffer && buffer.value();
      }
      renderHull(context) {
        const buffer = context == null ? context = new Path : undefined;
        const {hull, points} = this;
        const h = hull[0] * 2, n = hull.length;
        context.moveTo(points[h], points[h + 1]);
        for (let i = 1; i < n; ++i) {
          const h = 2 * hull[i];
          context.lineTo(points[h], points[h + 1]);
        }
        context.closePath();
        return buffer && buffer.value();
      }
      hullPolygon() {
        const polygon = new Polygon;
        this.renderHull(polygon);
        return polygon.value();
      }
      renderTriangle(i, context) {
        const buffer = context == null ? context = new Path : undefined;
        const {points, triangles} = this;
        const t0 = triangles[i *= 3] * 2;
        const t1 = triangles[i + 1] * 2;
        const t2 = triangles[i + 2] * 2;
        context.moveTo(points[t0], points[t0 + 1]);
        context.lineTo(points[t1], points[t1 + 1]);
        context.lineTo(points[t2], points[t2 + 1]);
        context.closePath();
        return buffer && buffer.value();
      }
      *trianglePolygons() {
        const {triangles} = this;
        for (let i = 0, n = triangles.length / 3; i < n; ++i) {
          yield this.trianglePolygon(i);
        }
      }
      trianglePolygon(i) {
        const polygon = new Polygon;
        this.renderTriangle(i, polygon);
        return polygon.value();
      }
    }

    function flatArray(points, fx, fy, that) {
      const n = points.length;
      const array = new Float64Array(n * 2);
      for (let i = 0; i < n; ++i) {
        const p = points[i];
        array[i * 2] = fx.call(that, p, i, points);
        array[i * 2 + 1] = fy.call(that, p, i, points);
      }
      return array;
    }

    function* flatIterable(points, fx, fy, that) {
      let i = 0;
      for (const p of points) {
        yield fx.call(that, p, i, points);
        yield fy.call(that, p, i, points);
        ++i;
      }
    }

    var EOL = {},
        EOF = {},
        QUOTE = 34,
        NEWLINE = 10,
        RETURN = 13;

    function objectConverter(columns) {
      return new Function("d", "return {" + columns.map(function(name, i) {
        return JSON.stringify(name) + ": d[" + i + "] || \"\"";
      }).join(",") + "}");
    }

    function customConverter(columns, f) {
      var object = objectConverter(columns);
      return function(row, i) {
        return f(object(row), i, columns);
      };
    }

    // Compute unique columns in order of discovery.
    function inferColumns(rows) {
      var columnSet = Object.create(null),
          columns = [];

      rows.forEach(function(row) {
        for (var column in row) {
          if (!(column in columnSet)) {
            columns.push(columnSet[column] = column);
          }
        }
      });

      return columns;
    }

    function pad$1(value, width) {
      var s = value + "", length = s.length;
      return length < width ? new Array(width - length + 1).join(0) + s : s;
    }

    function formatYear$1(year) {
      return year < 0 ? "-" + pad$1(-year, 6)
        : year > 9999 ? "+" + pad$1(year, 6)
        : pad$1(year, 4);
    }

    function formatDate(date) {
      var hours = date.getUTCHours(),
          minutes = date.getUTCMinutes(),
          seconds = date.getUTCSeconds(),
          milliseconds = date.getUTCMilliseconds();
      return isNaN(date) ? "Invalid Date"
          : formatYear$1(date.getUTCFullYear()) + "-" + pad$1(date.getUTCMonth() + 1, 2) + "-" + pad$1(date.getUTCDate(), 2)
          + (milliseconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "." + pad$1(milliseconds, 3) + "Z"
          : seconds ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + ":" + pad$1(seconds, 2) + "Z"
          : minutes || hours ? "T" + pad$1(hours, 2) + ":" + pad$1(minutes, 2) + "Z"
          : "");
    }

    function dsvFormat(delimiter) {
      var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
          DELIMITER = delimiter.charCodeAt(0);

      function parse(text, f) {
        var convert, columns, rows = parseRows(text, function(row, i) {
          if (convert) return convert(row, i - 1);
          columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
        });
        rows.columns = columns || [];
        return rows;
      }

      function parseRows(text, f) {
        var rows = [], // output rows
            N = text.length,
            I = 0, // current character index
            n = 0, // current line number
            t, // current token
            eof = N <= 0, // current token followed by EOF?
            eol = false; // current token followed by EOL?

        // Strip the trailing newline.
        if (text.charCodeAt(N - 1) === NEWLINE) --N;
        if (text.charCodeAt(N - 1) === RETURN) --N;

        function token() {
          if (eof) return EOF;
          if (eol) return eol = false, EOL;

          // Unescape quotes.
          var i, j = I, c;
          if (text.charCodeAt(j) === QUOTE) {
            while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);
            if ((i = I) >= N) eof = true;
            else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            return text.slice(j + 1, i - 1).replace(/""/g, "\"");
          }

          // Find next delimiter or newline.
          while (I < N) {
            if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
            else if (c === RETURN) { eol = true; if (text.charCodeAt(I) === NEWLINE) ++I; }
            else if (c !== DELIMITER) continue;
            return text.slice(j, i);
          }

          // Return last token before EOF.
          return eof = true, text.slice(j, N);
        }

        while ((t = token()) !== EOF) {
          var row = [];
          while (t !== EOL && t !== EOF) row.push(t), t = token();
          if (f && (row = f(row, n++)) == null) continue;
          rows.push(row);
        }

        return rows;
      }

      function preformatBody(rows, columns) {
        return rows.map(function(row) {
          return columns.map(function(column) {
            return formatValue(row[column]);
          }).join(delimiter);
        });
      }

      function format(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
      }

      function formatBody(rows, columns) {
        if (columns == null) columns = inferColumns(rows);
        return preformatBody(rows, columns).join("\n");
      }

      function formatRows(rows) {
        return rows.map(formatRow).join("\n");
      }

      function formatRow(row) {
        return row.map(formatValue).join(delimiter);
      }

      function formatValue(value) {
        return value == null ? ""
            : value instanceof Date ? formatDate(value)
            : reFormat.test(value += "") ? "\"" + value.replace(/"/g, "\"\"") + "\""
            : value;
      }

      return {
        parse: parse,
        parseRows: parseRows,
        format: format,
        formatBody: formatBody,
        formatRows: formatRows,
        formatRow: formatRow,
        formatValue: formatValue
      };
    }

    var csv$1 = dsvFormat(",");

    var csvParse = csv$1.parse;
    var csvParseRows = csv$1.parseRows;
    var csvFormat = csv$1.format;
    var csvFormatBody = csv$1.formatBody;
    var csvFormatRows = csv$1.formatRows;
    var csvFormatRow = csv$1.formatRow;
    var csvFormatValue = csv$1.formatValue;

    var tsv$1 = dsvFormat("\t");

    var tsvParse = tsv$1.parse;
    var tsvParseRows = tsv$1.parseRows;
    var tsvFormat = tsv$1.format;
    var tsvFormatBody = tsv$1.formatBody;
    var tsvFormatRows = tsv$1.formatRows;
    var tsvFormatRow = tsv$1.formatRow;
    var tsvFormatValue = tsv$1.formatValue;

    function autoType(object) {
      for (var key in object) {
        var value = object[key].trim(), number, m;
        if (!value) value = null;
        else if (value === "true") value = true;
        else if (value === "false") value = false;
        else if (value === "NaN") value = NaN;
        else if (!isNaN(number = +value)) value = number;
        else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
          if (fixtz && !!m[4] && !m[7]) value = value.replace(/-/g, "/").replace(/T/, " ");
          value = new Date(value);
        }
        else continue;
        object[key] = value;
      }
      return object;
    }

    // https://github.com/d3/d3-dsv/issues/45
    const fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();

    function responseBlob(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.blob();
    }

    function blob(input, init) {
      return fetch(input, init).then(responseBlob);
    }

    function responseArrayBuffer(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.arrayBuffer();
    }

    function buffer(input, init) {
      return fetch(input, init).then(responseArrayBuffer);
    }

    function responseText(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      return response.text();
    }

    function text(input, init) {
      return fetch(input, init).then(responseText);
    }

    function dsvParse(parse) {
      return function(input, init, row) {
        if (arguments.length === 2 && typeof init === "function") row = init, init = undefined;
        return text(input, init).then(function(response) {
          return parse(response, row);
        });
      };
    }

    function dsv(delimiter, input, init, row) {
      if (arguments.length === 3 && typeof init === "function") row = init, init = undefined;
      var format = dsvFormat(delimiter);
      return text(input, init).then(function(response) {
        return format.parse(response, row);
      });
    }

    var csv = dsvParse(csvParse);
    var tsv = dsvParse(tsvParse);

    function image(input, init) {
      return new Promise(function(resolve, reject) {
        var image = new Image;
        for (var key in init) image[key] = init[key];
        image.onerror = reject;
        image.onload = function() { resolve(image); };
        image.src = input;
      });
    }

    function responseJson(response) {
      if (!response.ok) throw new Error(response.status + " " + response.statusText);
      if (response.status === 204 || response.status === 205) return;
      return response.json();
    }

    function json(input, init) {
      return fetch(input, init).then(responseJson);
    }

    function parser(type) {
      return (input, init) => text(input, init)
        .then(text => (new DOMParser).parseFromString(text, type));
    }

    var xml = parser("application/xml");

    var html = parser("text/html");

    var svg = parser("image/svg+xml");

    function center(x, y) {
      var nodes, strength = 1;

      if (x == null) x = 0;
      if (y == null) y = 0;

      function force() {
        var i,
            n = nodes.length,
            node,
            sx = 0,
            sy = 0;

        for (i = 0; i < n; ++i) {
          node = nodes[i], sx += node.x, sy += node.y;
        }

        for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
          node = nodes[i], node.x -= sx, node.y -= sy;
        }
      }

      force.initialize = function(_) {
        nodes = _;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      return force;
    }

    function tree_add(d) {
      const x = +this._x.call(null, d),
          y = +this._y.call(null, d);
      return add(this.cover(x, y), x, y, d);
    }

    function add(tree, x, y, d) {
      if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

      var parent,
          node = tree._root,
          leaf = {data: d},
          x0 = tree._x0,
          y0 = tree._y0,
          x1 = tree._x1,
          y1 = tree._y1,
          xm,
          ym,
          xp,
          yp,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return tree._root = leaf, tree;

      // Find the existing leaf for the new point, or add it.
      while (node.length) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
      }

      // Is the new point is exactly coincident with the existing point?
      xp = +tree._x.call(null, node.data);
      yp = +tree._y.call(null, node.data);
      if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

      // Otherwise, split the leaf node until the old and new point are separated.
      do {
        parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
      } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
      return parent[j] = node, parent[i] = leaf, tree;
    }

    function addAll(data) {
      var d, i, n = data.length,
          x,
          y,
          xz = new Array(n),
          yz = new Array(n),
          x0 = Infinity,
          y0 = Infinity,
          x1 = -Infinity,
          y1 = -Infinity;

      // Compute the points and their extent.
      for (i = 0; i < n; ++i) {
        if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
        xz[i] = x;
        yz[i] = y;
        if (x < x0) x0 = x;
        if (x > x1) x1 = x;
        if (y < y0) y0 = y;
        if (y > y1) y1 = y;
      }

      // If there were no (valid) points, abort.
      if (x0 > x1 || y0 > y1) return this;

      // Expand the tree to cover the new points.
      this.cover(x0, y0).cover(x1, y1);

      // Add the new points.
      for (i = 0; i < n; ++i) {
        add(this, xz[i], yz[i], data[i]);
      }

      return this;
    }

    function tree_cover(x, y) {
      if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

      var x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1;

      // If the quadtree has no extent, initialize them.
      // Integer extent are necessary so that if we later double the extent,
      // the existing quadrant boundaries dont change due to floating point error!
      if (isNaN(x0)) {
        x1 = (x0 = Math.floor(x)) + 1;
        y1 = (y0 = Math.floor(y)) + 1;
      }

      // Otherwise, double repeatedly to cover.
      else {
        var z = x1 - x0 || 1,
            node = this._root,
            parent,
            i;

        while (x0 > x || x >= x1 || y0 > y || y >= y1) {
          i = (y < y0) << 1 | (x < x0);
          parent = new Array(4), parent[i] = node, node = parent, z *= 2;
          switch (i) {
            case 0: x1 = x0 + z, y1 = y0 + z; break;
            case 1: x0 = x1 - z, y1 = y0 + z; break;
            case 2: x1 = x0 + z, y0 = y1 - z; break;
            case 3: x0 = x1 - z, y0 = y1 - z; break;
          }
        }

        if (this._root && this._root.length) this._root = node;
      }

      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      return this;
    }

    function tree_data() {
      var data = [];
      this.visit(function(node) {
        if (!node.length) do data.push(node.data); while (node = node.next)
      });
      return data;
    }

    function tree_extent(_) {
      return arguments.length
          ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
          : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
    }

    function Quad(node, x0, y0, x1, y1) {
      this.node = node;
      this.x0 = x0;
      this.y0 = y0;
      this.x1 = x1;
      this.y1 = y1;
    }

    function tree_find(x, y, radius) {
      var data,
          x0 = this._x0,
          y0 = this._y0,
          x1,
          y1,
          x2,
          y2,
          x3 = this._x1,
          y3 = this._y1,
          quads = [],
          node = this._root,
          q,
          i;

      if (node) quads.push(new Quad(node, x0, y0, x3, y3));
      if (radius == null) radius = Infinity;
      else {
        x0 = x - radius, y0 = y - radius;
        x3 = x + radius, y3 = y + radius;
        radius *= radius;
      }

      while (q = quads.pop()) {

        // Stop searching if this quadrant cant contain a closer node.
        if (!(node = q.node)
            || (x1 = q.x0) > x3
            || (y1 = q.y0) > y3
            || (x2 = q.x1) < x0
            || (y2 = q.y1) < y0) continue;

        // Bisect the current quadrant.
        if (node.length) {
          var xm = (x1 + x2) / 2,
              ym = (y1 + y2) / 2;

          quads.push(
            new Quad(node[3], xm, ym, x2, y2),
            new Quad(node[2], x1, ym, xm, y2),
            new Quad(node[1], xm, y1, x2, ym),
            new Quad(node[0], x1, y1, xm, ym)
          );

          // Visit the closest quadrant first.
          if (i = (y >= ym) << 1 | (x >= xm)) {
            q = quads[quads.length - 1];
            quads[quads.length - 1] = quads[quads.length - 1 - i];
            quads[quads.length - 1 - i] = q;
          }
        }

        // Visit this point. (Visiting coincident points isnt necessary!)
        else {
          var dx = x - +this._x.call(null, node.data),
              dy = y - +this._y.call(null, node.data),
              d2 = dx * dx + dy * dy;
          if (d2 < radius) {
            var d = Math.sqrt(radius = d2);
            x0 = x - d, y0 = y - d;
            x3 = x + d, y3 = y + d;
            data = node.data;
          }
        }
      }

      return data;
    }

    function tree_remove(d) {
      if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

      var parent,
          node = this._root,
          retainer,
          previous,
          next,
          x0 = this._x0,
          y0 = this._y0,
          x1 = this._x1,
          y1 = this._y1,
          x,
          y,
          xm,
          ym,
          right,
          bottom,
          i,
          j;

      // If the tree is empty, initialize the root as a leaf.
      if (!node) return this;

      // Find the leaf node for the point.
      // While descending, also retain the deepest parent with a non-removed sibling.
      if (node.length) while (true) {
        if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
        if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
        if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
        if (!node.length) break;
        if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
      }

      // Find the point to remove.
      while (node.data !== d) if (!(previous = node, node = node.next)) return this;
      if (next = node.next) delete node.next;

      // If there are multiple coincident points, remove just the point.
      if (previous) return (next ? previous.next = next : delete previous.next), this;

      // If this is the root point, remove it.
      if (!parent) return this._root = next, this;

      // Remove this leaf.
      next ? parent[i] = next : delete parent[i];

      // If the parent now contains exactly one leaf, collapse superfluous parents.
      if ((node = parent[0] || parent[1] || parent[2] || parent[3])
          && node === (parent[3] || parent[2] || parent[1] || parent[0])
          && !node.length) {
        if (retainer) retainer[j] = node;
        else this._root = node;
      }

      return this;
    }

    function removeAll(data) {
      for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
      return this;
    }

    function tree_root() {
      return this._root;
    }

    function tree_size() {
      var size = 0;
      this.visit(function(node) {
        if (!node.length) do ++size; while (node = node.next)
      });
      return size;
    }

    function tree_visit(callback) {
      var quads = [], q, node = this._root, child, x0, y0, x1, y1;
      if (node) quads.push(new Quad(node, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
          var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
        }
      }
      return this;
    }

    function tree_visitAfter(callback) {
      var quads = [], next = [], q;
      if (this._root) quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
      while (q = quads.pop()) {
        var node = q.node;
        if (node.length) {
          var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
          if (child = node[0]) quads.push(new Quad(child, x0, y0, xm, ym));
          if (child = node[1]) quads.push(new Quad(child, xm, y0, x1, ym));
          if (child = node[2]) quads.push(new Quad(child, x0, ym, xm, y1));
          if (child = node[3]) quads.push(new Quad(child, xm, ym, x1, y1));
        }
        next.push(q);
      }
      while (q = next.pop()) {
        callback(q.node, q.x0, q.y0, q.x1, q.y1);
      }
      return this;
    }

    function defaultX(d) {
      return d[0];
    }

    function tree_x(_) {
      return arguments.length ? (this._x = _, this) : this._x;
    }

    function defaultY(d) {
      return d[1];
    }

    function tree_y(_) {
      return arguments.length ? (this._y = _, this) : this._y;
    }

    function quadtree(nodes, x, y) {
      var tree = new Quadtree(x == null ? defaultX : x, y == null ? defaultY : y, NaN, NaN, NaN, NaN);
      return nodes == null ? tree : tree.addAll(nodes);
    }

    function Quadtree(x, y, x0, y0, x1, y1) {
      this._x = x;
      this._y = y;
      this._x0 = x0;
      this._y0 = y0;
      this._x1 = x1;
      this._y1 = y1;
      this._root = undefined;
    }

    function leaf_copy(leaf) {
      var copy = {data: leaf.data}, next = copy;
      while (leaf = leaf.next) next = next.next = {data: leaf.data};
      return copy;
    }

    var treeProto = quadtree.prototype = Quadtree.prototype;

    treeProto.copy = function() {
      var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
          node = this._root,
          nodes,
          child;

      if (!node) return copy;

      if (!node.length) return copy._root = leaf_copy(node), copy;

      nodes = [{source: node, target: copy._root = new Array(4)}];
      while (node = nodes.pop()) {
        for (var i = 0; i < 4; ++i) {
          if (child = node.source[i]) {
            if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
            else node.target[i] = leaf_copy(child);
          }
        }
      }

      return copy;
    };

    treeProto.add = tree_add;
    treeProto.addAll = addAll;
    treeProto.cover = tree_cover;
    treeProto.data = tree_data;
    treeProto.extent = tree_extent;
    treeProto.find = tree_find;
    treeProto.remove = tree_remove;
    treeProto.removeAll = removeAll;
    treeProto.root = tree_root;
    treeProto.size = tree_size;
    treeProto.visit = tree_visit;
    treeProto.visitAfter = tree_visitAfter;
    treeProto.x = tree_x;
    treeProto.y = tree_y;

    function constant$4(x) {
      return function() {
        return x;
      };
    }

    function jiggle(random) {
      return (random() - 0.5) * 1e-6;
    }

    function x$4(d) {
      return d.x + d.vx;
    }

    function y$3(d) {
      return d.y + d.vy;
    }

    function collide(radius) {
      var nodes,
          radii,
          random,
          strength = 1,
          iterations = 1;

      if (typeof radius !== "function") radius = constant$4(radius == null ? 1 : +radius);

      function force() {
        var i, n = nodes.length,
            tree,
            node,
            xi,
            yi,
            ri,
            ri2;

        for (var k = 0; k < iterations; ++k) {
          tree = quadtree(nodes, x$4, y$3).visitAfter(prepare);
          for (i = 0; i < n; ++i) {
            node = nodes[i];
            ri = radii[node.index], ri2 = ri * ri;
            xi = node.x + node.vx;
            yi = node.y + node.vy;
            tree.visit(apply);
          }
        }

        function apply(quad, x0, y0, x1, y1) {
          var data = quad.data, rj = quad.r, r = ri + rj;
          if (data) {
            if (data.index > node.index) {
              var x = xi - data.x - data.vx,
                  y = yi - data.y - data.vy,
                  l = x * x + y * y;
              if (l < r * r) {
                if (x === 0) x = jiggle(random), l += x * x;
                if (y === 0) y = jiggle(random), l += y * y;
                l = (r - (l = Math.sqrt(l))) / l * strength;
                node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
                node.vy += (y *= l) * r;
                data.vx -= x * (r = 1 - r);
                data.vy -= y * r;
              }
            }
            return;
          }
          return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
        }
      }

      function prepare(quad) {
        if (quad.data) return quad.r = radii[quad.data.index];
        for (var i = quad.r = 0; i < 4; ++i) {
          if (quad[i] && quad[i].r > quad.r) {
            quad.r = quad[i].r;
          }
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        radii = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = +_, force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      return force;
    }

    function index$3(d) {
      return d.index;
    }

    function find(nodeById, nodeId) {
      var node = nodeById.get(nodeId);
      if (!node) throw new Error("node not found: " + nodeId);
      return node;
    }

    function link$2(links) {
      var id = index$3,
          strength = defaultStrength,
          strengths,
          distance = constant$4(30),
          distances,
          nodes,
          count,
          bias,
          random,
          iterations = 1;

      if (links == null) links = [];

      function defaultStrength(link) {
        return 1 / Math.min(count[link.source.index], count[link.target.index]);
      }

      function force(alpha) {
        for (var k = 0, n = links.length; k < iterations; ++k) {
          for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
            link = links[i], source = link.source, target = link.target;
            x = target.x + target.vx - source.x - source.vx || jiggle(random);
            y = target.y + target.vy - source.y - source.vy || jiggle(random);
            l = Math.sqrt(x * x + y * y);
            l = (l - distances[i]) / l * alpha * strengths[i];
            x *= l, y *= l;
            target.vx -= x * (b = bias[i]);
            target.vy -= y * b;
            source.vx += x * (b = 1 - b);
            source.vy += y * b;
          }
        }
      }

      function initialize() {
        if (!nodes) return;

        var i,
            n = nodes.length,
            m = links.length,
            nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
            link;

        for (i = 0, count = new Array(n); i < m; ++i) {
          link = links[i], link.index = i;
          if (typeof link.source !== "object") link.source = find(nodeById, link.source);
          if (typeof link.target !== "object") link.target = find(nodeById, link.target);
          count[link.source.index] = (count[link.source.index] || 0) + 1;
          count[link.target.index] = (count[link.target.index] || 0) + 1;
        }

        for (i = 0, bias = new Array(m); i < m; ++i) {
          link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
        }

        strengths = new Array(m), initializeStrength();
        distances = new Array(m), initializeDistance();
      }

      function initializeStrength() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          strengths[i] = +strength(links[i], i, links);
        }
      }

      function initializeDistance() {
        if (!nodes) return;

        for (var i = 0, n = links.length; i < n; ++i) {
          distances[i] = +distance(links[i], i, links);
        }
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.links = function(_) {
        return arguments.length ? (links = _, initialize(), force) : links;
      };

      force.id = function(_) {
        return arguments.length ? (id = _, force) : id;
      };

      force.iterations = function(_) {
        return arguments.length ? (iterations = +_, force) : iterations;
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initializeStrength(), force) : strength;
      };

      force.distance = function(_) {
        return arguments.length ? (distance = typeof _ === "function" ? _ : constant$4(+_), initializeDistance(), force) : distance;
      };

      return force;
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$2 = 1664525;
    const c$4 = 1013904223;
    const m$1 = 4294967296; // 2^32

    function lcg$2() {
      let s = 1;
      return () => (s = (a$2 * s + c$4) % m$1) / m$1;
    }

    function x$3(d) {
      return d.x;
    }

    function y$2(d) {
      return d.y;
    }

    var initialRadius = 10,
        initialAngle = Math.PI * (3 - Math.sqrt(5));

    function simulation(nodes) {
      var simulation,
          alpha = 1,
          alphaMin = 0.001,
          alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
          alphaTarget = 0,
          velocityDecay = 0.6,
          forces = new Map(),
          stepper = timer(step),
          event = dispatch("tick", "end"),
          random = lcg$2();

      if (nodes == null) nodes = [];

      function step() {
        tick();
        event.call("tick", simulation);
        if (alpha < alphaMin) {
          stepper.stop();
          event.call("end", simulation);
        }
      }

      function tick(iterations) {
        var i, n = nodes.length, node;

        if (iterations === undefined) iterations = 1;

        for (var k = 0; k < iterations; ++k) {
          alpha += (alphaTarget - alpha) * alphaDecay;

          forces.forEach(function(force) {
            force(alpha);
          });

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            if (node.fx == null) node.x += node.vx *= velocityDecay;
            else node.x = node.fx, node.vx = 0;
            if (node.fy == null) node.y += node.vy *= velocityDecay;
            else node.y = node.fy, node.vy = 0;
          }
        }

        return simulation;
      }

      function initializeNodes() {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.index = i;
          if (node.fx != null) node.x = node.fx;
          if (node.fy != null) node.y = node.fy;
          if (isNaN(node.x) || isNaN(node.y)) {
            var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
            node.x = radius * Math.cos(angle);
            node.y = radius * Math.sin(angle);
          }
          if (isNaN(node.vx) || isNaN(node.vy)) {
            node.vx = node.vy = 0;
          }
        }
      }

      function initializeForce(force) {
        if (force.initialize) force.initialize(nodes, random);
        return force;
      }

      initializeNodes();

      return simulation = {
        tick: tick,

        restart: function() {
          return stepper.restart(step), simulation;
        },

        stop: function() {
          return stepper.stop(), simulation;
        },

        nodes: function(_) {
          return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
        },

        alpha: function(_) {
          return arguments.length ? (alpha = +_, simulation) : alpha;
        },

        alphaMin: function(_) {
          return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
        },

        alphaDecay: function(_) {
          return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
        },

        alphaTarget: function(_) {
          return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
        },

        velocityDecay: function(_) {
          return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
        },

        randomSource: function(_) {
          return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
        },

        force: function(name, _) {
          return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
        },

        find: function(x, y, radius) {
          var i = 0,
              n = nodes.length,
              dx,
              dy,
              d2,
              node,
              closest;

          if (radius == null) radius = Infinity;
          else radius *= radius;

          for (i = 0; i < n; ++i) {
            node = nodes[i];
            dx = x - node.x;
            dy = y - node.y;
            d2 = dx * dx + dy * dy;
            if (d2 < radius) closest = node, radius = d2;
          }

          return closest;
        },

        on: function(name, _) {
          return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
        }
      };
    }

    function manyBody() {
      var nodes,
          node,
          random,
          alpha,
          strength = constant$4(-30),
          strengths,
          distanceMin2 = 1,
          distanceMax2 = Infinity,
          theta2 = 0.81;

      function force(_) {
        var i, n = nodes.length, tree = quadtree(nodes, x$3, y$2).visitAfter(accumulate);
        for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length, node;
        strengths = new Array(n);
        for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
      }

      function accumulate(quad) {
        var strength = 0, q, c, weight = 0, x, y, i;

        // For internal nodes, accumulate forces from child quadrants.
        if (quad.length) {
          for (x = y = i = 0; i < 4; ++i) {
            if ((q = quad[i]) && (c = Math.abs(q.value))) {
              strength += q.value, weight += c, x += c * q.x, y += c * q.y;
            }
          }
          quad.x = x / weight;
          quad.y = y / weight;
        }

        // For leaf nodes, accumulate forces from coincident quadrants.
        else {
          q = quad;
          q.x = q.data.x;
          q.y = q.data.y;
          do strength += strengths[q.data.index];
          while (q = q.next);
        }

        quad.value = strength;
      }

      function apply(quad, x1, _, x2) {
        if (!quad.value) return true;

        var x = quad.x - node.x,
            y = quad.y - node.y,
            w = x2 - x1,
            l = x * x + y * y;

        // Apply the Barnes-Hut approximation if possible.
        // Limit forces for very close nodes; randomize direction if coincident.
        if (w * w / theta2 < l) {
          if (l < distanceMax2) {
            if (x === 0) x = jiggle(random), l += x * x;
            if (y === 0) y = jiggle(random), l += y * y;
            if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
            node.vx += x * quad.value * alpha / l;
            node.vy += y * quad.value * alpha / l;
          }
          return true;
        }

        // Otherwise, process points directly.
        else if (quad.length || l >= distanceMax2) return;

        // Limit forces for very close nodes; randomize direction if coincident.
        if (quad.data !== node || quad.next) {
          if (x === 0) x = jiggle(random), l += x * x;
          if (y === 0) y = jiggle(random), l += y * y;
          if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        }

        do if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l;
          node.vx += x * w;
          node.vy += y * w;
        } while (quad = quad.next);
      }

      force.initialize = function(_nodes, _random) {
        nodes = _nodes;
        random = _random;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.distanceMin = function(_) {
        return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
      };

      force.distanceMax = function(_) {
        return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
      };

      force.theta = function(_) {
        return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
      };

      return force;
    }

    function radial$1(radius, x, y) {
      var nodes,
          strength = constant$4(0.1),
          strengths,
          radiuses;

      if (typeof radius !== "function") radius = constant$4(+radius);
      if (x == null) x = 0;
      if (y == null) y = 0;

      function force(alpha) {
        for (var i = 0, n = nodes.length; i < n; ++i) {
          var node = nodes[i],
              dx = node.x - x || 1e-6,
              dy = node.y - y || 1e-6,
              r = Math.sqrt(dx * dx + dy * dy),
              k = (radiuses[i] - r) * strengths[i] * alpha / r;
          node.vx += dx * k;
          node.vy += dy * k;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        radiuses = new Array(n);
        for (i = 0; i < n; ++i) {
          radiuses[i] = +radius(nodes[i], i, nodes);
          strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _, initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : radius;
      };

      force.x = function(_) {
        return arguments.length ? (x = +_, force) : x;
      };

      force.y = function(_) {
        return arguments.length ? (y = +_, force) : y;
      };

      return force;
    }

    function x$2(x) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          xz;

      if (typeof x !== "function") x = constant$4(x == null ? 0 : +x);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        xz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : x;
      };

      return force;
    }

    function y$1(y) {
      var strength = constant$4(0.1),
          nodes,
          strengths,
          yz;

      if (typeof y !== "function") y = constant$4(y == null ? 0 : +y);

      function force(alpha) {
        for (var i = 0, n = nodes.length, node; i < n; ++i) {
          node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
        }
      }

      function initialize() {
        if (!nodes) return;
        var i, n = nodes.length;
        strengths = new Array(n);
        yz = new Array(n);
        for (i = 0; i < n; ++i) {
          strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
        }
      }

      force.initialize = function(_) {
        nodes = _;
        initialize();
      };

      force.strength = function(_) {
        return arguments.length ? (strength = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : strength;
      };

      force.y = function(_) {
        return arguments.length ? (y = typeof _ === "function" ? _ : constant$4(+_), initialize(), force) : y;
      };

      return force;
    }

    function formatDecimal(x) {
      return Math.abs(x = Math.round(x)) >= 1e21
          ? x.toLocaleString("en").replace(/,/g, "")
          : x.toString(10);
    }

    // Computes the decimal coefficient and exponent of the specified number x with
    // significant digits p, where x is positive and p is in [1, 21] or undefined.
    // For example, formatDecimalParts(1.23) returns ["123", 0].
    function formatDecimalParts(x, p) {
      if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, Infinity
      var i, coefficient = x.slice(0, i);

      // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
      // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
      return [
        coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
        +x.slice(i + 1)
      ];
    }

    function exponent(x) {
      return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
    }

    function formatGroup(grouping, thousands) {
      return function(value, width) {
        var i = value.length,
            t = [],
            j = 0,
            g = grouping[0],
            length = 0;

        while (i > 0 && g > 0) {
          if (length + g + 1 > width) g = Math.max(1, width - length);
          t.push(value.substring(i -= g, i + g));
          if ((length += g + 1) > width) break;
          g = grouping[j = (j + 1) % grouping.length];
        }

        return t.reverse().join(thousands);
      };
    }

    function formatNumerals(numerals) {
      return function(value) {
        return value.replace(/[0-9]/g, function(i) {
          return numerals[+i];
        });
      };
    }

    // [[fill]align][sign][symbol][0][width][,][.precision][~][type]
    var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;

    function formatSpecifier(specifier) {
      if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
      var match;
      return new FormatSpecifier({
        fill: match[1],
        align: match[2],
        sign: match[3],
        symbol: match[4],
        zero: match[5],
        width: match[6],
        comma: match[7],
        precision: match[8] && match[8].slice(1),
        trim: match[9],
        type: match[10]
      });
    }

    formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

    function FormatSpecifier(specifier) {
      this.fill = specifier.fill === undefined ? " " : specifier.fill + "";
      this.align = specifier.align === undefined ? ">" : specifier.align + "";
      this.sign = specifier.sign === undefined ? "-" : specifier.sign + "";
      this.symbol = specifier.symbol === undefined ? "" : specifier.symbol + "";
      this.zero = !!specifier.zero;
      this.width = specifier.width === undefined ? undefined : +specifier.width;
      this.comma = !!specifier.comma;
      this.precision = specifier.precision === undefined ? undefined : +specifier.precision;
      this.trim = !!specifier.trim;
      this.type = specifier.type === undefined ? "" : specifier.type + "";
    }

    FormatSpecifier.prototype.toString = function() {
      return this.fill
          + this.align
          + this.sign
          + this.symbol
          + (this.zero ? "0" : "")
          + (this.width === undefined ? "" : Math.max(1, this.width | 0))
          + (this.comma ? "," : "")
          + (this.precision === undefined ? "" : "." + Math.max(0, this.precision | 0))
          + (this.trim ? "~" : "")
          + this.type;
    };

    // Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.
    function formatTrim(s) {
      out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".": i0 = i1 = i; break;
          case "0": if (i0 === 0) i0 = i; i1 = i; break;
          default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;
        }
      }
      return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
    }

    var prefixExponent;

    function formatPrefixAuto(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1],
          i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
          n = coefficient.length;
      return i === n ? coefficient
          : i > n ? coefficient + new Array(i - n + 1).join("0")
          : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
          : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!
    }

    function formatRounded(x, p) {
      var d = formatDecimalParts(x, p);
      if (!d) return x + "";
      var coefficient = d[0],
          exponent = d[1];
      return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
          : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
          : coefficient + new Array(exponent - coefficient.length + 2).join("0");
    }

    var formatTypes = {
      "%": (x, p) => (x * 100).toFixed(p),
      "b": (x) => Math.round(x).toString(2),
      "c": (x) => x + "",
      "d": formatDecimal,
      "e": (x, p) => x.toExponential(p),
      "f": (x, p) => x.toFixed(p),
      "g": (x, p) => x.toPrecision(p),
      "o": (x) => Math.round(x).toString(8),
      "p": (x, p) => formatRounded(x * 100, p),
      "r": formatRounded,
      "s": formatPrefixAuto,
      "X": (x) => Math.round(x).toString(16).toUpperCase(),
      "x": (x) => Math.round(x).toString(16)
    };

    function identity$6(x) {
      return x;
    }

    var map = Array.prototype.map,
        prefixes = ["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];

    function formatLocale$1(locale) {
      var group = locale.grouping === undefined || locale.thousands === undefined ? identity$6 : formatGroup(map.call(locale.grouping, Number), locale.thousands + ""),
          currencyPrefix = locale.currency === undefined ? "" : locale.currency[0] + "",
          currencySuffix = locale.currency === undefined ? "" : locale.currency[1] + "",
          decimal = locale.decimal === undefined ? "." : locale.decimal + "",
          numerals = locale.numerals === undefined ? identity$6 : formatNumerals(map.call(locale.numerals, String)),
          percent = locale.percent === undefined ? "%" : locale.percent + "",
          minus = locale.minus === undefined ? "" : locale.minus + "",
          nan = locale.nan === undefined ? "NaN" : locale.nan + "";

      function newFormat(specifier) {
        specifier = formatSpecifier(specifier);

        var fill = specifier.fill,
            align = specifier.align,
            sign = specifier.sign,
            symbol = specifier.symbol,
            zero = specifier.zero,
            width = specifier.width,
            comma = specifier.comma,
            precision = specifier.precision,
            trim = specifier.trim,
            type = specifier.type;

        // The "n" type is an alias for ",g".
        if (type === "n") comma = true, type = "g";

        // The "" type, and any invalid type, is an alias for ".12~g".
        else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = "g";

        // If zero fill is specified, padding goes after sign and before digits.
        if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

        // Compute the prefix and suffix.
        // For SI-prefix, the suffix is lazily computed.
        var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
            suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";

        // What format function should we use?
        // Is this an integer type?
        // Can this type generate exponential notation?
        var formatType = formatTypes[type],
            maybeSuffix = /[defgprs%]/.test(type);

        // Set the default precision if not specified,
        // or clamp the specified precision to the supported range.
        // For significant precision, it must be in [1, 21].
        // For fixed precision, it must be in [0, 20].
        precision = precision === undefined ? 6
            : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
            : Math.max(0, Math.min(20, precision));

        function format(value) {
          var valuePrefix = prefix,
              valueSuffix = suffix,
              i, n, c;

          if (type === "c") {
            valueSuffix = formatType(value) + valueSuffix;
            value = "";
          } else {
            value = +value;

            // Determine the sign. -0 is not less than 0, but 1 / -0 is!
            var valueNegative = value < 0 || 1 / value < 0;

            // Perform the initial formatting.
            value = isNaN(value) ? nan : formatType(Math.abs(value), precision);

            // Trim insignificant zeros.
            if (trim) value = formatTrim(value);

            // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.
            if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;

            // Compute the prefix and suffix.
            valuePrefix = (valueNegative ? (sign === "(" ? sign : minus) : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
            valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");

            // Break the formatted value into the integer value part that can be
            // grouped, and fractional or exponential suffix part that is not.
            if (maybeSuffix) {
              i = -1, n = value.length;
              while (++i < n) {
                if (c = value.charCodeAt(i), 48 > c || c > 57) {
                  valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                  value = value.slice(0, i);
                  break;
                }
              }
            }
          }

          // If the fill character is not "0", grouping is applied before padding.
          if (comma && !zero) value = group(value, Infinity);

          // Compute the padding.
          var length = valuePrefix.length + value.length + valueSuffix.length,
              padding = length < width ? new Array(width - length + 1).join(fill) : "";

          // If the fill character is "0", grouping is applied after padding.
          if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

          // Reconstruct the final output based on the desired alignment.
          switch (align) {
            case "<": value = valuePrefix + value + valueSuffix + padding; break;
            case "=": value = valuePrefix + padding + value + valueSuffix; break;
            case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
            default: value = padding + valuePrefix + value + valueSuffix; break;
          }

          return numerals(value);
        }

        format.toString = function() {
          return specifier + "";
        };

        return format;
      }

      function formatPrefix(specifier, value) {
        var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
            e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
            k = Math.pow(10, -e),
            prefix = prefixes[8 + e / 3];
        return function(value) {
          return f(k * value) + prefix;
        };
      }

      return {
        format: newFormat,
        formatPrefix: formatPrefix
      };
    }

    var locale$1;
    var format;
    var formatPrefix;

    defaultLocale$1({
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    });

    function defaultLocale$1(definition) {
      locale$1 = formatLocale$1(definition);
      format = locale$1.format;
      formatPrefix = locale$1.formatPrefix;
      return locale$1;
    }

    function precisionFixed(step) {
      return Math.max(0, -exponent(Math.abs(step)));
    }

    function precisionPrefix(step, value) {
      return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
    }

    function precisionRound(step, max) {
      step = Math.abs(step), max = Math.abs(max) - step;
      return Math.max(0, exponent(max) - exponent(step)) + 1;
    }

    var epsilon$1 = 1e-6;
    var epsilon2 = 1e-12;
    var pi$1 = Math.PI;
    var halfPi$1 = pi$1 / 2;
    var quarterPi = pi$1 / 4;
    var tau$1 = pi$1 * 2;

    var degrees = 180 / pi$1;
    var radians = pi$1 / 180;

    var abs$1 = Math.abs;
    var atan = Math.atan;
    var atan2$1 = Math.atan2;
    var cos$1 = Math.cos;
    var ceil = Math.ceil;
    var exp = Math.exp;
    var hypot = Math.hypot;
    var log$1 = Math.log;
    var pow$1 = Math.pow;
    var sin$1 = Math.sin;
    var sign$1 = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
    var sqrt$2 = Math.sqrt;
    var tan = Math.tan;

    function acos$1(x) {
      return x > 1 ? 0 : x < -1 ? pi$1 : Math.acos(x);
    }

    function asin$1(x) {
      return x > 1 ? halfPi$1 : x < -1 ? -halfPi$1 : Math.asin(x);
    }

    function haversin(x) {
      return (x = sin$1(x / 2)) * x;
    }

    function noop$1() {}

    function streamGeometry(geometry, stream) {
      if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
        streamGeometryType[geometry.type](geometry, stream);
      }
    }

    var streamObjectType = {
      Feature: function(object, stream) {
        streamGeometry(object.geometry, stream);
      },
      FeatureCollection: function(object, stream) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) streamGeometry(features[i].geometry, stream);
      }
    };

    var streamGeometryType = {
      Sphere: function(object, stream) {
        stream.sphere();
      },
      Point: function(object, stream) {
        object = object.coordinates;
        stream.point(object[0], object[1], object[2]);
      },
      MultiPoint: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
      },
      LineString: function(object, stream) {
        streamLine(object.coordinates, stream, 0);
      },
      MultiLineString: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamLine(coordinates[i], stream, 0);
      },
      Polygon: function(object, stream) {
        streamPolygon(object.coordinates, stream);
      },
      MultiPolygon: function(object, stream) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) streamPolygon(coordinates[i], stream);
      },
      GeometryCollection: function(object, stream) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) streamGeometry(geometries[i], stream);
      }
    };

    function streamLine(coordinates, stream, closed) {
      var i = -1, n = coordinates.length - closed, coordinate;
      stream.lineStart();
      while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
      stream.lineEnd();
    }

    function streamPolygon(coordinates, stream) {
      var i = -1, n = coordinates.length;
      stream.polygonStart();
      while (++i < n) streamLine(coordinates[i], stream, 1);
      stream.polygonEnd();
    }

    function geoStream(object, stream) {
      if (object && streamObjectType.hasOwnProperty(object.type)) {
        streamObjectType[object.type](object, stream);
      } else {
        streamGeometry(object, stream);
      }
    }

    var areaRingSum$1 = new Adder();

    // hello?

    var areaSum$1 = new Adder(),
        lambda00$2,
        phi00$2,
        lambda0$2,
        cosPhi0$1,
        sinPhi0$1;

    var areaStream$1 = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaRingSum$1 = new Adder();
        areaStream$1.lineStart = areaRingStart$1;
        areaStream$1.lineEnd = areaRingEnd$1;
      },
      polygonEnd: function() {
        var areaRing = +areaRingSum$1;
        areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
        this.lineStart = this.lineEnd = this.point = noop$1;
      },
      sphere: function() {
        areaSum$1.add(tau$1);
      }
    };

    function areaRingStart$1() {
      areaStream$1.point = areaPointFirst$1;
    }

    function areaRingEnd$1() {
      areaPoint$1(lambda00$2, phi00$2);
    }

    function areaPointFirst$1(lambda, phi) {
      areaStream$1.point = areaPoint$1;
      lambda00$2 = lambda, phi00$2 = phi;
      lambda *= radians, phi *= radians;
      lambda0$2 = lambda, cosPhi0$1 = cos$1(phi = phi / 2 + quarterPi), sinPhi0$1 = sin$1(phi);
    }

    function areaPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      phi = phi / 2 + quarterPi; // half the angular distance from south pole

      // Spherical excess E for a spherical triangle with vertices: south pole,
      // previous point, current point.  Uses a formula derived from Cagnolis
      // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).
      var dLambda = lambda - lambda0$2,
          sdLambda = dLambda >= 0 ? 1 : -1,
          adLambda = sdLambda * dLambda,
          cosPhi = cos$1(phi),
          sinPhi = sin$1(phi),
          k = sinPhi0$1 * sinPhi,
          u = cosPhi0$1 * cosPhi + k * cos$1(adLambda),
          v = k * sdLambda * sin$1(adLambda);
      areaRingSum$1.add(atan2$1(v, u));

      // Advance the previous points.
      lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
    }

    function area$2(object) {
      areaSum$1 = new Adder();
      geoStream(object, areaStream$1);
      return areaSum$1 * 2;
    }

    function spherical(cartesian) {
      return [atan2$1(cartesian[1], cartesian[0]), asin$1(cartesian[2])];
    }

    function cartesian(spherical) {
      var lambda = spherical[0], phi = spherical[1], cosPhi = cos$1(phi);
      return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi)];
    }

    function cartesianDot(a, b) {
      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    }

    function cartesianCross(a, b) {
      return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
    }

    // TODO return a
    function cartesianAddInPlace(a, b) {
      a[0] += b[0], a[1] += b[1], a[2] += b[2];
    }

    function cartesianScale(vector, k) {
      return [vector[0] * k, vector[1] * k, vector[2] * k];
    }

    // TODO return d
    function cartesianNormalizeInPlace(d) {
      var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
      d[0] /= l, d[1] /= l, d[2] /= l;
    }

    var lambda0$1, phi0, lambda1, phi1, // bounds
        lambda2, // previous lambda-coordinate
        lambda00$1, phi00$1, // first point
        p0, // previous 3D point
        deltaSum,
        ranges,
        range;

    var boundsStream$2 = {
      point: boundsPoint$1,
      lineStart: boundsLineStart,
      lineEnd: boundsLineEnd,
      polygonStart: function() {
        boundsStream$2.point = boundsRingPoint;
        boundsStream$2.lineStart = boundsRingStart;
        boundsStream$2.lineEnd = boundsRingEnd;
        deltaSum = new Adder();
        areaStream$1.polygonStart();
      },
      polygonEnd: function() {
        areaStream$1.polygonEnd();
        boundsStream$2.point = boundsPoint$1;
        boundsStream$2.lineStart = boundsLineStart;
        boundsStream$2.lineEnd = boundsLineEnd;
        if (areaRingSum$1 < 0) lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
        else if (deltaSum > epsilon$1) phi1 = 90;
        else if (deltaSum < -epsilon$1) phi0 = -90;
        range[0] = lambda0$1, range[1] = lambda1;
      },
      sphere: function() {
        lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
      }
    };

    function boundsPoint$1(lambda, phi) {
      ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    function linePoint(lambda, phi) {
      var p = cartesian([lambda * radians, phi * radians]);
      if (p0) {
        var normal = cartesianCross(p0, p),
            equatorial = [normal[1], -normal[0], 0],
            inflection = cartesianCross(equatorial, normal);
        cartesianNormalizeInPlace(inflection);
        inflection = spherical(inflection);
        var delta = lambda - lambda2,
            sign = delta > 0 ? 1 : -1,
            lambdai = inflection[0] * degrees * sign,
            phii,
            antimeridian = abs$1(delta) > 180;
        if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = inflection[1] * degrees;
          if (phii > phi1) phi1 = phii;
        } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
          phii = -inflection[1] * degrees;
          if (phii < phi0) phi0 = phii;
        } else {
          if (phi < phi0) phi0 = phi;
          if (phi > phi1) phi1 = phi;
        }
        if (antimeridian) {
          if (lambda < lambda2) {
            if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
          } else {
            if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
          }
        } else {
          if (lambda1 >= lambda0$1) {
            if (lambda < lambda0$1) lambda0$1 = lambda;
            if (lambda > lambda1) lambda1 = lambda;
          } else {
            if (lambda > lambda2) {
              if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1)) lambda1 = lambda;
            } else {
              if (angle(lambda, lambda1) > angle(lambda0$1, lambda1)) lambda0$1 = lambda;
            }
          }
        }
      } else {
        ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
      }
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
      p0 = p, lambda2 = lambda;
    }

    function boundsLineStart() {
      boundsStream$2.point = linePoint;
    }

    function boundsLineEnd() {
      range[0] = lambda0$1, range[1] = lambda1;
      boundsStream$2.point = boundsPoint$1;
      p0 = null;
    }

    function boundsRingPoint(lambda, phi) {
      if (p0) {
        var delta = lambda - lambda2;
        deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
      } else {
        lambda00$1 = lambda, phi00$1 = phi;
      }
      areaStream$1.point(lambda, phi);
      linePoint(lambda, phi);
    }

    function boundsRingStart() {
      areaStream$1.lineStart();
    }

    function boundsRingEnd() {
      boundsRingPoint(lambda00$1, phi00$1);
      areaStream$1.lineEnd();
      if (abs$1(deltaSum) > epsilon$1) lambda0$1 = -(lambda1 = 180);
      range[0] = lambda0$1, range[1] = lambda1;
      p0 = null;
    }

    // Finds the left-right distance between two longitudes.
    // This is almost the same as (lambda1 - lambda0 + 360) % 360, except that we want
    // the distance between 180 to be 360.
    function angle(lambda0, lambda1) {
      return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
    }

    function rangeCompare(a, b) {
      return a[0] - b[0];
    }

    function rangeContains(range, x) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }

    function bounds(feature) {
      var i, n, a, b, merged, deltaMax, delta;

      phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
      ranges = [];
      geoStream(feature, boundsStream$2);

      // First, sort ranges by their minimum longitudes.
      if (n = ranges.length) {
        ranges.sort(rangeCompare);

        // Then, merge any ranges that overlap.
        for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
          b = ranges[i];
          if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }

        // Finally, find the largest gap between the merged ranges.
        // The final bounding box will be the inverse of this gap.
        for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
          b = merged[i];
          if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0$1 = b[0], lambda1 = a[1];
        }
      }

      ranges = range = null;

      return lambda0$1 === Infinity || phi0 === Infinity
          ? [[NaN, NaN], [NaN, NaN]]
          : [[lambda0$1, phi0], [lambda1, phi1]];
    }

    var W0, W1,
        X0$1, Y0$1, Z0$1,
        X1$1, Y1$1, Z1$1,
        X2$1, Y2$1, Z2$1,
        lambda00, phi00, // first point
        x0$4, y0$4, z0; // previous point

    var centroidStream$1 = {
      sphere: noop$1,
      point: centroidPoint$1,
      lineStart: centroidLineStart$1,
      lineEnd: centroidLineEnd$1,
      polygonStart: function() {
        centroidStream$1.lineStart = centroidRingStart$1;
        centroidStream$1.lineEnd = centroidRingEnd$1;
      },
      polygonEnd: function() {
        centroidStream$1.lineStart = centroidLineStart$1;
        centroidStream$1.lineEnd = centroidLineEnd$1;
      }
    };

    // Arithmetic mean of Cartesian vectors.
    function centroidPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi));
    }

    function centroidPointCartesian(x, y, z) {
      ++W0;
      X0$1 += (x - X0$1) / W0;
      Y0$1 += (y - Y0$1) / W0;
      Z0$1 += (z - Z0$1) / W0;
    }

    function centroidLineStart$1() {
      centroidStream$1.point = centroidLinePointFirst;
    }

    function centroidLinePointFirst(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidStream$1.point = centroidLinePoint;
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLinePoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          w = atan2$1(sqrt$2((w = y0$4 * z - z0 * y) * w + (w = z0 * x - x0$4 * z) * w + (w = x0$4 * y - y0$4 * x) * w), x0$4 * x + y0$4 * y + z0 * z);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidLineEnd$1() {
      centroidStream$1.point = centroidPoint$1;
    }

    // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
    // J. Applied Mechanics 42, 239 (1975).
    function centroidRingStart$1() {
      centroidStream$1.point = centroidRingPointFirst;
    }

    function centroidRingEnd$1() {
      centroidRingPoint(lambda00, phi00);
      centroidStream$1.point = centroidPoint$1;
    }

    function centroidRingPointFirst(lambda, phi) {
      lambda00 = lambda, phi00 = phi;
      lambda *= radians, phi *= radians;
      centroidStream$1.point = centroidRingPoint;
      var cosPhi = cos$1(phi);
      x0$4 = cosPhi * cos$1(lambda);
      y0$4 = cosPhi * sin$1(lambda);
      z0 = sin$1(phi);
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroidRingPoint(lambda, phi) {
      lambda *= radians, phi *= radians;
      var cosPhi = cos$1(phi),
          x = cosPhi * cos$1(lambda),
          y = cosPhi * sin$1(lambda),
          z = sin$1(phi),
          cx = y0$4 * z - z0 * y,
          cy = z0 * x - x0$4 * z,
          cz = x0$4 * y - y0$4 * x,
          m = hypot(cx, cy, cz),
          w = asin$1(m), // line weight = angle
          v = m && -w / m; // area weight multiplier
      X2$1.add(v * cx);
      Y2$1.add(v * cy);
      Z2$1.add(v * cz);
      W1 += w;
      X1$1 += w * (x0$4 + (x0$4 = x));
      Y1$1 += w * (y0$4 + (y0$4 = y));
      Z1$1 += w * (z0 + (z0 = z));
      centroidPointCartesian(x0$4, y0$4, z0);
    }

    function centroid$1(object) {
      W0 = W1 =
      X0$1 = Y0$1 = Z0$1 =
      X1$1 = Y1$1 = Z1$1 = 0;
      X2$1 = new Adder();
      Y2$1 = new Adder();
      Z2$1 = new Adder();
      geoStream(object, centroidStream$1);

      var x = +X2$1,
          y = +Y2$1,
          z = +Z2$1,
          m = hypot(x, y, z);

      // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.
      if (m < epsilon2) {
        x = X1$1, y = Y1$1, z = Z1$1;
        // If the feature has zero length, fall back to arithmetic mean of point vectors.
        if (W1 < epsilon$1) x = X0$1, y = Y0$1, z = Z0$1;
        m = hypot(x, y, z);
        // If the feature still has an undefined ccentroid, then return.
        if (m < epsilon2) return [NaN, NaN];
      }

      return [atan2$1(y, x) * degrees, asin$1(z / m) * degrees];
    }

    function constant$3(x) {
      return function() {
        return x;
      };
    }

    function compose(a, b) {

      function compose(x, y) {
        return x = a(x, y), b(x[0], x[1]);
      }

      if (a.invert && b.invert) compose.invert = function(x, y) {
        return x = b.invert(x, y), x && a.invert(x[0], x[1]);
      };

      return compose;
    }

    function rotationIdentity(lambda, phi) {
      return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi];
    }

    rotationIdentity.invert = rotationIdentity;

    function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
      return (deltaLambda %= tau$1) ? (deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma))
        : rotationLambda(deltaLambda))
        : (deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma)
        : rotationIdentity);
    }

    function forwardRotationLambda(deltaLambda) {
      return function(lambda, phi) {
        return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi];
      };
    }

    function rotationLambda(deltaLambda) {
      var rotation = forwardRotationLambda(deltaLambda);
      rotation.invert = forwardRotationLambda(-deltaLambda);
      return rotation;
    }

    function rotationPhiGamma(deltaPhi, deltaGamma) {
      var cosDeltaPhi = cos$1(deltaPhi),
          sinDeltaPhi = sin$1(deltaPhi),
          cosDeltaGamma = cos$1(deltaGamma),
          sinDeltaGamma = sin$1(deltaGamma);

      function rotation(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaPhi + x * sinDeltaPhi;
        return [
          atan2$1(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
          asin$1(k * cosDeltaGamma + y * sinDeltaGamma)
        ];
      }

      rotation.invert = function(lambda, phi) {
        var cosPhi = cos$1(phi),
            x = cos$1(lambda) * cosPhi,
            y = sin$1(lambda) * cosPhi,
            z = sin$1(phi),
            k = z * cosDeltaGamma - y * sinDeltaGamma;
        return [
          atan2$1(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi),
          asin$1(k * cosDeltaPhi - x * sinDeltaPhi)
        ];
      };

      return rotation;
    }

    function rotation(rotate) {
      rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);

      function forward(coordinates) {
        coordinates = rotate(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      }

      forward.invert = function(coordinates) {
        coordinates = rotate.invert(coordinates[0] * radians, coordinates[1] * radians);
        return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
      };

      return forward;
    }

    // Generates a circle centered at [0, 0], with a given radius and precision.
    function circleStream(stream, radius, delta, direction, t0, t1) {
      if (!delta) return;
      var cosRadius = cos$1(radius),
          sinRadius = sin$1(radius),
          step = direction * delta;
      if (t0 == null) {
        t0 = radius + direction * tau$1;
        t1 = radius - step / 2;
      } else {
        t0 = circleRadius(cosRadius, t0);
        t1 = circleRadius(cosRadius, t1);
        if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * tau$1;
      }
      for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
        point = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
        stream.point(point[0], point[1]);
      }
    }

    // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].
    function circleRadius(cosRadius, point) {
      point = cartesian(point), point[0] -= cosRadius;
      cartesianNormalizeInPlace(point);
      var radius = acos$1(-point[1]);
      return ((-point[2] < 0 ? -radius : radius) + tau$1 - epsilon$1) % tau$1;
    }

    function circle$2() {
      var center = constant$3([0, 0]),
          radius = constant$3(90),
          precision = constant$3(6),
          ring,
          rotate,
          stream = {point: point};

      function point(x, y) {
        ring.push(x = rotate(x, y));
        x[0] *= degrees, x[1] *= degrees;
      }

      function circle() {
        var c = center.apply(this, arguments),
            r = radius.apply(this, arguments) * radians,
            p = precision.apply(this, arguments) * radians;
        ring = [];
        rotate = rotateRadians(-c[0] * radians, -c[1] * radians, 0).invert;
        circleStream(stream, r, p, 1);
        c = {type: "Polygon", coordinates: [ring]};
        ring = rotate = null;
        return c;
      }

      circle.center = function(_) {
        return arguments.length ? (center = typeof _ === "function" ? _ : constant$3([+_[0], +_[1]]), circle) : center;
      };

      circle.radius = function(_) {
        return arguments.length ? (radius = typeof _ === "function" ? _ : constant$3(+_), circle) : radius;
      };

      circle.precision = function(_) {
        return arguments.length ? (precision = typeof _ === "function" ? _ : constant$3(+_), circle) : precision;
      };

      return circle;
    }

    function clipBuffer() {
      var lines = [],
          line;
      return {
        point: function(x, y, m) {
          line.push([x, y, m]);
        },
        lineStart: function() {
          lines.push(line = []);
        },
        lineEnd: noop$1,
        rejoin: function() {
          if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
        },
        result: function() {
          var result = lines;
          lines = [];
          line = null;
          return result;
        }
      };
    }

    function pointEqual(a, b) {
      return abs$1(a[0] - b[0]) < epsilon$1 && abs$1(a[1] - b[1]) < epsilon$1;
    }

    function Intersection(point, points, other, entry) {
      this.x = point;
      this.z = points;
      this.o = other; // another intersection
      this.e = entry; // is an entry?
      this.v = false; // visited
      this.n = this.p = null; // next & previous
    }

    // A generalized polygon clipping algorithm: given a polygon that has been cut
    // into its visible line segments, and rejoins the segments by interpolating
    // along the clip edge.
    function clipRejoin(segments, compareIntersection, startInside, interpolate, stream) {
      var subject = [],
          clip = [],
          i,
          n;

      segments.forEach(function(segment) {
        if ((n = segment.length - 1) <= 0) return;
        var n, p0 = segment[0], p1 = segment[n], x;

        if (pointEqual(p0, p1)) {
          if (!p0[2] && !p1[2]) {
            stream.lineStart();
            for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);
            stream.lineEnd();
            return;
          }
          // handle degenerate cases by moving the point
          p1[0] += 2 * epsilon$1;
        }

        subject.push(x = new Intersection(p0, segment, null, true));
        clip.push(x.o = new Intersection(p0, null, x, false));
        subject.push(x = new Intersection(p1, segment, null, false));
        clip.push(x.o = new Intersection(p1, null, x, true));
      });

      if (!subject.length) return;

      clip.sort(compareIntersection);
      link$1(subject);
      link$1(clip);

      for (i = 0, n = clip.length; i < n; ++i) {
        clip[i].e = startInside = !startInside;
      }

      var start = subject[0],
          points,
          point;

      while (1) {
        // Find first unvisited intersection.
        var current = start,
            isSubject = true;
        while (current.v) if ((current = current.n) === start) return;
        points = current.z;
        stream.lineStart();
        do {
          current.v = current.o.v = true;
          if (current.e) {
            if (isSubject) {
              for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.n.x, 1, stream);
            }
            current = current.n;
          } else {
            if (isSubject) {
              points = current.p.z;
              for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
            } else {
              interpolate(current.x, current.p.x, -1, stream);
            }
            current = current.p;
          }
          current = current.o;
          points = current.z;
          isSubject = !isSubject;
        } while (!current.v);
        stream.lineEnd();
      }
    }

    function link$1(array) {
      if (!(n = array.length)) return;
      var n,
          i = 0,
          a = array[0],
          b;
      while (++i < n) {
        a.n = b = array[i];
        b.p = a;
        a = b;
      }
      a.n = b = array[0];
      b.p = a;
    }

    function longitude(point) {
      return abs$1(point[0]) <= pi$1 ? point[0] : sign$1(point[0]) * ((abs$1(point[0]) + pi$1) % tau$1 - pi$1);
    }

    function polygonContains(polygon, point) {
      var lambda = longitude(point),
          phi = point[1],
          sinPhi = sin$1(phi),
          normal = [sin$1(lambda), -cos$1(lambda), 0],
          angle = 0,
          winding = 0;

      var sum = new Adder();

      if (sinPhi === 1) phi = halfPi$1 + epsilon$1;
      else if (sinPhi === -1) phi = -halfPi$1 - epsilon$1;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        if (!(m = (ring = polygon[i]).length)) continue;
        var ring,
            m,
            point0 = ring[m - 1],
            lambda0 = longitude(point0),
            phi0 = point0[1] / 2 + quarterPi,
            sinPhi0 = sin$1(phi0),
            cosPhi0 = cos$1(phi0);

        for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
          var point1 = ring[j],
              lambda1 = longitude(point1),
              phi1 = point1[1] / 2 + quarterPi,
              sinPhi1 = sin$1(phi1),
              cosPhi1 = cos$1(phi1),
              delta = lambda1 - lambda0,
              sign = delta >= 0 ? 1 : -1,
              absDelta = sign * delta,
              antimeridian = absDelta > pi$1,
              k = sinPhi0 * sinPhi1;

          sum.add(atan2$1(k * sign * sin$1(absDelta), cosPhi0 * cosPhi1 + k * cos$1(absDelta)));
          angle += antimeridian ? delta + sign * tau$1 : delta;

          // Are the longitudes either side of the points meridian (lambda),
          // and are the latitudes smaller than the parallel (phi)?
          if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
            var arc = cartesianCross(cartesian(point0), cartesian(point1));
            cartesianNormalizeInPlace(arc);
            var intersection = cartesianCross(normal, arc);
            cartesianNormalizeInPlace(intersection);
            var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection[2]);
            if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
              winding += antimeridian ^ delta >= 0 ? 1 : -1;
            }
          }
        }
      }

      // First, determine whether the South pole is inside or outside:
      //
      // It is inside if:
      // * the polygon winds around it in a clockwise direction.
      // * the polygon does not (cumulatively) wind around it, but has a negative
      //   (counter-clockwise) area.
      //
      // Second, count the (signed) number of times a segment crosses a lambda
      // from the point to the South pole.  If it is zero, then the point is the
      // same side as the South pole.

      return (angle < -epsilon$1 || angle < epsilon$1 && sum < -epsilon2) ^ (winding & 1);
    }

    function clip(pointVisible, clipLine, interpolate, start) {
      return function(sink) {
        var line = clipLine(sink),
            ringBuffer = clipBuffer(),
            ringSink = clipLine(ringBuffer),
            polygonStarted = false,
            polygon,
            segments,
            ring;

        var clip = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() {
            clip.point = pointRing;
            clip.lineStart = ringStart;
            clip.lineEnd = ringEnd;
            segments = [];
            polygon = [];
          },
          polygonEnd: function() {
            clip.point = point;
            clip.lineStart = lineStart;
            clip.lineEnd = lineEnd;
            segments = merge(segments);
            var startInside = polygonContains(polygon, start);
            if (segments.length) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              clipRejoin(segments, compareIntersection, startInside, interpolate, sink);
            } else if (startInside) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              interpolate(null, null, 1, sink);
              sink.lineEnd();
            }
            if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
            segments = polygon = null;
          },
          sphere: function() {
            sink.polygonStart();
            sink.lineStart();
            interpolate(null, null, 1, sink);
            sink.lineEnd();
            sink.polygonEnd();
          }
        };

        function point(lambda, phi) {
          if (pointVisible(lambda, phi)) sink.point(lambda, phi);
        }

        function pointLine(lambda, phi) {
          line.point(lambda, phi);
        }

        function lineStart() {
          clip.point = pointLine;
          line.lineStart();
        }

        function lineEnd() {
          clip.point = point;
          line.lineEnd();
        }

        function pointRing(lambda, phi) {
          ring.push([lambda, phi]);
          ringSink.point(lambda, phi);
        }

        function ringStart() {
          ringSink.lineStart();
          ring = [];
        }

        function ringEnd() {
          pointRing(ring[0][0], ring[0][1]);
          ringSink.lineEnd();

          var clean = ringSink.clean(),
              ringSegments = ringBuffer.result(),
              i, n = ringSegments.length, m,
              segment,
              point;

          ring.pop();
          polygon.push(ring);
          ring = null;

          if (!n) return;

          // No intersections.
          if (clean & 1) {
            segment = ringSegments[0];
            if ((m = segment.length - 1) > 0) {
              if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
              sink.lineStart();
              for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);
              sink.lineEnd();
            }
            return;
          }

          // Rejoin connected segments.
          // TODO reuse ringBuffer.rejoin()?
          if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));

          segments.push(ringSegments.filter(validSegment));
        }

        return clip;
      };
    }

    function validSegment(segment) {
      return segment.length > 1;
    }

    // Intersections are sorted along the clip edge. For both antimeridian cutting
    // and circle clipping, the same comparison is used.
    function compareIntersection(a, b) {
      return ((a = a.x)[0] < 0 ? a[1] - halfPi$1 - epsilon$1 : halfPi$1 - a[1])
           - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$1 : halfPi$1 - b[1]);
    }

    var clipAntimeridian = clip(
      function() { return true; },
      clipAntimeridianLine,
      clipAntimeridianInterpolate,
      [-pi$1, -halfPi$1]
    );

    // Takes a line and cuts into visible segments. Return values: 0 - there were
    // intersections or the line was empty; 1 - no intersections; 2 - there were
    // intersections, and the first and last segments should be rejoined.
    function clipAntimeridianLine(stream) {
      var lambda0 = NaN,
          phi0 = NaN,
          sign0 = NaN,
          clean; // no intersections

      return {
        lineStart: function() {
          stream.lineStart();
          clean = 1;
        },
        point: function(lambda1, phi1) {
          var sign1 = lambda1 > 0 ? pi$1 : -pi$1,
              delta = abs$1(lambda1 - lambda0);
          if (abs$1(delta - pi$1) < epsilon$1) { // line crosses a pole
            stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi$1 : -halfPi$1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            stream.point(lambda1, phi0);
            clean = 0;
          } else if (sign0 !== sign1 && delta >= pi$1) { // line crosses antimeridian
            if (abs$1(lambda0 - sign0) < epsilon$1) lambda0 -= sign0 * epsilon$1; // handle degeneracies
            if (abs$1(lambda1 - sign1) < epsilon$1) lambda1 -= sign1 * epsilon$1;
            phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
            stream.point(sign0, phi0);
            stream.lineEnd();
            stream.lineStart();
            stream.point(sign1, phi0);
            clean = 0;
          }
          stream.point(lambda0 = lambda1, phi0 = phi1);
          sign0 = sign1;
        },
        lineEnd: function() {
          stream.lineEnd();
          lambda0 = phi0 = NaN;
        },
        clean: function() {
          return 2 - clean; // if intersections, rejoin first and last segments
        }
      };
    }

    function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
      var cosPhi0,
          cosPhi1,
          sinLambda0Lambda1 = sin$1(lambda0 - lambda1);
      return abs$1(sinLambda0Lambda1) > epsilon$1
          ? atan((sin$1(phi0) * (cosPhi1 = cos$1(phi1)) * sin$1(lambda1)
              - sin$1(phi1) * (cosPhi0 = cos$1(phi0)) * sin$1(lambda0))
              / (cosPhi0 * cosPhi1 * sinLambda0Lambda1))
          : (phi0 + phi1) / 2;
    }

    function clipAntimeridianInterpolate(from, to, direction, stream) {
      var phi;
      if (from == null) {
        phi = direction * halfPi$1;
        stream.point(-pi$1, phi);
        stream.point(0, phi);
        stream.point(pi$1, phi);
        stream.point(pi$1, 0);
        stream.point(pi$1, -phi);
        stream.point(0, -phi);
        stream.point(-pi$1, -phi);
        stream.point(-pi$1, 0);
        stream.point(-pi$1, phi);
      } else if (abs$1(from[0] - to[0]) > epsilon$1) {
        var lambda = from[0] < to[0] ? pi$1 : -pi$1;
        phi = direction * lambda / 2;
        stream.point(-lambda, phi);
        stream.point(0, phi);
        stream.point(lambda, phi);
      } else {
        stream.point(to[0], to[1]);
      }
    }

    function clipCircle(radius) {
      var cr = cos$1(radius),
          delta = 6 * radians,
          smallRadius = cr > 0,
          notHemisphere = abs$1(cr) > epsilon$1; // TODO optimise for this common case

      function interpolate(from, to, direction, stream) {
        circleStream(stream, radius, delta, direction, from, to);
      }

      function visible(lambda, phi) {
        return cos$1(lambda) * cos$1(phi) > cr;
      }

      // Takes a line and cuts into visible segments. Return values used for polygon
      // clipping: 0 - there were intersections or the line was empty; 1 - no
      // intersections 2 - there were intersections, and the first and last segments
      // should be rejoined.
      function clipLine(stream) {
        var point0, // previous point
            c0, // code for previous point
            v0, // visibility of previous point
            v00, // visibility of first point
            clean; // no intersections
        return {
          lineStart: function() {
            v00 = v0 = false;
            clean = 1;
          },
          point: function(lambda, phi) {
            var point1 = [lambda, phi],
                point2,
                v = visible(lambda, phi),
                c = smallRadius
                  ? v ? 0 : code(lambda, phi)
                  : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi) : 0;
            if (!point0 && (v00 = v0 = v)) stream.lineStart();
            if (v !== v0) {
              point2 = intersect(point0, point1);
              if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
                point1[2] = 1;
            }
            if (v !== v0) {
              clean = 0;
              if (v) {
                // outside going in
                stream.lineStart();
                point2 = intersect(point1, point0);
                stream.point(point2[0], point2[1]);
              } else {
                // inside going out
                point2 = intersect(point0, point1);
                stream.point(point2[0], point2[1], 2);
                stream.lineEnd();
              }
              point0 = point2;
            } else if (notHemisphere && point0 && smallRadius ^ v) {
              var t;
              // If the codes for two points are different, or are both zero,
              // and there this segment intersects with the small circle.
              if (!(c & c0) && (t = intersect(point1, point0, true))) {
                clean = 0;
                if (smallRadius) {
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1]);
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                } else {
                  stream.point(t[1][0], t[1][1]);
                  stream.lineEnd();
                  stream.lineStart();
                  stream.point(t[0][0], t[0][1], 3);
                }
              }
            }
            if (v && (!point0 || !pointEqual(point0, point1))) {
              stream.point(point1[0], point1[1]);
            }
            point0 = point1, v0 = v, c0 = c;
          },
          lineEnd: function() {
            if (v0) stream.lineEnd();
            point0 = null;
          },
          // Rejoin first and last segments if there were intersections and the first
          // and last points were visible.
          clean: function() {
            return clean | ((v00 && v0) << 1);
          }
        };
      }

      // Intersects the great circle between a and b with the clip circle.
      function intersect(a, b, two) {
        var pa = cartesian(a),
            pb = cartesian(b);

        // We have two planes, n1.p = d1 and n2.p = d2.
        // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1  n2).
        var n1 = [1, 0, 0], // normal
            n2 = cartesianCross(pa, pb),
            n2n2 = cartesianDot(n2, n2),
            n1n2 = n2[0], // cartesianDot(n1, n2),
            determinant = n2n2 - n1n2 * n1n2;

        // Two polar points.
        if (!determinant) return !two && a;

        var c1 =  cr * n2n2 / determinant,
            c2 = -cr * n1n2 / determinant,
            n1xn2 = cartesianCross(n1, n2),
            A = cartesianScale(n1, c1),
            B = cartesianScale(n2, c2);
        cartesianAddInPlace(A, B);

        // Solve |p(t)|^2 = 1.
        var u = n1xn2,
            w = cartesianDot(A, u),
            uu = cartesianDot(u, u),
            t2 = w * w - uu * (cartesianDot(A, A) - 1);

        if (t2 < 0) return;

        var t = sqrt$2(t2),
            q = cartesianScale(u, (-w - t) / uu);
        cartesianAddInPlace(q, A);
        q = spherical(q);

        if (!two) return q;

        // Two intersection points.
        var lambda0 = a[0],
            lambda1 = b[0],
            phi0 = a[1],
            phi1 = b[1],
            z;

        if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

        var delta = lambda1 - lambda0,
            polar = abs$1(delta - pi$1) < epsilon$1,
            meridian = polar || delta < epsilon$1;

        if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;

        // Check that the first point is between a and b.
        if (meridian
            ? polar
              ? phi0 + phi1 > 0 ^ q[1] < (abs$1(q[0] - lambda0) < epsilon$1 ? phi0 : phi1)
              : phi0 <= q[1] && q[1] <= phi1
            : delta > pi$1 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
          var q1 = cartesianScale(u, (-w + t) / uu);
          cartesianAddInPlace(q1, A);
          return [q, spherical(q1)];
        }
      }

      // Generates a 4-bit vector representing the location of a point relative to
      // the small circle's bounding box.
      function code(lambda, phi) {
        var r = smallRadius ? radius : pi$1 - radius,
            code = 0;
        if (lambda < -r) code |= 1; // left
        else if (lambda > r) code |= 2; // right
        if (phi < -r) code |= 4; // below
        else if (phi > r) code |= 8; // above
        return code;
      }

      return clip(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
    }

    function clipLine(a, b, x0, y0, x1, y1) {
      var ax = a[0],
          ay = a[1],
          bx = b[0],
          by = b[1],
          t0 = 0,
          t1 = 1,
          dx = bx - ax,
          dy = by - ay,
          r;

      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }

      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }

      if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
      if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
      return true;
    }

    var clipMax = 1e9, clipMin = -clipMax;

    // TODO Use d3-polygons polygonContains here for the ring check?
    // TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

    function clipRectangle(x0, y0, x1, y1) {

      function visible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }

      function interpolate(from, to, direction, stream) {
        var a = 0, a1 = 0;
        if (from == null
            || (a = corner(from, direction)) !== (a1 = corner(to, direction))
            || comparePoint(from, to) < 0 ^ direction > 0) {
          do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          stream.point(to[0], to[1]);
        }
      }

      function corner(p, direction) {
        return abs$1(p[0] - x0) < epsilon$1 ? direction > 0 ? 0 : 3
            : abs$1(p[0] - x1) < epsilon$1 ? direction > 0 ? 2 : 1
            : abs$1(p[1] - y0) < epsilon$1 ? direction > 0 ? 1 : 0
            : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
      }

      function compareIntersection(a, b) {
        return comparePoint(a.x, b.x);
      }

      function comparePoint(a, b) {
        var ca = corner(a, 1),
            cb = corner(b, 1);
        return ca !== cb ? ca - cb
            : ca === 0 ? b[1] - a[1]
            : ca === 1 ? a[0] - b[0]
            : ca === 2 ? a[1] - b[1]
            : b[0] - a[0];
      }

      return function(stream) {
        var activeStream = stream,
            bufferStream = clipBuffer(),
            segments,
            polygon,
            ring,
            x__, y__, v__, // first point
            x_, y_, v_, // previous point
            first,
            clean;

        var clipStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: polygonStart,
          polygonEnd: polygonEnd
        };

        function point(x, y) {
          if (visible(x, y)) activeStream.point(x, y);
        }

        function polygonInside() {
          var winding = 0;

          for (var i = 0, n = polygon.length; i < n; ++i) {
            for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
              a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];
              if (a1 <= y1) { if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding; }
              else { if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding; }
            }
          }

          return winding;
        }

        // Buffer geometry within a polygon and then clip it en masse.
        function polygonStart() {
          activeStream = bufferStream, segments = [], polygon = [], clean = true;
        }

        function polygonEnd() {
          var startInside = polygonInside(),
              cleanInside = clean && startInside,
              visible = (segments = merge(segments)).length;
          if (cleanInside || visible) {
            stream.polygonStart();
            if (cleanInside) {
              stream.lineStart();
              interpolate(null, null, 1, stream);
              stream.lineEnd();
            }
            if (visible) {
              clipRejoin(segments, compareIntersection, startInside, interpolate, stream);
            }
            stream.polygonEnd();
          }
          activeStream = stream, segments = polygon = ring = null;
        }

        function lineStart() {
          clipStream.point = linePoint;
          if (polygon) polygon.push(ring = []);
          first = true;
          v_ = false;
          x_ = y_ = NaN;
        }

        // TODO rather than special-case polygons, simply handle them separately.
        // Ideally, coincident intersection points should be jittered to avoid
        // clipping issues.
        function lineEnd() {
          if (segments) {
            linePoint(x__, y__);
            if (v__ && v_) bufferStream.rejoin();
            segments.push(bufferStream.result());
          }
          clipStream.point = point;
          if (v_) activeStream.lineEnd();
        }

        function linePoint(x, y) {
          var v = visible(x, y);
          if (polygon) ring.push([x, y]);
          if (first) {
            x__ = x, y__ = y, v__ = v;
            first = false;
            if (v) {
              activeStream.lineStart();
              activeStream.point(x, y);
            }
          } else {
            if (v && v_) activeStream.point(x, y);
            else {
              var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
                  b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
              if (clipLine(a, b, x0, y0, x1, y1)) {
                if (!v_) {
                  activeStream.lineStart();
                  activeStream.point(a[0], a[1]);
                }
                activeStream.point(b[0], b[1]);
                if (!v) activeStream.lineEnd();
                clean = false;
              } else if (v) {
                activeStream.lineStart();
                activeStream.point(x, y);
                clean = false;
              }
            }
          }
          x_ = x, y_ = y, v_ = v;
        }

        return clipStream;
      };
    }

    function extent() {
      var x0 = 0,
          y0 = 0,
          x1 = 960,
          y1 = 500,
          cache,
          cacheStream,
          clip;

      return clip = {
        stream: function(stream) {
          return cache && cacheStream === stream ? cache : cache = clipRectangle(x0, y0, x1, y1)(cacheStream = stream);
        },
        extent: function(_) {
          return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
        }
      };
    }

    var lengthSum$1,
        lambda0,
        sinPhi0,
        cosPhi0;

    var lengthStream$1 = {
      sphere: noop$1,
      point: noop$1,
      lineStart: lengthLineStart,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1
    };

    function lengthLineStart() {
      lengthStream$1.point = lengthPointFirst$1;
      lengthStream$1.lineEnd = lengthLineEnd;
    }

    function lengthLineEnd() {
      lengthStream$1.point = lengthStream$1.lineEnd = noop$1;
    }

    function lengthPointFirst$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      lambda0 = lambda, sinPhi0 = sin$1(phi), cosPhi0 = cos$1(phi);
      lengthStream$1.point = lengthPoint$1;
    }

    function lengthPoint$1(lambda, phi) {
      lambda *= radians, phi *= radians;
      var sinPhi = sin$1(phi),
          cosPhi = cos$1(phi),
          delta = abs$1(lambda - lambda0),
          cosDelta = cos$1(delta),
          sinDelta = sin$1(delta),
          x = cosPhi * sinDelta,
          y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
          z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
      lengthSum$1.add(atan2$1(sqrt$2(x * x + y * y), z));
      lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
    }

    function length$1(object) {
      lengthSum$1 = new Adder();
      geoStream(object, lengthStream$1);
      return +lengthSum$1;
    }

    var coordinates = [null, null],
        object = {type: "LineString", coordinates: coordinates};

    function distance(a, b) {
      coordinates[0] = a;
      coordinates[1] = b;
      return length$1(object);
    }

    var containsObjectType = {
      Feature: function(object, point) {
        return containsGeometry(object.geometry, point);
      },
      FeatureCollection: function(object, point) {
        var features = object.features, i = -1, n = features.length;
        while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;
        return false;
      }
    };

    var containsGeometryType = {
      Sphere: function() {
        return true;
      },
      Point: function(object, point) {
        return containsPoint(object.coordinates, point);
      },
      MultiPoint: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPoint(coordinates[i], point)) return true;
        return false;
      },
      LineString: function(object, point) {
        return containsLine(object.coordinates, point);
      },
      MultiLineString: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsLine(coordinates[i], point)) return true;
        return false;
      },
      Polygon: function(object, point) {
        return containsPolygon(object.coordinates, point);
      },
      MultiPolygon: function(object, point) {
        var coordinates = object.coordinates, i = -1, n = coordinates.length;
        while (++i < n) if (containsPolygon(coordinates[i], point)) return true;
        return false;
      },
      GeometryCollection: function(object, point) {
        var geometries = object.geometries, i = -1, n = geometries.length;
        while (++i < n) if (containsGeometry(geometries[i], point)) return true;
        return false;
      }
    };

    function containsGeometry(geometry, point) {
      return geometry && containsGeometryType.hasOwnProperty(geometry.type)
          ? containsGeometryType[geometry.type](geometry, point)
          : false;
    }

    function containsPoint(coordinates, point) {
      return distance(coordinates, point) === 0;
    }

    function containsLine(coordinates, point) {
      var ao, bo, ab;
      for (var i = 0, n = coordinates.length; i < n; i++) {
        bo = distance(coordinates[i], point);
        if (bo === 0) return true;
        if (i > 0) {
          ab = distance(coordinates[i], coordinates[i - 1]);
          if (
            ab > 0 &&
            ao <= ab &&
            bo <= ab &&
            (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2 * ab
          )
            return true;
        }
        ao = bo;
      }
      return false;
    }

    function containsPolygon(coordinates, point) {
      return !!polygonContains(coordinates.map(ringRadians), pointRadians(point));
    }

    function ringRadians(ring) {
      return ring = ring.map(pointRadians), ring.pop(), ring;
    }

    function pointRadians(point) {
      return [point[0] * radians, point[1] * radians];
    }

    function contains$1(object, point) {
      return (object && containsObjectType.hasOwnProperty(object.type)
          ? containsObjectType[object.type]
          : containsGeometry)(object, point);
    }

    function graticuleX(y0, y1, dy) {
      var y = range$2(y0, y1 - epsilon$1, dy).concat(y1);
      return function(x) { return y.map(function(y) { return [x, y]; }); };
    }

    function graticuleY(x0, x1, dx) {
      var x = range$2(x0, x1 - epsilon$1, dx).concat(x1);
      return function(y) { return x.map(function(x) { return [x, y]; }); };
    }

    function graticule() {
      var x1, x0, X1, X0,
          y1, y0, Y1, Y0,
          dx = 10, dy = dx, DX = 90, DY = 360,
          x, y, X, Y,
          precision = 2.5;

      function graticule() {
        return {type: "MultiLineString", coordinates: lines()};
      }

      function lines() {
        return range$2(ceil(X0 / DX) * DX, X1, DX).map(X)
            .concat(range$2(ceil(Y0 / DY) * DY, Y1, DY).map(Y))
            .concat(range$2(ceil(x0 / dx) * dx, x1, dx).filter(function(x) { return abs$1(x % DX) > epsilon$1; }).map(x))
            .concat(range$2(ceil(y0 / dy) * dy, y1, dy).filter(function(y) { return abs$1(y % DY) > epsilon$1; }).map(y));
      }

      graticule.lines = function() {
        return lines().map(function(coordinates) { return {type: "LineString", coordinates: coordinates}; });
      };

      graticule.outline = function() {
        return {
          type: "Polygon",
          coordinates: [
            X(X0).concat(
            Y(Y1).slice(1),
            X(X1).reverse().slice(1),
            Y(Y0).reverse().slice(1))
          ]
        };
      };

      graticule.extent = function(_) {
        if (!arguments.length) return graticule.extentMinor();
        return graticule.extentMajor(_).extentMinor(_);
      };

      graticule.extentMajor = function(_) {
        if (!arguments.length) return [[X0, Y0], [X1, Y1]];
        X0 = +_[0][0], X1 = +_[1][0];
        Y0 = +_[0][1], Y1 = +_[1][1];
        if (X0 > X1) _ = X0, X0 = X1, X1 = _;
        if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
        return graticule.precision(precision);
      };

      graticule.extentMinor = function(_) {
        if (!arguments.length) return [[x0, y0], [x1, y1]];
        x0 = +_[0][0], x1 = +_[1][0];
        y0 = +_[0][1], y1 = +_[1][1];
        if (x0 > x1) _ = x0, x0 = x1, x1 = _;
        if (y0 > y1) _ = y0, y0 = y1, y1 = _;
        return graticule.precision(precision);
      };

      graticule.step = function(_) {
        if (!arguments.length) return graticule.stepMinor();
        return graticule.stepMajor(_).stepMinor(_);
      };

      graticule.stepMajor = function(_) {
        if (!arguments.length) return [DX, DY];
        DX = +_[0], DY = +_[1];
        return graticule;
      };

      graticule.stepMinor = function(_) {
        if (!arguments.length) return [dx, dy];
        dx = +_[0], dy = +_[1];
        return graticule;
      };

      graticule.precision = function(_) {
        if (!arguments.length) return precision;
        precision = +_;
        x = graticuleX(y0, y1, 90);
        y = graticuleY(x0, x1, precision);
        X = graticuleX(Y0, Y1, 90);
        Y = graticuleY(X0, X1, precision);
        return graticule;
      };

      return graticule
          .extentMajor([[-180, -90 + epsilon$1], [180, 90 - epsilon$1]])
          .extentMinor([[-180, -80 - epsilon$1], [180, 80 + epsilon$1]]);
    }

    function graticule10() {
      return graticule()();
    }

    function interpolate(a, b) {
      var x0 = a[0] * radians,
          y0 = a[1] * radians,
          x1 = b[0] * radians,
          y1 = b[1] * radians,
          cy0 = cos$1(y0),
          sy0 = sin$1(y0),
          cy1 = cos$1(y1),
          sy1 = sin$1(y1),
          kx0 = cy0 * cos$1(x0),
          ky0 = cy0 * sin$1(x0),
          kx1 = cy1 * cos$1(x1),
          ky1 = cy1 * sin$1(x1),
          d = 2 * asin$1(sqrt$2(haversin(y1 - y0) + cy0 * cy1 * haversin(x1 - x0))),
          k = sin$1(d);

      var interpolate = d ? function(t) {
        var B = sin$1(t *= d) / k,
            A = sin$1(d - t) / k,
            x = A * kx0 + B * kx1,
            y = A * ky0 + B * ky1,
            z = A * sy0 + B * sy1;
        return [
          atan2$1(y, x) * degrees,
          atan2$1(z, sqrt$2(x * x + y * y)) * degrees
        ];
      } : function() {
        return [x0 * degrees, y0 * degrees];
      };

      interpolate.distance = d;

      return interpolate;
    }

    var identity$5 = x => x;

    var areaSum = new Adder(),
        areaRingSum = new Adder(),
        x00$2,
        y00$2,
        x0$3,
        y0$3;

    var areaStream = {
      point: noop$1,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: function() {
        areaStream.lineStart = areaRingStart;
        areaStream.lineEnd = areaRingEnd;
      },
      polygonEnd: function() {
        areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
        areaSum.add(abs$1(areaRingSum));
        areaRingSum = new Adder();
      },
      result: function() {
        var area = areaSum / 2;
        areaSum = new Adder();
        return area;
      }
    };

    function areaRingStart() {
      areaStream.point = areaPointFirst;
    }

    function areaPointFirst(x, y) {
      areaStream.point = areaPoint;
      x00$2 = x0$3 = x, y00$2 = y0$3 = y;
    }

    function areaPoint(x, y) {
      areaRingSum.add(y0$3 * x - x0$3 * y);
      x0$3 = x, y0$3 = y;
    }

    function areaRingEnd() {
      areaPoint(x00$2, y00$2);
    }

    var pathArea = areaStream;

    var x0$2 = Infinity,
        y0$2 = x0$2,
        x1 = -x0$2,
        y1 = x1;

    var boundsStream = {
      point: boundsPoint,
      lineStart: noop$1,
      lineEnd: noop$1,
      polygonStart: noop$1,
      polygonEnd: noop$1,
      result: function() {
        var bounds = [[x0$2, y0$2], [x1, y1]];
        x1 = y1 = -(y0$2 = x0$2 = Infinity);
        return bounds;
      }
    };

    function boundsPoint(x, y) {
      if (x < x0$2) x0$2 = x;
      if (x > x1) x1 = x;
      if (y < y0$2) y0$2 = y;
      if (y > y1) y1 = y;
    }

    var boundsStream$1 = boundsStream;

    // TODO Enforce positive area for exterior, negative area for interior?

    var X0 = 0,
        Y0 = 0,
        Z0 = 0,
        X1 = 0,
        Y1 = 0,
        Z1 = 0,
        X2 = 0,
        Y2 = 0,
        Z2 = 0,
        x00$1,
        y00$1,
        x0$1,
        y0$1;

    var centroidStream = {
      point: centroidPoint,
      lineStart: centroidLineStart,
      lineEnd: centroidLineEnd,
      polygonStart: function() {
        centroidStream.lineStart = centroidRingStart;
        centroidStream.lineEnd = centroidRingEnd;
      },
      polygonEnd: function() {
        centroidStream.point = centroidPoint;
        centroidStream.lineStart = centroidLineStart;
        centroidStream.lineEnd = centroidLineEnd;
      },
      result: function() {
        var centroid = Z2 ? [X2 / Z2, Y2 / Z2]
            : Z1 ? [X1 / Z1, Y1 / Z1]
            : Z0 ? [X0 / Z0, Y0 / Z0]
            : [NaN, NaN];
        X0 = Y0 = Z0 =
        X1 = Y1 = Z1 =
        X2 = Y2 = Z2 = 0;
        return centroid;
      }
    };

    function centroidPoint(x, y) {
      X0 += x;
      Y0 += y;
      ++Z0;
    }

    function centroidLineStart() {
      centroidStream.point = centroidPointFirstLine;
    }

    function centroidPointFirstLine(x, y) {
      centroidStream.point = centroidPointLine;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidPointLine(x, y) {
      var dx = x - x0$1, dy = y - y0$1, z = sqrt$2(dx * dx + dy * dy);
      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    function centroidLineEnd() {
      centroidStream.point = centroidPoint;
    }

    function centroidRingStart() {
      centroidStream.point = centroidPointFirstRing;
    }

    function centroidRingEnd() {
      centroidPointRing(x00$1, y00$1);
    }

    function centroidPointFirstRing(x, y) {
      centroidStream.point = centroidPointRing;
      centroidPoint(x00$1 = x0$1 = x, y00$1 = y0$1 = y);
    }

    function centroidPointRing(x, y) {
      var dx = x - x0$1,
          dy = y - y0$1,
          z = sqrt$2(dx * dx + dy * dy);

      X1 += z * (x0$1 + x) / 2;
      Y1 += z * (y0$1 + y) / 2;
      Z1 += z;

      z = y0$1 * x - x0$1 * y;
      X2 += z * (x0$1 + x);
      Y2 += z * (y0$1 + y);
      Z2 += z * 3;
      centroidPoint(x0$1 = x, y0$1 = y);
    }

    var pathCentroid = centroidStream;

    function PathContext(context) {
      this._context = context;
    }

    PathContext.prototype = {
      _radius: 4.5,
      pointRadius: function(_) {
        return this._radius = _, this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._context.closePath();
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._context.moveTo(x, y);
            this._point = 1;
            break;
          }
          case 1: {
            this._context.lineTo(x, y);
            break;
          }
          default: {
            this._context.moveTo(x + this._radius, y);
            this._context.arc(x, y, this._radius, 0, tau$1);
            break;
          }
        }
      },
      result: noop$1
    };

    var lengthSum = new Adder(),
        lengthRing,
        x00,
        y00,
        x0,
        y0;

    var lengthStream = {
      point: noop$1,
      lineStart: function() {
        lengthStream.point = lengthPointFirst;
      },
      lineEnd: function() {
        if (lengthRing) lengthPoint(x00, y00);
        lengthStream.point = noop$1;
      },
      polygonStart: function() {
        lengthRing = true;
      },
      polygonEnd: function() {
        lengthRing = null;
      },
      result: function() {
        var length = +lengthSum;
        lengthSum = new Adder();
        return length;
      }
    };

    function lengthPointFirst(x, y) {
      lengthStream.point = lengthPoint;
      x00 = x0 = x, y00 = y0 = y;
    }

    function lengthPoint(x, y) {
      x0 -= x, y0 -= y;
      lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
      x0 = x, y0 = y;
    }

    var pathMeasure = lengthStream;

    function PathString() {
      this._string = [];
    }

    PathString.prototype = {
      _radius: 4.5,
      _circle: circle$1(4.5),
      pointRadius: function(_) {
        if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
        return this;
      },
      polygonStart: function() {
        this._line = 0;
      },
      polygonEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line === 0) this._string.push("Z");
        this._point = NaN;
      },
      point: function(x, y) {
        switch (this._point) {
          case 0: {
            this._string.push("M", x, ",", y);
            this._point = 1;
            break;
          }
          case 1: {
            this._string.push("L", x, ",", y);
            break;
          }
          default: {
            if (this._circle == null) this._circle = circle$1(this._radius);
            this._string.push("M", x, ",", y, this._circle);
            break;
          }
        }
      },
      result: function() {
        if (this._string.length) {
          var result = this._string.join("");
          this._string = [];
          return result;
        } else {
          return null;
        }
      }
    };

    function circle$1(radius) {
      return "m0," + radius
          + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius
          + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius
          + "z";
    }

    function index$2(projection, context) {
      var pointRadius = 4.5,
          projectionStream,
          contextStream;

      function path(object) {
        if (object) {
          if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
          geoStream(object, projectionStream(contextStream));
        }
        return contextStream.result();
      }

      path.area = function(object) {
        geoStream(object, projectionStream(pathArea));
        return pathArea.result();
      };

      path.measure = function(object) {
        geoStream(object, projectionStream(pathMeasure));
        return pathMeasure.result();
      };

      path.bounds = function(object) {
        geoStream(object, projectionStream(boundsStream$1));
        return boundsStream$1.result();
      };

      path.centroid = function(object) {
        geoStream(object, projectionStream(pathCentroid));
        return pathCentroid.result();
      };

      path.projection = function(_) {
        return arguments.length ? (projectionStream = _ == null ? (projection = null, identity$5) : (projection = _).stream, path) : projection;
      };

      path.context = function(_) {
        if (!arguments.length) return context;
        contextStream = _ == null ? (context = null, new PathString) : new PathContext(context = _);
        if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
        return path;
      };

      path.pointRadius = function(_) {
        if (!arguments.length) return pointRadius;
        pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
        return path;
      };

      return path.projection(projection).context(context);
    }

    function transform$1(methods) {
      return {
        stream: transformer$3(methods)
      };
    }

    function transformer$3(methods) {
      return function(stream) {
        var s = new TransformStream;
        for (var key in methods) s[key] = methods[key];
        s.stream = stream;
        return s;
      };
    }

    function TransformStream() {}

    TransformStream.prototype = {
      constructor: TransformStream,
      point: function(x, y) { this.stream.point(x, y); },
      sphere: function() { this.stream.sphere(); },
      lineStart: function() { this.stream.lineStart(); },
      lineEnd: function() { this.stream.lineEnd(); },
      polygonStart: function() { this.stream.polygonStart(); },
      polygonEnd: function() { this.stream.polygonEnd(); }
    };

    function fit(projection, fitBounds, object) {
      var clip = projection.clipExtent && projection.clipExtent();
      projection.scale(150).translate([0, 0]);
      if (clip != null) projection.clipExtent(null);
      geoStream(object, projection.stream(boundsStream$1));
      fitBounds(boundsStream$1.result());
      if (clip != null) projection.clipExtent(clip);
      return projection;
    }

    function fitExtent(projection, extent, object) {
      return fit(projection, function(b) {
        var w = extent[1][0] - extent[0][0],
            h = extent[1][1] - extent[0][1],
            k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
            x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
            y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitSize(projection, size, object) {
      return fitExtent(projection, [[0, 0], size], object);
    }

    function fitWidth(projection, width, object) {
      return fit(projection, function(b) {
        var w = +width,
            k = w / (b[1][0] - b[0][0]),
            x = (w - k * (b[1][0] + b[0][0])) / 2,
            y = -k * b[0][1];
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    function fitHeight(projection, height, object) {
      return fit(projection, function(b) {
        var h = +height,
            k = h / (b[1][1] - b[0][1]),
            x = -k * b[0][0],
            y = (h - k * (b[1][1] + b[0][1])) / 2;
        projection.scale(150 * k).translate([x, y]);
      }, object);
    }

    var maxDepth = 16, // maximum depth of subdivision
        cosMinDistance = cos$1(30 * radians); // cos(minimum angular distance)

    function resample(project, delta2) {
      return +delta2 ? resample$1(project, delta2) : resampleNone(project);
    }

    function resampleNone(project) {
      return transformer$3({
        point: function(x, y) {
          x = project(x, y);
          this.stream.point(x[0], x[1]);
        }
      });
    }

    function resample$1(project, delta2) {

      function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
        var dx = x1 - x0,
            dy = y1 - y0,
            d2 = dx * dx + dy * dy;
        if (d2 > 4 * delta2 && depth--) {
          var a = a0 + a1,
              b = b0 + b1,
              c = c0 + c1,
              m = sqrt$2(a * a + b * b + c * c),
              phi2 = asin$1(c /= m),
              lambda2 = abs$1(abs$1(c) - 1) < epsilon$1 || abs$1(lambda0 - lambda1) < epsilon$1 ? (lambda0 + lambda1) / 2 : atan2$1(b, a),
              p = project(lambda2, phi2),
              x2 = p[0],
              y2 = p[1],
              dx2 = x2 - x0,
              dy2 = y2 - y0,
              dz = dy * dx2 - dx * dy2;
          if (dz * dz / d2 > delta2 // perpendicular projected distance
              || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
              || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) { // angular distance
            resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
            stream.point(x2, y2);
            resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
          }
        }
      }
      return function(stream) {
        var lambda00, x00, y00, a00, b00, c00, // first point
            lambda0, x0, y0, a0, b0, c0; // previous point

        var resampleStream = {
          point: point,
          lineStart: lineStart,
          lineEnd: lineEnd,
          polygonStart: function() { stream.polygonStart(); resampleStream.lineStart = ringStart; },
          polygonEnd: function() { stream.polygonEnd(); resampleStream.lineStart = lineStart; }
        };

        function point(x, y) {
          x = project(x, y);
          stream.point(x[0], x[1]);
        }

        function lineStart() {
          x0 = NaN;
          resampleStream.point = linePoint;
          stream.lineStart();
        }

        function linePoint(lambda, phi) {
          var c = cartesian([lambda, phi]), p = project(lambda, phi);
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
          stream.point(x0, y0);
        }

        function lineEnd() {
          resampleStream.point = point;
          stream.lineEnd();
        }

        function ringStart() {
          lineStart();
          resampleStream.point = ringPoint;
          resampleStream.lineEnd = ringEnd;
        }

        function ringPoint(lambda, phi) {
          linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
          resampleStream.point = linePoint;
        }

        function ringEnd() {
          resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
          resampleStream.lineEnd = lineEnd;
          lineEnd();
        }

        return resampleStream;
      };
    }

    var transformRadians = transformer$3({
      point: function(x, y) {
        this.stream.point(x * radians, y * radians);
      }
    });

    function transformRotate(rotate) {
      return transformer$3({
        point: function(x, y) {
          var r = rotate(x, y);
          return this.stream.point(r[0], r[1]);
        }
      });
    }

    function scaleTranslate(k, dx, dy, sx, sy) {
      function transform(x, y) {
        x *= sx; y *= sy;
        return [dx + k * x, dy - k * y];
      }
      transform.invert = function(x, y) {
        return [(x - dx) / k * sx, (dy - y) / k * sy];
      };
      return transform;
    }

    function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
      if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
      var cosAlpha = cos$1(alpha),
          sinAlpha = sin$1(alpha),
          a = cosAlpha * k,
          b = sinAlpha * k,
          ai = cosAlpha / k,
          bi = sinAlpha / k,
          ci = (sinAlpha * dy - cosAlpha * dx) / k,
          fi = (sinAlpha * dx + cosAlpha * dy) / k;
      function transform(x, y) {
        x *= sx; y *= sy;
        return [a * x - b * y + dx, dy - b * x - a * y];
      }
      transform.invert = function(x, y) {
        return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
      };
      return transform;
    }

    function projection(project) {
      return projectionMutator(function() { return project; })();
    }

    function projectionMutator(projectAt) {
      var project,
          k = 150, // scale
          x = 480, y = 250, // translate
          lambda = 0, phi = 0, // center
          deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, // pre-rotate
          alpha = 0, // post-rotate angle
          sx = 1, // reflectX
          sy = 1, // reflectX
          theta = null, preclip = clipAntimeridian, // pre-clip angle
          x0 = null, y0, x1, y1, postclip = identity$5, // post-clip extent
          delta2 = 0.5, // precision
          projectResample,
          projectTransform,
          projectRotateTransform,
          cache,
          cacheStream;

      function projection(point) {
        return projectRotateTransform(point[0] * radians, point[1] * radians);
      }

      function invert(point) {
        point = projectRotateTransform.invert(point[0], point[1]);
        return point && [point[0] * degrees, point[1] * degrees];
      }

      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
      };

      projection.preclip = function(_) {
        return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
      };

      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };

      projection.clipAngle = function(_) {
        return arguments.length ? (preclip = +_ ? clipCircle(theta = _ * radians) : (theta = null, clipAntimeridian), reset()) : theta * degrees;
      };

      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      projection.scale = function(_) {
        return arguments.length ? (k = +_, recenter()) : k;
      };

      projection.translate = function(_) {
        return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
      };

      projection.center = function(_) {
        return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
      };

      projection.rotate = function(_) {
        return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
      };

      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
      };

      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
      };

      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
      };

      projection.precision = function(_) {
        return arguments.length ? (projectResample = resample(projectTransform, delta2 = _ * _), reset()) : sqrt$2(delta2);
      };

      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };

      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };

      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };

      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      function recenter() {
        var center = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)),
            transform = scaleTranslateRotate(k, x - center[0], y - center[1], sx, sy, alpha);
        rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
        projectTransform = compose(project, transform);
        projectRotateTransform = compose(rotate, projectTransform);
        projectResample = resample(projectTransform, delta2);
        return reset();
      }

      function reset() {
        cache = cacheStream = null;
        return projection;
      }

      return function() {
        project = projectAt.apply(this, arguments);
        projection.invert = project.invert && invert;
        return recenter();
      };
    }

    function conicProjection(projectAt) {
      var phi0 = 0,
          phi1 = pi$1 / 3,
          m = projectionMutator(projectAt),
          p = m(phi0, phi1);

      p.parallels = function(_) {
        return arguments.length ? m(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
      };

      return p;
    }

    function cylindricalEqualAreaRaw(phi0) {
      var cosPhi0 = cos$1(phi0);

      function forward(lambda, phi) {
        return [lambda * cosPhi0, sin$1(phi) / cosPhi0];
      }

      forward.invert = function(x, y) {
        return [x / cosPhi0, asin$1(y * cosPhi0)];
      };

      return forward;
    }

    function conicEqualAreaRaw(y0, y1) {
      var sy0 = sin$1(y0), n = (sy0 + sin$1(y1)) / 2;

      // Are the parallels symmetrical around the Equator?
      if (abs$1(n) < epsilon$1) return cylindricalEqualAreaRaw(y0);

      var c = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c) / n;

      function project(x, y) {
        var r = sqrt$2(c - 2 * n * sin$1(y)) / n;
        return [r * sin$1(x *= n), r0 - r * cos$1(x)];
      }

      project.invert = function(x, y) {
        var r0y = r0 - y,
            l = atan2$1(x, abs$1(r0y)) * sign$1(r0y);
        if (r0y * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(r0y);
        return [l / n, asin$1((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
      };

      return project;
    }

    function conicEqualArea() {
      return conicProjection(conicEqualAreaRaw)
          .scale(155.424)
          .center([0, 33.6442]);
    }

    function albers() {
      return conicEqualArea()
          .parallels([29.5, 45.5])
          .scale(1070)
          .translate([480, 250])
          .rotate([96, 0])
          .center([-0.6, 38.7]);
    }

    // The projections must have mutually exclusive clip regions on the sphere,
    // as this will avoid emitting interleaving lines and polygons.
    function multiplex(streams) {
      var n = streams.length;
      return {
        point: function(x, y) { var i = -1; while (++i < n) streams[i].point(x, y); },
        sphere: function() { var i = -1; while (++i < n) streams[i].sphere(); },
        lineStart: function() { var i = -1; while (++i < n) streams[i].lineStart(); },
        lineEnd: function() { var i = -1; while (++i < n) streams[i].lineEnd(); },
        polygonStart: function() { var i = -1; while (++i < n) streams[i].polygonStart(); },
        polygonEnd: function() { var i = -1; while (++i < n) streams[i].polygonEnd(); }
      };
    }

    // A composite projection for the United States, configured by default for
    // 960500. The projection also works quite well at 960600 if you change the
    // scale to 1285 and adjust the translate accordingly. The set of standard
    // parallels for each region comes from USGS, which is published here:
    // http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers
    function albersUsa() {
      var cache,
          cacheStream,
          lower48 = albers(), lower48Point,
          alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, // EPSG:3338
          hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, // ESRI:102007
          point, pointStream = {point: function(x, y) { point = [x, y]; }};

      function albersUsa(coordinates) {
        var x = coordinates[0], y = coordinates[1];
        return point = null,
            (lower48Point.point(x, y), point)
            || (alaskaPoint.point(x, y), point)
            || (hawaiiPoint.point(x, y), point);
      }

      albersUsa.invert = function(coordinates) {
        var k = lower48.scale(),
            t = lower48.translate(),
            x = (coordinates[0] - t[0]) / k,
            y = (coordinates[1] - t[1]) / k;
        return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska
            : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii
            : lower48).invert(coordinates);
      };

      albersUsa.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
      };

      albersUsa.precision = function(_) {
        if (!arguments.length) return lower48.precision();
        lower48.precision(_), alaska.precision(_), hawaii.precision(_);
        return reset();
      };

      albersUsa.scale = function(_) {
        if (!arguments.length) return lower48.scale();
        lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
        return albersUsa.translate(lower48.translate());
      };

      albersUsa.translate = function(_) {
        if (!arguments.length) return lower48.translate();
        var k = lower48.scale(), x = +_[0], y = +_[1];

        lower48Point = lower48
            .translate(_)
            .clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]])
            .stream(pointStream);

        alaskaPoint = alaska
            .translate([x - 0.307 * k, y + 0.201 * k])
            .clipExtent([[x - 0.425 * k + epsilon$1, y + 0.120 * k + epsilon$1], [x - 0.214 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        hawaiiPoint = hawaii
            .translate([x - 0.205 * k, y + 0.212 * k])
            .clipExtent([[x - 0.214 * k + epsilon$1, y + 0.166 * k + epsilon$1], [x - 0.115 * k - epsilon$1, y + 0.234 * k - epsilon$1]])
            .stream(pointStream);

        return reset();
      };

      albersUsa.fitExtent = function(extent, object) {
        return fitExtent(albersUsa, extent, object);
      };

      albersUsa.fitSize = function(size, object) {
        return fitSize(albersUsa, size, object);
      };

      albersUsa.fitWidth = function(width, object) {
        return fitWidth(albersUsa, width, object);
      };

      albersUsa.fitHeight = function(height, object) {
        return fitHeight(albersUsa, height, object);
      };

      function reset() {
        cache = cacheStream = null;
        return albersUsa;
      }

      return albersUsa.scale(1070);
    }

    function azimuthalRaw(scale) {
      return function(x, y) {
        var cx = cos$1(x),
            cy = cos$1(y),
            k = scale(cx * cy);
            if (k === Infinity) return [2, 0];
        return [
          k * cy * sin$1(x),
          k * sin$1(y)
        ];
      }
    }

    function azimuthalInvert(angle) {
      return function(x, y) {
        var z = sqrt$2(x * x + y * y),
            c = angle(z),
            sc = sin$1(c),
            cc = cos$1(c);
        return [
          atan2$1(x * sc, z * cc),
          asin$1(z && y * sc / z)
        ];
      }
    }

    var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
      return sqrt$2(2 / (1 + cxcy));
    });

    azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
      return 2 * asin$1(z / 2);
    });

    function azimuthalEqualArea() {
      return projection(azimuthalEqualAreaRaw)
          .scale(124.75)
          .clipAngle(180 - 1e-3);
    }

    var azimuthalEquidistantRaw = azimuthalRaw(function(c) {
      return (c = acos$1(c)) && c / sin$1(c);
    });

    azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
      return z;
    });

    function azimuthalEquidistant() {
      return projection(azimuthalEquidistantRaw)
          .scale(79.4188)
          .clipAngle(180 - 1e-3);
    }

    function mercatorRaw(lambda, phi) {
      return [lambda, log$1(tan((halfPi$1 + phi) / 2))];
    }

    mercatorRaw.invert = function(x, y) {
      return [x, 2 * atan(exp(y)) - halfPi$1];
    };

    function mercator() {
      return mercatorProjection(mercatorRaw)
          .scale(961 / tau$1);
    }

    function mercatorProjection(project) {
      var m = projection(project),
          center = m.center,
          scale = m.scale,
          translate = m.translate,
          clipExtent = m.clipExtent,
          x0 = null, y0, x1, y1; // clip extent

      m.scale = function(_) {
        return arguments.length ? (scale(_), reclip()) : scale();
      };

      m.translate = function(_) {
        return arguments.length ? (translate(_), reclip()) : translate();
      };

      m.center = function(_) {
        return arguments.length ? (center(_), reclip()) : center();
      };

      m.clipExtent = function(_) {
        return arguments.length ? ((_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1])), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };

      function reclip() {
        var k = pi$1 * scale(),
            t = m(rotation(m.rotate()).invert([0, 0]));
        return clipExtent(x0 == null
            ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw
            ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]]
            : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
      }

      return reclip();
    }

    function tany(y) {
      return tan((halfPi$1 + y) / 2);
    }

    function conicConformalRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : log$1(cy0 / cos$1(y1)) / log$1(tany(y1) / tany(y0)),
          f = cy0 * pow$1(tany(y0), n) / n;

      if (!n) return mercatorRaw;

      function project(x, y) {
        if (f > 0) { if (y < -halfPi$1 + epsilon$1) y = -halfPi$1 + epsilon$1; }
        else { if (y > halfPi$1 - epsilon$1) y = halfPi$1 - epsilon$1; }
        var r = f / pow$1(tany(y), n);
        return [r * sin$1(n * x), f - r * cos$1(n * x)];
      }

      project.invert = function(x, y) {
        var fy = f - y, r = sign$1(n) * sqrt$2(x * x + fy * fy),
          l = atan2$1(x, abs$1(fy)) * sign$1(fy);
        if (fy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(fy);
        return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$1];
      };

      return project;
    }

    function conicConformal() {
      return conicProjection(conicConformalRaw)
          .scale(109.5)
          .parallels([30, 30]);
    }

    function equirectangularRaw(lambda, phi) {
      return [lambda, phi];
    }

    equirectangularRaw.invert = equirectangularRaw;

    function equirectangular() {
      return projection(equirectangularRaw)
          .scale(152.63);
    }

    function conicEquidistantRaw(y0, y1) {
      var cy0 = cos$1(y0),
          n = y0 === y1 ? sin$1(y0) : (cy0 - cos$1(y1)) / (y1 - y0),
          g = cy0 / n + y0;

      if (abs$1(n) < epsilon$1) return equirectangularRaw;

      function project(x, y) {
        var gy = g - y, nx = n * x;
        return [gy * sin$1(nx), g - gy * cos$1(nx)];
      }

      project.invert = function(x, y) {
        var gy = g - y,
            l = atan2$1(x, abs$1(gy)) * sign$1(gy);
        if (gy * n < 0)
          l -= pi$1 * sign$1(x) * sign$1(gy);
        return [l / n, g - sign$1(n) * sqrt$2(x * x + gy * gy)];
      };

      return project;
    }

    function conicEquidistant() {
      return conicProjection(conicEquidistantRaw)
          .scale(131.154)
          .center([0, 13.9389]);
    }

    var A1 = 1.340264,
        A2 = -0.081106,
        A3 = 0.000893,
        A4 = 0.003796,
        M = sqrt$2(3) / 2,
        iterations = 12;

    function equalEarthRaw(lambda, phi) {
      var l = asin$1(M * sin$1(phi)), l2 = l * l, l6 = l2 * l2 * l2;
      return [
        lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
        l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
      ];
    }

    equalEarthRaw.invert = function(x, y) {
      var l = y, l2 = l * l, l6 = l2 * l2 * l2;
      for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
        fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
        fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
        l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
        if (abs$1(delta) < epsilon2) break;
      }
      return [
        M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
        asin$1(sin$1(l) / M)
      ];
    };

    function equalEarth() {
      return projection(equalEarthRaw)
          .scale(177.158);
    }

    function gnomonicRaw(x, y) {
      var cy = cos$1(y), k = cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    gnomonicRaw.invert = azimuthalInvert(atan);

    function gnomonic() {
      return projection(gnomonicRaw)
          .scale(144.049)
          .clipAngle(60);
    }

    function identity$4() {
      var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, // scale, translate and reflect
          alpha = 0, ca, sa, // angle
          x0 = null, y0, x1, y1, // clip extent
          kx = 1, ky = 1,
          transform = transformer$3({
            point: function(x, y) {
              var p = projection([x, y]);
              this.stream.point(p[0], p[1]);
            }
          }),
          postclip = identity$5,
          cache,
          cacheStream;

      function reset() {
        kx = k * sx;
        ky = k * sy;
        cache = cacheStream = null;
        return projection;
      }

      function projection (p) {
        var x = p[0] * kx, y = p[1] * ky;
        if (alpha) {
          var t = y * ca - x * sa;
          x = x * ca + y * sa;
          y = t;
        }    
        return [x + tx, y + ty];
      }
      projection.invert = function(p) {
        var x = p[0] - tx, y = p[1] - ty;
        if (alpha) {
          var t = y * ca + x * sa;
          x = x * ca - y * sa;
          y = t;
        }
        return [x / kx, y / ky];
      };
      projection.stream = function(stream) {
        return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
      };
      projection.postclip = function(_) {
        return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
      };
      projection.clipExtent = function(_) {
        return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, identity$5) : clipRectangle(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
      };
      projection.scale = function(_) {
        return arguments.length ? (k = +_, reset()) : k;
      };
      projection.translate = function(_) {
        return arguments.length ? (tx = +_[0], ty = +_[1], reset()) : [tx, ty];
      };
      projection.angle = function(_) {
        return arguments.length ? (alpha = _ % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset()) : alpha * degrees;
      };
      projection.reflectX = function(_) {
        return arguments.length ? (sx = _ ? -1 : 1, reset()) : sx < 0;
      };
      projection.reflectY = function(_) {
        return arguments.length ? (sy = _ ? -1 : 1, reset()) : sy < 0;
      };
      projection.fitExtent = function(extent, object) {
        return fitExtent(projection, extent, object);
      };
      projection.fitSize = function(size, object) {
        return fitSize(projection, size, object);
      };
      projection.fitWidth = function(width, object) {
        return fitWidth(projection, width, object);
      };
      projection.fitHeight = function(height, object) {
        return fitHeight(projection, height, object);
      };

      return projection;
    }

    function naturalEarth1Raw(lambda, phi) {
      var phi2 = phi * phi, phi4 = phi2 * phi2;
      return [
        lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))),
        phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))
      ];
    }

    naturalEarth1Raw.invert = function(x, y) {
      var phi = y, i = 25, delta;
      do {
        var phi2 = phi * phi, phi4 = phi2 * phi2;
        phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) /
            (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
      } while (abs$1(delta) > epsilon$1 && --i > 0);
      return [
        x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))),
        phi
      ];
    };

    function naturalEarth1() {
      return projection(naturalEarth1Raw)
          .scale(175.295);
    }

    function orthographicRaw(x, y) {
      return [cos$1(y) * sin$1(x), sin$1(y)];
    }

    orthographicRaw.invert = azimuthalInvert(asin$1);

    function orthographic() {
      return projection(orthographicRaw)
          .scale(249.5)
          .clipAngle(90 + epsilon$1);
    }

    function stereographicRaw(x, y) {
      var cy = cos$1(y), k = 1 + cos$1(x) * cy;
      return [cy * sin$1(x) / k, sin$1(y) / k];
    }

    stereographicRaw.invert = azimuthalInvert(function(z) {
      return 2 * atan(z);
    });

    function stereographic() {
      return projection(stereographicRaw)
          .scale(250)
          .clipAngle(142);
    }

    function transverseMercatorRaw(lambda, phi) {
      return [log$1(tan((halfPi$1 + phi) / 2)), -lambda];
    }

    transverseMercatorRaw.invert = function(x, y) {
      return [-y, 2 * atan(exp(x)) - halfPi$1];
    };

    function transverseMercator() {
      var m = mercatorProjection(transverseMercatorRaw),
          center = m.center,
          rotate = m.rotate;

      m.center = function(_) {
        return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
      };

      m.rotate = function(_) {
        return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
      };

      return rotate([0, 0, 90])
          .scale(159.155);
    }

    function defaultSeparation$1(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    function meanX(children) {
      return children.reduce(meanXReduce, 0) / children.length;
    }

    function meanXReduce(x, c) {
      return x + c.x;
    }

    function maxY(children) {
      return 1 + children.reduce(maxYReduce, 0);
    }

    function maxYReduce(y, c) {
      return Math.max(y, c.y);
    }

    function leafLeft(node) {
      var children;
      while (children = node.children) node = children[0];
      return node;
    }

    function leafRight(node) {
      var children;
      while (children = node.children) node = children[children.length - 1];
      return node;
    }

    function cluster() {
      var separation = defaultSeparation$1,
          dx = 1,
          dy = 1,
          nodeSize = false;

      function cluster(root) {
        var previousNode,
            x = 0;

        // First walk, computing the initial x & y values.
        root.eachAfter(function(node) {
          var children = node.children;
          if (children) {
            node.x = meanX(children);
            node.y = maxY(children);
          } else {
            node.x = previousNode ? x += separation(node, previousNode) : 0;
            node.y = 0;
            previousNode = node;
          }
        });

        var left = leafLeft(root),
            right = leafRight(root),
            x0 = left.x - separation(left, right) / 2,
            x1 = right.x + separation(right, left) / 2;

        // Second walk, normalizing x & y to the desired size.
        return root.eachAfter(nodeSize ? function(node) {
          node.x = (node.x - root.x) * dx;
          node.y = (root.y - node.y) * dy;
        } : function(node) {
          node.x = (node.x - x0) / (x1 - x0) * dx;
          node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
        });
      }

      cluster.separation = function(x) {
        return arguments.length ? (separation = x, cluster) : separation;
      };

      cluster.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? null : [dx, dy]);
      };

      cluster.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : (nodeSize ? [dx, dy] : null);
      };

      return cluster;
    }

    function count(node) {
      var sum = 0,
          children = node.children,
          i = children && children.length;
      if (!i) sum = 1;
      else while (--i >= 0) sum += children[i].value;
      node.value = sum;
    }

    function node_count() {
      return this.eachAfter(count);
    }

    function node_each(callback, that) {
      let index = -1;
      for (const node of this) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_eachBefore(callback, that) {
      var node = this, nodes = [node], children, i, index = -1;
      while (node = nodes.pop()) {
        callback.call(that, node, ++index, this);
        if (children = node.children) {
          for (i = children.length - 1; i >= 0; --i) {
            nodes.push(children[i]);
          }
        }
      }
      return this;
    }

    function node_eachAfter(callback, that) {
      var node = this, nodes = [node], next = [], children, i, n, index = -1;
      while (node = nodes.pop()) {
        next.push(node);
        if (children = node.children) {
          for (i = 0, n = children.length; i < n; ++i) {
            nodes.push(children[i]);
          }
        }
      }
      while (node = next.pop()) {
        callback.call(that, node, ++index, this);
      }
      return this;
    }

    function node_find(callback, that) {
      let index = -1;
      for (const node of this) {
        if (callback.call(that, node, ++index, this)) {
          return node;
        }
      }
    }

    function node_sum(value) {
      return this.eachAfter(function(node) {
        var sum = +value(node.data) || 0,
            children = node.children,
            i = children && children.length;
        while (--i >= 0) sum += children[i].value;
        node.value = sum;
      });
    }

    function node_sort(compare) {
      return this.eachBefore(function(node) {
        if (node.children) {
          node.children.sort(compare);
        }
      });
    }

    function node_path(end) {
      var start = this,
          ancestor = leastCommonAncestor(start, end),
          nodes = [start];
      while (start !== ancestor) {
        start = start.parent;
        nodes.push(start);
      }
      var k = nodes.length;
      while (end !== ancestor) {
        nodes.splice(k, 0, end);
        end = end.parent;
      }
      return nodes;
    }

    function leastCommonAncestor(a, b) {
      if (a === b) return a;
      var aNodes = a.ancestors(),
          bNodes = b.ancestors(),
          c = null;
      a = aNodes.pop();
      b = bNodes.pop();
      while (a === b) {
        c = a;
        a = aNodes.pop();
        b = bNodes.pop();
      }
      return c;
    }

    function node_ancestors() {
      var node = this, nodes = [node];
      while (node = node.parent) {
        nodes.push(node);
      }
      return nodes;
    }

    function node_descendants() {
      return Array.from(this);
    }

    function node_leaves() {
      var leaves = [];
      this.eachBefore(function(node) {
        if (!node.children) {
          leaves.push(node);
        }
      });
      return leaves;
    }

    function node_links() {
      var root = this, links = [];
      root.each(function(node) {
        if (node !== root) { // Dont include the roots parent, if any.
          links.push({source: node.parent, target: node});
        }
      });
      return links;
    }

    function* node_iterator() {
      var node = this, current, next = [node], children, i, n;
      do {
        current = next.reverse(), next = [];
        while (node = current.pop()) {
          yield node;
          if (children = node.children) {
            for (i = 0, n = children.length; i < n; ++i) {
              next.push(children[i]);
            }
          }
        }
      } while (next.length);
    }

    function hierarchy(data, children) {
      if (data instanceof Map) {
        data = [undefined, data];
        if (children === undefined) children = mapChildren;
      } else if (children === undefined) {
        children = objectChildren;
      }

      var root = new Node$2(data),
          node,
          nodes = [root],
          child,
          childs,
          i,
          n;

      while (node = nodes.pop()) {
        if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
          node.children = childs;
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = childs[i] = new Node$2(childs[i]));
            child.parent = node;
            child.depth = node.depth + 1;
          }
        }
      }

      return root.eachBefore(computeHeight);
    }

    function node_copy() {
      return hierarchy(this).eachBefore(copyData);
    }

    function objectChildren(d) {
      return d.children;
    }

    function mapChildren(d) {
      return Array.isArray(d) ? d[1] : null;
    }

    function copyData(node) {
      if (node.data.value !== undefined) node.value = node.data.value;
      node.data = node.data.data;
    }

    function computeHeight(node) {
      var height = 0;
      do node.height = height;
      while ((node = node.parent) && (node.height < ++height));
    }

    function Node$2(data) {
      this.data = data;
      this.depth =
      this.height = 0;
      this.parent = null;
    }

    Node$2.prototype = hierarchy.prototype = {
      constructor: Node$2,
      count: node_count,
      each: node_each,
      eachAfter: node_eachAfter,
      eachBefore: node_eachBefore,
      find: node_find,
      sum: node_sum,
      sort: node_sort,
      path: node_path,
      ancestors: node_ancestors,
      descendants: node_descendants,
      leaves: node_leaves,
      links: node_links,
      copy: node_copy,
      [Symbol.iterator]: node_iterator
    };

    function optional(f) {
      return f == null ? null : required(f);
    }

    function required(f) {
      if (typeof f !== "function") throw new Error;
      return f;
    }

    function constantZero() {
      return 0;
    }

    function constant$2(x) {
      return function() {
        return x;
      };
    }

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const a$1 = 1664525;
    const c$3 = 1013904223;
    const m = 4294967296; // 2^32

    function lcg$1() {
      let s = 1;
      return () => (s = (a$1 * s + c$3) % m) / m;
    }

    function array$1(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function shuffle(array, random) {
      let m = array.length,
          t,
          i;

      while (m) {
        i = random() * m-- | 0;
        t = array[m];
        array[m] = array[i];
        array[i] = t;
      }

      return array;
    }

    function enclose(circles) {
      return packEncloseRandom(circles, lcg$1());
    }

    function packEncloseRandom(circles, random) {
      var i = 0, n = (circles = shuffle(Array.from(circles), random)).length, B = [], p, e;

      while (i < n) {
        p = circles[i];
        if (e && enclosesWeak(e, p)) ++i;
        else e = encloseBasis(B = extendBasis(B, p)), i = 0;
      }

      return e;
    }

    function extendBasis(B, p) {
      var i, j;

      if (enclosesWeakAll(p, B)) return [p];

      // If we get here then B must have at least one element.
      for (i = 0; i < B.length; ++i) {
        if (enclosesNot(p, B[i])
            && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
          return [B[i], p];
        }
      }

      // If we get here then B must have at least two elements.
      for (i = 0; i < B.length - 1; ++i) {
        for (j = i + 1; j < B.length; ++j) {
          if (enclosesNot(encloseBasis2(B[i], B[j]), p)
              && enclosesNot(encloseBasis2(B[i], p), B[j])
              && enclosesNot(encloseBasis2(B[j], p), B[i])
              && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
            return [B[i], B[j], p];
          }
        }
      }

      // If we get here then something is very wrong.
      throw new Error;
    }

    function enclosesNot(a, b) {
      var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
      return dr < 0 || dr * dr < dx * dx + dy * dy;
    }

    function enclosesWeak(a, b) {
      var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function enclosesWeakAll(a, B) {
      for (var i = 0; i < B.length; ++i) {
        if (!enclosesWeak(a, B[i])) {
          return false;
        }
      }
      return true;
    }

    function encloseBasis(B) {
      switch (B.length) {
        case 1: return encloseBasis1(B[0]);
        case 2: return encloseBasis2(B[0], B[1]);
        case 3: return encloseBasis3(B[0], B[1], B[2]);
      }
    }

    function encloseBasis1(a) {
      return {
        x: a.x,
        y: a.y,
        r: a.r
      };
    }

    function encloseBasis2(a, b) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1,
          l = Math.sqrt(x21 * x21 + y21 * y21);
      return {
        x: (x1 + x2 + x21 / l * r21) / 2,
        y: (y1 + y2 + y21 / l * r21) / 2,
        r: (l + r1 + r2) / 2
      };
    }

    function encloseBasis3(a, b, c) {
      var x1 = a.x, y1 = a.y, r1 = a.r,
          x2 = b.x, y2 = b.y, r2 = b.r,
          x3 = c.x, y3 = c.y, r3 = c.r,
          a2 = x1 - x2,
          a3 = x1 - x3,
          b2 = y1 - y2,
          b3 = y1 - y3,
          c2 = r2 - r1,
          c3 = r3 - r1,
          d1 = x1 * x1 + y1 * y1 - r1 * r1,
          d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
          d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
          ab = a3 * b2 - a2 * b3,
          xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
          xb = (b3 * c2 - b2 * c3) / ab,
          ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
          yb = (a2 * c3 - a3 * c2) / ab,
          A = xb * xb + yb * yb - 1,
          B = 2 * (r1 + xa * xb + ya * yb),
          C = xa * xa + ya * ya - r1 * r1,
          r = -(Math.abs(A) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
      return {
        x: x1 + xa + xb * r,
        y: y1 + ya + yb * r,
        r: r
      };
    }

    function place(b, a, c) {
      var dx = b.x - a.x, x, a2,
          dy = b.y - a.y, y, b2,
          d2 = dx * dx + dy * dy;
      if (d2) {
        a2 = a.r + c.r, a2 *= a2;
        b2 = b.r + c.r, b2 *= b2;
        if (a2 > b2) {
          x = (d2 + b2 - a2) / (2 * d2);
          y = Math.sqrt(Math.max(0, b2 / d2 - x * x));
          c.x = b.x - x * dx - y * dy;
          c.y = b.y - x * dy + y * dx;
        } else {
          x = (d2 + a2 - b2) / (2 * d2);
          y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
          c.x = a.x + x * dx - y * dy;
          c.y = a.y + x * dy + y * dx;
        }
      } else {
        c.x = a.x + c.r;
        c.y = a.y;
      }
    }

    function intersects(a, b) {
      var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
      return dr > 0 && dr * dr > dx * dx + dy * dy;
    }

    function score(node) {
      var a = node._,
          b = node.next._,
          ab = a.r + b.r,
          dx = (a.x * b.r + b.x * a.r) / ab,
          dy = (a.y * b.r + b.y * a.r) / ab;
      return dx * dx + dy * dy;
    }

    function Node$1(circle) {
      this._ = circle;
      this.next = null;
      this.previous = null;
    }

    function packSiblingsRandom(circles, random) {
      if (!(n = (circles = array$1(circles)).length)) return 0;

      var a, b, c, n, aa, ca, i, j, k, sj, sk;

      // Place the first circle.
      a = circles[0], a.x = 0, a.y = 0;
      if (!(n > 1)) return a.r;

      // Place the second circle.
      b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
      if (!(n > 2)) return a.r + b.r;

      // Place the third circle.
      place(b, a, c = circles[2]);

      // Initialize the front-chain using the first three circles a, b and c.
      a = new Node$1(a), b = new Node$1(b), c = new Node$1(c);
      a.next = c.previous = b;
      b.next = a.previous = c;
      c.next = b.previous = a;

      // Attempt to place each remaining circle
      pack: for (i = 3; i < n; ++i) {
        place(a._, b._, c = circles[i]), c = new Node$1(c);

        // Find the closest intersecting circle on the front-chain, if any.
        // Closeness is determined by linear distance along the front-chain.
        // Ahead or behind is likewise determined by linear distance.
        j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
        do {
          if (sj <= sk) {
            if (intersects(j._, c._)) {
              b = j, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sj += j._.r, j = j.next;
          } else {
            if (intersects(k._, c._)) {
              a = k, a.next = b, b.previous = a, --i;
              continue pack;
            }
            sk += k._.r, k = k.previous;
          }
        } while (j !== k.next);

        // Success! Insert the new circle c between a and b.
        c.previous = a, c.next = b, a.next = b.previous = b = c;

        // Compute the new closest circle pair to the centroid.
        aa = score(a);
        while ((c = c.next) !== b) {
          if ((ca = score(c)) < aa) {
            a = c, aa = ca;
          }
        }
        b = a.next;
      }

      // Compute the enclosing circle of the front chain.
      a = [b._], c = b; while ((c = c.next) !== b) a.push(c._); c = packEncloseRandom(a, random);

      // Translate the circles to put the enclosing circle around the origin.
      for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

      return c.r;
    }

    function siblings(circles) {
      packSiblingsRandom(circles, lcg$1());
      return circles;
    }

    function defaultRadius(d) {
      return Math.sqrt(d.value);
    }

    function index$1() {
      var radius = null,
          dx = 1,
          dy = 1,
          padding = constantZero;

      function pack(root) {
        const random = lcg$1();
        root.x = dx / 2, root.y = dy / 2;
        if (radius) {
          root.eachBefore(radiusLeaf(radius))
              .eachAfter(packChildrenRandom(padding, 0.5, random))
              .eachBefore(translateChild(1));
        } else {
          root.eachBefore(radiusLeaf(defaultRadius))
              .eachAfter(packChildrenRandom(constantZero, 1, random))
              .eachAfter(packChildrenRandom(padding, root.r / Math.min(dx, dy), random))
              .eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
        }
        return root;
      }

      pack.radius = function(x) {
        return arguments.length ? (radius = optional(x), pack) : radius;
      };

      pack.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
      };

      pack.padding = function(x) {
        return arguments.length ? (padding = typeof x === "function" ? x : constant$2(+x), pack) : padding;
      };

      return pack;
    }

    function radiusLeaf(radius) {
      return function(node) {
        if (!node.children) {
          node.r = Math.max(0, +radius(node) || 0);
        }
      };
    }

    function packChildrenRandom(padding, k, random) {
      return function(node) {
        if (children = node.children) {
          var children,
              i,
              n = children.length,
              r = padding(node) * k || 0,
              e;

          if (r) for (i = 0; i < n; ++i) children[i].r += r;
          e = packSiblingsRandom(children, random);
          if (r) for (i = 0; i < n; ++i) children[i].r -= r;
          node.r = e + r;
        }
      };
    }

    function translateChild(k) {
      return function(node) {
        var parent = node.parent;
        node.r *= k;
        if (parent) {
          node.x = parent.x + k * node.x;
          node.y = parent.y + k * node.y;
        }
      };
    }

    function roundNode(node) {
      node.x0 = Math.round(node.x0);
      node.y0 = Math.round(node.y0);
      node.x1 = Math.round(node.x1);
      node.y1 = Math.round(node.y1);
    }

    function treemapDice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (x1 - x0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.y0 = y0, node.y1 = y1;
        node.x0 = x0, node.x1 = x0 += node.value * k;
      }
    }

    function partition() {
      var dx = 1,
          dy = 1,
          padding = 0,
          round = false;

      function partition(root) {
        var n = root.height + 1;
        root.x0 =
        root.y0 = padding;
        root.x1 = dx;
        root.y1 = dy / n;
        root.eachBefore(positionNode(dy, n));
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(dy, n) {
        return function(node) {
          if (node.children) {
            treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
          }
          var x0 = node.x0,
              y0 = node.y0,
              x1 = node.x1 - padding,
              y1 = node.y1 - padding;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          node.x0 = x0;
          node.y0 = y0;
          node.x1 = x1;
          node.y1 = y1;
        };
      }

      partition.round = function(x) {
        return arguments.length ? (round = !!x, partition) : round;
      };

      partition.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
      };

      partition.padding = function(x) {
        return arguments.length ? (padding = +x, partition) : padding;
      };

      return partition;
    }

    var preroot = {depth: -1},
        ambiguous = {},
        imputed = {};

    function defaultId(d) {
      return d.id;
    }

    function defaultParentId(d) {
      return d.parentId;
    }

    function stratify() {
      var id = defaultId,
          parentId = defaultParentId,
          path;

      function stratify(data) {
        var nodes = Array.from(data),
            currentId = id,
            currentParentId = parentId,
            n,
            d,
            i,
            root,
            parent,
            node,
            nodeId,
            nodeKey,
            nodeByKey = new Map;

        if (path != null) {
          const I = nodes.map((d, i) => normalize$1(path(d, i, data)));
          const P = I.map(parentof);
          const S = new Set(I).add("");
          for (const i of P) {
            if (!S.has(i)) {
              S.add(i);
              I.push(i);
              P.push(parentof(i));
              nodes.push(imputed);
            }
          }
          currentId = (_, i) => I[i];
          currentParentId = (_, i) => P[i];
        }

        for (i = 0, n = nodes.length; i < n; ++i) {
          d = nodes[i], node = nodes[i] = new Node$2(d);
          if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
            nodeKey = node.id = nodeId;
            nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
          }
          if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
            node.parent = nodeId;
          }
        }

        for (i = 0; i < n; ++i) {
          node = nodes[i];
          if (nodeId = node.parent) {
            parent = nodeByKey.get(nodeId);
            if (!parent) throw new Error("missing: " + nodeId);
            if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
            if (parent.children) parent.children.push(node);
            else parent.children = [node];
            node.parent = parent;
          } else {
            if (root) throw new Error("multiple roots");
            root = node;
          }
        }

        if (!root) throw new Error("no root");

        // When imputing internal nodes, only introduce roots if needed.
        // Then replace the imputed marker data with null.
        if (path != null) {
          while (root.data === imputed && root.children.length === 1) {
            root = root.children[0], --n;
          }
          for (let i = nodes.length - 1; i >= 0; --i) {
            node = nodes[i];
            if (node.data !== imputed) break;
            node.data = null;
          }
        }

        root.parent = preroot;
        root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
        root.parent = null;
        if (n > 0) throw new Error("cycle");

        return root;
      }

      stratify.id = function(x) {
        return arguments.length ? (id = optional(x), stratify) : id;
      };

      stratify.parentId = function(x) {
        return arguments.length ? (parentId = optional(x), stratify) : parentId;
      };

      stratify.path = function(x) {
        return arguments.length ? (path = optional(x), stratify) : path;
      };

      return stratify;
    }

    // To normalize a path, we coerce to a string, strip the trailing slash if any
    // (as long as the trailing slash is not immediately preceded by another slash),
    // and add leading slash if missing.
    function normalize$1(path) {
      path = `${path}`;
      let i = path.length;
      if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);
      return path[0] === "/" ? path : `/${path}`;
    }

    // Walk backwards to find the first slash that is not the leading slash, e.g.:
    // "/foo/bar"  "/foo", "/foo"  "/", "/"  "". (The root is special-cased
    // because the id of the root must be a truthy value.)
    function parentof(path) {
      let i = path.length;
      if (i < 2) return "";
      while (--i > 1) if (slash(path, i)) break;
      return path.slice(0, i);
    }

    // Slashes can be escaped; to determine whether a slash is a path delimiter, we
    // count the number of preceding backslashes escaping the forward slash: an odd
    // number indicates an escaped forward slash.
    function slash(path, i) {
      if (path[i] === "/") {
        let k = 0;
        while (i > 0 && path[--i] === "\\") ++k;
        if ((k & 1) === 0) return true;
      }
      return false;
    }

    function defaultSeparation(a, b) {
      return a.parent === b.parent ? 1 : 2;
    }

    // function radialSeparation(a, b) {
    //   return (a.parent === b.parent ? 1 : 2) / a.depth;
    // }

    // This function is used to traverse the left contour of a subtree (or
    // subforest). It returns the successor of v on this contour. This successor is
    // either given by the leftmost child of v or by the thread of v. The function
    // returns null if and only if v is on the highest level of its subtree.
    function nextLeft(v) {
      var children = v.children;
      return children ? children[0] : v.t;
    }

    // This function works analogously to nextLeft.
    function nextRight(v) {
      var children = v.children;
      return children ? children[children.length - 1] : v.t;
    }

    // Shifts the current subtree rooted at w+. This is done by increasing
    // prelim(w+) and mod(w+) by shift.
    function moveSubtree(wm, wp, shift) {
      var change = shift / (wp.i - wm.i);
      wp.c -= change;
      wp.s += shift;
      wm.c += change;
      wp.z += shift;
      wp.m += shift;
    }

    // All other shifts, applied to the smaller subtrees between w- and w+, are
    // performed by this function. To prepare the shifts, we have to adjust
    // change(w+), shift(w+), and change(w-).
    function executeShifts(v) {
      var shift = 0,
          change = 0,
          children = v.children,
          i = children.length,
          w;
      while (--i >= 0) {
        w = children[i];
        w.z += shift;
        w.m += shift;
        shift += w.s + (change += w.c);
      }
    }

    // If vi-s ancestor is a sibling of v, returns vi-s ancestor. Otherwise,
    // returns the specified (default) ancestor.
    function nextAncestor(vim, v, ancestor) {
      return vim.a.parent === v.parent ? vim.a : ancestor;
    }

    function TreeNode(node, i) {
      this._ = node;
      this.parent = null;
      this.children = null;
      this.A = null; // default ancestor
      this.a = this; // ancestor
      this.z = 0; // prelim
      this.m = 0; // mod
      this.c = 0; // change
      this.s = 0; // shift
      this.t = null; // thread
      this.i = i; // number
    }

    TreeNode.prototype = Object.create(Node$2.prototype);

    function treeRoot(root) {
      var tree = new TreeNode(root, 0),
          node,
          nodes = [tree],
          child,
          children,
          i,
          n;

      while (node = nodes.pop()) {
        if (children = node._.children) {
          node.children = new Array(n = children.length);
          for (i = n - 1; i >= 0; --i) {
            nodes.push(child = node.children[i] = new TreeNode(children[i], i));
            child.parent = node;
          }
        }
      }

      (tree.parent = new TreeNode(null, 0)).children = [tree];
      return tree;
    }

    // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm
    function tree() {
      var separation = defaultSeparation,
          dx = 1,
          dy = 1,
          nodeSize = null;

      function tree(root) {
        var t = treeRoot(root);

        // Compute the layout using Buchheim et al.s algorithm.
        t.eachAfter(firstWalk), t.parent.m = -t.z;
        t.eachBefore(secondWalk);

        // If a fixed node size is specified, scale x and y.
        if (nodeSize) root.eachBefore(sizeNode);

        // If a fixed tree size is specified, scale x and y based on the extent.
        // Compute the left-most, right-most, and depth-most nodes for extents.
        else {
          var left = root,
              right = root,
              bottom = root;
          root.eachBefore(function(node) {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
            if (node.depth > bottom.depth) bottom = node;
          });
          var s = left === right ? 1 : separation(left, right) / 2,
              tx = s - left.x,
              kx = dx / (right.x + s + tx),
              ky = dy / (bottom.depth || 1);
          root.eachBefore(function(node) {
            node.x = (node.x + tx) * kx;
            node.y = node.depth * ky;
          });
        }

        return root;
      }

      // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
      // applied recursively to the children of v, as well as the function
      // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
      // node v is placed to the midpoint of its outermost children.
      function firstWalk(v) {
        var children = v.children,
            siblings = v.parent.children,
            w = v.i ? siblings[v.i - 1] : null;
        if (children) {
          executeShifts(v);
          var midpoint = (children[0].z + children[children.length - 1].z) / 2;
          if (w) {
            v.z = w.z + separation(v._, w._);
            v.m = v.z - midpoint;
          } else {
            v.z = midpoint;
          }
        } else if (w) {
          v.z = w.z + separation(v._, w._);
        }
        v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
      }

      // Computes all real x-coordinates by summing up the modifiers recursively.
      function secondWalk(v) {
        v._.x = v.z + v.parent.m;
        v.m += v.parent.m;
      }

      // The core of the algorithm. Here, a new subtree is combined with the
      // previous subtrees. Threads are used to traverse the inside and outside
      // contours of the left and right subtree up to the highest common level. The
      // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
      // superscript o means outside and i means inside, the subscript - means left
      // subtree and + means right subtree. For summing up the modifiers along the
      // contour, we use respective variables si+, si-, so-, and so+. Whenever two
      // nodes of the inside contours conflict, we compute the left one of the
      // greatest uncommon ancestors using the function ANCESTOR and call MOVE
      // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
      // Finally, we add a new thread (if necessary).
      function apportion(v, w, ancestor) {
        if (w) {
          var vip = v,
              vop = v,
              vim = w,
              vom = vip.parent.children[0],
              sip = vip.m,
              sop = vop.m,
              sim = vim.m,
              som = vom.m,
              shift;
          while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
            vom = nextLeft(vom);
            vop = nextRight(vop);
            vop.a = v;
            shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
            if (shift > 0) {
              moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
              sip += shift;
              sop += shift;
            }
            sim += vim.m;
            sip += vip.m;
            som += vom.m;
            sop += vop.m;
          }
          if (vim && !nextRight(vop)) {
            vop.t = vim;
            vop.m += sim - sop;
          }
          if (vip && !nextLeft(vom)) {
            vom.t = vip;
            vom.m += sip - som;
            ancestor = v;
          }
        }
        return ancestor;
      }

      function sizeNode(node) {
        node.x *= dx;
        node.y = node.depth * dy;
      }

      tree.separation = function(x) {
        return arguments.length ? (separation = x, tree) : separation;
      };

      tree.size = function(x) {
        return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : (nodeSize ? null : [dx, dy]);
      };

      tree.nodeSize = function(x) {
        return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : (nodeSize ? [dx, dy] : null);
      };

      return tree;
    }

    function treemapSlice(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          node,
          i = -1,
          n = nodes.length,
          k = parent.value && (y1 - y0) / parent.value;

      while (++i < n) {
        node = nodes[i], node.x0 = x0, node.x1 = x1;
        node.y0 = y0, node.y1 = y0 += node.value * k;
      }
    }

    var phi = (1 + Math.sqrt(5)) / 2;

    function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
      var rows = [],
          nodes = parent.children,
          row,
          nodeValue,
          i0 = 0,
          i1 = 0,
          n = nodes.length,
          dx, dy,
          value = parent.value,
          sumValue,
          minValue,
          maxValue,
          newRatio,
          minRatio,
          alpha,
          beta;

      while (i0 < n) {
        dx = x1 - x0, dy = y1 - y0;

        // Find the next non-empty node.
        do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
        minValue = maxValue = sumValue;
        alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
        beta = sumValue * sumValue * alpha;
        minRatio = Math.max(maxValue / beta, beta / minValue);

        // Keep adding nodes while the aspect ratio maintains or improves.
        for (; i1 < n; ++i1) {
          sumValue += nodeValue = nodes[i1].value;
          if (nodeValue < minValue) minValue = nodeValue;
          if (nodeValue > maxValue) maxValue = nodeValue;
          beta = sumValue * sumValue * alpha;
          newRatio = Math.max(maxValue / beta, beta / minValue);
          if (newRatio > minRatio) { sumValue -= nodeValue; break; }
          minRatio = newRatio;
        }

        // Position and record the row orientation.
        rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
        if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
        else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
        value -= sumValue, i0 = i1;
      }

      return rows;
    }

    var squarify = (function custom(ratio) {

      function squarify(parent, x0, y0, x1, y1) {
        squarifyRatio(ratio, parent, x0, y0, x1, y1);
      }

      squarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return squarify;
    })(phi);

    function index() {
      var tile = squarify,
          round = false,
          dx = 1,
          dy = 1,
          paddingStack = [0],
          paddingInner = constantZero,
          paddingTop = constantZero,
          paddingRight = constantZero,
          paddingBottom = constantZero,
          paddingLeft = constantZero;

      function treemap(root) {
        root.x0 =
        root.y0 = 0;
        root.x1 = dx;
        root.y1 = dy;
        root.eachBefore(positionNode);
        paddingStack = [0];
        if (round) root.eachBefore(roundNode);
        return root;
      }

      function positionNode(node) {
        var p = paddingStack[node.depth],
            x0 = node.x0 + p,
            y0 = node.y0 + p,
            x1 = node.x1 - p,
            y1 = node.y1 - p;
        if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
        if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
        node.x0 = x0;
        node.y0 = y0;
        node.x1 = x1;
        node.y1 = y1;
        if (node.children) {
          p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
          x0 += paddingLeft(node) - p;
          y0 += paddingTop(node) - p;
          x1 -= paddingRight(node) - p;
          y1 -= paddingBottom(node) - p;
          if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
          if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
          tile(node, x0, y0, x1, y1);
        }
      }

      treemap.round = function(x) {
        return arguments.length ? (round = !!x, treemap) : round;
      };

      treemap.size = function(x) {
        return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
      };

      treemap.tile = function(x) {
        return arguments.length ? (tile = required(x), treemap) : tile;
      };

      treemap.padding = function(x) {
        return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
      };

      treemap.paddingInner = function(x) {
        return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$2(+x), treemap) : paddingInner;
      };

      treemap.paddingOuter = function(x) {
        return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
      };

      treemap.paddingTop = function(x) {
        return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$2(+x), treemap) : paddingTop;
      };

      treemap.paddingRight = function(x) {
        return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$2(+x), treemap) : paddingRight;
      };

      treemap.paddingBottom = function(x) {
        return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$2(+x), treemap) : paddingBottom;
      };

      treemap.paddingLeft = function(x) {
        return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$2(+x), treemap) : paddingLeft;
      };

      return treemap;
    }

    function binary(parent, x0, y0, x1, y1) {
      var nodes = parent.children,
          i, n = nodes.length,
          sum, sums = new Array(n + 1);

      for (sums[0] = sum = i = 0; i < n; ++i) {
        sums[i + 1] = sum += nodes[i].value;
      }

      partition(0, n, parent.value, x0, y0, x1, y1);

      function partition(i, j, value, x0, y0, x1, y1) {
        if (i >= j - 1) {
          var node = nodes[i];
          node.x0 = x0, node.y0 = y0;
          node.x1 = x1, node.y1 = y1;
          return;
        }

        var valueOffset = sums[i],
            valueTarget = (value / 2) + valueOffset,
            k = i + 1,
            hi = j - 1;

        while (k < hi) {
          var mid = k + hi >>> 1;
          if (sums[mid] < valueTarget) k = mid + 1;
          else hi = mid;
        }

        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k;

        var valueLeft = sums[k] - valueOffset,
            valueRight = value - valueLeft;

        if ((x1 - x0) > (y1 - y0)) {
          var xk = value ? (x0 * valueRight + x1 * valueLeft) / value : x1;
          partition(i, k, valueLeft, x0, y0, xk, y1);
          partition(k, j, valueRight, xk, y0, x1, y1);
        } else {
          var yk = value ? (y0 * valueRight + y1 * valueLeft) / value : y1;
          partition(i, k, valueLeft, x0, y0, x1, yk);
          partition(k, j, valueRight, x0, yk, x1, y1);
        }
      }
    }

    function sliceDice(parent, x0, y0, x1, y1) {
      (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
    }

    var resquarify = (function custom(ratio) {

      function resquarify(parent, x0, y0, x1, y1) {
        if ((rows = parent._squarify) && (rows.ratio === ratio)) {
          var rows,
              row,
              nodes,
              i,
              j = -1,
              n,
              m = rows.length,
              value = parent.value;

          while (++j < m) {
            row = rows[j], nodes = row.children;
            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;
            if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += (y1 - y0) * row.value / value : y1);
            else treemapSlice(row, x0, y0, value ? x0 += (x1 - x0) * row.value / value : x1, y1);
            value -= row.value;
          }
        } else {
          parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
          rows.ratio = ratio;
        }
      }

      resquarify.ratio = function(x) {
        return custom((x = +x) > 1 ? x : 1);
      };

      return resquarify;
    })(phi);

    function area$1(polygon) {
      var i = -1,
          n = polygon.length,
          a,
          b = polygon[n - 1],
          area = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        area += a[1] * b[0] - a[0] * b[1];
      }

      return area / 2;
    }

    function centroid(polygon) {
      var i = -1,
          n = polygon.length,
          x = 0,
          y = 0,
          a,
          b = polygon[n - 1],
          c,
          k = 0;

      while (++i < n) {
        a = b;
        b = polygon[i];
        k += c = a[0] * b[1] - b[0] * a[1];
        x += (a[0] + b[0]) * c;
        y += (a[1] + b[1]) * c;
      }

      return k *= 3, [x / k, y / k];
    }

    // Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
    // the 3D cross product in a quadrant I Cartesian coordinate system (+x is
    // right, +y is up). Returns a positive value if ABC is counter-clockwise,
    // negative if clockwise, and zero if the points are collinear.
    function cross$1(a, b, c) {
      return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
    }

    function lexicographicOrder(a, b) {
      return a[0] - b[0] || a[1] - b[1];
    }

    // Computes the upper convex hull per the monotone chain algorithm.
    // Assumes points.length >= 3, is sorted by x, unique in y.
    // Returns an array of indices into points in left-to-right order.
    function computeUpperHullIndexes(points) {
      const n = points.length,
          indexes = [0, 1];
      let size = 2, i;

      for (i = 2; i < n; ++i) {
        while (size > 1 && cross$1(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;
        indexes[size++] = i;
      }

      return indexes.slice(0, size); // remove popped points
    }

    function hull(points) {
      if ((n = points.length) < 3) return null;

      var i,
          n,
          sortedPoints = new Array(n),
          flippedPoints = new Array(n);

      for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];
      sortedPoints.sort(lexicographicOrder);
      for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

      var upperIndexes = computeUpperHullIndexes(sortedPoints),
          lowerIndexes = computeUpperHullIndexes(flippedPoints);

      // Construct the hull polygon, removing possible duplicate endpoints.
      var skipLeft = lowerIndexes[0] === upperIndexes[0],
          skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
          hull = [];

      // Add upper hull in right-to-l order.
      // Then add lower hull in left-to-right order.
      for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);
      for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

      return hull;
    }

    function contains(polygon, point) {
      var n = polygon.length,
          p = polygon[n - 1],
          x = point[0], y = point[1],
          x0 = p[0], y0 = p[1],
          x1, y1,
          inside = false;

      for (var i = 0; i < n; ++i) {
        p = polygon[i], x1 = p[0], y1 = p[1];
        if (((y1 > y) !== (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside;
        x0 = x1, y0 = y1;
      }

      return inside;
    }

    function length(polygon) {
      var i = -1,
          n = polygon.length,
          b = polygon[n - 1],
          xa,
          ya,
          xb = b[0],
          yb = b[1],
          perimeter = 0;

      while (++i < n) {
        xa = xb;
        ya = yb;
        b = polygon[i];
        xb = b[0];
        yb = b[1];
        xa -= xb;
        ya -= yb;
        perimeter += Math.hypot(xa, ya);
      }

      return perimeter;
    }

    var defaultSource = Math.random;

    var uniform = (function sourceRandomUniform(source) {
      function randomUniform(min, max) {
        min = min == null ? 0 : +min;
        max = max == null ? 1 : +max;
        if (arguments.length === 1) max = min, min = 0;
        else max -= min;
        return function() {
          return source() * max + min;
        };
      }

      randomUniform.source = sourceRandomUniform;

      return randomUniform;
    })(defaultSource);

    var int = (function sourceRandomInt(source) {
      function randomInt(min, max) {
        if (arguments.length < 2) max = min, min = 0;
        min = Math.floor(min);
        max = Math.floor(max) - min;
        return function() {
          return Math.floor(source() * max + min);
        };
      }

      randomInt.source = sourceRandomInt;

      return randomInt;
    })(defaultSource);

    var normal = (function sourceRandomNormal(source) {
      function randomNormal(mu, sigma) {
        var x, r;
        mu = mu == null ? 0 : +mu;
        sigma = sigma == null ? 1 : +sigma;
        return function() {
          var y;

          // If available, use the second previously-generated uniform random.
          if (x != null) y = x, x = null;

          // Otherwise, generate a new x and y.
          else do {
            x = source() * 2 - 1;
            y = source() * 2 - 1;
            r = x * x + y * y;
          } while (!r || r > 1);

          return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
        };
      }

      randomNormal.source = sourceRandomNormal;

      return randomNormal;
    })(defaultSource);

    var logNormal = (function sourceRandomLogNormal(source) {
      var N = normal.source(source);

      function randomLogNormal() {
        var randomNormal = N.apply(this, arguments);
        return function() {
          return Math.exp(randomNormal());
        };
      }

      randomLogNormal.source = sourceRandomLogNormal;

      return randomLogNormal;
    })(defaultSource);

    var irwinHall = (function sourceRandomIrwinHall(source) {
      function randomIrwinHall(n) {
        if ((n = +n) <= 0) return () => 0;
        return function() {
          for (var sum = 0, i = n; i > 1; --i) sum += source();
          return sum + i * source();
        };
      }

      randomIrwinHall.source = sourceRandomIrwinHall;

      return randomIrwinHall;
    })(defaultSource);

    var bates = (function sourceRandomBates(source) {
      var I = irwinHall.source(source);

      function randomBates(n) {
        // use limiting distribution at n === 0
        if ((n = +n) === 0) return source;
        var randomIrwinHall = I(n);
        return function() {
          return randomIrwinHall() / n;
        };
      }

      randomBates.source = sourceRandomBates;

      return randomBates;
    })(defaultSource);

    var exponential = (function sourceRandomExponential(source) {
      function randomExponential(lambda) {
        return function() {
          return -Math.log1p(-source()) / lambda;
        };
      }

      randomExponential.source = sourceRandomExponential;

      return randomExponential;
    })(defaultSource);

    var pareto = (function sourceRandomPareto(source) {
      function randomPareto(alpha) {
        if ((alpha = +alpha) < 0) throw new RangeError("invalid alpha");
        alpha = 1 / -alpha;
        return function() {
          return Math.pow(1 - source(), alpha);
        };
      }

      randomPareto.source = sourceRandomPareto;

      return randomPareto;
    })(defaultSource);

    var bernoulli = (function sourceRandomBernoulli(source) {
      function randomBernoulli(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        return function() {
          return Math.floor(source() + p);
        };
      }

      randomBernoulli.source = sourceRandomBernoulli;

      return randomBernoulli;
    })(defaultSource);

    var geometric = (function sourceRandomGeometric(source) {
      function randomGeometric(p) {
        if ((p = +p) < 0 || p > 1) throw new RangeError("invalid p");
        if (p === 0) return () => Infinity;
        if (p === 1) return () => 1;
        p = Math.log1p(-p);
        return function() {
          return 1 + Math.floor(Math.log1p(-source()) / p);
        };
      }

      randomGeometric.source = sourceRandomGeometric;

      return randomGeometric;
    })(defaultSource);

    var gamma = (function sourceRandomGamma(source) {
      var randomNormal = normal.source(source)();

      function randomGamma(k, theta) {
        if ((k = +k) < 0) throw new RangeError("invalid k");
        // degenerate distribution if k === 0
        if (k === 0) return () => 0;
        theta = theta == null ? 1 : +theta;
        // exponential distribution if k === 1
        if (k === 1) return () => -Math.log1p(-source()) * theta;

        var d = (k < 1 ? k + 1 : k) - 1 / 3,
            c = 1 / (3 * Math.sqrt(d)),
            multiplier = k < 1 ? () => Math.pow(source(), 1 / k) : () => 1;
        return function() {
          do {
            do {
              var x = randomNormal(),
                  v = 1 + c * x;
            } while (v <= 0);
            v *= v * v;
            var u = 1 - source();
          } while (u >= 1 - 0.0331 * x * x * x * x && Math.log(u) >= 0.5 * x * x + d * (1 - v + Math.log(v)));
          return d * v * multiplier() * theta;
        };
      }

      randomGamma.source = sourceRandomGamma;

      return randomGamma;
    })(defaultSource);

    var beta = (function sourceRandomBeta(source) {
      var G = gamma.source(source);

      function randomBeta(alpha, beta) {
        var X = G(alpha),
            Y = G(beta);
        return function() {
          var x = X();
          return x === 0 ? 0 : x / (x + Y());
        };
      }

      randomBeta.source = sourceRandomBeta;

      return randomBeta;
    })(defaultSource);

    var binomial = (function sourceRandomBinomial(source) {
      var G = geometric.source(source),
          B = beta.source(source);

      function randomBinomial(n, p) {
        n = +n;
        if ((p = +p) >= 1) return () => n;
        if (p <= 0) return () => 0;
        return function() {
          var acc = 0, nn = n, pp = p;
          while (nn * pp > 16 && nn * (1 - pp) > 16) {
            var i = Math.floor((nn + 1) * pp),
                y = B(i, nn - i + 1)();
            if (y <= pp) {
              acc += i;
              nn -= i;
              pp = (pp - y) / (1 - y);
            } else {
              nn = i - 1;
              pp /= y;
            }
          }
          var sign = pp < 0.5,
              pFinal = sign ? pp : 1 - pp,
              g = G(pFinal);
          for (var s = g(), k = 0; s <= nn; ++k) s += g();
          return acc + (sign ? k : nn - k);
        };
      }

      randomBinomial.source = sourceRandomBinomial;

      return randomBinomial;
    })(defaultSource);

    var weibull = (function sourceRandomWeibull(source) {
      function randomWeibull(k, a, b) {
        var outerFunc;
        if ((k = +k) === 0) {
          outerFunc = x => -Math.log(x);
        } else {
          k = 1 / k;
          outerFunc = x => Math.pow(x, k);
        }
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * outerFunc(-Math.log1p(-source()));
        };
      }

      randomWeibull.source = sourceRandomWeibull;

      return randomWeibull;
    })(defaultSource);

    var cauchy = (function sourceRandomCauchy(source) {
      function randomCauchy(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          return a + b * Math.tan(Math.PI * source());
        };
      }

      randomCauchy.source = sourceRandomCauchy;

      return randomCauchy;
    })(defaultSource);

    var logistic = (function sourceRandomLogistic(source) {
      function randomLogistic(a, b) {
        a = a == null ? 0 : +a;
        b = b == null ? 1 : +b;
        return function() {
          var u = source();
          return a + b * Math.log(u / (1 - u));
        };
      }

      randomLogistic.source = sourceRandomLogistic;

      return randomLogistic;
    })(defaultSource);

    var poisson = (function sourceRandomPoisson(source) {
      var G = gamma.source(source),
          B = binomial.source(source);

      function randomPoisson(lambda) {
        return function() {
          var acc = 0, l = lambda;
          while (l > 16) {
            var n = Math.floor(0.875 * l),
                t = G(n)();
            if (t > l) return acc + B(n - 1, l / t)();
            acc += n;
            l -= t;
          }
          for (var s = -Math.log1p(-source()), k = 0; s <= l; ++k) s -= Math.log1p(-source());
          return acc + k;
        };
      }

      randomPoisson.source = sourceRandomPoisson;

      return randomPoisson;
    })(defaultSource);

    // https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
    const mul = 0x19660D;
    const inc = 0x3C6EF35F;
    const eps = 1 / 0x100000000;

    function lcg(seed = Math.random()) {
      let state = (0 <= seed && seed < 1 ? seed / eps : Math.abs(seed)) | 0;
      return () => (state = mul * state + inc | 0, eps * (state >>> 0));
    }

    function initRange(domain, range) {
      switch (arguments.length) {
        case 0: break;
        case 1: this.range(domain); break;
        default: this.range(range).domain(domain); break;
      }
      return this;
    }

    function initInterpolator(domain, interpolator) {
      switch (arguments.length) {
        case 0: break;
        case 1: {
          if (typeof domain === "function") this.interpolator(domain);
          else this.range(domain);
          break;
        }
        default: {
          this.domain(domain);
          if (typeof interpolator === "function") this.interpolator(interpolator);
          else this.range(interpolator);
          break;
        }
      }
      return this;
    }

    const implicit = Symbol("implicit");

    function ordinal() {
      var index = new InternMap(),
          domain = [],
          range = [],
          unknown = implicit;

      function scale(d) {
        let i = index.get(d);
        if (i === undefined) {
          if (unknown !== implicit) return unknown;
          index.set(d, i = domain.push(d) - 1);
        }
        return range[i % range.length];
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [], index = new InternMap();
        for (const value of _) {
          if (index.has(value)) continue;
          index.set(value, domain.push(value) - 1);
        }
        return scale;
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), scale) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return ordinal(domain, range).unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function band() {
      var scale = ordinal().unknown(undefined),
          domain = scale.domain,
          ordinalRange = scale.range,
          r0 = 0,
          r1 = 1,
          step,
          bandwidth,
          round = false,
          paddingInner = 0,
          paddingOuter = 0,
          align = 0.5;

      delete scale.unknown;

      function rescale() {
        var n = domain().length,
            reverse = r1 < r0,
            start = reverse ? r1 : r0,
            stop = reverse ? r0 : r1;
        step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
        if (round) step = Math.floor(step);
        start += (stop - start - step * (n - paddingInner)) * align;
        bandwidth = step * (1 - paddingInner);
        if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
        var values = range$2(n).map(function(i) { return start + step * i; });
        return ordinalRange(reverse ? values.reverse() : values);
      }

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.range = function(_) {
        return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
      };

      scale.rangeRound = function(_) {
        return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
      };

      scale.bandwidth = function() {
        return bandwidth;
      };

      scale.step = function() {
        return step;
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, rescale()) : round;
      };

      scale.padding = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
      };

      scale.paddingInner = function(_) {
        return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
      };

      scale.paddingOuter = function(_) {
        return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
      };

      scale.align = function(_) {
        return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
      };

      scale.copy = function() {
        return band(domain(), [r0, r1])
            .round(round)
            .paddingInner(paddingInner)
            .paddingOuter(paddingOuter)
            .align(align);
      };

      return initRange.apply(rescale(), arguments);
    }

    function pointish(scale) {
      var copy = scale.copy;

      scale.padding = scale.paddingOuter;
      delete scale.paddingInner;
      delete scale.paddingOuter;

      scale.copy = function() {
        return pointish(copy());
      };

      return scale;
    }

    function point$4() {
      return pointish(band.apply(null, arguments).paddingInner(1));
    }

    function constants(x) {
      return function() {
        return x;
      };
    }

    function number$1(x) {
      return +x;
    }

    var unit = [0, 1];

    function identity$3(x) {
      return x;
    }

    function normalize(a, b) {
      return (b -= (a = +a))
          ? function(x) { return (x - a) / b; }
          : constants(isNaN(b) ? NaN : 0.5);
    }

    function clamper(a, b) {
      var t;
      if (a > b) t = a, a = b, b = t;
      return function(x) { return Math.max(a, Math.min(b, x)); };
    }

    // normalize(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
    // interpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding range value x in [a,b].
    function bimap(domain, range, interpolate) {
      var d0 = domain[0], d1 = domain[1], r0 = range[0], r1 = range[1];
      if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
      else d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
      return function(x) { return r0(d0(x)); };
    }

    function polymap(domain, range, interpolate) {
      var j = Math.min(domain.length, range.length) - 1,
          d = new Array(j),
          r = new Array(j),
          i = -1;

      // Reverse descending domains.
      if (domain[j] < domain[0]) {
        domain = domain.slice().reverse();
        range = range.slice().reverse();
      }

      while (++i < j) {
        d[i] = normalize(domain[i], domain[i + 1]);
        r[i] = interpolate(range[i], range[i + 1]);
      }

      return function(x) {
        var i = bisect(domain, x, 1, j) - 1;
        return r[i](d[i](x));
      };
    }

    function copy$1(source, target) {
      return target
          .domain(source.domain())
          .range(source.range())
          .interpolate(source.interpolate())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function transformer$2() {
      var domain = unit,
          range = unit,
          interpolate = interpolate$2,
          transform,
          untransform,
          unknown,
          clamp = identity$3,
          piecewise,
          output,
          input;

      function rescale() {
        var n = Math.min(domain.length, range.length);
        if (clamp !== identity$3) clamp = clamper(domain[0], domain[n - 1]);
        piecewise = n > 2 ? polymap : bimap;
        output = input = null;
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range, interpolate)))(transform(clamp(x)));
      }

      scale.invert = function(y) {
        return clamp(untransform((input || (input = piecewise(range, domain.map(transform), interpolateNumber)))(y)));
      };

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.rangeRound = function(_) {
        return range = Array.from(_), interpolate = interpolateRound, rescale();
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = _ ? true : identity$3, rescale()) : clamp !== identity$3;
      };

      scale.interpolate = function(_) {
        return arguments.length ? (interpolate = _, rescale()) : interpolate;
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t, u) {
        transform = t, untransform = u;
        return rescale();
      };
    }

    function continuous() {
      return transformer$2()(identity$3, identity$3);
    }

    function tickFormat(start, stop, count, specifier) {
      var step = tickStep(start, stop, count),
          precision;
      specifier = formatSpecifier(specifier == null ? ",f" : specifier);
      switch (specifier.type) {
        case "s": {
          var value = Math.max(Math.abs(start), Math.abs(stop));
          if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value))) specifier.precision = precision;
          return formatPrefix(specifier, value);
        }
        case "":
        case "e":
        case "g":
        case "p":
        case "r": {
          if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
          break;
        }
        case "f":
        case "%": {
          if (specifier.precision == null && !isNaN(precision = precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
          break;
        }
      }
      return format(specifier);
    }

    function linearish(scale) {
      var domain = scale.domain;

      scale.ticks = function(count) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
      };

      scale.tickFormat = function(count, specifier) {
        var d = domain();
        return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
      };

      scale.nice = function(count) {
        if (count == null) count = 10;

        var d = domain();
        var i0 = 0;
        var i1 = d.length - 1;
        var start = d[i0];
        var stop = d[i1];
        var prestep;
        var step;
        var maxIter = 10;

        if (stop < start) {
          step = start, start = stop, stop = step;
          step = i0, i0 = i1, i1 = step;
        }
        
        while (maxIter-- > 0) {
          step = tickIncrement(start, stop, count);
          if (step === prestep) {
            d[i0] = start;
            d[i1] = stop;
            return domain(d);
          } else if (step > 0) {
            start = Math.floor(start / step) * step;
            stop = Math.ceil(stop / step) * step;
          } else if (step < 0) {
            start = Math.ceil(start * step) / step;
            stop = Math.floor(stop * step) / step;
          } else {
            break;
          }
          prestep = step;
        }

        return scale;
      };

      return scale;
    }

    function linear() {
      var scale = continuous();

      scale.copy = function() {
        return copy$1(scale, linear());
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function identity$2(domain) {
      var unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : x;
      }

      scale.invert = scale;

      scale.domain = scale.range = function(_) {
        return arguments.length ? (domain = Array.from(_, number$1), scale) : domain.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return identity$2(domain).unknown(unknown);
      };

      domain = arguments.length ? Array.from(domain, number$1) : [0, 1];

      return linearish(scale);
    }

    function nice(domain, interval) {
      domain = domain.slice();

      var i0 = 0,
          i1 = domain.length - 1,
          x0 = domain[i0],
          x1 = domain[i1],
          t;

      if (x1 < x0) {
        t = i0, i0 = i1, i1 = t;
        t = x0, x0 = x1, x1 = t;
      }

      domain[i0] = interval.floor(x0);
      domain[i1] = interval.ceil(x1);
      return domain;
    }

    function transformLog(x) {
      return Math.log(x);
    }

    function transformExp(x) {
      return Math.exp(x);
    }

    function transformLogn(x) {
      return -Math.log(-x);
    }

    function transformExpn(x) {
      return -Math.exp(-x);
    }

    function pow10(x) {
      return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
    }

    function powp(base) {
      return base === 10 ? pow10
          : base === Math.E ? Math.exp
          : x => Math.pow(base, x);
    }

    function logp(base) {
      return base === Math.E ? Math.log
          : base === 10 && Math.log10
          || base === 2 && Math.log2
          || (base = Math.log(base), x => Math.log(x) / base);
    }

    function reflect(f) {
      return (x, k) => -f(-x, k);
    }

    function loggish(transform) {
      const scale = transform(transformLog, transformExp);
      const domain = scale.domain;
      let base = 10;
      let logs;
      let pows;

      function rescale() {
        logs = logp(base), pows = powp(base);
        if (domain()[0] < 0) {
          logs = reflect(logs), pows = reflect(pows);
          transform(transformLogn, transformExpn);
        } else {
          transform(transformLog, transformExp);
        }
        return scale;
      }

      scale.base = function(_) {
        return arguments.length ? (base = +_, rescale()) : base;
      };

      scale.domain = function(_) {
        return arguments.length ? (domain(_), rescale()) : domain();
      };

      scale.ticks = count => {
        const d = domain();
        let u = d[0];
        let v = d[d.length - 1];
        const r = v < u;

        if (r) ([u, v] = [v, u]);

        let i = logs(u);
        let j = logs(v);
        let k;
        let t;
        const n = count == null ? 10 : +count;
        let z = [];

        if (!(base % 1) && j - i < n) {
          i = Math.floor(i), j = Math.ceil(j);
          if (u > 0) for (; i <= j; ++i) {
            for (k = 1; k < base; ++k) {
              t = i < 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          } else for (; i <= j; ++i) {
            for (k = base - 1; k >= 1; --k) {
              t = i > 0 ? k / pows(-i) : k * pows(i);
              if (t < u) continue;
              if (t > v) break;
              z.push(t);
            }
          }
          if (z.length * 2 < n) z = ticks(u, v, n);
        } else {
          z = ticks(i, j, Math.min(j - i, n)).map(pows);
        }
        return r ? z.reverse() : z;
      };

      scale.tickFormat = (count, specifier) => {
        if (count == null) count = 10;
        if (specifier == null) specifier = base === 10 ? "s" : ",";
        if (typeof specifier !== "function") {
          if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
          specifier = format(specifier);
        }
        if (count === Infinity) return specifier;
        const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
        return d => {
          let i = d / pows(Math.round(logs(d)));
          if (i * base < base - 0.5) i *= base;
          return i <= k ? specifier(d) : "";
        };
      };

      scale.nice = () => {
        return domain(nice(domain(), {
          floor: x => pows(Math.floor(logs(x))),
          ceil: x => pows(Math.ceil(logs(x)))
        }));
      };

      return scale;
    }

    function log() {
      const scale = loggish(transformer$2()).domain([1, 10]);
      scale.copy = () => copy$1(scale, log()).base(scale.base());
      initRange.apply(scale, arguments);
      return scale;
    }

    function transformSymlog(c) {
      return function(x) {
        return Math.sign(x) * Math.log1p(Math.abs(x / c));
      };
    }

    function transformSymexp(c) {
      return function(x) {
        return Math.sign(x) * Math.expm1(Math.abs(x)) * c;
      };
    }

    function symlogish(transform) {
      var c = 1, scale = transform(transformSymlog(c), transformSymexp(c));

      scale.constant = function(_) {
        return arguments.length ? transform(transformSymlog(c = +_), transformSymexp(c)) : c;
      };

      return linearish(scale);
    }

    function symlog() {
      var scale = symlogish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, symlog()).constant(scale.constant());
      };

      return initRange.apply(scale, arguments);
    }

    function transformPow(exponent) {
      return function(x) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };
    }

    function transformSqrt(x) {
      return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
    }

    function transformSquare(x) {
      return x < 0 ? -x * x : x * x;
    }

    function powish(transform) {
      var scale = transform(identity$3, identity$3),
          exponent = 1;

      function rescale() {
        return exponent === 1 ? transform(identity$3, identity$3)
            : exponent === 0.5 ? transform(transformSqrt, transformSquare)
            : transform(transformPow(exponent), transformPow(1 / exponent));
      }

      scale.exponent = function(_) {
        return arguments.length ? (exponent = +_, rescale()) : exponent;
      };

      return linearish(scale);
    }

    function pow() {
      var scale = powish(transformer$2());

      scale.copy = function() {
        return copy$1(scale, pow()).exponent(scale.exponent());
      };

      initRange.apply(scale, arguments);

      return scale;
    }

    function sqrt$1() {
      return pow.apply(null, arguments).exponent(0.5);
    }

    function square$1(x) {
      return Math.sign(x) * x * x;
    }

    function unsquare(x) {
      return Math.sign(x) * Math.sqrt(Math.abs(x));
    }

    function radial() {
      var squared = continuous(),
          range = [0, 1],
          round = false,
          unknown;

      function scale(x) {
        var y = unsquare(squared(x));
        return isNaN(y) ? unknown : round ? Math.round(y) : y;
      }

      scale.invert = function(y) {
        return squared.invert(square$1(y));
      };

      scale.domain = function(_) {
        return arguments.length ? (squared.domain(_), scale) : squared.domain();
      };

      scale.range = function(_) {
        return arguments.length ? (squared.range((range = Array.from(_, number$1)).map(square$1)), scale) : range.slice();
      };

      scale.rangeRound = function(_) {
        return scale.range(_).round(true);
      };

      scale.round = function(_) {
        return arguments.length ? (round = !!_, scale) : round;
      };

      scale.clamp = function(_) {
        return arguments.length ? (squared.clamp(_), scale) : squared.clamp();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return radial(squared.domain(), range)
            .round(round)
            .clamp(squared.clamp())
            .unknown(unknown);
      };

      initRange.apply(scale, arguments);

      return linearish(scale);
    }

    function quantile() {
      var domain = [],
          range = [],
          thresholds = [],
          unknown;

      function rescale() {
        var i = 0, n = Math.max(1, range.length);
        thresholds = new Array(n - 1);
        while (++i < n) thresholds[i - 1] = quantileSorted(domain, i / n);
        return scale;
      }

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : range[bisect(thresholds, x)];
      }

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN] : [
          i > 0 ? thresholds[i - 1] : domain[0],
          i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
        ];
      };

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return rescale();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), rescale()) : range.slice();
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.quantiles = function() {
        return thresholds.slice();
      };

      scale.copy = function() {
        return quantile()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    function quantize() {
      var x0 = 0,
          x1 = 1,
          n = 1,
          domain = [0.5],
          range = [0, 1],
          unknown;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      function rescale() {
        var i = -1;
        domain = new Array(n);
        while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
        return scale;
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
      };

      scale.range = function(_) {
        return arguments.length ? (n = (range = Array.from(_)).length - 1, rescale()) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return i < 0 ? [NaN, NaN]
            : i < 1 ? [x0, domain[0]]
            : i >= n ? [domain[n - 1], x1]
            : [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : scale;
      };

      scale.thresholds = function() {
        return domain.slice();
      };

      scale.copy = function() {
        return quantize()
            .domain([x0, x1])
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(linearish(scale), arguments);
    }

    function threshold() {
      var domain = [0.5],
          range = [0, 1],
          unknown,
          n = 1;

      function scale(x) {
        return x != null && x <= x ? range[bisect(domain, x, 0, n)] : unknown;
      }

      scale.domain = function(_) {
        return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
      };

      scale.range = function(_) {
        return arguments.length ? (range = Array.from(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
      };

      scale.invertExtent = function(y) {
        var i = range.indexOf(y);
        return [domain[i - 1], domain[i]];
      };

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      scale.copy = function() {
        return threshold()
            .domain(domain)
            .range(range)
            .unknown(unknown);
      };

      return initRange.apply(scale, arguments);
    }

    var t0 = new Date,
        t1 = new Date;

    function newInterval(floori, offseti, count, field) {

      function interval(date) {
        return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
      }

      interval.floor = function(date) {
        return floori(date = new Date(+date)), date;
      };

      interval.ceil = function(date) {
        return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
      };

      interval.round = function(date) {
        var d0 = interval(date),
            d1 = interval.ceil(date);
        return date - d0 < d1 - date ? d0 : d1;
      };

      interval.offset = function(date, step) {
        return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
      };

      interval.range = function(start, stop, step) {
        var range = [], previous;
        start = interval.ceil(start);
        step = step == null ? 1 : Math.floor(step);
        if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
        do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
        while (previous < start && start < stop);
        return range;
      };

      interval.filter = function(test) {
        return newInterval(function(date) {
          if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
        }, function(date, step) {
          if (date >= date) {
            if (step < 0) while (++step <= 0) {
              while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
            } else while (--step >= 0) {
              while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
            }
          }
        });
      };

      if (count) {
        interval.count = function(start, end) {
          t0.setTime(+start), t1.setTime(+end);
          floori(t0), floori(t1);
          return Math.floor(count(t0, t1));
        };

        interval.every = function(step) {
          step = Math.floor(step);
          return !isFinite(step) || !(step > 0) ? null
              : !(step > 1) ? interval
              : interval.filter(field
                  ? function(d) { return field(d) % step === 0; }
                  : function(d) { return interval.count(0, d) % step === 0; });
        };
      }

      return interval;
    }

    var millisecond = newInterval(function() {
      // noop
    }, function(date, step) {
      date.setTime(+date + step);
    }, function(start, end) {
      return end - start;
    });

    // An optimized implementation for this simple case.
    millisecond.every = function(k) {
      k = Math.floor(k);
      if (!isFinite(k) || !(k > 0)) return null;
      if (!(k > 1)) return millisecond;
      return newInterval(function(date) {
        date.setTime(Math.floor(date / k) * k);
      }, function(date, step) {
        date.setTime(+date + step * k);
      }, function(start, end) {
        return (end - start) / k;
      });
    };

    var millisecond$1 = millisecond;
    var milliseconds = millisecond.range;

    const durationSecond = 1000;
    const durationMinute = durationSecond * 60;
    const durationHour = durationMinute * 60;
    const durationDay = durationHour * 24;
    const durationWeek = durationDay * 7;
    const durationMonth = durationDay * 30;
    const durationYear = durationDay * 365;

    var second = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds());
    }, function(date, step) {
      date.setTime(+date + step * durationSecond);
    }, function(start, end) {
      return (end - start) / durationSecond;
    }, function(date) {
      return date.getUTCSeconds();
    });

    var utcSecond = second;
    var seconds = second.range;

    var minute = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getMinutes();
    });

    var timeMinute = minute;
    var minutes = minute.range;

    var hour = newInterval(function(date) {
      date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getHours();
    });

    var timeHour = hour;
    var hours = hour.range;

    var day = newInterval(
      date => date.setHours(0, 0, 0, 0),
      (date, step) => date.setDate(date.getDate() + step),
      (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
      date => date.getDate() - 1
    );

    var timeDay = day;
    var days = day.range;

    function weekday(i) {
      return newInterval(function(date) {
        date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setDate(date.getDate() + step * 7);
      }, function(start, end) {
        return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
      });
    }

    var sunday = weekday(0);
    var monday = weekday(1);
    var tuesday = weekday(2);
    var wednesday = weekday(3);
    var thursday = weekday(4);
    var friday = weekday(5);
    var saturday = weekday(6);

    var sundays = sunday.range;
    var mondays = monday.range;
    var tuesdays = tuesday.range;
    var wednesdays = wednesday.range;
    var thursdays = thursday.range;
    var fridays = friday.range;
    var saturdays = saturday.range;

    var month = newInterval(function(date) {
      date.setDate(1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setMonth(date.getMonth() + step);
    }, function(start, end) {
      return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
    }, function(date) {
      return date.getMonth();
    });

    var timeMonth = month;
    var months = month.range;

    var year = newInterval(function(date) {
      date.setMonth(0, 1);
      date.setHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setFullYear(date.getFullYear() + step);
    }, function(start, end) {
      return end.getFullYear() - start.getFullYear();
    }, function(date) {
      return date.getFullYear();
    });

    // An optimized implementation for this simple case.
    year.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setFullYear(Math.floor(date.getFullYear() / k) * k);
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setFullYear(date.getFullYear() + step * k);
      });
    };

    var timeYear = year;
    var years = year.range;

    var utcMinute = newInterval(function(date) {
      date.setUTCSeconds(0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationMinute);
    }, function(start, end) {
      return (end - start) / durationMinute;
    }, function(date) {
      return date.getUTCMinutes();
    });

    var utcMinute$1 = utcMinute;
    var utcMinutes = utcMinute.range;

    var utcHour = newInterval(function(date) {
      date.setUTCMinutes(0, 0, 0);
    }, function(date, step) {
      date.setTime(+date + step * durationHour);
    }, function(start, end) {
      return (end - start) / durationHour;
    }, function(date) {
      return date.getUTCHours();
    });

    var utcHour$1 = utcHour;
    var utcHours = utcHour.range;

    var utcDay = newInterval(function(date) {
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCDate(date.getUTCDate() + step);
    }, function(start, end) {
      return (end - start) / durationDay;
    }, function(date) {
      return date.getUTCDate() - 1;
    });

    var utcDay$1 = utcDay;
    var utcDays = utcDay.range;

    function utcWeekday(i) {
      return newInterval(function(date) {
        date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCDate(date.getUTCDate() + step * 7);
      }, function(start, end) {
        return (end - start) / durationWeek;
      });
    }

    var utcSunday = utcWeekday(0);
    var utcMonday = utcWeekday(1);
    var utcTuesday = utcWeekday(2);
    var utcWednesday = utcWeekday(3);
    var utcThursday = utcWeekday(4);
    var utcFriday = utcWeekday(5);
    var utcSaturday = utcWeekday(6);

    var utcSundays = utcSunday.range;
    var utcMondays = utcMonday.range;
    var utcTuesdays = utcTuesday.range;
    var utcWednesdays = utcWednesday.range;
    var utcThursdays = utcThursday.range;
    var utcFridays = utcFriday.range;
    var utcSaturdays = utcSaturday.range;

    var utcMonth = newInterval(function(date) {
      date.setUTCDate(1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCMonth(date.getUTCMonth() + step);
    }, function(start, end) {
      return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
    }, function(date) {
      return date.getUTCMonth();
    });

    var utcMonth$1 = utcMonth;
    var utcMonths = utcMonth.range;

    var utcYear = newInterval(function(date) {
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
    }, function(date, step) {
      date.setUTCFullYear(date.getUTCFullYear() + step);
    }, function(start, end) {
      return end.getUTCFullYear() - start.getUTCFullYear();
    }, function(date) {
      return date.getUTCFullYear();
    });

    // An optimized implementation for this simple case.
    utcYear.every = function(k) {
      return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
        date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
        date.setUTCMonth(0, 1);
        date.setUTCHours(0, 0, 0, 0);
      }, function(date, step) {
        date.setUTCFullYear(date.getUTCFullYear() + step * k);
      });
    };

    var utcYear$1 = utcYear;
    var utcYears = utcYear.range;

    function ticker(year, month, week, day, hour, minute) {

      const tickIntervals = [
        [utcSecond,  1,      durationSecond],
        [utcSecond,  5,  5 * durationSecond],
        [utcSecond, 15, 15 * durationSecond],
        [utcSecond, 30, 30 * durationSecond],
        [minute,  1,      durationMinute],
        [minute,  5,  5 * durationMinute],
        [minute, 15, 15 * durationMinute],
        [minute, 30, 30 * durationMinute],
        [  hour,  1,      durationHour  ],
        [  hour,  3,  3 * durationHour  ],
        [  hour,  6,  6 * durationHour  ],
        [  hour, 12, 12 * durationHour  ],
        [   day,  1,      durationDay   ],
        [   day,  2,  2 * durationDay   ],
        [  week,  1,      durationWeek  ],
        [ month,  1,      durationMonth ],
        [ month,  3,  3 * durationMonth ],
        [  year,  1,      durationYear  ]
      ];

      function ticks(start, stop, count) {
        const reverse = stop < start;
        if (reverse) [start, stop] = [stop, start];
        const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
        const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
        return reverse ? ticks.reverse() : ticks;
      }

      function tickInterval(start, stop, count) {
        const target = Math.abs(stop - start) / count;
        const i = bisector(([,, step]) => step).right(tickIntervals, target);
        if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
        if (i === 0) return millisecond$1.every(Math.max(tickStep(start, stop, count), 1));
        const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        return t.every(step);
      }

      return [ticks, tickInterval];
    }

    const [utcTicks, utcTickInterval] = ticker(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1);
    const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute);

    function localDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
        date.setFullYear(d.y);
        return date;
      }
      return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
    }

    function utcDate(d) {
      if (0 <= d.y && d.y < 100) {
        var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
        date.setUTCFullYear(d.y);
        return date;
      }
      return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
    }

    function newDate(y, m, d) {
      return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
    }

    function formatLocale(locale) {
      var locale_dateTime = locale.dateTime,
          locale_date = locale.date,
          locale_time = locale.time,
          locale_periods = locale.periods,
          locale_weekdays = locale.days,
          locale_shortWeekdays = locale.shortDays,
          locale_months = locale.months,
          locale_shortMonths = locale.shortMonths;

      var periodRe = formatRe(locale_periods),
          periodLookup = formatLookup(locale_periods),
          weekdayRe = formatRe(locale_weekdays),
          weekdayLookup = formatLookup(locale_weekdays),
          shortWeekdayRe = formatRe(locale_shortWeekdays),
          shortWeekdayLookup = formatLookup(locale_shortWeekdays),
          monthRe = formatRe(locale_months),
          monthLookup = formatLookup(locale_months),
          shortMonthRe = formatRe(locale_shortMonths),
          shortMonthLookup = formatLookup(locale_shortMonths);

      var formats = {
        "a": formatShortWeekday,
        "A": formatWeekday,
        "b": formatShortMonth,
        "B": formatMonth,
        "c": null,
        "d": formatDayOfMonth,
        "e": formatDayOfMonth,
        "f": formatMicroseconds,
        "g": formatYearISO,
        "G": formatFullYearISO,
        "H": formatHour24,
        "I": formatHour12,
        "j": formatDayOfYear,
        "L": formatMilliseconds,
        "m": formatMonthNumber,
        "M": formatMinutes,
        "p": formatPeriod,
        "q": formatQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatSeconds,
        "u": formatWeekdayNumberMonday,
        "U": formatWeekNumberSunday,
        "V": formatWeekNumberISO,
        "w": formatWeekdayNumberSunday,
        "W": formatWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatYear,
        "Y": formatFullYear,
        "Z": formatZone,
        "%": formatLiteralPercent
      };

      var utcFormats = {
        "a": formatUTCShortWeekday,
        "A": formatUTCWeekday,
        "b": formatUTCShortMonth,
        "B": formatUTCMonth,
        "c": null,
        "d": formatUTCDayOfMonth,
        "e": formatUTCDayOfMonth,
        "f": formatUTCMicroseconds,
        "g": formatUTCYearISO,
        "G": formatUTCFullYearISO,
        "H": formatUTCHour24,
        "I": formatUTCHour12,
        "j": formatUTCDayOfYear,
        "L": formatUTCMilliseconds,
        "m": formatUTCMonthNumber,
        "M": formatUTCMinutes,
        "p": formatUTCPeriod,
        "q": formatUTCQuarter,
        "Q": formatUnixTimestamp,
        "s": formatUnixTimestampSeconds,
        "S": formatUTCSeconds,
        "u": formatUTCWeekdayNumberMonday,
        "U": formatUTCWeekNumberSunday,
        "V": formatUTCWeekNumberISO,
        "w": formatUTCWeekdayNumberSunday,
        "W": formatUTCWeekNumberMonday,
        "x": null,
        "X": null,
        "y": formatUTCYear,
        "Y": formatUTCFullYear,
        "Z": formatUTCZone,
        "%": formatLiteralPercent
      };

      var parses = {
        "a": parseShortWeekday,
        "A": parseWeekday,
        "b": parseShortMonth,
        "B": parseMonth,
        "c": parseLocaleDateTime,
        "d": parseDayOfMonth,
        "e": parseDayOfMonth,
        "f": parseMicroseconds,
        "g": parseYear,
        "G": parseFullYear,
        "H": parseHour24,
        "I": parseHour24,
        "j": parseDayOfYear,
        "L": parseMilliseconds,
        "m": parseMonthNumber,
        "M": parseMinutes,
        "p": parsePeriod,
        "q": parseQuarter,
        "Q": parseUnixTimestamp,
        "s": parseUnixTimestampSeconds,
        "S": parseSeconds,
        "u": parseWeekdayNumberMonday,
        "U": parseWeekNumberSunday,
        "V": parseWeekNumberISO,
        "w": parseWeekdayNumberSunday,
        "W": parseWeekNumberMonday,
        "x": parseLocaleDate,
        "X": parseLocaleTime,
        "y": parseYear,
        "Y": parseFullYear,
        "Z": parseZone,
        "%": parseLiteralPercent
      };

      // These recursive directive definitions must be deferred.
      formats.x = newFormat(locale_date, formats);
      formats.X = newFormat(locale_time, formats);
      formats.c = newFormat(locale_dateTime, formats);
      utcFormats.x = newFormat(locale_date, utcFormats);
      utcFormats.X = newFormat(locale_time, utcFormats);
      utcFormats.c = newFormat(locale_dateTime, utcFormats);

      function newFormat(specifier, formats) {
        return function(date) {
          var string = [],
              i = -1,
              j = 0,
              n = specifier.length,
              c,
              pad,
              format;

          if (!(date instanceof Date)) date = new Date(+date);

          while (++i < n) {
            if (specifier.charCodeAt(i) === 37) {
              string.push(specifier.slice(j, i));
              if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
              else pad = c === "e" ? " " : "0";
              if (format = formats[c]) c = format(date, pad);
              string.push(c);
              j = i + 1;
            }
          }

          string.push(specifier.slice(j, i));
          return string.join("");
        };
      }

      function newParse(specifier, Z) {
        return function(string) {
          var d = newDate(1900, undefined, 1),
              i = parseSpecifier(d, specifier, string += "", 0),
              week, day;
          if (i != string.length) return null;

          // If a UNIX timestamp is specified, return it.
          if ("Q" in d) return new Date(d.Q);
          if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

          // If this is utcParse, never use the local timezone.
          if (Z && !("Z" in d)) d.Z = 0;

          // The am-pm flag is 0 for AM, and 1 for PM.
          if ("p" in d) d.H = d.H % 12 + d.p * 12;

          // If the month was not specified, inherit from the quarter.
          if (d.m === undefined) d.m = "q" in d ? d.q : 0;

          // Convert day-of-week and week-of-year to day-of-year.
          if ("V" in d) {
            if (d.V < 1 || d.V > 53) return null;
            if (!("w" in d)) d.w = 1;
            if ("Z" in d) {
              week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
              week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
              week = utcDay$1.offset(week, (d.V - 1) * 7);
              d.y = week.getUTCFullYear();
              d.m = week.getUTCMonth();
              d.d = week.getUTCDate() + (d.w + 6) % 7;
            } else {
              week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
              week = day > 4 || day === 0 ? monday.ceil(week) : monday(week);
              week = timeDay.offset(week, (d.V - 1) * 7);
              d.y = week.getFullYear();
              d.m = week.getMonth();
              d.d = week.getDate() + (d.w + 6) % 7;
            }
          } else if ("W" in d || "U" in d) {
            if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
            day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
            d.m = 0;
            d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
          }

          // If a time zone is specified, all fields are interpreted as UTC and then
          // offset according to the specified time zone.
          if ("Z" in d) {
            d.H += d.Z / 100 | 0;
            d.M += d.Z % 100;
            return utcDate(d);
          }

          // Otherwise, all fields are in local time.
          return localDate(d);
        };
      }

      function parseSpecifier(d, specifier, string, j) {
        var i = 0,
            n = specifier.length,
            m = string.length,
            c,
            parse;

        while (i < n) {
          if (j >= m) return -1;
          c = specifier.charCodeAt(i++);
          if (c === 37) {
            c = specifier.charAt(i++);
            parse = parses[c in pads ? specifier.charAt(i++) : c];
            if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
          } else if (c != string.charCodeAt(j++)) {
            return -1;
          }
        }

        return j;
      }

      function parsePeriod(d, string, i) {
        var n = periodRe.exec(string.slice(i));
        return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortWeekday(d, string, i) {
        var n = shortWeekdayRe.exec(string.slice(i));
        return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseWeekday(d, string, i) {
        var n = weekdayRe.exec(string.slice(i));
        return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseShortMonth(d, string, i) {
        var n = shortMonthRe.exec(string.slice(i));
        return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseMonth(d, string, i) {
        var n = monthRe.exec(string.slice(i));
        return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
      }

      function parseLocaleDateTime(d, string, i) {
        return parseSpecifier(d, locale_dateTime, string, i);
      }

      function parseLocaleDate(d, string, i) {
        return parseSpecifier(d, locale_date, string, i);
      }

      function parseLocaleTime(d, string, i) {
        return parseSpecifier(d, locale_time, string, i);
      }

      function formatShortWeekday(d) {
        return locale_shortWeekdays[d.getDay()];
      }

      function formatWeekday(d) {
        return locale_weekdays[d.getDay()];
      }

      function formatShortMonth(d) {
        return locale_shortMonths[d.getMonth()];
      }

      function formatMonth(d) {
        return locale_months[d.getMonth()];
      }

      function formatPeriod(d) {
        return locale_periods[+(d.getHours() >= 12)];
      }

      function formatQuarter(d) {
        return 1 + ~~(d.getMonth() / 3);
      }

      function formatUTCShortWeekday(d) {
        return locale_shortWeekdays[d.getUTCDay()];
      }

      function formatUTCWeekday(d) {
        return locale_weekdays[d.getUTCDay()];
      }

      function formatUTCShortMonth(d) {
        return locale_shortMonths[d.getUTCMonth()];
      }

      function formatUTCMonth(d) {
        return locale_months[d.getUTCMonth()];
      }

      function formatUTCPeriod(d) {
        return locale_periods[+(d.getUTCHours() >= 12)];
      }

      function formatUTCQuarter(d) {
        return 1 + ~~(d.getUTCMonth() / 3);
      }

      return {
        format: function(specifier) {
          var f = newFormat(specifier += "", formats);
          f.toString = function() { return specifier; };
          return f;
        },
        parse: function(specifier) {
          var p = newParse(specifier += "", false);
          p.toString = function() { return specifier; };
          return p;
        },
        utcFormat: function(specifier) {
          var f = newFormat(specifier += "", utcFormats);
          f.toString = function() { return specifier; };
          return f;
        },
        utcParse: function(specifier) {
          var p = newParse(specifier += "", true);
          p.toString = function() { return specifier; };
          return p;
        }
      };
    }

    var pads = {"-": "", "_": " ", "0": "0"},
        numberRe = /^\s*\d+/, // note: ignores next directive
        percentRe = /^%/,
        requoteRe = /[\\^$*+?|[\]().{}]/g;

    function pad(value, fill, width) {
      var sign = value < 0 ? "-" : "",
          string = (sign ? -value : value) + "",
          length = string.length;
      return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
    }

    function requote(s) {
      return s.replace(requoteRe, "\\$&");
    }

    function formatRe(names) {
      return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
    }

    function formatLookup(names) {
      return new Map(names.map((name, i) => [name.toLowerCase(), i]));
    }

    function parseWeekdayNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.w = +n[0], i + n[0].length) : -1;
    }

    function parseWeekdayNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.u = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberSunday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.U = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberISO(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.V = +n[0], i + n[0].length) : -1;
    }

    function parseWeekNumberMonday(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.W = +n[0], i + n[0].length) : -1;
    }

    function parseFullYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }

    function parseYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
    }

    function parseZone(d, string, i) {
      var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
      return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
    }

    function parseQuarter(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 1));
      return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
    }

    function parseMonthNumber(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
    }

    function parseDayOfMonth(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }

    function parseDayOfYear(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
    }

    function parseHour24(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }

    function parseMinutes(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }

    function parseSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }

    function parseMilliseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }

    function parseMicroseconds(d, string, i) {
      var n = numberRe.exec(string.slice(i, i + 6));
      return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
    }

    function parseLiteralPercent(d, string, i) {
      var n = percentRe.exec(string.slice(i, i + 1));
      return n ? i + n[0].length : -1;
    }

    function parseUnixTimestamp(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.Q = +n[0], i + n[0].length) : -1;
    }

    function parseUnixTimestampSeconds(d, string, i) {
      var n = numberRe.exec(string.slice(i));
      return n ? (d.s = +n[0], i + n[0].length) : -1;
    }

    function formatDayOfMonth(d, p) {
      return pad(d.getDate(), p, 2);
    }

    function formatHour24(d, p) {
      return pad(d.getHours(), p, 2);
    }

    function formatHour12(d, p) {
      return pad(d.getHours() % 12 || 12, p, 2);
    }

    function formatDayOfYear(d, p) {
      return pad(1 + timeDay.count(timeYear(d), d), p, 3);
    }

    function formatMilliseconds(d, p) {
      return pad(d.getMilliseconds(), p, 3);
    }

    function formatMicroseconds(d, p) {
      return formatMilliseconds(d, p) + "000";
    }

    function formatMonthNumber(d, p) {
      return pad(d.getMonth() + 1, p, 2);
    }

    function formatMinutes(d, p) {
      return pad(d.getMinutes(), p, 2);
    }

    function formatSeconds(d, p) {
      return pad(d.getSeconds(), p, 2);
    }

    function formatWeekdayNumberMonday(d) {
      var day = d.getDay();
      return day === 0 ? 7 : day;
    }

    function formatWeekNumberSunday(d, p) {
      return pad(sunday.count(timeYear(d) - 1, d), p, 2);
    }

    function dISO(d) {
      var day = d.getDay();
      return (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
    }

    function formatWeekNumberISO(d, p) {
      d = dISO(d);
      return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
    }

    function formatWeekdayNumberSunday(d) {
      return d.getDay();
    }

    function formatWeekNumberMonday(d, p) {
      return pad(monday.count(timeYear(d) - 1, d), p, 2);
    }

    function formatYear(d, p) {
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatYearISO(d, p) {
      d = dISO(d);
      return pad(d.getFullYear() % 100, p, 2);
    }

    function formatFullYear(d, p) {
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatFullYearISO(d, p) {
      var day = d.getDay();
      d = (day >= 4 || day === 0) ? thursday(d) : thursday.ceil(d);
      return pad(d.getFullYear() % 10000, p, 4);
    }

    function formatZone(d) {
      var z = d.getTimezoneOffset();
      return (z > 0 ? "-" : (z *= -1, "+"))
          + pad(z / 60 | 0, "0", 2)
          + pad(z % 60, "0", 2);
    }

    function formatUTCDayOfMonth(d, p) {
      return pad(d.getUTCDate(), p, 2);
    }

    function formatUTCHour24(d, p) {
      return pad(d.getUTCHours(), p, 2);
    }

    function formatUTCHour12(d, p) {
      return pad(d.getUTCHours() % 12 || 12, p, 2);
    }

    function formatUTCDayOfYear(d, p) {
      return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
    }

    function formatUTCMilliseconds(d, p) {
      return pad(d.getUTCMilliseconds(), p, 3);
    }

    function formatUTCMicroseconds(d, p) {
      return formatUTCMilliseconds(d, p) + "000";
    }

    function formatUTCMonthNumber(d, p) {
      return pad(d.getUTCMonth() + 1, p, 2);
    }

    function formatUTCMinutes(d, p) {
      return pad(d.getUTCMinutes(), p, 2);
    }

    function formatUTCSeconds(d, p) {
      return pad(d.getUTCSeconds(), p, 2);
    }

    function formatUTCWeekdayNumberMonday(d) {
      var dow = d.getUTCDay();
      return dow === 0 ? 7 : dow;
    }

    function formatUTCWeekNumberSunday(d, p) {
      return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
    }

    function UTCdISO(d) {
      var day = d.getUTCDay();
      return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
    }

    function formatUTCWeekNumberISO(d, p) {
      d = UTCdISO(d);
      return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
    }

    function formatUTCWeekdayNumberSunday(d) {
      return d.getUTCDay();
    }

    function formatUTCWeekNumberMonday(d, p) {
      return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
    }

    function formatUTCYear(d, p) {
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCYearISO(d, p) {
      d = UTCdISO(d);
      return pad(d.getUTCFullYear() % 100, p, 2);
    }

    function formatUTCFullYear(d, p) {
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCFullYearISO(d, p) {
      var day = d.getUTCDay();
      d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
      return pad(d.getUTCFullYear() % 10000, p, 4);
    }

    function formatUTCZone() {
      return "+0000";
    }

    function formatLiteralPercent() {
      return "%";
    }

    function formatUnixTimestamp(d) {
      return +d;
    }

    function formatUnixTimestampSeconds(d) {
      return Math.floor(+d / 1000);
    }

    var locale;
    var timeFormat;
    var timeParse;
    var utcFormat;
    var utcParse;

    defaultLocale({
      dateTime: "%x, %X",
      date: "%-m/%-d/%Y",
      time: "%-I:%M:%S %p",
      periods: ["AM", "PM"],
      days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
      shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    });

    function defaultLocale(definition) {
      locale = formatLocale(definition);
      timeFormat = locale.format;
      timeParse = locale.parse;
      utcFormat = locale.utcFormat;
      utcParse = locale.utcParse;
      return locale;
    }

    var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

    function formatIsoNative(date) {
      return date.toISOString();
    }

    var formatIso = Date.prototype.toISOString
        ? formatIsoNative
        : utcFormat(isoSpecifier);

    var formatIso$1 = formatIso;

    function parseIsoNative(string) {
      var date = new Date(string);
      return isNaN(date) ? null : date;
    }

    var parseIso = +new Date("2000-01-01T00:00:00.000Z")
        ? parseIsoNative
        : utcParse(isoSpecifier);

    var parseIso$1 = parseIso;

    function date(t) {
      return new Date(t);
    }

    function number(t) {
      return t instanceof Date ? +t : +new Date(+t);
    }

    function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
      var scale = continuous(),
          invert = scale.invert,
          domain = scale.domain;

      var formatMillisecond = format(".%L"),
          formatSecond = format(":%S"),
          formatMinute = format("%I:%M"),
          formatHour = format("%I %p"),
          formatDay = format("%a %d"),
          formatWeek = format("%b %d"),
          formatMonth = format("%B"),
          formatYear = format("%Y");

      function tickFormat(date) {
        return (second(date) < date ? formatMillisecond
            : minute(date) < date ? formatSecond
            : hour(date) < date ? formatMinute
            : day(date) < date ? formatHour
            : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
            : year(date) < date ? formatMonth
            : formatYear)(date);
      }

      scale.invert = function(y) {
        return new Date(invert(y));
      };

      scale.domain = function(_) {
        return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
      };

      scale.ticks = function(interval) {
        var d = domain();
        return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
      };

      scale.tickFormat = function(count, specifier) {
        return specifier == null ? tickFormat : format(specifier);
      };

      scale.nice = function(interval) {
        var d = domain();
        if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
        return interval ? domain(nice(d, interval)) : scale;
      };

      scale.copy = function() {
        return copy$1(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
      };

      return scale;
    }

    function time() {
      return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
    }

    function utcTime() {
      return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1, utcSecond, utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]), arguments);
    }

    function transformer$1() {
      var x0 = 0,
          x1 = 1,
          t0,
          t1,
          k10,
          transform,
          interpolator = identity$3,
          clamp = false,
          unknown;

      function scale(x) {
        return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1;
          return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);
        return scale;
      };
    }

    function copy(source, target) {
      return target
          .domain(source.domain())
          .interpolator(source.interpolator())
          .clamp(source.clamp())
          .unknown(source.unknown());
    }

    function sequential() {
      var scale = linearish(transformer$1()(identity$3));

      scale.copy = function() {
        return copy(scale, sequential());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialLog() {
      var scale = loggish(transformer$1()).domain([1, 10]);

      scale.copy = function() {
        return copy(scale, sequentialLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSymlog() {
      var scale = symlogish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialPow() {
      var scale = powish(transformer$1());

      scale.copy = function() {
        return copy(scale, sequentialPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function sequentialSqrt() {
      return sequentialPow.apply(null, arguments).exponent(0.5);
    }

    function sequentialQuantile() {
      var domain = [],
          interpolator = identity$3;

      function scale(x) {
        if (x != null && !isNaN(x = +x)) return interpolator((bisect(domain, x, 1) - 1) / (domain.length - 1));
      }

      scale.domain = function(_) {
        if (!arguments.length) return domain.slice();
        domain = [];
        for (let d of _) if (d != null && !isNaN(d = +d)) domain.push(d);
        domain.sort(ascending$3);
        return scale;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      scale.range = function() {
        return domain.map((d, i) => interpolator(i / (domain.length - 1)));
      };

      scale.quantiles = function(n) {
        return Array.from({length: n + 1}, (_, i) => quantile$1(domain, i / n));
      };

      scale.copy = function() {
        return sequentialQuantile(interpolator).domain(domain);
      };

      return initInterpolator.apply(scale, arguments);
    }

    function transformer() {
      var x0 = 0,
          x1 = 0.5,
          x2 = 1,
          s = 1,
          t0,
          t1,
          t2,
          k10,
          k21,
          interpolator = identity$3,
          transform,
          clamp = false,
          unknown;

      function scale(x) {
        return isNaN(x = +x) ? unknown : (x = 0.5 + ((x = +transform(x)) - t1) * (s * x < s * t1 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x)) : x));
      }

      scale.domain = function(_) {
        return arguments.length ? ([x0, x1, x2] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1, scale) : [x0, x1, x2];
      };

      scale.clamp = function(_) {
        return arguments.length ? (clamp = !!_, scale) : clamp;
      };

      scale.interpolator = function(_) {
        return arguments.length ? (interpolator = _, scale) : interpolator;
      };

      function range(interpolate) {
        return function(_) {
          var r0, r1, r2;
          return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate, [r0, r1, r2]), scale) : [interpolator(0), interpolator(0.5), interpolator(1)];
        };
      }

      scale.range = range(interpolate$2);

      scale.rangeRound = range(interpolateRound);

      scale.unknown = function(_) {
        return arguments.length ? (unknown = _, scale) : unknown;
      };

      return function(t) {
        transform = t, t0 = t(x0), t1 = t(x1), t2 = t(x2), k10 = t0 === t1 ? 0 : 0.5 / (t1 - t0), k21 = t1 === t2 ? 0 : 0.5 / (t2 - t1), s = t1 < t0 ? -1 : 1;
        return scale;
      };
    }

    function diverging$1() {
      var scale = linearish(transformer()(identity$3));

      scale.copy = function() {
        return copy(scale, diverging$1());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingLog() {
      var scale = loggish(transformer()).domain([0.1, 1, 10]);

      scale.copy = function() {
        return copy(scale, divergingLog()).base(scale.base());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSymlog() {
      var scale = symlogish(transformer());

      scale.copy = function() {
        return copy(scale, divergingSymlog()).constant(scale.constant());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingPow() {
      var scale = powish(transformer());

      scale.copy = function() {
        return copy(scale, divergingPow()).exponent(scale.exponent());
      };

      return initInterpolator.apply(scale, arguments);
    }

    function divergingSqrt() {
      return divergingPow.apply(null, arguments).exponent(0.5);
    }

    function colors(specifier) {
      var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
      while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
      return colors;
    }

    var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

    var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

    var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

    var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

    var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

    var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

    var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

    var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

    var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

    var Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

    var ramp$1 = scheme => rgbBasis(scheme[scheme.length - 1]);

    var scheme$q = new Array(3).concat(
      "d8b365f5f5f55ab4ac",
      "a6611adfc27d80cdc1018571",
      "a6611adfc27df5f5f580cdc1018571",
      "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
      "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
      "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
      "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
      "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
      "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
    ).map(colors);

    var BrBG = ramp$1(scheme$q);

    var scheme$p = new Array(3).concat(
      "af8dc3f7f7f77fbf7b",
      "7b3294c2a5cfa6dba0008837",
      "7b3294c2a5cff7f7f7a6dba0008837",
      "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
      "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
      "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
      "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
      "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
      "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
    ).map(colors);

    var PRGn = ramp$1(scheme$p);

    var scheme$o = new Array(3).concat(
      "e9a3c9f7f7f7a1d76a",
      "d01c8bf1b6dab8e1864dac26",
      "d01c8bf1b6daf7f7f7b8e1864dac26",
      "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
      "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
      "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
      "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
      "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
      "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
    ).map(colors);

    var PiYG = ramp$1(scheme$o);

    var scheme$n = new Array(3).concat(
      "998ec3f7f7f7f1a340",
      "5e3c99b2abd2fdb863e66101",
      "5e3c99b2abd2f7f7f7fdb863e66101",
      "542788998ec3d8daebfee0b6f1a340b35806",
      "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
      "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
      "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
      "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
      "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
    ).map(colors);

    var PuOr = ramp$1(scheme$n);

    var scheme$m = new Array(3).concat(
      "ef8a62f7f7f767a9cf",
      "ca0020f4a58292c5de0571b0",
      "ca0020f4a582f7f7f792c5de0571b0",
      "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
      "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
      "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
      "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
      "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
      "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
    ).map(colors);

    var RdBu = ramp$1(scheme$m);

    var scheme$l = new Array(3).concat(
      "ef8a62ffffff999999",
      "ca0020f4a582bababa404040",
      "ca0020f4a582ffffffbababa404040",
      "b2182bef8a62fddbc7e0e0e09999994d4d4d",
      "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
      "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
      "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
      "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
      "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
    ).map(colors);

    var RdGy = ramp$1(scheme$l);

    var scheme$k = new Array(3).concat(
      "fc8d59ffffbf91bfdb",
      "d7191cfdae61abd9e92c7bb6",
      "d7191cfdae61ffffbfabd9e92c7bb6",
      "d73027fc8d59fee090e0f3f891bfdb4575b4",
      "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
      "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
      "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
      "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
      "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
    ).map(colors);

    var RdYlBu = ramp$1(scheme$k);

    var scheme$j = new Array(3).concat(
      "fc8d59ffffbf91cf60",
      "d7191cfdae61a6d96a1a9641",
      "d7191cfdae61ffffbfa6d96a1a9641",
      "d73027fc8d59fee08bd9ef8b91cf601a9850",
      "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
      "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
      "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
      "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
      "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
    ).map(colors);

    var RdYlGn = ramp$1(scheme$j);

    var scheme$i = new Array(3).concat(
      "fc8d59ffffbf99d594",
      "d7191cfdae61abdda42b83ba",
      "d7191cfdae61ffffbfabdda42b83ba",
      "d53e4ffc8d59fee08be6f59899d5943288bd",
      "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
      "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
      "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
      "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
      "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
    ).map(colors);

    var Spectral = ramp$1(scheme$i);

    var scheme$h = new Array(3).concat(
      "e5f5f999d8c92ca25f",
      "edf8fbb2e2e266c2a4238b45",
      "edf8fbb2e2e266c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a42ca25f006d2c",
      "edf8fbccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
      "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
    ).map(colors);

    var BuGn = ramp$1(scheme$h);

    var scheme$g = new Array(3).concat(
      "e0ecf49ebcda8856a7",
      "edf8fbb3cde38c96c688419d",
      "edf8fbb3cde38c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
      "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
      "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
    ).map(colors);

    var BuPu = ramp$1(scheme$g);

    var scheme$f = new Array(3).concat(
      "e0f3dba8ddb543a2ca",
      "f0f9e8bae4bc7bccc42b8cbe",
      "f0f9e8bae4bc7bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
      "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
      "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
    ).map(colors);

    var GnBu = ramp$1(scheme$f);

    var scheme$e = new Array(3).concat(
      "fee8c8fdbb84e34a33",
      "fef0d9fdcc8afc8d59d7301f",
      "fef0d9fdcc8afc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59e34a33b30000",
      "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
      "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
    ).map(colors);

    var OrRd = ramp$1(scheme$e);

    var scheme$d = new Array(3).concat(
      "ece2f0a6bddb1c9099",
      "f6eff7bdc9e167a9cf02818a",
      "f6eff7bdc9e167a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
      "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
      "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
    ).map(colors);

    var PuBuGn = ramp$1(scheme$d);

    var scheme$c = new Array(3).concat(
      "ece7f2a6bddb2b8cbe",
      "f1eef6bdc9e174a9cf0570b0",
      "f1eef6bdc9e174a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
      "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
      "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
    ).map(colors);

    var PuBu = ramp$1(scheme$c);

    var scheme$b = new Array(3).concat(
      "e7e1efc994c7dd1c77",
      "f1eef6d7b5d8df65b0ce1256",
      "f1eef6d7b5d8df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0dd1c77980043",
      "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
      "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
    ).map(colors);

    var PuRd = ramp$1(scheme$b);

    var scheme$a = new Array(3).concat(
      "fde0ddfa9fb5c51b8a",
      "feebe2fbb4b9f768a1ae017e",
      "feebe2fbb4b9f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
      "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
      "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
    ).map(colors);

    var RdPu = ramp$1(scheme$a);

    var scheme$9 = new Array(3).concat(
      "edf8b17fcdbb2c7fb8",
      "ffffcca1dab441b6c4225ea8",
      "ffffcca1dab441b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
      "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
      "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
    ).map(colors);

    var YlGnBu = ramp$1(scheme$9);

    var scheme$8 = new Array(3).concat(
      "f7fcb9addd8e31a354",
      "ffffccc2e69978c679238443",
      "ffffccc2e69978c67931a354006837",
      "ffffccd9f0a3addd8e78c67931a354006837",
      "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
      "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
    ).map(colors);

    var YlGn = ramp$1(scheme$8);

    var scheme$7 = new Array(3).concat(
      "fff7bcfec44fd95f0e",
      "ffffd4fed98efe9929cc4c02",
      "ffffd4fed98efe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929d95f0e993404",
      "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
      "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
    ).map(colors);

    var YlOrBr = ramp$1(scheme$7);

    var scheme$6 = new Array(3).concat(
      "ffeda0feb24cf03b20",
      "ffffb2fecc5cfd8d3ce31a1c",
      "ffffb2fecc5cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cf03b20bd0026",
      "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
      "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
    ).map(colors);

    var YlOrRd = ramp$1(scheme$6);

    var scheme$5 = new Array(3).concat(
      "deebf79ecae13182bd",
      "eff3ffbdd7e76baed62171b5",
      "eff3ffbdd7e76baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed63182bd08519c",
      "eff3ffc6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
      "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
    ).map(colors);

    var Blues = ramp$1(scheme$5);

    var scheme$4 = new Array(3).concat(
      "e5f5e0a1d99b31a354",
      "edf8e9bae4b374c476238b45",
      "edf8e9bae4b374c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47631a354006d2c",
      "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
      "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
    ).map(colors);

    var Greens = ramp$1(scheme$4);

    var scheme$3 = new Array(3).concat(
      "f0f0f0bdbdbd636363",
      "f7f7f7cccccc969696525252",
      "f7f7f7cccccc969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696636363252525",
      "f7f7f7d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
      "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
    ).map(colors);

    var Greys = ramp$1(scheme$3);

    var scheme$2 = new Array(3).concat(
      "efedf5bcbddc756bb1",
      "f2f0f7cbc9e29e9ac86a51a3",
      "f2f0f7cbc9e29e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
      "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
      "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
    ).map(colors);

    var Purples = ramp$1(scheme$2);

    var scheme$1 = new Array(3).concat(
      "fee0d2fc9272de2d26",
      "fee5d9fcae91fb6a4acb181d",
      "fee5d9fcae91fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
      "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
      "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
    ).map(colors);

    var Reds = ramp$1(scheme$1);

    var scheme = new Array(3).concat(
      "fee6cefdae6be6550d",
      "feeddefdbe85fd8d3cd94701",
      "feeddefdbe85fd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3ce6550da63603",
      "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
      "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
    ).map(colors);

    var Oranges = ramp$1(scheme);

    function cividis(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67)))))))
          + ")";
    }

    var cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0.0), cubehelix$3(-240, 0.5, 1.0));

    var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.50, 0.8));

    var c$2 = cubehelix$3();

    function rainbow(t) {
      if (t < 0 || t > 1) t -= Math.floor(t);
      var ts = Math.abs(t - 0.5);
      c$2.h = 360 * t - 100;
      c$2.s = 1.5 - 1.5 * ts;
      c$2.l = 0.8 - 0.9 * ts;
      return c$2 + "";
    }

    var c$1 = rgb(),
        pi_1_3 = Math.PI / 3,
        pi_2_3 = Math.PI * 2 / 3;

    function sinebow(t) {
      var x;
      t = (0.5 - t) * Math.PI;
      c$1.r = 255 * (x = Math.sin(t)) * x;
      c$1.g = 255 * (x = Math.sin(t + pi_1_3)) * x;
      c$1.b = 255 * (x = Math.sin(t + pi_2_3)) * x;
      return c$1 + "";
    }

    function turbo(t) {
      t = Math.max(0, Math.min(1, t));
      return "rgb("
          + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", "
          + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66)))))))
          + ")";
    }

    function ramp(range) {
      var n = range.length;
      return function(t) {
        return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
      };
    }

    var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

    var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

    var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

    var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

    function constant$1(x) {
      return function constant() {
        return x;
      };
    }

    const abs = Math.abs;
    const atan2 = Math.atan2;
    const cos = Math.cos;
    const max = Math.max;
    const min = Math.min;
    const sin = Math.sin;
    const sqrt = Math.sqrt;

    const epsilon = 1e-12;
    const pi = Math.PI;
    const halfPi = pi / 2;
    const tau = 2 * pi;

    function acos(x) {
      return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
    }

    function asin(x) {
      return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
    }

    function arcInnerRadius(d) {
      return d.innerRadius;
    }

    function arcOuterRadius(d) {
      return d.outerRadius;
    }

    function arcStartAngle(d) {
      return d.startAngle;
    }

    function arcEndAngle(d) {
      return d.endAngle;
    }

    function arcPadAngle(d) {
      return d && d.padAngle; // Note: optional!
    }

    function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
      var x10 = x1 - x0, y10 = y1 - y0,
          x32 = x3 - x2, y32 = y3 - y2,
          t = y32 * x10 - x32 * y10;
      if (t * t < epsilon) return;
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
      return [x0 + t * x10, y0 + t * y10];
    }

    // Compute perpendicular offset line of length rc.
    // http://mathworld.wolfram.com/Circle-LineIntersection.html
    function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
      var x01 = x0 - x1,
          y01 = y0 - y1,
          lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01),
          ox = lo * y01,
          oy = -lo * x01,
          x11 = x0 + ox,
          y11 = y0 + oy,
          x10 = x1 + ox,
          y10 = y1 + oy,
          x00 = (x11 + x10) / 2,
          y00 = (y11 + y10) / 2,
          dx = x10 - x11,
          dy = y10 - y11,
          d2 = dx * dx + dy * dy,
          r = r1 - rc,
          D = x11 * y10 - x10 * y11,
          d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D * D)),
          cx0 = (D * dy - dx * d) / d2,
          cy0 = (-D * dx - dy * d) / d2,
          cx1 = (D * dy + dx * d) / d2,
          cy1 = (-D * dx + dy * d) / d2,
          dx0 = cx0 - x00,
          dy0 = cy0 - y00,
          dx1 = cx1 - x00,
          dy1 = cy1 - y00;

      // Pick the closer of the two intersection points.
      // TODO Is there a faster way to determine which intersection to use?
      if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;

      return {
        cx: cx0,
        cy: cy0,
        x01: -ox,
        y01: -oy,
        x11: cx0 * (r1 / r - 1),
        y11: cy0 * (r1 / r - 1)
      };
    }

    function arc() {
      var innerRadius = arcInnerRadius,
          outerRadius = arcOuterRadius,
          cornerRadius = constant$1(0),
          padRadius = null,
          startAngle = arcStartAngle,
          endAngle = arcEndAngle,
          padAngle = arcPadAngle,
          context = null;

      function arc() {
        var buffer,
            r,
            r0 = +innerRadius.apply(this, arguments),
            r1 = +outerRadius.apply(this, arguments),
            a0 = startAngle.apply(this, arguments) - halfPi,
            a1 = endAngle.apply(this, arguments) - halfPi,
            da = abs(a1 - a0),
            cw = a1 > a0;

        if (!context) context = buffer = path();

        // Ensure that the outer radius is always larger than the inner radius.
        if (r1 < r0) r = r1, r1 = r0, r0 = r;

        // Is it a point?
        if (!(r1 > epsilon)) context.moveTo(0, 0);

        // Or is it a circle or annulus?
        else if (da > tau - epsilon) {
          context.moveTo(r1 * cos(a0), r1 * sin(a0));
          context.arc(0, 0, r1, a0, a1, !cw);
          if (r0 > epsilon) {
            context.moveTo(r0 * cos(a1), r0 * sin(a1));
            context.arc(0, 0, r0, a1, a0, cw);
          }
        }

        // Or is it a circular or annular sector?
        else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = (ap > epsilon) && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)),
              rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1;

          // Apply padding? Note that since r1  r0, da1  da0.
          if (rp > epsilon) {
            var p0 = asin(rp / r0 * sin(ap)),
                p1 = asin(rp / r1 * sin(ap));
            if ((da0 -= p0 * 2) > epsilon) p0 *= (cw ? 1 : -1), a00 += p0, a10 -= p0;
            else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > epsilon) p1 *= (cw ? 1 : -1), a01 += p1, a11 -= p1;
            else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * cos(a01),
              y01 = r1 * sin(a01),
              x10 = r0 * cos(a10),
              y10 = r0 * sin(a10);

          // Apply rounded corners?
          if (rc > epsilon) {
            var x11 = r1 * cos(a11),
                y11 = r1 * sin(a11),
                x00 = r0 * cos(a00),
                y00 = r0 * sin(a00),
                oc;

            // Restrict the corner radius according to the sector angle.
            if (da < pi && (oc = intersect(x01, y01, x00, y00, x11, y11, x10, y10))) {
              var ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
                  lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min(rc, (r0 - lc) / (kc - 1));
              rc1 = min(rc, (r1 - lc) / (kc + 1));
            }
          }

          // Is the sector collapsed to a line?
          if (!(da1 > epsilon)) context.moveTo(x01, y01);

          // Does the sectors outer ring have rounded corners?
          else if (rc1 > epsilon) {
            t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
            t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);

            context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
              context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the outer ring just a circular arc?
          else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);

          // Is there no inner ring, and its a circular sector?
          // Or perhaps its an annular sector collapsed due to padding?
          if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);

          // Does the sectors inner ring (or point) have rounded corners?
          else if (rc0 > epsilon) {
            t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
            t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);

            context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);

            // Have the corners merged?
            if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw);

            // Otherwise, draw the two corners and the ring.
            else {
              context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw);
              context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw);
              context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw);
            }
          }

          // Or is the inner ring just a circular arc?
          else context.arc(0, 0, r0, a10, a00, cw);
        }

        context.closePath();

        if (buffer) return context = null, buffer + "" || null;
      }

      arc.centroid = function() {
        var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
            a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
        return [cos(a) * r, sin(a) * r];
      };

      arc.innerRadius = function(_) {
        return arguments.length ? (innerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : innerRadius;
      };

      arc.outerRadius = function(_) {
        return arguments.length ? (outerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : outerRadius;
      };

      arc.cornerRadius = function(_) {
        return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : constant$1(+_), arc) : cornerRadius;
      };

      arc.padRadius = function(_) {
        return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), arc) : padRadius;
      };

      arc.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : startAngle;
      };

      arc.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : endAngle;
      };

      arc.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), arc) : padAngle;
      };

      arc.context = function(_) {
        return arguments.length ? ((context = _ == null ? null : _), arc) : context;
      };

      return arc;
    }

    var slice = Array.prototype.slice;

    function array(x) {
      return typeof x === "object" && "length" in x
        ? x // Array, TypedArray, NodeList, array-like
        : Array.from(x); // Map, Set, iterable, string, or anything else
    }

    function Linear(context) {
      this._context = context;
    }

    Linear.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: this._context.lineTo(x, y); break;
        }
      }
    };

    function curveLinear(context) {
      return new Linear(context);
    }

    function x$1(p) {
      return p[0];
    }

    function y(p) {
      return p[1];
    }

    function line(x, y$1) {
      var defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x = typeof x === "function" ? x : (x === undefined) ? x$1 : constant$1(x);
      y$1 = typeof y$1 === "function" ? y$1 : (y$1 === undefined) ? y : constant$1(y$1);

      function line(data) {
        var i,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer;

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) output.lineStart();
            else output.lineEnd();
          }
          if (defined0) output.point(+x(d, i, data), +y$1(d, i, data));
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      line.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$1(+_), line) : x;
      };

      line.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), line) : y$1;
      };

      line.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), line) : defined;
      };

      line.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
      };

      line.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
      };

      return line;
    }

    function area(x0, y0, y1) {
      var x1 = null,
          defined = constant$1(true),
          context = null,
          curve = curveLinear,
          output = null;

      x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x$1 : constant$1(+x0);
      y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$1(0) : constant$1(+y0);
      y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y : constant$1(+y1);

      function area(data) {
        var i,
            j,
            k,
            n = (data = array(data)).length,
            d,
            defined0 = false,
            buffer,
            x0z = new Array(n),
            y0z = new Array(n);

        if (context == null) output = curve(buffer = path());

        for (i = 0; i <= n; ++i) {
          if (!(i < n && defined(d = data[i], i, data)) === defined0) {
            if (defined0 = !defined0) {
              j = i;
              output.areaStart();
              output.lineStart();
            } else {
              output.lineEnd();
              output.lineStart();
              for (k = i - 1; k >= j; --k) {
                output.point(x0z[k], y0z[k]);
              }
              output.lineEnd();
              output.areaEnd();
            }
          }
          if (defined0) {
            x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
            output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
          }
        }

        if (buffer) return output = null, buffer + "" || null;
      }

      function arealine() {
        return line().defined(defined).curve(curve).context(context);
      }

      area.x = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
      };

      area.x0 = function(_) {
        return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
      };

      area.x1 = function(_) {
        return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
      };

      area.y = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
      };

      area.y0 = function(_) {
        return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
      };

      area.y1 = function(_) {
        return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
      };

      area.lineX0 =
      area.lineY0 = function() {
        return arealine().x(x0).y(y0);
      };

      area.lineY1 = function() {
        return arealine().x(x0).y(y1);
      };

      area.lineX1 = function() {
        return arealine().x(x1).y(y0);
      };

      area.defined = function(_) {
        return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), area) : defined;
      };

      area.curve = function(_) {
        return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
      };

      area.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
      };

      return area;
    }

    function descending$1(a, b) {
      return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
    }

    function identity$1(d) {
      return d;
    }

    function pie() {
      var value = identity$1,
          sortValues = descending$1,
          sort = null,
          startAngle = constant$1(0),
          endAngle = constant$1(tau),
          padAngle = constant$1(0);

      function pie(data) {
        var i,
            n = (data = array(data)).length,
            j,
            k,
            sum = 0,
            index = new Array(n),
            arcs = new Array(n),
            a0 = +startAngle.apply(this, arguments),
            da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)),
            a1,
            p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
            pa = p * (da < 0 ? -1 : 1),
            v;

        for (i = 0; i < n; ++i) {
          if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
            sum += v;
          }
        }

        // Optionally sort the arcs by previously-computed values or by data.
        if (sortValues != null) index.sort(function(i, j) { return sortValues(arcs[i], arcs[j]); });
        else if (sort != null) index.sort(function(i, j) { return sort(data[i], data[j]); });

        // Compute the arcs! They are stored in the original data's order.
        for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
          j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
            data: data[j],
            index: i,
            value: v,
            startAngle: a0,
            endAngle: a1,
            padAngle: p
          };
        }

        return arcs;
      }

      pie.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), pie) : value;
      };

      pie.sortValues = function(_) {
        return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
      };

      pie.sort = function(_) {
        return arguments.length ? (sort = _, sortValues = null, pie) : sort;
      };

      pie.startAngle = function(_) {
        return arguments.length ? (startAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : startAngle;
      };

      pie.endAngle = function(_) {
        return arguments.length ? (endAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : endAngle;
      };

      pie.padAngle = function(_) {
        return arguments.length ? (padAngle = typeof _ === "function" ? _ : constant$1(+_), pie) : padAngle;
      };

      return pie;
    }

    var curveRadialLinear = curveRadial(curveLinear);

    function Radial(curve) {
      this._curve = curve;
    }

    Radial.prototype = {
      areaStart: function() {
        this._curve.areaStart();
      },
      areaEnd: function() {
        this._curve.areaEnd();
      },
      lineStart: function() {
        this._curve.lineStart();
      },
      lineEnd: function() {
        this._curve.lineEnd();
      },
      point: function(a, r) {
        this._curve.point(r * Math.sin(a), r * -Math.cos(a));
      }
    };

    function curveRadial(curve) {

      function radial(context) {
        return new Radial(curve(context));
      }

      radial._curve = curve;

      return radial;
    }

    function lineRadial(l) {
      var c = l.curve;

      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;

      l.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return l;
    }

    function lineRadial$1() {
      return lineRadial(line().curve(curveRadialLinear));
    }

    function areaRadial() {
      var a = area().curve(curveRadialLinear),
          c = a.curve,
          x0 = a.lineX0,
          x1 = a.lineX1,
          y0 = a.lineY0,
          y1 = a.lineY1;

      a.angle = a.x, delete a.x;
      a.startAngle = a.x0, delete a.x0;
      a.endAngle = a.x1, delete a.x1;
      a.radius = a.y, delete a.y;
      a.innerRadius = a.y0, delete a.y0;
      a.outerRadius = a.y1, delete a.y1;
      a.lineStartAngle = function() { return lineRadial(x0()); }, delete a.lineX0;
      a.lineEndAngle = function() { return lineRadial(x1()); }, delete a.lineX1;
      a.lineInnerRadius = function() { return lineRadial(y0()); }, delete a.lineY0;
      a.lineOuterRadius = function() { return lineRadial(y1()); }, delete a.lineY1;

      a.curve = function(_) {
        return arguments.length ? c(curveRadial(_)) : c()._curve;
      };

      return a;
    }

    function pointRadial(x, y) {
      return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
    }

    class Bump {
      constructor(context, x) {
        this._context = context;
        this._x = x;
      }
      areaStart() {
        this._line = 0;
      }
      areaEnd() {
        this._line = NaN;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      }
      point(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: {
            this._point = 1;
            if (this._line) this._context.lineTo(x, y);
            else this._context.moveTo(x, y);
            break;
          }
          case 1: this._point = 2; // falls through
          default: {
            if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
            else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
            break;
          }
        }
        this._x0 = x, this._y0 = y;
      }
    }

    class BumpRadial {
      constructor(context) {
        this._context = context;
      }
      lineStart() {
        this._point = 0;
      }
      lineEnd() {}
      point(x, y) {
        x = +x, y = +y;
        if (this._point++ === 0) {
          this._x0 = x, this._y0 = y;
        } else {
          const p0 = pointRadial(this._x0, this._y0);
          const p1 = pointRadial(this._x0, this._y0 = (this._y0 + y) / 2);
          const p2 = pointRadial(x, this._y0);
          const p3 = pointRadial(x, y);
          this._context.moveTo(...p0);
          this._context.bezierCurveTo(...p1, ...p2, ...p3);
        }
      }
    }

    function bumpX(context) {
      return new Bump(context, true);
    }

    function bumpY(context) {
      return new Bump(context, false);
    }

    function bumpRadial(context) {
      return new BumpRadial(context);
    }

    function linkSource(d) {
      return d.source;
    }

    function linkTarget(d) {
      return d.target;
    }

    function link(curve) {
      let source = linkSource;
      let target = linkTarget;
      let x = x$1;
      let y$1 = y;
      let context = null;
      let output = null;

      function link() {
        let buffer;
        const argv = slice.call(arguments);
        const s = source.apply(this, argv);
        const t = target.apply(this, argv);
        if (context == null) output = curve(buffer = path());
        output.lineStart();
        argv[0] = s, output.point(+x.apply(this, argv), +y$1.apply(this, argv));
        argv[0] = t, output.point(+x.apply(this, argv), +y$1.apply(this, argv));
        output.lineEnd();
        if (buffer) return output = null, buffer + "" || null;
      }

      link.source = function(_) {
        return arguments.length ? (source = _, link) : source;
      };

      link.target = function(_) {
        return arguments.length ? (target = _, link) : target;
      };

      link.x = function(_) {
        return arguments.length ? (x = typeof _ === "function" ? _ : constant$1(+_), link) : x;
      };

      link.y = function(_) {
        return arguments.length ? (y$1 = typeof _ === "function" ? _ : constant$1(+_), link) : y$1;
      };

      link.context = function(_) {
        return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), link) : context;
      };

      return link;
    }

    function linkHorizontal() {
      return link(bumpX);
    }

    function linkVertical() {
      return link(bumpY);
    }

    function linkRadial() {
      const l = link(bumpRadial);
      l.angle = l.x, delete l.x;
      l.radius = l.y, delete l.y;
      return l;
    }

    const sqrt3$2 = sqrt(3);

    var asterisk = {
      draw(context, size) {
        const r = sqrt(size + min(size / 28, 0.75)) * 0.59436;
        const t = r / 2;
        const u = t * sqrt3$2;
        context.moveTo(0, r);
        context.lineTo(0, -r);
        context.moveTo(-u, -t);
        context.lineTo(u, t);
        context.moveTo(-u, t);
        context.lineTo(u, -t);
      }
    };

    var circle = {
      draw(context, size) {
        const r = sqrt(size / pi);
        context.moveTo(r, 0);
        context.arc(0, 0, r, 0, tau);
      }
    };

    var cross = {
      draw(context, size) {
        const r = sqrt(size / 5) / 2;
        context.moveTo(-3 * r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, -3 * r);
        context.lineTo(r, -3 * r);
        context.lineTo(r, -r);
        context.lineTo(3 * r, -r);
        context.lineTo(3 * r, r);
        context.lineTo(r, r);
        context.lineTo(r, 3 * r);
        context.lineTo(-r, 3 * r);
        context.lineTo(-r, r);
        context.lineTo(-3 * r, r);
        context.closePath();
      }
    };

    const tan30 = sqrt(1 / 3);
    const tan30_2 = tan30 * 2;

    var diamond = {
      draw(context, size) {
        const y = sqrt(size / tan30_2);
        const x = y * tan30;
        context.moveTo(0, -y);
        context.lineTo(x, 0);
        context.lineTo(0, y);
        context.lineTo(-x, 0);
        context.closePath();
      }
    };

    var diamond2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.62625;
        context.moveTo(0, -r);
        context.lineTo(r, 0);
        context.lineTo(0, r);
        context.lineTo(-r, 0);
        context.closePath();
      }
    };

    var plus = {
      draw(context, size) {
        const r = sqrt(size - min(size / 7, 2)) * 0.87559;
        context.moveTo(-r, 0);
        context.lineTo(r, 0);
        context.moveTo(0, r);
        context.lineTo(0, -r);
      }
    };

    var square = {
      draw(context, size) {
        const w = sqrt(size);
        const x = -w / 2;
        context.rect(x, x, w, w);
      }
    };

    var square2 = {
      draw(context, size) {
        const r = sqrt(size) * 0.4431;
        context.moveTo(r, r);
        context.lineTo(r, -r);
        context.lineTo(-r, -r);
        context.lineTo(-r, r);
        context.closePath();
      }
    };

    const ka = 0.89081309152928522810;
    const kr = sin(pi / 10) / sin(7 * pi / 10);
    const kx = sin(tau / 10) * kr;
    const ky = -cos(tau / 10) * kr;

    var star = {
      draw(context, size) {
        const r = sqrt(size * ka);
        const x = kx * r;
        const y = ky * r;
        context.moveTo(0, -r);
        context.lineTo(x, y);
        for (let i = 1; i < 5; ++i) {
          const a = tau * i / 5;
          const c = cos(a);
          const s = sin(a);
          context.lineTo(s * r, -c * r);
          context.lineTo(c * x - s * y, s * x + c * y);
        }
        context.closePath();
      }
    };

    const sqrt3$1 = sqrt(3);

    var triangle = {
      draw(context, size) {
        const y = -sqrt(size / (sqrt3$1 * 3));
        context.moveTo(0, y * 2);
        context.lineTo(-sqrt3$1 * y, -y);
        context.lineTo(sqrt3$1 * y, -y);
        context.closePath();
      }
    };

    const sqrt3 = sqrt(3);

    var triangle2 = {
      draw(context, size) {
        const s = sqrt(size) * 0.6824;
        const t = s  / 2;
        const u = (s * sqrt3) / 2; // cos(Math.PI / 6)
        context.moveTo(0, -s);
        context.lineTo(u, t);
        context.lineTo(-u, t);
        context.closePath();
      }
    };

    const c = -0.5;
    const s = sqrt(3) / 2;
    const k = 1 / sqrt(12);
    const a = (k / 2 + 1) * 3;

    var wye = {
      draw(context, size) {
        const r = sqrt(size / a);
        const x0 = r / 2, y0 = r * k;
        const x1 = x0, y1 = r * k + r;
        const x2 = -x1, y2 = y1;
        context.moveTo(x0, y0);
        context.lineTo(x1, y1);
        context.lineTo(x2, y2);
        context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
        context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
        context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
        context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
        context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
        context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
        context.closePath();
      }
    };

    var x = {
      draw(context, size) {
        const r = sqrt(size - min(size / 6, 1.7)) * 0.6189;
        context.moveTo(-r, -r);
        context.lineTo(r, r);
        context.moveTo(-r, r);
        context.lineTo(r, -r);
      }
    };

    // These symbols are designed to be filled.
    const symbolsFill = [
      circle,
      cross,
      diamond,
      square,
      star,
      triangle,
      wye
    ];

    // These symbols are designed to be stroked (with a width of 1.5px and round caps).
    const symbolsStroke = [
      circle,
      plus,
      x,
      triangle2,
      asterisk,
      square2,
      diamond2
    ];

    function Symbol$1(type, size) {
      let context = null;

      type = typeof type === "function" ? type : constant$1(type || circle);
      size = typeof size === "function" ? size : constant$1(size === undefined ? 64 : +size);

      function symbol() {
        let buffer;
        if (!context) context = buffer = path();
        type.apply(this, arguments).draw(context, +size.apply(this, arguments));
        if (buffer) return context = null, buffer + "" || null;
      }

      symbol.type = function(_) {
        return arguments.length ? (type = typeof _ === "function" ? _ : constant$1(_), symbol) : type;
      };

      symbol.size = function(_) {
        return arguments.length ? (size = typeof _ === "function" ? _ : constant$1(+_), symbol) : size;
      };

      symbol.context = function(_) {
        return arguments.length ? (context = _ == null ? null : _, symbol) : context;
      };

      return symbol;
    }

    function noop() {}

    function point$3(that, x, y) {
      that._context.bezierCurveTo(
        (2 * that._x0 + that._x1) / 3,
        (2 * that._y0 + that._y1) / 3,
        (that._x0 + 2 * that._x1) / 3,
        (that._y0 + 2 * that._y1) / 3,
        (that._x0 + 4 * that._x1 + x) / 6,
        (that._y0 + 4 * that._y1 + y) / 6
      );
    }

    function Basis(context) {
      this._context = context;
    }

    Basis.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 3: point$3(this, this._x1, this._y1); // falls through
          case 2: this._context.lineTo(this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basis(context) {
      return new Basis(context);
    }

    function BasisClosed(context) {
      this._context = context;
    }

    BasisClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x2, this._y2);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
            this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x2, this._y2);
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
          case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
          case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisClosed(context) {
      return new BasisClosed(context);
    }

    function BasisOpen(context) {
      this._context = context;
    }

    BasisOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
          case 3: this._point = 4; // falls through
          default: point$3(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
      }
    };

    function basisOpen(context) {
      return new BasisOpen(context);
    }

    function Bundle(context, beta) {
      this._basis = new Basis(context);
      this._beta = beta;
    }

    Bundle.prototype = {
      lineStart: function() {
        this._x = [];
        this._y = [];
        this._basis.lineStart();
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            j = x.length - 1;

        if (j > 0) {
          var x0 = x[0],
              y0 = y[0],
              dx = x[j] - x0,
              dy = y[j] - y0,
              i = -1,
              t;

          while (++i <= j) {
            t = i / j;
            this._basis.point(
              this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
              this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
            );
          }
        }

        this._x = this._y = null;
        this._basis.lineEnd();
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    var bundle = (function custom(beta) {

      function bundle(context) {
        return beta === 1 ? new Basis(context) : new Bundle(context, beta);
      }

      bundle.beta = function(beta) {
        return custom(+beta);
      };

      return bundle;
    })(0.85);

    function point$2(that, x, y) {
      that._context.bezierCurveTo(
        that._x1 + that._k * (that._x2 - that._x0),
        that._y1 + that._k * (that._y2 - that._y0),
        that._x2 + that._k * (that._x1 - x),
        that._y2 + that._k * (that._y1 - y),
        that._x2,
        that._y2
      );
    }

    function Cardinal(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    Cardinal.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: point$2(this, this._x1, this._y1); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
          case 2: this._point = 3; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinal = (function custom(tension) {

      function cardinal(context) {
        return new Cardinal(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalClosed(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalClosed = (function custom(tension) {

      function cardinal(context) {
        return new CardinalClosed(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function CardinalOpen(context, tension) {
      this._context = context;
      this._k = (1 - tension) / 6;
    }

    CardinalOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$2(this, x, y); break;
        }
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var cardinalOpen = (function custom(tension) {

      function cardinal(context) {
        return new CardinalOpen(context, tension);
      }

      cardinal.tension = function(tension) {
        return custom(+tension);
      };

      return cardinal;
    })(0);

    function point$1(that, x, y) {
      var x1 = that._x1,
          y1 = that._y1,
          x2 = that._x2,
          y2 = that._y2;

      if (that._l01_a > epsilon) {
        var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
            n = 3 * that._l01_a * (that._l01_a + that._l12_a);
        x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
        y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
      }

      if (that._l23_a > epsilon) {
        var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
            m = 3 * that._l23_a * (that._l23_a + that._l12_a);
        x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
        y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
      }

      that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
    }

    function CatmullRom(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRom.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x2, this._y2); break;
          case 3: this.point(this._x2, this._y2); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRom = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomClosed(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
        this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 1: {
            this._context.moveTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 2: {
            this._context.lineTo(this._x3, this._y3);
            this._context.closePath();
            break;
          }
          case 3: {
            this.point(this._x3, this._y3);
            this.point(this._x4, this._y4);
            this.point(this._x5, this._y5);
            break;
          }
        }
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
          case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
          case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomClosed = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function CatmullRomOpen(context, alpha) {
      this._context = context;
      this._alpha = alpha;
    }

    CatmullRomOpen.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 = this._x2 =
        this._y0 = this._y1 = this._y2 = NaN;
        this._l01_a = this._l12_a = this._l23_a =
        this._l01_2a = this._l12_2a = this._l23_2a =
        this._point = 0;
      },
      lineEnd: function() {
        if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;

        if (this._point) {
          var x23 = this._x2 - x,
              y23 = this._y2 - y;
          this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
        }

        switch (this._point) {
          case 0: this._point = 1; break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
          case 3: this._point = 4; // falls through
          default: point$1(this, x, y); break;
        }

        this._l01_a = this._l12_a, this._l12_a = this._l23_a;
        this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
        this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
        this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
      }
    };

    var catmullRomOpen = (function custom(alpha) {

      function catmullRom(context) {
        return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
      }

      catmullRom.alpha = function(alpha) {
        return custom(+alpha);
      };

      return catmullRom;
    })(0.5);

    function LinearClosed(context) {
      this._context = context;
    }

    LinearClosed.prototype = {
      areaStart: noop,
      areaEnd: noop,
      lineStart: function() {
        this._point = 0;
      },
      lineEnd: function() {
        if (this._point) this._context.closePath();
      },
      point: function(x, y) {
        x = +x, y = +y;
        if (this._point) this._context.lineTo(x, y);
        else this._point = 1, this._context.moveTo(x, y);
      }
    };

    function linearClosed(context) {
      return new LinearClosed(context);
    }

    function sign(x) {
      return x < 0 ? -1 : 1;
    }

    // Calculate the slopes of the tangents (Hermite-type interpolation) based on
    // the following paper: Steffen, M. 1990. A Simple Method for Monotonic
    // Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
    // NOV(II), P. 443, 1990.
    function slope3(that, x2, y2) {
      var h0 = that._x1 - that._x0,
          h1 = x2 - that._x1,
          s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
          s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
          p = (s0 * h1 + s1 * h0) / (h0 + h1);
      return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
    }

    // Calculate a one-sided slope.
    function slope2(that, t) {
      var h = that._x1 - that._x0;
      return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
    }

    // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
    // "you can express cubic Hermite interpolation in terms of cubic Bzier curves
    // with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
    function point(that, t0, t1) {
      var x0 = that._x0,
          y0 = that._y0,
          x1 = that._x1,
          y1 = that._y1,
          dx = (x1 - x0) / 3;
      that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
    }

    function MonotoneX(context) {
      this._context = context;
    }

    MonotoneX.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x0 = this._x1 =
        this._y0 = this._y1 =
        this._t0 = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        switch (this._point) {
          case 2: this._context.lineTo(this._x1, this._y1); break;
          case 3: point(this, this._t0, slope2(this, this._t0)); break;
        }
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        this._line = 1 - this._line;
      },
      point: function(x, y) {
        var t1 = NaN;

        x = +x, y = +y;
        if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; break;
          case 2: this._point = 3; point(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
          default: point(this, this._t0, t1 = slope3(this, x, y)); break;
        }

        this._x0 = this._x1, this._x1 = x;
        this._y0 = this._y1, this._y1 = y;
        this._t0 = t1;
      }
    };

    function MonotoneY(context) {
      this._context = new ReflectContext(context);
    }

    (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
      MonotoneX.prototype.point.call(this, y, x);
    };

    function ReflectContext(context) {
      this._context = context;
    }

    ReflectContext.prototype = {
      moveTo: function(x, y) { this._context.moveTo(y, x); },
      closePath: function() { this._context.closePath(); },
      lineTo: function(x, y) { this._context.lineTo(y, x); },
      bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
    };

    function monotoneX(context) {
      return new MonotoneX(context);
    }

    function monotoneY(context) {
      return new MonotoneY(context);
    }

    function Natural(context) {
      this._context = context;
    }

    Natural.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = [];
        this._y = [];
      },
      lineEnd: function() {
        var x = this._x,
            y = this._y,
            n = x.length;

        if (n) {
          this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
          if (n === 2) {
            this._context.lineTo(x[1], y[1]);
          } else {
            var px = controlPoints(x),
                py = controlPoints(y);
            for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
              this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
            }
          }
        }

        if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
        this._line = 1 - this._line;
        this._x = this._y = null;
      },
      point: function(x, y) {
        this._x.push(+x);
        this._y.push(+y);
      }
    };

    // See https://www.particleincell.com/2012/bezier-splines/ for derivation.
    function controlPoints(x) {
      var i,
          n = x.length - 1,
          m,
          a = new Array(n),
          b = new Array(n),
          r = new Array(n);
      a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
      for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
      a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
      for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
      a[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
      b[n - 1] = (x[n] + a[n - 1]) / 2;
      for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
      return [a, b];
    }

    function natural(context) {
      return new Natural(context);
    }

    function Step(context, t) {
      this._context = context;
      this._t = t;
    }

    Step.prototype = {
      areaStart: function() {
        this._line = 0;
      },
      areaEnd: function() {
        this._line = NaN;
      },
      lineStart: function() {
        this._x = this._y = NaN;
        this._point = 0;
      },
      lineEnd: function() {
        if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
        if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
        if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
      },
      point: function(x, y) {
        x = +x, y = +y;
        switch (this._point) {
          case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
          case 1: this._point = 2; // falls through
          default: {
            if (this._t <= 0) {
              this._context.lineTo(this._x, y);
              this._context.lineTo(x, y);
            } else {
              var x1 = this._x * (1 - this._t) + x * this._t;
              this._context.lineTo(x1, this._y);
              this._context.lineTo(x1, y);
            }
            break;
          }
        }
        this._x = x, this._y = y;
      }
    };

    function step(context) {
      return new Step(context, 0.5);
    }

    function stepBefore(context) {
      return new Step(context, 0);
    }

    function stepAfter(context) {
      return new Step(context, 1);
    }

    function none$1(series, order) {
      if (!((n = series.length) > 1)) return;
      for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
        s0 = s1, s1 = series[order[i]];
        for (j = 0; j < m; ++j) {
          s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
        }
      }
    }

    function none(series) {
      var n = series.length, o = new Array(n);
      while (--n >= 0) o[n] = n;
      return o;
    }

    function stackValue(d, key) {
      return d[key];
    }

    function stackSeries(key) {
      const series = [];
      series.key = key;
      return series;
    }

    function stack() {
      var keys = constant$1([]),
          order = none,
          offset = none$1,
          value = stackValue;

      function stack(data) {
        var sz = Array.from(keys.apply(this, arguments), stackSeries),
            i, n = sz.length, j = -1,
            oz;

        for (const d of data) {
          for (i = 0, ++j; i < n; ++i) {
            (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
          }
        }

        for (i = 0, oz = array(order(sz)); i < n; ++i) {
          sz[oz[i]].index = i;
        }

        offset(sz, oz);
        return sz;
      }

      stack.keys = function(_) {
        return arguments.length ? (keys = typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : keys;
      };

      stack.value = function(_) {
        return arguments.length ? (value = typeof _ === "function" ? _ : constant$1(+_), stack) : value;
      };

      stack.order = function(_) {
        return arguments.length ? (order = _ == null ? none : typeof _ === "function" ? _ : constant$1(Array.from(_)), stack) : order;
      };

      stack.offset = function(_) {
        return arguments.length ? (offset = _ == null ? none$1 : _, stack) : offset;
      };

      return stack;
    }

    function expand(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
        for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
        if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
      }
      none$1(series, order);
    }

    function diverging(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
        for (yp = yn = 0, i = 0; i < n; ++i) {
          if ((dy = (d = series[order[i]][j])[1] - d[0]) > 0) {
            d[0] = yp, d[1] = yp += dy;
          } else if (dy < 0) {
            d[1] = yn, d[0] = yn += dy;
          } else {
            d[0] = 0, d[1] = dy;
          }
        }
      }
    }

    function silhouette(series, order) {
      if (!((n = series.length) > 0)) return;
      for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
        for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
        s0[j][1] += s0[j][0] = -y / 2;
      }
      none$1(series, order);
    }

    function wiggle(series, order) {
      if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;
      for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
        for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
          var si = series[order[i]],
              sij0 = si[j][1] || 0,
              sij1 = si[j - 1][1] || 0,
              s3 = (sij0 - sij1) / 2;
          for (var k = 0; k < i; ++k) {
            var sk = series[order[k]],
                skj0 = sk[j][1] || 0,
                skj1 = sk[j - 1][1] || 0;
            s3 += skj0 - skj1;
          }
          s1 += sij0, s2 += s3 * sij0;
        }
        s0[j - 1][1] += s0[j - 1][0] = y;
        if (s1) y -= s2 / s1;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      none$1(series, order);
    }

    function appearance(series) {
      var peaks = series.map(peak);
      return none(series).sort(function(a, b) { return peaks[a] - peaks[b]; });
    }

    function peak(series) {
      var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
      while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
      return j;
    }

    function ascending(series) {
      var sums = series.map(sum);
      return none(series).sort(function(a, b) { return sums[a] - sums[b]; });
    }

    function sum(series) {
      var s = 0, i = -1, n = series.length, v;
      while (++i < n) if (v = +series[i][1]) s += v;
      return s;
    }

    function descending(series) {
      return ascending(series).reverse();
    }

    function insideOut(series) {
      var n = series.length,
          i,
          j,
          sums = series.map(sum),
          order = appearance(series),
          top = 0,
          bottom = 0,
          tops = [],
          bottoms = [];

      for (i = 0; i < n; ++i) {
        j = order[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }

      return bottoms.reverse().concat(tops);
    }

    function reverse(series) {
      return none(series).reverse();
    }

    var constant = x => () => x;

    function ZoomEvent(type, {
      sourceEvent,
      target,
      transform,
      dispatch
    }) {
      Object.defineProperties(this, {
        type: {value: type, enumerable: true, configurable: true},
        sourceEvent: {value: sourceEvent, enumerable: true, configurable: true},
        target: {value: target, enumerable: true, configurable: true},
        transform: {value: transform, enumerable: true, configurable: true},
        _: {value: dispatch}
      });
    }

    function Transform(k, x, y) {
      this.k = k;
      this.x = x;
      this.y = y;
    }

    Transform.prototype = {
      constructor: Transform,
      scale: function(k) {
        return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
      },
      translate: function(x, y) {
        return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
      },
      apply: function(point) {
        return [point[0] * this.k + this.x, point[1] * this.k + this.y];
      },
      applyX: function(x) {
        return x * this.k + this.x;
      },
      applyY: function(y) {
        return y * this.k + this.y;
      },
      invert: function(location) {
        return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
      },
      invertX: function(x) {
        return (x - this.x) / this.k;
      },
      invertY: function(y) {
        return (y - this.y) / this.k;
      },
      rescaleX: function(x) {
        return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
      },
      rescaleY: function(y) {
        return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
      },
      toString: function() {
        return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
      }
    };

    var identity = new Transform(1, 0, 0);

    transform.prototype = Transform.prototype;

    function transform(node) {
      while (!node.__zoom) if (!(node = node.parentNode)) return identity;
      return node.__zoom;
    }

    function nopropagation(event) {
      event.stopImmediatePropagation();
    }

    function noevent(event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }

    // Ignore right-click, since that should open the context menu.
    // except for pinch-to-zoom, which is sent as a wheel+ctrlKey event
    function defaultFilter(event) {
      return (!event.ctrlKey || event.type === 'wheel') && !event.button;
    }

    function defaultExtent() {
      var e = this;
      if (e instanceof SVGElement) {
        e = e.ownerSVGElement || e;
        if (e.hasAttribute("viewBox")) {
          e = e.viewBox.baseVal;
          return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
        }
        return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
      }
      return [[0, 0], [e.clientWidth, e.clientHeight]];
    }

    function defaultTransform() {
      return this.__zoom || identity;
    }

    function defaultWheelDelta(event) {
      return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * (event.ctrlKey ? 10 : 1);
    }

    function defaultTouchable() {
      return navigator.maxTouchPoints || ("ontouchstart" in this);
    }

    function defaultConstrain(transform, extent, translateExtent) {
      var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
          dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
          dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
          dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
      return transform.translate(
        dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
        dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
      );
    }

    function zoom() {
      var filter = defaultFilter,
          extent = defaultExtent,
          constrain = defaultConstrain,
          wheelDelta = defaultWheelDelta,
          touchable = defaultTouchable,
          scaleExtent = [0, Infinity],
          translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
          duration = 250,
          interpolate = interpolateZoom,
          listeners = dispatch("start", "zoom", "end"),
          touchstarting,
          touchfirst,
          touchending,
          touchDelay = 500,
          wheelDelay = 150,
          clickDistance2 = 0,
          tapDistance = 10;

      function zoom(selection) {
        selection
            .property("__zoom", defaultTransform)
            .on("wheel.zoom", wheeled, {passive: false})
            .on("mousedown.zoom", mousedowned)
            .on("dblclick.zoom", dblclicked)
          .filter(touchable)
            .on("touchstart.zoom", touchstarted)
            .on("touchmove.zoom", touchmoved)
            .on("touchend.zoom touchcancel.zoom", touchended)
            .style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
      }

      zoom.transform = function(collection, transform, point, event) {
        var selection = collection.selection ? collection.selection() : collection;
        selection.property("__zoom", defaultTransform);
        if (collection !== selection) {
          schedule(collection, transform, point, event);
        } else {
          selection.interrupt().each(function() {
            gesture(this, arguments)
              .event(event)
              .start()
              .zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform)
              .end();
          });
        }
      };

      zoom.scaleBy = function(selection, k, p, event) {
        zoom.scaleTo(selection, function() {
          var k0 = this.__zoom.k,
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return k0 * k1;
        }, p, event);
      };

      zoom.scaleTo = function(selection, k, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t0 = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p,
              p1 = t0.invert(p0),
              k1 = typeof k === "function" ? k.apply(this, arguments) : k;
          return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
        }, p, event);
      };

      zoom.translateBy = function(selection, x, y, event) {
        zoom.transform(selection, function() {
          return constrain(this.__zoom.translate(
            typeof x === "function" ? x.apply(this, arguments) : x,
            typeof y === "function" ? y.apply(this, arguments) : y
          ), extent.apply(this, arguments), translateExtent);
        }, null, event);
      };

      zoom.translateTo = function(selection, x, y, p, event) {
        zoom.transform(selection, function() {
          var e = extent.apply(this, arguments),
              t = this.__zoom,
              p0 = p == null ? centroid(e) : typeof p === "function" ? p.apply(this, arguments) : p;
          return constrain(identity.translate(p0[0], p0[1]).scale(t.k).translate(
            typeof x === "function" ? -x.apply(this, arguments) : -x,
            typeof y === "function" ? -y.apply(this, arguments) : -y
          ), e, translateExtent);
        }, p, event);
      };

      function scale(transform, k) {
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
        return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
      }

      function translate(transform, p0, p1) {
        var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;
        return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);
      }

      function centroid(extent) {
        return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
      }

      function schedule(transition, transform, point, event) {
        transition
            .on("start.zoom", function() { gesture(this, arguments).event(event).start(); })
            .on("interrupt.zoom end.zoom", function() { gesture(this, arguments).event(event).end(); })
            .tween("zoom", function() {
              var that = this,
                  args = arguments,
                  g = gesture(that, args).event(event),
                  e = extent.apply(that, args),
                  p = point == null ? centroid(e) : typeof point === "function" ? point.apply(that, args) : point,
                  w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
                  a = that.__zoom,
                  b = typeof transform === "function" ? transform.apply(that, args) : transform,
                  i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
              return function(t) {
                if (t === 1) t = b; // Avoid rounding error on end.
                else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }
                g.zoom(null, t);
              };
            });
      }

      function gesture(that, args, clean) {
        return (!clean && that.__zooming) || new Gesture(that, args);
      }

      function Gesture(that, args) {
        this.that = that;
        this.args = args;
        this.active = 0;
        this.sourceEvent = null;
        this.extent = extent.apply(that, args);
        this.taps = 0;
      }

      Gesture.prototype = {
        event: function(event) {
          if (event) this.sourceEvent = event;
          return this;
        },
        start: function() {
          if (++this.active === 1) {
            this.that.__zooming = this;
            this.emit("start");
          }
          return this;
        },
        zoom: function(key, transform) {
          if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
          if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
          if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
          this.that.__zoom = transform;
          this.emit("zoom");
          return this;
        },
        end: function() {
          if (--this.active === 0) {
            delete this.that.__zooming;
            this.emit("end");
          }
          return this;
        },
        emit: function(type) {
          var d = select(this.that).datum();
          listeners.call(
            type,
            this.that,
            new ZoomEvent(type, {
              sourceEvent: this.sourceEvent,
              target: zoom,
              type,
              transform: this.that.__zoom,
              dispatch: listeners
            }),
            d
          );
        }
      };

      function wheeled(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var g = gesture(this, args).event(event),
            t = this.__zoom,
            k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
            p = pointer(event);

        // If the mouse is in the same location as before, reuse it.
        // If there were recent wheel events, reset the wheel idle timeout.
        if (g.wheel) {
          if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
            g.mouse[1] = t.invert(g.mouse[0] = p);
          }
          clearTimeout(g.wheel);
        }

        // If this wheel event wont trigger a transform change, ignore it.
        else if (t.k === k) return;

        // Otherwise, capture the mouse point and location at the start.
        else {
          g.mouse = [p, t.invert(p)];
          interrupt(this);
          g.start();
        }

        noevent(event);
        g.wheel = setTimeout(wheelidled, wheelDelay);
        g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

        function wheelidled() {
          g.wheel = null;
          g.end();
        }
      }

      function mousedowned(event, ...args) {
        if (touchending || !filter.apply(this, arguments)) return;
        var currentTarget = event.currentTarget,
            g = gesture(this, args, true).event(event),
            v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
            p = pointer(event, currentTarget),
            x0 = event.clientX,
            y0 = event.clientY;

        dragDisable(event.view);
        nopropagation(event);
        g.mouse = [p, this.__zoom.invert(p)];
        interrupt(this);
        g.start();

        function mousemoved(event) {
          noevent(event);
          if (!g.moved) {
            var dx = event.clientX - x0, dy = event.clientY - y0;
            g.moved = dx * dx + dy * dy > clickDistance2;
          }
          g.event(event)
           .zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = pointer(event, currentTarget), g.mouse[1]), g.extent, translateExtent));
        }

        function mouseupped(event) {
          v.on("mousemove.zoom mouseup.zoom", null);
          yesdrag(event.view, g.moved);
          noevent(event);
          g.event(event).end();
        }
      }

      function dblclicked(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var t0 = this.__zoom,
            p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this),
            p1 = t0.invert(p0),
            k1 = t0.k * (event.shiftKey ? 0.5 : 2),
            t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, args), translateExtent);

        noevent(event);
        if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0, event);
        else select(this).call(zoom.transform, t1, p0, event);
      }

      function touchstarted(event, ...args) {
        if (!filter.apply(this, arguments)) return;
        var touches = event.touches,
            n = touches.length,
            g = gesture(this, args, event.changedTouches.length === n).event(event),
            started, i, t, p;

        nopropagation(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          p = [p, this.__zoom.invert(p), t.identifier];
          if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
          else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
        }

        if (touchstarting) touchstarting = clearTimeout(touchstarting);

        if (started) {
          if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);
          interrupt(this);
          g.start();
        }
      }

      function touchmoved(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t, p, l;

        noevent(event);
        for (i = 0; i < n; ++i) {
          t = touches[i], p = pointer(t, this);
          if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;
          else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
        }
        t = g.that.__zoom;
        if (g.touch1) {
          var p0 = g.touch0[0], l0 = g.touch0[1],
              p1 = g.touch1[0], l1 = g.touch1[1],
              dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
              dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
          t = scale(t, Math.sqrt(dp / dl));
          p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
          l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
        }
        else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
        else return;

        g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
      }

      function touchended(event, ...args) {
        if (!this.__zooming) return;
        var g = gesture(this, args).event(event),
            touches = event.changedTouches,
            n = touches.length, i, t;

        nopropagation(event);
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function() { touchending = null; }, touchDelay);
        for (i = 0; i < n; ++i) {
          t = touches[i];
          if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;
          else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
        }
        if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
        if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
        else {
          g.end();
          // If this was a dbltap, reroute to the (optional) dblclick.zoom handler.
          if (g.taps === 2) {
            t = pointer(t, this);
            if (Math.hypot(touchfirst[0] - t[0], touchfirst[1] - t[1]) < tapDistance) {
              var p = select(this).on("dblclick.zoom");
              if (p) p.apply(this, arguments);
            }
          }
        }
      }

      zoom.wheelDelta = function(_) {
        return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : constant(+_), zoom) : wheelDelta;
      };

      zoom.filter = function(_) {
        return arguments.length ? (filter = typeof _ === "function" ? _ : constant(!!_), zoom) : filter;
      };

      zoom.touchable = function(_) {
        return arguments.length ? (touchable = typeof _ === "function" ? _ : constant(!!_), zoom) : touchable;
      };

      zoom.extent = function(_) {
        return arguments.length ? (extent = typeof _ === "function" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
      };

      zoom.scaleExtent = function(_) {
        return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
      };

      zoom.translateExtent = function(_) {
        return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
      };

      zoom.constrain = function(_) {
        return arguments.length ? (constrain = _, zoom) : constrain;
      };

      zoom.duration = function(_) {
        return arguments.length ? (duration = +_, zoom) : duration;
      };

      zoom.interpolate = function(_) {
        return arguments.length ? (interpolate = _, zoom) : interpolate;
      };

      zoom.on = function() {
        var value = listeners.on.apply(listeners, arguments);
        return value === listeners ? zoom : value;
      };

      zoom.clickDistance = function(_) {
        return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
      };

      zoom.tapDistance = function(_) {
        return arguments.length ? (tapDistance = +_, zoom) : tapDistance;
      };

      return zoom;
    }

    var d3 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        bisect: bisect,
        bisectRight: bisectRight,
        bisectLeft: bisectLeft,
        bisectCenter: bisectCenter,
        ascending: ascending$3,
        bisector: bisector,
        count: count$1,
        cross: cross$2,
        cumsum: cumsum,
        descending: descending$2,
        deviation: deviation,
        extent: extent$1,
        Adder: Adder,
        fsum: fsum,
        fcumsum: fcumsum,
        group: group,
        flatGroup: flatGroup,
        flatRollup: flatRollup,
        groups: groups,
        index: index$4,
        indexes: indexes,
        rollup: rollup,
        rollups: rollups,
        groupSort: groupSort,
        bin: bin,
        histogram: bin,
        thresholdFreedmanDiaconis: thresholdFreedmanDiaconis,
        thresholdScott: thresholdScott,
        thresholdSturges: thresholdSturges,
        max: max$3,
        maxIndex: maxIndex,
        mean: mean,
        median: median,
        merge: merge,
        min: min$2,
        minIndex: minIndex,
        mode: mode,
        nice: nice$1,
        pairs: pairs,
        permute: permute,
        quantile: quantile$1,
        quantileSorted: quantileSorted,
        quickselect: quickselect,
        range: range$2,
        rank: rank,
        least: least,
        leastIndex: leastIndex,
        greatest: greatest,
        greatestIndex: greatestIndex,
        scan: scan,
        shuffle: shuffle$1,
        shuffler: shuffler,
        sum: sum$2,
        ticks: ticks,
        tickIncrement: tickIncrement,
        tickStep: tickStep,
        transpose: transpose,
        variance: variance,
        zip: zip,
        every: every,
        some: some,
        filter: filter$1,
        map: map$1,
        reduce: reduce,
        reverse: reverse$1,
        sort: sort,
        difference: difference,
        disjoint: disjoint,
        intersection: intersection,
        subset: subset,
        superset: superset,
        union: union,
        InternMap: InternMap,
        InternSet: InternSet,
        axisTop: axisTop,
        axisRight: axisRight,
        axisBottom: axisBottom,
        axisLeft: axisLeft,
        brush: brush,
        brushX: brushX,
        brushY: brushY,
        brushSelection: brushSelection,
        chord: chord,
        chordTranspose: chordTranspose,
        chordDirected: chordDirected,
        ribbon: ribbon$1,
        ribbonArrow: ribbonArrow,
        color: color,
        rgb: rgb,
        hsl: hsl$2,
        lab: lab$1,
        hcl: hcl$2,
        lch: lch,
        gray: gray,
        cubehelix: cubehelix$3,
        contours: contours,
        contourDensity: density,
        Delaunay: Delaunay,
        Voronoi: Voronoi,
        dispatch: dispatch,
        drag: drag,
        dragDisable: dragDisable,
        dragEnable: yesdrag,
        dsvFormat: dsvFormat,
        csvParse: csvParse,
        csvParseRows: csvParseRows,
        csvFormat: csvFormat,
        csvFormatBody: csvFormatBody,
        csvFormatRows: csvFormatRows,
        csvFormatRow: csvFormatRow,
        csvFormatValue: csvFormatValue,
        tsvParse: tsvParse,
        tsvParseRows: tsvParseRows,
        tsvFormat: tsvFormat,
        tsvFormatBody: tsvFormatBody,
        tsvFormatRows: tsvFormatRows,
        tsvFormatRow: tsvFormatRow,
        tsvFormatValue: tsvFormatValue,
        autoType: autoType,
        easeLinear: linear$1,
        easeQuad: quadInOut,
        easeQuadIn: quadIn,
        easeQuadOut: quadOut,
        easeQuadInOut: quadInOut,
        easeCubic: cubicInOut,
        easeCubicIn: cubicIn,
        easeCubicOut: cubicOut,
        easeCubicInOut: cubicInOut,
        easePoly: polyInOut,
        easePolyIn: polyIn,
        easePolyOut: polyOut,
        easePolyInOut: polyInOut,
        easeSin: sinInOut,
        easeSinIn: sinIn,
        easeSinOut: sinOut,
        easeSinInOut: sinInOut,
        easeExp: expInOut,
        easeExpIn: expIn,
        easeExpOut: expOut,
        easeExpInOut: expInOut,
        easeCircle: circleInOut,
        easeCircleIn: circleIn,
        easeCircleOut: circleOut,
        easeCircleInOut: circleInOut,
        easeBounce: bounceOut,
        easeBounceIn: bounceIn,
        easeBounceOut: bounceOut,
        easeBounceInOut: bounceInOut,
        easeBack: backInOut,
        easeBackIn: backIn,
        easeBackOut: backOut,
        easeBackInOut: backInOut,
        easeElastic: elasticOut,
        easeElasticIn: elasticIn,
        easeElasticOut: elasticOut,
        easeElasticInOut: elasticInOut,
        blob: blob,
        buffer: buffer,
        dsv: dsv,
        csv: csv,
        tsv: tsv,
        image: image,
        json: json,
        text: text,
        xml: xml,
        html: html,
        svg: svg,
        forceCenter: center,
        forceCollide: collide,
        forceLink: link$2,
        forceManyBody: manyBody,
        forceRadial: radial$1,
        forceSimulation: simulation,
        forceX: x$2,
        forceY: y$1,
        formatDefaultLocale: defaultLocale$1,
        get format () { return format; },
        get formatPrefix () { return formatPrefix; },
        formatLocale: formatLocale$1,
        formatSpecifier: formatSpecifier,
        FormatSpecifier: FormatSpecifier,
        precisionFixed: precisionFixed,
        precisionPrefix: precisionPrefix,
        precisionRound: precisionRound,
        geoArea: area$2,
        geoBounds: bounds,
        geoCentroid: centroid$1,
        geoCircle: circle$2,
        geoClipAntimeridian: clipAntimeridian,
        geoClipCircle: clipCircle,
        geoClipExtent: extent,
        geoClipRectangle: clipRectangle,
        geoContains: contains$1,
        geoDistance: distance,
        geoGraticule: graticule,
        geoGraticule10: graticule10,
        geoInterpolate: interpolate,
        geoLength: length$1,
        geoPath: index$2,
        geoAlbers: albers,
        geoAlbersUsa: albersUsa,
        geoAzimuthalEqualArea: azimuthalEqualArea,
        geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
        geoAzimuthalEquidistant: azimuthalEquidistant,
        geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
        geoConicConformal: conicConformal,
        geoConicConformalRaw: conicConformalRaw,
        geoConicEqualArea: conicEqualArea,
        geoConicEqualAreaRaw: conicEqualAreaRaw,
        geoConicEquidistant: conicEquidistant,
        geoConicEquidistantRaw: conicEquidistantRaw,
        geoEqualEarth: equalEarth,
        geoEqualEarthRaw: equalEarthRaw,
        geoEquirectangular: equirectangular,
        geoEquirectangularRaw: equirectangularRaw,
        geoGnomonic: gnomonic,
        geoGnomonicRaw: gnomonicRaw,
        geoIdentity: identity$4,
        geoProjection: projection,
        geoProjectionMutator: projectionMutator,
        geoMercator: mercator,
        geoMercatorRaw: mercatorRaw,
        geoNaturalEarth1: naturalEarth1,
        geoNaturalEarth1Raw: naturalEarth1Raw,
        geoOrthographic: orthographic,
        geoOrthographicRaw: orthographicRaw,
        geoStereographic: stereographic,
        geoStereographicRaw: stereographicRaw,
        geoTransverseMercator: transverseMercator,
        geoTransverseMercatorRaw: transverseMercatorRaw,
        geoRotation: rotation,
        geoStream: geoStream,
        geoTransform: transform$1,
        cluster: cluster,
        hierarchy: hierarchy,
        Node: Node$2,
        pack: index$1,
        packSiblings: siblings,
        packEnclose: enclose,
        partition: partition,
        stratify: stratify,
        tree: tree,
        treemap: index,
        treemapBinary: binary,
        treemapDice: treemapDice,
        treemapSlice: treemapSlice,
        treemapSliceDice: sliceDice,
        treemapSquarify: squarify,
        treemapResquarify: resquarify,
        interpolate: interpolate$2,
        interpolateArray: array$3,
        interpolateBasis: basis$2,
        interpolateBasisClosed: basisClosed$1,
        interpolateDate: date$1,
        interpolateDiscrete: discrete,
        interpolateHue: hue,
        interpolateNumber: interpolateNumber,
        interpolateNumberArray: numberArray,
        interpolateObject: object$1,
        interpolateRound: interpolateRound,
        interpolateString: interpolateString,
        interpolateTransformCss: interpolateTransformCss,
        interpolateTransformSvg: interpolateTransformSvg,
        interpolateZoom: interpolateZoom,
        interpolateRgb: interpolateRgb,
        interpolateRgbBasis: rgbBasis,
        interpolateRgbBasisClosed: rgbBasisClosed,
        interpolateHsl: hsl$1,
        interpolateHslLong: hslLong,
        interpolateLab: lab,
        interpolateHcl: hcl$1,
        interpolateHclLong: hclLong,
        interpolateCubehelix: cubehelix$2,
        interpolateCubehelixLong: cubehelixLong,
        piecewise: piecewise,
        quantize: quantize$1,
        path: path,
        polygonArea: area$1,
        polygonCentroid: centroid,
        polygonHull: hull,
        polygonContains: contains,
        polygonLength: length,
        quadtree: quadtree,
        randomUniform: uniform,
        randomInt: int,
        randomNormal: normal,
        randomLogNormal: logNormal,
        randomBates: bates,
        randomIrwinHall: irwinHall,
        randomExponential: exponential,
        randomPareto: pareto,
        randomBernoulli: bernoulli,
        randomGeometric: geometric,
        randomBinomial: binomial,
        randomGamma: gamma,
        randomBeta: beta,
        randomWeibull: weibull,
        randomCauchy: cauchy,
        randomLogistic: logistic,
        randomPoisson: poisson,
        randomLcg: lcg,
        scaleBand: band,
        scalePoint: point$4,
        scaleIdentity: identity$2,
        scaleLinear: linear,
        scaleLog: log,
        scaleSymlog: symlog,
        scaleOrdinal: ordinal,
        scaleImplicit: implicit,
        scalePow: pow,
        scaleSqrt: sqrt$1,
        scaleRadial: radial,
        scaleQuantile: quantile,
        scaleQuantize: quantize,
        scaleThreshold: threshold,
        scaleTime: time,
        scaleUtc: utcTime,
        scaleSequential: sequential,
        scaleSequentialLog: sequentialLog,
        scaleSequentialPow: sequentialPow,
        scaleSequentialSqrt: sequentialSqrt,
        scaleSequentialSymlog: sequentialSymlog,
        scaleSequentialQuantile: sequentialQuantile,
        scaleDiverging: diverging$1,
        scaleDivergingLog: divergingLog,
        scaleDivergingPow: divergingPow,
        scaleDivergingSqrt: divergingSqrt,
        scaleDivergingSymlog: divergingSymlog,
        tickFormat: tickFormat,
        schemeCategory10: category10,
        schemeAccent: Accent,
        schemeDark2: Dark2,
        schemePaired: Paired,
        schemePastel1: Pastel1,
        schemePastel2: Pastel2,
        schemeSet1: Set1,
        schemeSet2: Set2,
        schemeSet3: Set3,
        schemeTableau10: Tableau10,
        interpolateBrBG: BrBG,
        schemeBrBG: scheme$q,
        interpolatePRGn: PRGn,
        schemePRGn: scheme$p,
        interpolatePiYG: PiYG,
        schemePiYG: scheme$o,
        interpolatePuOr: PuOr,
        schemePuOr: scheme$n,
        interpolateRdBu: RdBu,
        schemeRdBu: scheme$m,
        interpolateRdGy: RdGy,
        schemeRdGy: scheme$l,
        interpolateRdYlBu: RdYlBu,
        schemeRdYlBu: scheme$k,
        interpolateRdYlGn: RdYlGn,
        schemeRdYlGn: scheme$j,
        interpolateSpectral: Spectral,
        schemeSpectral: scheme$i,
        interpolateBuGn: BuGn,
        schemeBuGn: scheme$h,
        interpolateBuPu: BuPu,
        schemeBuPu: scheme$g,
        interpolateGnBu: GnBu,
        schemeGnBu: scheme$f,
        interpolateOrRd: OrRd,
        schemeOrRd: scheme$e,
        interpolatePuBuGn: PuBuGn,
        schemePuBuGn: scheme$d,
        interpolatePuBu: PuBu,
        schemePuBu: scheme$c,
        interpolatePuRd: PuRd,
        schemePuRd: scheme$b,
        interpolateRdPu: RdPu,
        schemeRdPu: scheme$a,
        interpolateYlGnBu: YlGnBu,
        schemeYlGnBu: scheme$9,
        interpolateYlGn: YlGn,
        schemeYlGn: scheme$8,
        interpolateYlOrBr: YlOrBr,
        schemeYlOrBr: scheme$7,
        interpolateYlOrRd: YlOrRd,
        schemeYlOrRd: scheme$6,
        interpolateBlues: Blues,
        schemeBlues: scheme$5,
        interpolateGreens: Greens,
        schemeGreens: scheme$4,
        interpolateGreys: Greys,
        schemeGreys: scheme$3,
        interpolatePurples: Purples,
        schemePurples: scheme$2,
        interpolateReds: Reds,
        schemeReds: scheme$1,
        interpolateOranges: Oranges,
        schemeOranges: scheme,
        interpolateCividis: cividis,
        interpolateCubehelixDefault: cubehelix,
        interpolateRainbow: rainbow,
        interpolateWarm: warm,
        interpolateCool: cool,
        interpolateSinebow: sinebow,
        interpolateTurbo: turbo,
        interpolateViridis: viridis,
        interpolateMagma: magma,
        interpolateInferno: inferno,
        interpolatePlasma: plasma,
        create: create$1,
        creator: creator,
        local: local$1,
        matcher: matcher,
        namespace: namespace,
        namespaces: namespaces,
        pointer: pointer,
        pointers: pointers,
        select: select,
        selectAll: selectAll,
        selection: selection,
        selector: selector,
        selectorAll: selectorAll,
        style: styleValue,
        window: defaultView,
        arc: arc,
        area: area,
        line: line,
        pie: pie,
        areaRadial: areaRadial,
        radialArea: areaRadial,
        lineRadial: lineRadial$1,
        radialLine: lineRadial$1,
        pointRadial: pointRadial,
        link: link,
        linkHorizontal: linkHorizontal,
        linkVertical: linkVertical,
        linkRadial: linkRadial,
        symbol: Symbol$1,
        symbolsStroke: symbolsStroke,
        symbolsFill: symbolsFill,
        symbols: symbolsFill,
        symbolAsterisk: asterisk,
        symbolCircle: circle,
        symbolCross: cross,
        symbolDiamond: diamond,
        symbolDiamond2: diamond2,
        symbolPlus: plus,
        symbolSquare: square,
        symbolSquare2: square2,
        symbolStar: star,
        symbolTriangle: triangle,
        symbolTriangle2: triangle2,
        symbolWye: wye,
        symbolX: x,
        curveBasisClosed: basisClosed,
        curveBasisOpen: basisOpen,
        curveBasis: basis,
        curveBumpX: bumpX,
        curveBumpY: bumpY,
        curveBundle: bundle,
        curveCardinalClosed: cardinalClosed,
        curveCardinalOpen: cardinalOpen,
        curveCardinal: cardinal,
        curveCatmullRomClosed: catmullRomClosed,
        curveCatmullRomOpen: catmullRomOpen,
        curveCatmullRom: catmullRom,
        curveLinearClosed: linearClosed,
        curveLinear: curveLinear,
        curveMonotoneX: monotoneX,
        curveMonotoneY: monotoneY,
        curveNatural: natural,
        curveStep: step,
        curveStepAfter: stepAfter,
        curveStepBefore: stepBefore,
        stack: stack,
        stackOffsetExpand: expand,
        stackOffsetDiverging: diverging,
        stackOffsetNone: none$1,
        stackOffsetSilhouette: silhouette,
        stackOffsetWiggle: wiggle,
        stackOrderAppearance: appearance,
        stackOrderAscending: ascending,
        stackOrderDescending: descending,
        stackOrderInsideOut: insideOut,
        stackOrderNone: none,
        stackOrderReverse: reverse,
        timeInterval: newInterval,
        timeMillisecond: millisecond$1,
        timeMilliseconds: milliseconds,
        utcMillisecond: millisecond$1,
        utcMilliseconds: milliseconds,
        timeSecond: utcSecond,
        timeSeconds: seconds,
        utcSecond: utcSecond,
        utcSeconds: seconds,
        timeMinute: timeMinute,
        timeMinutes: minutes,
        timeHour: timeHour,
        timeHours: hours,
        timeDay: timeDay,
        timeDays: days,
        timeWeek: sunday,
        timeWeeks: sundays,
        timeSunday: sunday,
        timeSundays: sundays,
        timeMonday: monday,
        timeMondays: mondays,
        timeTuesday: tuesday,
        timeTuesdays: tuesdays,
        timeWednesday: wednesday,
        timeWednesdays: wednesdays,
        timeThursday: thursday,
        timeThursdays: thursdays,
        timeFriday: friday,
        timeFridays: fridays,
        timeSaturday: saturday,
        timeSaturdays: saturdays,
        timeMonth: timeMonth,
        timeMonths: months,
        timeYear: timeYear,
        timeYears: years,
        utcMinute: utcMinute$1,
        utcMinutes: utcMinutes,
        utcHour: utcHour$1,
        utcHours: utcHours,
        utcDay: utcDay$1,
        utcDays: utcDays,
        utcWeek: utcSunday,
        utcWeeks: utcSundays,
        utcSunday: utcSunday,
        utcSundays: utcSundays,
        utcMonday: utcMonday,
        utcMondays: utcMondays,
        utcTuesday: utcTuesday,
        utcTuesdays: utcTuesdays,
        utcWednesday: utcWednesday,
        utcWednesdays: utcWednesdays,
        utcThursday: utcThursday,
        utcThursdays: utcThursdays,
        utcFriday: utcFriday,
        utcFridays: utcFridays,
        utcSaturday: utcSaturday,
        utcSaturdays: utcSaturdays,
        utcMonth: utcMonth$1,
        utcMonths: utcMonths,
        utcYear: utcYear$1,
        utcYears: utcYears,
        utcTicks: utcTicks,
        utcTickInterval: utcTickInterval,
        timeTicks: timeTicks,
        timeTickInterval: timeTickInterval,
        timeFormatDefaultLocale: defaultLocale,
        get timeFormat () { return timeFormat; },
        get timeParse () { return timeParse; },
        get utcFormat () { return utcFormat; },
        get utcParse () { return utcParse; },
        timeFormatLocale: formatLocale,
        isoFormat: formatIso$1,
        isoParse: parseIso$1,
        now: now,
        timer: timer,
        timerFlush: timerFlush,
        timeout: timeout,
        interval: interval,
        transition: transition,
        active: active,
        interrupt: interrupt,
        zoom: zoom,
        zoomTransform: transform,
        zoomIdentity: identity,
        ZoomTransform: Transform
    });

    /* src/components/DashD3.svelte generated by Svelte v3.45.0 */

    const file$a = "src/components/DashD3.svelte";

    // (478:4) {:else }
    function create_else_block$9(ctx) {
    	let svg;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			add_location(svg, file$a, 478, 8, 21611);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(478:4) {:else }",
    		ctx
    	});

    	return block;
    }

    // (476:4) {#if data.length === 0}
    function create_if_block$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading data...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(476:4) {#if data.length === 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div;

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0) return create_if_block$9;
    		return create_else_block$9;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "id", "dash-d3");
    			add_location(div, file$a, 474, 0, 21519);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const chartWidth = 1000;
    const barHeight = 1.5;
    const hoverColor = 'yellow';
    const selectColor = 'orange';

    function instance$a($$self, $$props, $$invalidate) {
    	let $screenWidthL;
    	let $screenWidthM;
    	let $screenWidthS;
    	let $events;
    	let $screenWidthXL;
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(2, $screenWidthL = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(3, $screenWidthM = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(4, $screenWidthS = $$value));
    	validate_store(events, 'events');
    	component_subscribe($$self, events, $$value => $$invalidate(37, $events = $$value));
    	validate_store(screenWidthXL, 'screenWidthXL');
    	component_subscribe($$self, screenWidthXL, $$value => $$invalidate(5, $screenWidthXL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DashD3', slots, []);
    	let { data = [] } = $$props;
    	let { selectedDay = DateTime_1.now().toSQLDate() } = $$props;
    	let eventData;
    	let groupData;
    	let capacityData;
    	let maxCapacity = 0;
    	let chartMarginLeft = 20;
    	let chartMarginTop = 20;
    	let chartSpacingEvents = 58;
    	let chartSpacingGroups = 5;
    	let barWidth;
    	let eventColor;
    	let groupColor;
    	let scaleFactor = 1.;
    	let scaleFactorCircle = 1.;
    	let barHeightEvent = 17;
    	let fontSize10 = 10;
    	let fontSize12 = 12;
    	const color = ordinal().domain(['cancelled', 'stayers', 'eventstayers', 'total', 'waitinglist']).range(['gray', '#5EAAA8', '#A3D2CA', 'black', 'lightgray']);

    	let d3Svg,
    		d3Bg,
    		d3Stayers,
    		d3Capacity,
    		d3Arrival,
    		d3Departure,
    		d3Events,
    		d3Groups,
    		d3Hover;

    	let xAxisDate, xAxisMonth, yAxisCount;

    	let xScaleBars,
    		xScaleEvents,
    		yScaleArrivalDeparture,
    		yScaleStayers,
    		yScaleEvents,
    		yScaleGroups;

    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		d3Svg = select('#dash-d3').select('svg').attr('style', 'max-width: 100%; height: auto; height: intrinsic;');
    		d3Bg = d3Svg.append('g');
    		xAxisDate = d3Svg.append('g');
    		xAxisMonth = d3Svg.append('g');
    		yAxisCount = d3Svg.append('g');
    		d3Stayers = d3Svg.append('g');
    		d3Capacity = d3Svg.append('g');
    		d3Departure = d3Svg.append('g');
    		d3Arrival = d3Svg.append('g');
    		d3Events = d3Svg.append('g');
    		d3Groups = d3Svg.append('g');
    		d3Hover = d3Svg.append('g');
    		eventColor = ordinal().domain([...$events.map(e => e.abbreviation)]).range(Dark2);
    	});

    	function adjustPeriodWidth() {
    		scaleFactor = $screenWidthS
    		? 2
    		: $screenWidthM ? 1.5 : $screenWidthL ? 1.2 : 1;

    		scaleFactorCircle = $screenWidthS
    		? 0.25
    		: $screenWidthM ? 0.31 : $screenWidthL ? 0.35 : 0.36;

    		chartMarginLeft = 20 * scaleFactor;
    		chartMarginTop = 20 * scaleFactor;
    		chartSpacingEvents = 58 * scaleFactor;
    		chartSpacingGroups = 5 * scaleFactor;
    		barHeightEvent = 17 * scaleFactor;
    	}

    	function update() {
    		if (data === undefined || d3Svg === undefined || data.length === 0) return;
    		const chartStartDate = min$2(data, d => DateTime_1.fromSQL(d.date));
    		const chartEndDate = max$3(data, d => DateTime_1.fromSQL(d.date).endOf('day'));
    		eventData = new Map();
    		data.map(stat => stat.events).forEach(stat => stat.forEach(event => eventData.set(event.abbreviation, event)));

    		eventData.forEach(e => e.chart_start = DateTime_1.fromSQL(e.start_date) >= chartStartDate
    		? DateTime_1.fromSQL(e.start_date)
    		: chartStartDate);

    		eventData.forEach(e => e.chart_end = DateTime_1.fromSQL(e.end_date) <= chartEndDate
    		? DateTime_1.fromSQL(e.end_date).endOf('day')
    		: chartEndDate.endOf('day'));

    		eventData = [...eventData.values()];
    		groupData = new Map();

    		// inelegant and complicated hack to deal with multiple groups of same name
    		let gCnt = new Map();

    		data.map(stat => {
    			return { date: stat.date, groups: stat.groups };
    		}).forEach(stat => stat.groups.forEach(group => {
    			if (!gCnt.has(group)) gCnt.set(group, 0);
    			let gId = group + '-' + gCnt.get(group);

    			if (groupData.has(gId)) {
    				if (groupData.get(gId).end_date !== undefined && Interval_1.fromDateTimes(groupData.get(gId).end_date, DateTime_1.fromSQL(stat.date)).length('days') > 1) {
    					gCnt.set(group, gCnt.get(group) + 1);
    					gId = group + '-' + gCnt.get(group);

    					groupData.set(gId, {
    						group,
    						start_date: DateTime_1.fromSQL(stat.date),
    						end_date: DateTime_1.fromSQL(stat.date).endOf('day')
    					});
    				} else groupData.set(gId, {
    					group,
    					start_date: groupData.get(gId).start_date,
    					end_date: DateTime_1.fromSQL(stat.date).endOf('day')
    				});
    			} else groupData.set(gId, {
    				group,
    				start_date: DateTime_1.fromSQL(stat.date),
    				end_date: DateTime_1.fromSQL(stat.date).endOf('day')
    			});
    		}));

    		groupData = [...groupData.values()];
    		groupColor = ordinal().domain([...groupData.map(g => g.group)]).range(Pastel1);
    		capacityData = [];

    		data.map(stat => {
    			return {
    				date: stat.date,
    				max_capacity: stat.max_capacity
    			};
    		}).forEach(day => {
    			if (capacityData.length === 0 || day.max_capacity !== capacityData[capacityData.length - 1].max_capacity) capacityData.push({
    				max_capacity: day.max_capacity,
    				start_date: DateTime_1.fromSQL(day.date),
    				end_date: DateTime_1.fromSQL(day.date).endOf('day')
    			}); else capacityData[capacityData.length - 1] = {
    				max_capacity: day.max_capacity,
    				start_date: capacityData[capacityData.length - 1].start_date,
    				end_date: DateTime_1.fromSQL(day.date).endOf('day')
    			};
    		});

    		maxCapacity = max$3(data, d => d.max_capacity);

    		// const maxStayers = data.reduce((prev, curr) => Math.max(prev, curr.total), 0)
    		const maxStayers = 130;

    		const stayersHeight = maxStayers * barHeight;
    		const eventsHeight = eventData.length * barHeightEvent;
    		const groupsHeight = groupData.length * barHeightEvent;
    		const chartHeightTotal = chartMarginTop + stayersHeight + eventsHeight + groupsHeight + chartSpacingEvents + chartSpacingGroups;
    		d3Svg.attr('viewBox', [0, 0, chartWidth + chartMarginLeft, chartHeightTotal]);
    		d3Hover.attr('transform', 'translate(' + chartMarginLeft + ', ' + chartMarginTop + ')');
    		d3Bg.attr('transform', 'translate(' + chartMarginLeft + ', ' + chartMarginTop + ')');
    		xAxisDate.attr('transform', 'translate(' + chartMarginLeft + ', ' + (chartMarginTop + stayersHeight + 3) + ')');
    		xAxisMonth.attr('transform', 'translate(' + chartMarginLeft + ', ' + chartMarginTop + ')');
    		yAxisCount.attr('transform', 'translate(' + chartMarginLeft + ', ' + chartMarginTop + ')');
    		d3Stayers.attr('transform', 'translate(' + chartMarginLeft + ', ' + chartMarginTop + ')');
    		d3Capacity.attr('transform', 'translate(' + chartMarginLeft + ',' + chartMarginTop + ')');
    		d3Arrival.attr('transform', 'translate(' + chartMarginLeft + ', ' + (chartMarginTop + stayersHeight + 30 * scaleFactor) + ')');
    		d3Departure.attr('transform', 'translate(' + chartMarginLeft + ', ' + (chartMarginTop + stayersHeight + 42 * scaleFactor) + ')');
    		d3Events.attr('transform', 'translate(' + chartMarginLeft + ', ' + (chartMarginTop + stayersHeight + chartSpacingEvents) + ')');
    		d3Groups.attr('transform', 'translate(' + chartMarginLeft + ', ' + (chartMarginTop + stayersHeight + eventsHeight + chartSpacingEvents + chartSpacingGroups) + ')');
    		yScaleStayers = linear().domain([0, maxStayers]).range([stayersHeight, 0]);
    		barWidth = chartWidth / data.length;
    		xScaleBars = band().domain(data.map(d => DateTime_1.fromSQL(d.date))).range([0, chartWidth]).paddingInner(0.1);
    		const xAxis = axisBottom(xScaleBars).tickSize(-stayersHeight).tickFormat(timeFormat('%-d.'));
    		xAxisDate.call(xAxis).select('.domain').remove();
    		xAxisDate.call(g => g.selectAll('.tick').selectAll('line').attr("x1", -barWidth / 2).attr("x2", -barWidth / 2).attr("y1", 12).style('color', 'lightgray').style('shape-rendering', 'crispEdges').filter(d => d.weekday !== 1).remove());
    		xAxisDate.call(g => g.selectAll('.tick text').attr('font-size', fontSize10 * scaleFactor));
    		const xAxisM = axisTop(xScaleBars).tickSize(-stayersHeight - 14 - 12).tickFormat(d => d.monthLong);
    		xAxisMonth.selectAll('g').remove();
    		xAxisMonth.call(xAxisM).select('.domain').remove();
    		xAxisMonth.call(g => g.selectAll('.tick').attr('id', d => d).filter((d, i) => !(d.day === 1 || i === 0 && d.daysInMonth - d.day >= 2)).remove());
    		xAxisMonth.call(g => g.selectAll('.tick line').style('shape-rendering', 'crispEdges').attr('transform', 'translate(0, -12)').attr("x1", -barWidth / 2).attr("x2", -barWidth / 2).filter(d => chartStartDate.toMillis() === d.toMillis()).remove());
    		xAxisMonth.call(g => g.selectAll('.tick text').attr("id", d => d.month));
    		xAxisMonth.call(g => g.selectAll('.tick text').attr("x", d => document.getElementById(d.month).getBBox().width / 2 - barWidth / 2 + 6 * scaleFactor * 2).attr('color', 'black').attr('font-size', fontSize12 * scaleFactor));
    		const yScaleBars = linear().range([stayersHeight, 0]).domain([0, maxStayers]);
    		const yAxis = axisLeft(yScaleBars).tickValues(yScaleBars.ticks().filter(n => n % 20 === 0)).tickFormat(format('d')).tickSize(-chartWidth);
    		yAxisCount.call(yAxis).call(g => g.select('.domain').remove()).call(g => g.selectAll('.tick line').attr('stroke-dasharray', (d, i) => i === 0 ? null : '2,2').attr('stroke-opacity', (d, i) => i === 0 ? 1 : 0.5).attr('stroke-width', (d, i) => i === 0 ? 1 : 0.5)).call(g => g.selectAll('.tick text').attr('font-size', fontSize10 * scaleFactor));
    		xScaleEvents = linear().domain([chartStartDate.toJSDate(), chartEndDate.toJSDate()]).range([0, chartWidth]);
    		yScaleEvents = band().domain(range$2(eventData.length)).range([eventsHeight, 0]).paddingInner(0.1);
    		yScaleGroups = band().domain(range$2(groupData.length)).range([groupsHeight, 0]).paddingInner(0.1);
    		updateBgHover(chartHeightTotal);
    		updateStayers();
    		updateCapacity();
    		updateEvents();
    		updateGroups();
    	}

    	function updateStayers() {
    		const series = stack().keys(['stayers', 'eventstayers']).order(none).offset(none$1)(data);
    		d3Stayers.selectAll('g').remove();
    		d3Stayers.append('g').selectAll('g').data(series).join('g').attr('fill', d => color(d.key)).selectAll('rect').data(d => d).join('rect').attr('x', d => xScaleBars(DateTime_1.fromSQL(d.data.date).toJSDate())).attr('y', d => yScaleStayers(d[1])).attr('width', xScaleBars.bandwidth()).attr('height', d => yScaleStayers(d[0]) - yScaleStayers(d[1]));
    		d3Arrival.selectAll('circle').data(data).join('circle').attr('cx', d => xScaleBars(DateTime_1.fromSQL(d.date).toJSDate()) + xScaleBars.bandwidth() * 0.33).attr('r', xScaleBars.bandwidth() * scaleFactorCircle).style('fill', d => turbo(0.67 + d.arrivals / maxCapacity / 3)).style('opacity', d => d.arrivals > 0 ? 1 : 0);
    		d3Arrival.selectAll('text').data(data).join('text').text(d => d.arrivals > 0 ? '+' + d.arrivals : null).attr('x', d => xScaleBars(DateTime_1.fromSQL(d.date).toJSDate()) + xScaleBars.bandwidth() * 0.33).attr('y', 0.5).style('text-anchor', 'middle').style('dominant-baseline', 'middle').attr('font-size', fontSize10 * scaleFactor).style('fill', 'white');
    		d3Departure.selectAll('circle').data(data).join('circle').attr('cx', d => xScaleBars(DateTime_1.fromSQL(d.date).toJSDate()) + xScaleBars.bandwidth() * 0.66).attr('r', xScaleBars.bandwidth() * scaleFactorCircle).style('fill', d => PuBu(0.33 + d.departures / maxCapacity / 3)).style('opacity', d => d.departures > 0 ? 0.5 : 0);
    		d3Departure.selectAll('text').data(data).join('text').text(d => d.departures > 0 ? '-' + d.departures : null).attr('x', d => xScaleBars(DateTime_1.fromSQL(d.date).toJSDate()) + xScaleBars.bandwidth() * 0.66).attr('y', 0.5).style('text-anchor', 'middle').style('dominant-baseline', 'middle').attr('font-size', fontSize10 * scaleFactor).style('fill', 'black');
    	}

    	function updateCapacity() {
    		d3Capacity.selectAll('line').data(capacityData).join('line').attr('x1', d => xScaleEvents(d.start_date.toJSDate())).attr('y1', d => yScaleStayers(d.max_capacity)).attr('x2', d => xScaleEvents(d.end_date.toJSDate())).attr('y2', d => yScaleStayers(d.max_capacity)).attr('stroke', 'red').attr('stroke-width', scaleFactor).attr('opacity', 0.8).style('shape-rendering', 'crispEdges');
    	} // .attr('stroke-dasharray', '4 1')

    	function updateEvents() {
    		d3Events.selectAll('rect').data(eventData, d => d.abbreviation).join('rect').attr('x', d => xScaleEvents(d.chart_start.toJSDate())).attr('width', d => xScaleEvents(d.chart_end.toJSDate()) - xScaleEvents(d.chart_start.toJSDate())).attr('y', (d, i) => yScaleEvents(i)).attr('height', yScaleEvents.bandwidth()).attr('rx', 2 * scaleFactor).// .attr('fill', d => eventColor(d.abbreviation))
    		attr('fill', '#550A46').attr('opacity', 0.8);

    		d3Events.selectAll('text').data(eventData, d => d.abbreviation).join('text').text(d => d.abbreviation).attr('x', d => xScaleEvents(d.chart_start.toJSDate()) + 4).attr('y', (d, i) => yScaleEvents(i) + (yScaleEvents.bandwidth() - fontSize12 * scaleFactor) / 2 + 1).attr("font-size", fontSize12 * scaleFactor).attr('fill', 'white').style('text-anchor', 'start').style('dominant-baseline', 'hanging');
    	}

    	function updateGroups() {
    		d3Groups.selectAll('rect').data(groupData, d => d.group).join('rect').attr('x', d => xScaleEvents(d.start_date.toJSDate())).attr('width', d => xScaleEvents(d.end_date.toJSDate()) - xScaleEvents(d.start_date.toJSDate())).attr('y', (d, i) => yScaleGroups(i)).attr('height', yScaleGroups.bandwidth()).attr('rx', 2 * scaleFactor).// .attr('fill', d => groupColor(d.group))
    		attr('fill', '#204051').attr('opacity', 0.8);

    		d3Groups.selectAll('text').data(groupData, d => d.group).join('text').text(d => d.group).attr('x', d => xScaleEvents(d.start_date.toJSDate()) + 4).attr('y', (d, i) => yScaleGroups(i) + (yScaleGroups.bandwidth() - fontSize12 * scaleFactor) / 2 + 1).attr("font-size", fontSize12 * scaleFactor).attr('fill', 'white').style('text-anchor', 'start').style('dominant-baseline', 'hanging');
    	}

    	function updateBgHover(chartHeightTotal) {
    		d3Bg.selectAll('rect').data(data, d => d.date).join('rect').// .filter(d => )
    		attr('id', d => 'bg-ad-' + d.date).attr('x', d => xScaleBars(DateTime_1.fromSQL(d.date).toJSDate())).attr('width', xScaleBars.bandwidth()).attr('y', 0).attr('height', chartHeightTotal).style('opacity', 0.2).style('fill', d => d.date === selectedDay ? selectColor : 'transparent');

    		d3Hover.selectAll('rect').data(data, d => d.date).join('rect').attr('id', d => 'hover-' + d.date).attr('x', d => xScaleBars(DateTime_1.fromSQL(d.date).toJSDate())).attr('width', barWidth).attr('y', 0).attr('height', chartHeightTotal).style('fill', 'transparent').style('opacity', 0.3).on('mouseover', (event, d) => {
    			select('#hover-' + d.date).style('fill', hoverColor);
    			select('#tooltip').classed('hidden', false);
    			select('#tooltipHead').text(DateTime_1.fromSQL(d.date).toFormat('ccc dd. LLL'));
    			let newHtml = [];
    			newHtml.push('<tr>', '<td style="padding-left: 4px; background-color: ' + turbo(0.67 + d.arrivals / maxCapacity / 3) + '"></td>', '<td style="padding-left: 4px">Arrivals: </td>', '<td style="padding-left: 4px padding-right: 4px"><strong>' + d.arrivals + '</strong></td>', '</tr>');
    			newHtml.push('<tr>', '<td style="padding-left: 4px; background-color: ' + PuBu(0.33 + d.departures / maxCapacity / 3) + '"></td>', '<td style="padding-left: 4px">Departures: </td>', '<td style="padding-left: 4px padding-right: 4px"><strong>' + d.departures + '</strong></td>', '</tr>');

    			if (d.cancelled > 0) {
    				newHtml.push('<tr>', '<td style="padding-left: 4px; background-color: ' + color('cancelled') + '"></td>', '<td style="padding-left: 4px">Cancelled: </td>', '<td style="padding-left: 4px padding-right: 4px"><strong>' + d.cancelled + '</strong></td>', '</tr>');
    			}

    			select('#tooltipArrivalDeparture').html(newHtml.join(""));
    			newHtml = [];

    			if (d.eventstayers > 0) {
    				newHtml.push('<tr>', '<td style="padding-left: 4px; background-color: ' + color('eventstayers') + '"></td>', '<td style="padding-left: 4px">Event stayers: </td>', '<td style="padding-left: 4px padding-right: 4px"><strong>' + d.eventstayers + '</strong></td>', '</tr>');
    			}

    			newHtml.push('<tr>', '<td style="padding-left: 4px; background-color: ' + color('stayers') + '"></td>', '<td style="padding-left: 4px">Stayers: </td>', '<td style="padding-left: 4px padding-right: 4px"><strong>' + d.stayers + '</strong></td>', '</tr>');
    			newHtml.push('<tr>', '<td style="padding-left: 4px" class="paf-tooltip-total"></td>', '<td style="padding-left: 4px"><strong>Total: </strong></td>', '<td style="padding-left: 4px padding-right: 4px"><strong>' + d.total + '</strong></td>', '</tr>');
    			select('#tooltipStayers').html(newHtml.join(""));
    			newHtml = [];

    			if (d.waitinglist > 0) {
    				newHtml.push('<tr>', '<td style="padding-left: 4px; background-color: ' + color('waitinglist') + '"></td>', '<td style="padding-left: 4px">Waiting list: </td>', '<td style="padding-left: 4px padding-right: 4px"><strong>' + d.waitinglist + '</strong></td>', '</tr>');
    				select('#tooltipWaitingListDiv').classed('hidden', false);
    			} else select('#tooltipWaitingListDiv').classed('hidden', true);

    			select('#tooltipWaitingList').html(newHtml.join(""));
    		}).on('mousemove', (event, d) => {
    			select('#tooltip').style('left', event.pageX + 30 + 'px').style('top', event.pageY + 'px');
    		}).on('mouseout', (event, d) => {
    			d3Hover.selectAll('rect').nodes().indexOf(event.currentTarget);
    			select('#hover-' + d.date).style('fill', 'transparent');
    			select('#tooltip').classed('hidden', true);
    		}).on('click', (event, d) => {
    			dispatch('message', { select: d.date });
    		});
    	}

    	const writable_props = ['data', 'selectedDay'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DashD3> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('selectedDay' in $$props) $$invalidate(1, selectedDay = $$props.selectedDay);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		DateTime: DateTime_1,
    		Duration: Duration_1,
    		Interval: Interval_1,
    		events,
    		d3,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		screenWidthXL,
    		data,
    		selectedDay,
    		eventData,
    		groupData,
    		capacityData,
    		maxCapacity,
    		chartWidth,
    		chartMarginLeft,
    		chartMarginTop,
    		chartSpacingEvents,
    		chartSpacingGroups,
    		barHeight,
    		barWidth,
    		hoverColor,
    		selectColor,
    		eventColor,
    		groupColor,
    		scaleFactor,
    		scaleFactorCircle,
    		barHeightEvent,
    		fontSize10,
    		fontSize12,
    		color,
    		d3Svg,
    		d3Bg,
    		d3Stayers,
    		d3Capacity,
    		d3Arrival,
    		d3Departure,
    		d3Events,
    		d3Groups,
    		d3Hover,
    		xAxisDate,
    		xAxisMonth,
    		yAxisCount,
    		xScaleBars,
    		xScaleEvents,
    		yScaleArrivalDeparture,
    		yScaleStayers,
    		yScaleEvents,
    		yScaleGroups,
    		dispatch,
    		adjustPeriodWidth,
    		update,
    		updateStayers,
    		updateCapacity,
    		updateEvents,
    		updateGroups,
    		updateBgHover,
    		$screenWidthL,
    		$screenWidthM,
    		$screenWidthS,
    		$events,
    		$screenWidthXL
    	});

    	$$self.$inject_state = $$props => {
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('selectedDay' in $$props) $$invalidate(1, selectedDay = $$props.selectedDay);
    		if ('eventData' in $$props) eventData = $$props.eventData;
    		if ('groupData' in $$props) groupData = $$props.groupData;
    		if ('capacityData' in $$props) capacityData = $$props.capacityData;
    		if ('maxCapacity' in $$props) maxCapacity = $$props.maxCapacity;
    		if ('chartMarginLeft' in $$props) chartMarginLeft = $$props.chartMarginLeft;
    		if ('chartMarginTop' in $$props) chartMarginTop = $$props.chartMarginTop;
    		if ('chartSpacingEvents' in $$props) chartSpacingEvents = $$props.chartSpacingEvents;
    		if ('chartSpacingGroups' in $$props) chartSpacingGroups = $$props.chartSpacingGroups;
    		if ('barWidth' in $$props) barWidth = $$props.barWidth;
    		if ('eventColor' in $$props) eventColor = $$props.eventColor;
    		if ('groupColor' in $$props) groupColor = $$props.groupColor;
    		if ('scaleFactor' in $$props) scaleFactor = $$props.scaleFactor;
    		if ('scaleFactorCircle' in $$props) scaleFactorCircle = $$props.scaleFactorCircle;
    		if ('barHeightEvent' in $$props) barHeightEvent = $$props.barHeightEvent;
    		if ('fontSize10' in $$props) fontSize10 = $$props.fontSize10;
    		if ('fontSize12' in $$props) fontSize12 = $$props.fontSize12;
    		if ('d3Svg' in $$props) d3Svg = $$props.d3Svg;
    		if ('d3Bg' in $$props) d3Bg = $$props.d3Bg;
    		if ('d3Stayers' in $$props) d3Stayers = $$props.d3Stayers;
    		if ('d3Capacity' in $$props) d3Capacity = $$props.d3Capacity;
    		if ('d3Arrival' in $$props) d3Arrival = $$props.d3Arrival;
    		if ('d3Departure' in $$props) d3Departure = $$props.d3Departure;
    		if ('d3Events' in $$props) d3Events = $$props.d3Events;
    		if ('d3Groups' in $$props) d3Groups = $$props.d3Groups;
    		if ('d3Hover' in $$props) d3Hover = $$props.d3Hover;
    		if ('xAxisDate' in $$props) xAxisDate = $$props.xAxisDate;
    		if ('xAxisMonth' in $$props) xAxisMonth = $$props.xAxisMonth;
    		if ('yAxisCount' in $$props) yAxisCount = $$props.yAxisCount;
    		if ('xScaleBars' in $$props) xScaleBars = $$props.xScaleBars;
    		if ('xScaleEvents' in $$props) xScaleEvents = $$props.xScaleEvents;
    		if ('yScaleArrivalDeparture' in $$props) yScaleArrivalDeparture = $$props.yScaleArrivalDeparture;
    		if ('yScaleStayers' in $$props) yScaleStayers = $$props.yScaleStayers;
    		if ('yScaleEvents' in $$props) yScaleEvents = $$props.yScaleEvents;
    		if ('yScaleGroups' in $$props) yScaleGroups = $$props.yScaleGroups;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*$screenWidthS, $screenWidthM, $screenWidthL, $screenWidthXL*/ 60) {
    			($screenWidthS || $screenWidthM || $screenWidthL || $screenWidthXL) && adjustPeriodWidth();
    		}

    		if ($$self.$$.dirty[0] & /*data*/ 1) {
    			data && update();
    		}

    		if ($$self.$$.dirty[0] & /*selectedDay*/ 2) {
    			selectedDay && update();
    		}
    	};

    	return [data, selectedDay, $screenWidthL, $screenWidthM, $screenWidthS, $screenWidthXL];
    }

    class DashD3 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$a, create_fragment$a, safe_not_equal, { data: 0, selectedDay: 1 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DashD3",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get data() {
    		throw new Error("<DashD3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<DashD3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedDay() {
    		throw new Error("<DashD3>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedDay(value) {
    		throw new Error("<DashD3>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Dashboard.svelte generated by Svelte v3.45.0 */
    const file$9 = "src/components/Dashboard.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i];
    	return child_ctx;
    }

    // (104:8) {:else }
    function create_else_block$8(ctx) {
    	let dashd3;
    	let updating_data;
    	let updating_selectedDay;
    	let current;

    	function dashd3_data_binding(value) {
    		/*dashd3_data_binding*/ ctx[14](value);
    	}

    	function dashd3_selectedDay_binding(value) {
    		/*dashd3_selectedDay_binding*/ ctx[15](value);
    	}

    	let dashd3_props = {};

    	if (/*data*/ ctx[1] !== void 0) {
    		dashd3_props.data = /*data*/ ctx[1];
    	}

    	if (/*selectedDay*/ ctx[2] !== void 0) {
    		dashd3_props.selectedDay = /*selectedDay*/ ctx[2];
    	}

    	dashd3 = new DashD3({ props: dashd3_props, $$inline: true });
    	binding_callbacks.push(() => bind$1(dashd3, 'data', dashd3_data_binding));
    	binding_callbacks.push(() => bind$1(dashd3, 'selectedDay', dashd3_selectedDay_binding));
    	dashd3.$on("message", /*fetchDayStats*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(dashd3.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dashd3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dashd3_changes = {};

    			if (!updating_data && dirty & /*data*/ 2) {
    				updating_data = true;
    				dashd3_changes.data = /*data*/ ctx[1];
    				add_flush_callback(() => updating_data = false);
    			}

    			if (!updating_selectedDay && dirty & /*selectedDay*/ 4) {
    				updating_selectedDay = true;
    				dashd3_changes.selectedDay = /*selectedDay*/ ctx[2];
    				add_flush_callback(() => updating_selectedDay = false);
    			}

    			dashd3.$set(dashd3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dashd3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dashd3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dashd3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(104:8) {:else }",
    		ctx
    	});

    	return block;
    }

    // (102:8) {#if data.length === 0}
    function create_if_block_4$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading data...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(102:8) {#if data.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (113:12) {#if category.details.length > 0}
    function create_if_block$8(ctx) {
    	let div;
    	let h3;
    	let span;
    	let t0;
    	let t1_value = /*category*/ ctx[20].label + ': ' + /*category*/ ctx[20].count + "";
    	let t1;
    	let t2;
    	let t3;
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t5;
    	let th1;
    	let t7;
    	let th2;
    	let t9;
    	let th3;
    	let t11;
    	let th4;
    	let t12_value = (/*$screenWidthL*/ ctx[0] ? '' : 'PAF ') + "";
    	let t12;
    	let t13;
    	let t14;
    	let th5;
    	let t16;
    	let tbody;
    	let t17;
    	let each_value_1 = /*category*/ ctx[20].details;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			span = element("span");
    			t0 = text$1("");
    			t1 = text$1(t1_value);
    			t2 = text$1("");
    			t3 = space();
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Name";
    			t5 = space();
    			th1 = element("th");
    			th1.textContent = "People";
    			t7 = space();
    			th2 = element("th");
    			th2.textContent = "Stay";
    			t9 = space();
    			th3 = element("th");
    			th3.textContent = "Notes";
    			t11 = space();
    			th4 = element("th");
    			t12 = text$1(t12_value);
    			t13 = text$1("Events");
    			t14 = space();
    			th5 = element("th");
    			th5.textContent = "Group";
    			t16 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t17 = space();
    			add_location(span, file$9, 114, 120, 4489);
    			attr_dev(h3, "class", "uk-heading-line uk-text-center uk-text-light");
    			toggle_class(h3, "uk-text-muted", /*category*/ ctx[20].count === 0);
    			add_location(h3, file$9, 114, 20, 4389);
    			add_location(th0, file$9, 118, 28, 4757);
    			attr_dev(th1, "class", "uk-table-shrink");
    			add_location(th1, file$9, 119, 28, 4799);
    			add_location(th2, file$9, 120, 28, 4867);
    			attr_dev(th3, "class", "uk-visible@s uk-table-shrink");
    			add_location(th3, file$9, 121, 28, 4909);
    			attr_dev(th4, "class", "uk-visible@m");
    			add_location(th4, file$9, 122, 28, 4989);
    			attr_dev(th5, "class", "uk-visible@l");
    			add_location(th5, file$9, 123, 28, 5083);
    			add_location(tr, file$9, 117, 24, 4724);
    			add_location(thead, file$9, 116, 24, 4692);
    			add_location(tbody, file$9, 126, 24, 5206);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$9, 115, 20, 4582);
    			attr_dev(div, "class", "uk-margin-medium uk-margin-top");
    			add_location(div, file$9, 113, 16, 4324);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(h3, span);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			append_dev(div, t3);
    			append_dev(div, table);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t5);
    			append_dev(tr, th1);
    			append_dev(tr, t7);
    			append_dev(tr, th2);
    			append_dev(tr, t9);
    			append_dev(tr, th3);
    			append_dev(tr, t11);
    			append_dev(tr, th4);
    			append_dev(th4, t12);
    			append_dev(th4, t13);
    			append_dev(tr, t14);
    			append_dev(tr, th5);
    			append_dev(table, t16);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(div, t17);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dayData*/ 8 && t1_value !== (t1_value = /*category*/ ctx[20].label + ': ' + /*category*/ ctx[20].count + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*dayData*/ 8) {
    				toggle_class(h3, "uk-text-muted", /*category*/ ctx[20].count === 0);
    			}

    			if (dirty & /*$screenWidthL*/ 1 && t12_value !== (t12_value = (/*$screenWidthL*/ ctx[0] ? '' : 'PAF ') + "")) set_data_dev(t12, t12_value);

    			if (dirty & /*dayData, DateTime*/ 8) {
    				each_value_1 = /*category*/ ctx[20].details;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(113:12) {#if category.details.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (133:57) {#if details.info}
    function create_if_block_3$4(ctx) {
    	let span;
    	let span_uk_tooltip_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "uk-icon", "icon: info");
    			attr_dev(span, "uk-tooltip", span_uk_tooltip_value = "title: " + /*details*/ ctx[23].info.trim());
    			add_location(span, file$9, 132, 75, 5784);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dayData*/ 8 && span_uk_tooltip_value !== (span_uk_tooltip_value = "title: " + /*details*/ ctx[23].info.trim())) {
    				attr_dev(span, "uk-tooltip", span_uk_tooltip_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(133:57) {#if details.info}",
    		ctx
    	});

    	return block;
    }

    // (135:36) {#if details.events.length > 0}
    function create_if_block_2$4(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*details*/ ctx[23].events;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dayData*/ 8) {
    				each_value_2 = /*details*/ ctx[23].events;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(135:36) {#if details.events.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (136:40) {#each details.events as event}
    function create_each_block_2(ctx) {
    	let span;
    	let t0_value = /*event*/ ctx[26].abbreviation + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text$1(t0_value);
    			t1 = text$1("");
    			attr_dev(span, "class", "uk-label");
    			toggle_class(span, "uk-label-success", /*event*/ ctx[26].confirmed);
    			toggle_class(span, "uk-label-warning", !/*event*/ ctx[26].confirmed);
    			add_location(span, file$9, 136, 44, 6114);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dayData*/ 8 && t0_value !== (t0_value = /*event*/ ctx[26].abbreviation + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*dayData*/ 8) {
    				toggle_class(span, "uk-label-success", /*event*/ ctx[26].confirmed);
    			}

    			if (dirty & /*dayData*/ 8) {
    				toggle_class(span, "uk-label-warning", !/*event*/ ctx[26].confirmed);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(136:40) {#each details.events as event}",
    		ctx
    	});

    	return block;
    }

    // (142:36) {#if details.group_name !== null}
    function create_if_block_1$4(ctx) {
    	let span;
    	let t0_value = /*details*/ ctx[23].group_name + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text$1(t0_value);
    			t1 = text$1("");
    			attr_dev(span, "class", "uk-label uk-background-secondary");
    			add_location(span, file$9, 142, 40, 6550);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dayData*/ 8 && t0_value !== (t0_value = /*details*/ ctx[23].group_name + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(142:36) {#if details.group_name !== null}",
    		ctx
    	});

    	return block;
    }

    // (128:24) {#each category.details as details}
    function create_each_block_1$1(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*details*/ ctx[23].name + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*details*/ ctx[23].people_count + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = DateTime_1.fromISO(/*details*/ ctx[23].arrival).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromISO(/*details*/ ctx[23].departure).toFormat('dd LLL yyyy') + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6;
    	let td4;
    	let t7;
    	let td5;
    	let t8;
    	let if_block0 = /*details*/ ctx[23].info && create_if_block_3$4(ctx);
    	let if_block1 = /*details*/ ctx[23].events.length > 0 && create_if_block_2$4(ctx);
    	let if_block2 = /*details*/ ctx[23].group_name !== null && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			if (if_block0) if_block0.c();
    			t6 = space();
    			td4 = element("td");
    			if (if_block1) if_block1.c();
    			t7 = space();
    			td5 = element("td");
    			if (if_block2) if_block2.c();
    			t8 = space();
    			add_location(td0, file$9, 129, 32, 5441);
    			add_location(td1, file$9, 130, 32, 5497);
    			attr_dev(td2, "class", "");
    			add_location(td2, file$9, 131, 32, 5561);
    			attr_dev(td3, "class", "uk-visible@s");
    			add_location(td3, file$9, 132, 32, 5741);
    			attr_dev(td4, "class", "uk-visible@m");
    			add_location(td4, file$9, 133, 32, 5904);
    			attr_dev(td5, "class", "uk-visible@l");
    			add_location(td5, file$9, 140, 32, 6414);
    			attr_dev(tr, "class", "uk-table-link");
    			toggle_class(tr, "uk-text-muted", /*details*/ ctx[23].cancelled);
    			toggle_class(tr, "strikethrough", /*details*/ ctx[23].cancelled);
    			add_location(tr, file$9, 128, 28, 5302);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			if (if_block0) if_block0.m(td3, null);
    			append_dev(tr, t6);
    			append_dev(tr, td4);
    			if (if_block1) if_block1.m(td4, null);
    			append_dev(tr, t7);
    			append_dev(tr, td5);
    			if (if_block2) if_block2.m(td5, null);
    			append_dev(tr, t8);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dayData*/ 8 && t0_value !== (t0_value = /*details*/ ctx[23].name + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*dayData*/ 8 && t2_value !== (t2_value = /*details*/ ctx[23].people_count + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*dayData*/ 8 && t4_value !== (t4_value = DateTime_1.fromISO(/*details*/ ctx[23].arrival).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromISO(/*details*/ ctx[23].departure).toFormat('dd LLL yyyy') + "")) set_data_dev(t4, t4_value);

    			if (/*details*/ ctx[23].info) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					if_block0.m(td3, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*details*/ ctx[23].events.length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$4(ctx);
    					if_block1.c();
    					if_block1.m(td4, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*details*/ ctx[23].group_name !== null) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_1$4(ctx);
    					if_block2.c();
    					if_block2.m(td5, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*dayData*/ 8) {
    				toggle_class(tr, "uk-text-muted", /*details*/ ctx[23].cancelled);
    			}

    			if (dirty & /*dayData*/ 8) {
    				toggle_class(tr, "strikethrough", /*details*/ ctx[23].cancelled);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(128:24) {#each category.details as details}",
    		ctx
    	});

    	return block;
    }

    // (112:8) {#each dayData as category}
    function create_each_block$5(ctx) {
    	let if_block_anchor;
    	let if_block = /*category*/ ctx[20].details.length > 0 && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*category*/ ctx[20].details.length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(112:8) {#each dayData as category}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let div5;
    	let div4;
    	let div3;
    	let div0;
    	let a0;
    	let t0;
    	let span;
    	let t1_value = DateTime_1.fromISO(/*selectedDay*/ ctx[2]).toFormat('dd LLL yyyy') + "";
    	let t1;
    	let t2;
    	let div1;
    	let a1;
    	let t3;
    	let input;
    	let t4;
    	let div2;
    	let a2;
    	let t5;
    	let div7;
    	let div6;
    	let current_block_type_index;
    	let if_block;
    	let t6;
    	let div9;
    	let div8;
    	let t7;
    	let div14;
    	let div10;
    	let table0;
    	let tr;
    	let td0;
    	let t8;
    	let td1;
    	let strong;
    	let t9;
    	let div11;
    	let table1;
    	let tbody0;
    	let t10;
    	let div12;
    	let table2;
    	let tbody1;
    	let t11;
    	let div13;
    	let table3;
    	let tbody2;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_4$3, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[1].length === 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = /*dayData*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			a0 = element("a");
    			t0 = space();
    			span = element("span");
    			t1 = text$1(t1_value);
    			t2 = space();
    			div1 = element("div");
    			a1 = element("a");
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			div2 = element("div");
    			a2 = element("a");
    			t5 = space();
    			div7 = element("div");
    			div6 = element("div");
    			if_block.c();
    			t6 = space();
    			div9 = element("div");
    			div8 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t7 = space();
    			div14 = element("div");
    			div10 = element("div");
    			table0 = element("table");
    			tr = element("tr");
    			td0 = element("td");
    			t8 = space();
    			td1 = element("td");
    			strong = element("strong");
    			t9 = space();
    			div11 = element("div");
    			table1 = element("table");
    			tbody0 = element("tbody");
    			t10 = space();
    			div12 = element("div");
    			table2 = element("table");
    			tbody1 = element("tbody");
    			t11 = space();
    			div13 = element("div");
    			table3 = element("table");
    			tbody2 = element("tbody");
    			attr_dev(a0, "href", '#');
    			attr_dev(a0, "uk-icon", "icon: chevron-left");
    			attr_dev(a0, "uk-tooltip", "- 7 days");
    			add_location(a0, file$9, 88, 64, 2944);
    			attr_dev(div0, "class", "paf-arrow-circle uk-margin-small-right");
    			add_location(div0, file$9, 88, 12, 2892);
    			attr_dev(span, "class", "uk-text-lead uk-margin-left uk-margin-small-right");
    			add_location(span, file$9, 89, 12, 3063);
    			attr_dev(a1, "href", '#');
    			attr_dev(a1, "uk-icon", "icon: calendar");
    			attr_dev(a1, "class", "uk-position-center");
    			attr_dev(a1, "uk-tooltip", "Select date range");
    			add_location(a1, file$9, 91, 16, 3278);
    			attr_dev(input, "class", "uk-input uk-form-blank uk-form-width-xsmall");
    			attr_dev(input, "id", "date-select");
    			attr_dev(input, "type", "text");
    			input.readOnly = true;
    			set_style(input, "color", "transparent");
    			add_location(input, file$9, 92, 16, 3435);
    			attr_dev(div1, "class", "uk-inline");
    			add_location(div1, file$9, 90, 12, 3238);
    			attr_dev(a2, "href", '#');
    			attr_dev(a2, "uk-icon", "icon: chevron-right");
    			attr_dev(a2, "uk-tooltip", "+ 7 days");
    			add_location(a2, file$9, 94, 63, 3642);
    			attr_dev(div2, "class", "paf-arrow-circle uk-margin-small-left");
    			add_location(div2, file$9, 94, 12, 3591);
    			attr_dev(div3, "class", "uk-flex uk-flex-center uk-flex-middle");
    			add_location(div3, file$9, 87, 8, 2828);
    			attr_dev(div4, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6 paf-top-section-bg");
    			add_location(div4, file$9, 86, 4, 2730);
    			attr_dev(div5, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div5, file$9, 85, 0, 2652);
    			attr_dev(div6, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6");
    			add_location(div6, file$9, 100, 4, 3856);
    			attr_dev(div7, "class", "uk-flex uk-flex-center uk-margin-top uk-margin-bottom");
    			add_location(div7, file$9, 99, 0, 3784);
    			attr_dev(div8, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6");
    			add_location(div8, file$9, 110, 4, 4155);
    			attr_dev(div9, "class", "uk-flex uk-flex-center");
    			add_location(div9, file$9, 109, 0, 4114);
    			set_style(td0, "padding-left", "8px");
    			add_location(td0, file$9, 159, 16, 7055);
    			attr_dev(strong, "id", "tooltipHead");
    			add_location(strong, file$9, 160, 20, 7112);
    			add_location(td1, file$9, 160, 16, 7108);
    			add_location(tr, file$9, 158, 12, 7034);
    			add_location(table0, file$9, 157, 8, 7014);
    			set_style(div10, "padding-top", "4px");
    			set_style(div10, "padding-bottom", "2px");
    			add_location(div10, file$9, 156, 4, 6953);
    			attr_dev(tbody0, "id", "tooltipArrivalDeparture");
    			add_location(tbody0, file$9, 166, 12, 7326);
    			add_location(table1, file$9, 165, 8, 7306);
    			set_style(div11, "border-top-style", "solid");
    			set_style(div11, "border-width", "1px");
    			set_style(div11, "border-color", "darkgrey");
    			set_style(div11, "padding", "4px");
    			add_location(div11, file$9, 164, 4, 7202);
    			attr_dev(tbody1, "id", "tooltipStayers");
    			add_location(tbody1, file$9, 171, 12, 7527);
    			add_location(table2, file$9, 170, 8, 7507);
    			set_style(div12, "border-top-style", "solid");
    			set_style(div12, "border-width", "1px");
    			set_style(div12, "border-color", "darkgrey");
    			set_style(div12, "padding", "4px");
    			add_location(div12, file$9, 169, 4, 7403);
    			attr_dev(tbody2, "id", "tooltipWaitingList");
    			add_location(tbody2, file$9, 176, 12, 7761);
    			add_location(table3, file$9, 175, 8, 7741);
    			attr_dev(div13, "id", "tooltipWaitingListDiv");
    			set_style(div13, "border-top-style", "solid");
    			set_style(div13, "border-width", "1px");
    			set_style(div13, "border-color", "darkgrey");
    			set_style(div13, "padding", "4px");
    			attr_dev(div13, "class", "hidden svelte-1cwchl6");
    			add_location(div13, file$9, 174, 4, 7595);
    			attr_dev(div14, "id", "tooltip");
    			attr_dev(div14, "class", "hidden svelte-1cwchl6");
    			add_location(div14, file$9, 155, 0, 6915);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, div0);
    			append_dev(div0, a0);
    			append_dev(div3, t0);
    			append_dev(div3, span);
    			append_dev(span, t1);
    			append_dev(div3, t2);
    			append_dev(div3, div1);
    			append_dev(div1, a1);
    			append_dev(div1, t3);
    			append_dev(div1, input);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, a2);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div6);
    			if_blocks[current_block_type_index].m(div6, null);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div8, null);
    			}

    			insert_dev(target, t7, anchor);
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div10);
    			append_dev(div10, table0);
    			append_dev(table0, tr);
    			append_dev(tr, td0);
    			append_dev(tr, t8);
    			append_dev(tr, td1);
    			append_dev(td1, strong);
    			append_dev(div14, t9);
    			append_dev(div14, div11);
    			append_dev(div11, table1);
    			append_dev(table1, tbody0);
    			append_dev(div14, t10);
    			append_dev(div14, div12);
    			append_dev(div12, table2);
    			append_dev(table2, tbody1);
    			append_dev(div14, t11);
    			append_dev(div14, div13);
    			append_dev(div13, table3);
    			append_dev(table3, tbody2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", /*click_handler*/ ctx[10], false, false, false),
    					listen_dev(span, "click", /*click_handler_1*/ ctx[11], false, false, false),
    					listen_dev(a1, "click", /*click_handler_2*/ ctx[12], false, false, false),
    					listen_dev(a2, "click", /*click_handler_3*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*selectedDay*/ 4) && t1_value !== (t1_value = DateTime_1.fromISO(/*selectedDay*/ ctx[2]).toFormat('dd LLL yyyy') + "")) set_data_dev(t1, t1_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div6, null);
    			}

    			if (dirty & /*dayData, DateTime, $screenWidthL*/ 9) {
    				each_value = /*dayData*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div8, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div7);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(div9);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div14);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function selectDatePicker() {
    	document.getElementById('date-select').focus();
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $screenWidthL;
    	let $screenWidthM;
    	let $screenWidthS;
    	let $screenWidthXL;
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(0, $screenWidthL = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(7, $screenWidthM = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(8, $screenWidthS = $$value));
    	validate_store(screenWidthXL, 'screenWidthXL');
    	component_subscribe($$self, screenWidthXL, $$value => $$invalidate(9, $screenWidthXL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dashboard', slots, []);
    	let data = [];
    	let period = 20;
    	let startDate = DateTime_1.now().minus({ days: 1 });
    	let endDate = DateTime_1.now().plus({ days: period });
    	let selectedDay = DateTime_1.now().toSQLDate();
    	let dayData = [];

    	onMount(async () => {
    		await fetchData();
    		$$invalidate(3, dayData = await getDayStats(selectedDay));

    		flatpickr('#date-select', {
    			monthSelectorType: 'static',
    			mode: 'range',
    			defaultDate: [startDate.toISODate(), endDate.toISODate()],
    			onChange(selectedDates, dateStr) {
    				startDate = DateTime_1.fromFormat(dateStr.substring(0, 10), 'y-LL-dd');
    				$$invalidate(6, endDate = DateTime_1.fromFormat(dateStr.substring(14), 'y-LL-dd'));
    				$$invalidate(2, selectedDay = startDate.toSQLDate());
    				document.getElementById('date-select').blur();
    			}
    		});
    	});

    	function adjustPeriodWidth() {
    		period = $screenWidthS
    		? 7
    		: $screenWidthM ? 14 : $screenWidthL ? 21 : 28;

    		$$invalidate(6, endDate = startDate.plus({ days: period }));
    		fetchData();
    	}

    	async function fetchData() {
    		if (endDate.diff(startDate).shiftTo('days').days < period) $$invalidate(6, endDate = startDate.plus({ days: period }));
    		$$invalidate(1, data = await getStats(startDate, endDate));

    		if (startDate.toSQLDate() > selectedDay || endDate.toSQL() < selectedDay) {
    			$$invalidate(2, selectedDay = startDate.toSQLDate());
    			$$invalidate(3, dayData = await getDayStats(selectedDay));
    		}
    	}

    	async function scroll(amount) {
    		startDate = startDate.plus({ days: amount });
    		$$invalidate(6, endDate = endDate.plus({ days: amount }));
    		await fetchData();
    	}

    	async function fetchDayStats(event) {
    		if (event.detail.select !== undefined) {
    			$$invalidate(2, selectedDay = event.detail.select);
    			$$invalidate(3, dayData = await getDayStats(event.detail.select));
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dashboard> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => scroll(-7);
    	const click_handler_1 = () => selectDatePicker();
    	const click_handler_2 = () => selectDatePicker();
    	const click_handler_3 = () => scroll(+7);

    	function dashd3_data_binding(value) {
    		data = value;
    		$$invalidate(1, data);
    	}

    	function dashd3_selectedDay_binding(value) {
    		selectedDay = value;
    		$$invalidate(2, selectedDay);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		getDayStats,
    		getStats,
    		DateTime: DateTime_1,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		screenWidthXL,
    		DashD3,
    		flatpickr,
    		data,
    		period,
    		startDate,
    		endDate,
    		selectedDay,
    		dayData,
    		adjustPeriodWidth,
    		fetchData,
    		scroll,
    		fetchDayStats,
    		selectDatePicker,
    		$screenWidthL,
    		$screenWidthM,
    		$screenWidthS,
    		$screenWidthXL
    	});

    	$$self.$inject_state = $$props => {
    		if ('data' in $$props) $$invalidate(1, data = $$props.data);
    		if ('period' in $$props) period = $$props.period;
    		if ('startDate' in $$props) startDate = $$props.startDate;
    		if ('endDate' in $$props) $$invalidate(6, endDate = $$props.endDate);
    		if ('selectedDay' in $$props) $$invalidate(2, selectedDay = $$props.selectedDay);
    		if ('dayData' in $$props) $$invalidate(3, dayData = $$props.dayData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*endDate*/ 64) {
    			endDate && fetchData();
    		}

    		if ($$self.$$.dirty & /*$screenWidthS, $screenWidthM, $screenWidthL, $screenWidthXL*/ 897) {
    			($screenWidthS || $screenWidthM || $screenWidthL || $screenWidthXL) && adjustPeriodWidth();
    		}
    	};

    	return [
    		$screenWidthL,
    		data,
    		selectedDay,
    		dayData,
    		scroll,
    		fetchDayStats,
    		endDate,
    		$screenWidthM,
    		$screenWidthS,
    		$screenWidthXL,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		dashd3_data_binding,
    		dashd3_selectedDay_binding
    	];
    }

    class Dashboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$9, create_fragment$9, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dashboard",
    			options,
    			id: create_fragment$9.name
    		});
    	}
    }

    /* src/components/Reconciliation.svelte generated by Svelte v3.45.0 */
    const file$8 = "src/components/Reconciliation.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	return child_ctx;
    }

    // (181:8) {:else }
    function create_else_block$7(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let th5;
    	let t11;
    	let th6;
    	let t13;
    	let tbody;
    	let each_value = /*data*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Invoice";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Date";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Name";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Stay";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Type";
    			t9 = space();
    			th5 = element("th");
    			th5.textContent = "Amount";
    			t11 = space();
    			th6 = element("th");
    			th6.textContent = "Paid";
    			t13 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$8, 184, 20, 6830);
    			attr_dev(th1, "class", "uk-visible@m");
    			add_location(th1, file$8, 185, 20, 6867);
    			add_location(th2, file$8, 186, 20, 6922);
    			attr_dev(th3, "class", "uk-visible@l");
    			add_location(th3, file$8, 187, 20, 6956);
    			add_location(th4, file$8, 188, 20, 7011);
    			attr_dev(th5, "class", "uk-visible@s");
    			add_location(th5, file$8, 189, 20, 7045);
    			add_location(th6, file$8, 190, 20, 7102);
    			add_location(tr, file$8, 183, 16, 6805);
    			add_location(thead, file$8, 182, 16, 6781);
    			add_location(tbody, file$8, 193, 16, 7179);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$8, 181, 12, 6679);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(table, t13);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*removePaidDate, data, updatePaidDate, paidDates, attachDatePicker, invoiceQuery, DateTime*/ 7193) {
    				each_value = /*data*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(181:8) {:else }",
    		ctx
    	});

    	return block;
    }

    // (179:36) 
    function create_if_block_1$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading invoices...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(179:36) ",
    		ctx
    	});

    	return block;
    }

    // (177:8) {#if data.length === 0 && (invoiceQuery.filter || invoiceQuery.name)}
    function create_if_block$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("No filter results...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(177:8) {#if data.length === 0 && (invoiceQuery.filter || invoiceQuery.name)}",
    		ctx
    	});

    	return block;
    }

    // (211:24) {:else}
    function create_else_block_1$2(ctx) {
    	let td;

    	let t_value = (/*invoice*/ ctx[24].date_paid !== null
    	? DateTime_1.fromSQL(/*invoice*/ ctx[24].date_paid).toFormat('dd LLL yyyy')
    	: '') + "";

    	let t;

    	const block = {
    		c: function create() {
    			td = element("td");
    			t = text$1(t_value);
    			attr_dev(td, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td, file$8, 211, 28, 8972);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t_value !== (t_value = (/*invoice*/ ctx[24].date_paid !== null
    			? DateTime_1.fromSQL(/*invoice*/ ctx[24].date_paid).toFormat('dd LLL yyyy')
    			: '') + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(211:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (203:24) {#if !invoiceQuery.filter.paid}
    function create_if_block_2$3(ctx) {
    	let td;
    	let input;
    	let input_id_value;
    	let t;
    	let mounted;
    	let dispose;
    	let if_block = /*paidDates*/ ctx[4]['date-' + /*invoice*/ ctx[24].id] && create_if_block_3$3(ctx);

    	const block = {
    		c: function create() {
    			td = element("td");
    			input = element("input");
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(input, "class", "uk-input uk-form-width-small uk-form-small");
    			attr_dev(input, "id", input_id_value = "date-" + /*invoice*/ ctx[24].id);
    			attr_dev(input, "type", "text");
    			set_style(input, "color", "black");
    			add_location(input, file$8, 204, 32, 8164);
    			attr_dev(td, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td, file$8, 203, 28, 8088);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, td, anchor);
    			append_dev(td, input);
    			append_dev(td, t);
    			if (if_block) if_block.m(td, null);

    			if (!mounted) {
    				dispose = listen_dev(
    					input,
    					"focus",
    					function () {
    						if (is_function(/*attachDatePicker*/ ctx[10](/*invoice*/ ctx[24].id))) /*attachDatePicker*/ ctx[10](/*invoice*/ ctx[24].id).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*data*/ 1 && input_id_value !== (input_id_value = "date-" + /*invoice*/ ctx[24].id)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (/*paidDates*/ ctx[4]['date-' + /*invoice*/ ctx[24].id]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$3(ctx);
    					if_block.c();
    					if_block.m(td, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(td);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(203:24) {#if !invoiceQuery.filter.paid}",
    		ctx
    	});

    	return block;
    }

    // (206:32) {#if paidDates['date-' + invoice.id]}
    function create_if_block_3$3(ctx) {
    	let button0;
    	let span0;
    	let t;
    	let button1;
    	let span1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[13](/*invoice*/ ctx[24]);
    	}

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[14](/*invoice*/ ctx[24]);
    	}

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			span0 = element("span");
    			t = space();
    			button1 = element("button");
    			span1 = element("span");
    			attr_dev(span0, "uk-icon", "check");
    			add_location(span0, file$8, 206, 175, 8564);
    			attr_dev(button0, "class", "uk-button uk-button-small uk-button-primary uk-margin-small-left");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$8, 206, 36, 8425);
    			attr_dev(span1, "uk-icon", "close");
    			add_location(span1, file$8, 207, 198, 8801);
    			attr_dev(button1, "class", "uk-button uk-button-small uk-button-default uk-margin-small-left uk-margin-medium-right");
    			attr_dev(button1, "type", "button");
    			add_location(button1, file$8, 207, 36, 8639);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			append_dev(button0, span0);
    			insert_dev(target, t, anchor);
    			insert_dev(target, button1, anchor);
    			append_dev(button1, span1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", click_handler, false, false, false),
    					listen_dev(button1, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(206:32) {#if paidDates['date-' + invoice.id]}",
    		ctx
    	});

    	return block;
    }

    // (195:16) {#each data as invoice}
    function create_each_block$4(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*invoice*/ ctx[24].invoice_nr + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = DateTime_1.fromSQL(/*invoice*/ ctx[24].date).toFormat('dd LLL yyyy') + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*invoice*/ ctx[24].name + "";
    	let t4;
    	let t5;
    	let td3;

    	let t6_value = (/*invoice*/ ctx[24].stay_start
    	? DateTime_1.fromSQL(/*invoice*/ ctx[24].stay_start).toFormat('dd LLL yyyy')
    	: '') + ' - ' + (/*invoice*/ ctx[24].stay_end
    	? DateTime_1.fromSQL(/*invoice*/ ctx[24].stay_end).toFormat('dd LLL yyyy')
    	: '') + "";

    	let t6;
    	let t7;
    	let td4;
    	let span;
    	let t8_value = /*invoice*/ ctx[24].payment_type + "";
    	let t8;
    	let t9;
    	let td5;
    	let t10_value = /*invoice*/ ctx[24].total_amount + "";
    	let t10;
    	let t11;
    	let t12;

    	function select_block_type_1(ctx, dirty) {
    		if (!/*invoiceQuery*/ ctx[3].filter.paid) return create_if_block_2$3;
    		return create_else_block_1$2;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element("td");
    			span = element("span");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			if_block.c();
    			t12 = space();
    			attr_dev(td0, "class", "uk-table-shrink");
    			add_location(td0, file$8, 196, 24, 7276);
    			attr_dev(td1, "class", "uk-table-shrink uk-text-nowrap uk-visible@m");
    			add_location(td1, file$8, 197, 24, 7354);
    			add_location(td2, file$8, 198, 24, 7496);
    			attr_dev(td3, "class", "uk-visible@l");
    			add_location(td3, file$8, 199, 24, 7544);
    			attr_dev(span, "class", "uk-label uk-margin-remove uk-background-secondary");
    			add_location(span, file$8, 200, 52, 7812);
    			attr_dev(td4, "class", "uk-table-shrink");
    			add_location(td4, file$8, 200, 24, 7784);
    			attr_dev(td5, "class", "uk-table-shrink uk-visible@s");
    			add_location(td5, file$8, 201, 24, 7935);
    			add_location(tr, file$8, 195, 20, 7247);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, span);
    			append_dev(span, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			append_dev(td5, t10);
    			append_dev(tr, t11);
    			if_block.m(tr, null);
    			append_dev(tr, t12);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = /*invoice*/ ctx[24].invoice_nr + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*data*/ 1 && t2_value !== (t2_value = DateTime_1.fromSQL(/*invoice*/ ctx[24].date).toFormat('dd LLL yyyy') + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*data*/ 1 && t4_value !== (t4_value = /*invoice*/ ctx[24].name + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*data*/ 1 && t6_value !== (t6_value = (/*invoice*/ ctx[24].stay_start
    			? DateTime_1.fromSQL(/*invoice*/ ctx[24].stay_start).toFormat('dd LLL yyyy')
    			: '') + ' - ' + (/*invoice*/ ctx[24].stay_end
    			? DateTime_1.fromSQL(/*invoice*/ ctx[24].stay_end).toFormat('dd LLL yyyy')
    			: '') + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*data*/ 1 && t8_value !== (t8_value = /*invoice*/ ctx[24].payment_type + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*data*/ 1 && t10_value !== (t10_value = /*invoice*/ ctx[24].total_amount + "")) set_data_dev(t10, t10_value);

    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(tr, t12);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(195:16) {#each data as invoice}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div3;
    	let div2;
    	let div1;
    	let input0;
    	let input0_class_value;
    	let t0;
    	let div0;
    	let input1;
    	let t1;
    	let t2_value = (/*invoiceQuery*/ ctx[3].filter.paid ? 'Paid' : 'Unpaid') + "";
    	let t2;
    	let t3;
    	let div5;
    	let div4;
    	let t4;
    	let infinitescroll;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0 && (/*invoiceQuery*/ ctx[3].filter || /*invoiceQuery*/ ctx[3].name)) return create_if_block$7;
    		if (/*data*/ ctx[0].length === 0) return create_if_block_1$3;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	infinitescroll = new InfiniteScroll({
    			props: {
    				hasMore: /*newBatch*/ ctx[1].length,
    				threshold: 80
    			},
    			$$inline: true
    		});

    	infinitescroll.$on("loadMore", /*loadMore_handler*/ ctx[15]);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			input0 = element("input");
    			t0 = space();
    			div0 = element("div");
    			input1 = element("input");
    			t1 = space();
    			t2 = text$1(t2_value);
    			t3 = space();
    			div5 = element("div");
    			div4 = element("div");
    			if_block.c();
    			t4 = space();
    			create_component(infinitescroll.$$.fragment);

    			attr_dev(input0, "class", input0_class_value = "uk-input " + (/*$screenWidthS*/ ctx[5]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[6] || /*$screenWidthL*/ ctx[7]
    				? 'uk-width-medium'
    				: 'uk-width-large'));

    			attr_dev(input0, "id", "autocomplete");
    			attr_dev(input0, "type", "search");
    			attr_dev(input0, "spellcheck", "false");
    			attr_dev(input0, "autocorrect", "off");
    			attr_dev(input0, "autocomplete", "off");
    			attr_dev(input0, "autocapitalize", "off");
    			attr_dev(input0, "maxlength", "256");
    			add_location(input0, file$8, 165, 12, 5752);
    			attr_dev(input1, "type", "checkbox");
    			attr_dev(input1, "id", "paid");
    			attr_dev(input1, "data-type", "simple-switch");
    			input1.checked = true;
    			add_location(input1, file$8, 168, 40, 6087);
    			attr_dev(div0, "class", "uk-margin-left");
    			add_location(div0, file$8, 168, 12, 6059);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-flex-middle");
    			add_location(div1, file$8, 164, 8, 5688);
    			attr_dev(div2, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6 paf-top-section-bg");
    			add_location(div2, file$8, 163, 4, 5590);
    			attr_dev(div3, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div3, file$8, 162, 0, 5512);
    			attr_dev(div4, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6");
    			add_location(div4, file$8, 175, 4, 6399);
    			attr_dev(div5, "class", "uk-flex uk-flex-center");
    			set_style(div5, "max-height", "75%");
    			set_style(div5, "overflow-x", "scroll");
    			add_location(div5, file$8, 174, 0, 6313);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div1, input0);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, input1);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			if_block.m(div4, null);
    			append_dev(div5, t4);
    			mount_component(infinitescroll, div5, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input1, "change", /*togglePaid*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$screenWidthS, $screenWidthM, $screenWidthL*/ 224 && input0_class_value !== (input0_class_value = "uk-input " + (/*$screenWidthS*/ ctx[5]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[6] || /*$screenWidthL*/ ctx[7]
    				? 'uk-width-medium'
    				: 'uk-width-large'))) {
    				attr_dev(input0, "class", input0_class_value);
    			}

    			if ((!current || dirty & /*invoiceQuery*/ 8) && t2_value !== (t2_value = (/*invoiceQuery*/ ctx[3].filter.paid ? 'Paid' : 'Unpaid') + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div4, null);
    				}
    			}

    			const infinitescroll_changes = {};
    			if (dirty & /*newBatch*/ 2) infinitescroll_changes.hasMore = /*newBatch*/ ctx[1].length;
    			infinitescroll.$set(infinitescroll_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(infinitescroll.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(infinitescroll.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div5);
    			if_block.d();
    			destroy_component(infinitescroll);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $invoiceNames;
    	let $invoiceNumberStrings;
    	let $invoiceReconciliationNumbers;
    	let $screenWidthS;
    	let $screenWidthM;
    	let $screenWidthL;
    	validate_store(invoiceNames, 'invoiceNames');
    	component_subscribe($$self, invoiceNames, $$value => $$invalidate(18, $invoiceNames = $$value));
    	validate_store(invoiceNumberStrings, 'invoiceNumberStrings');
    	component_subscribe($$self, invoiceNumberStrings, $$value => $$invalidate(19, $invoiceNumberStrings = $$value));
    	validate_store(invoiceReconciliationNumbers, 'invoiceReconciliationNumbers');
    	component_subscribe($$self, invoiceReconciliationNumbers, $$value => $$invalidate(20, $invoiceReconciliationNumbers = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(5, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(6, $screenWidthM = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(7, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Reconciliation', slots, []);
    	let maxPage = 2;
    	let data = [];
    	let newBatch = [];
    	let autocompleteData = [];

    	let invoiceQuery = {
    		filter: {
    			date: [DateTime_1.now().minus({ years: 1 }).toSQLDate(), DateTime_1.now().toSQLDate()],
    			paid: false
    		},
    		page: 1,
    		limit: 50,
    		orderBy: { key: 'invoice_nr', order: 'ASC' }
    	};

    	let datePicker;
    	let paidDates = {};
    	let recreateForm = true;
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		await fetchData();
    		autocompleteData = [...$invoiceReconciliationNumbers, ...$invoiceNames];
    		init$1();

    		const autoCompleteJS = new autoComplete({
    				selector: "#autocomplete",
    				placeHolder: "Search invoices...",
    				diacritics: true,
    				searchEngine: 'strict',
    				data: { src: autocompleteData, cache: true },
    				resultsList: {
    					element: (list, data) => {
    						if (!data.results.length) {
    							const message = document.createElement("div");
    							message.setAttribute("class", "no_result");
    							message.innerHTML = `<span>No Invoice for "${data.query}"</span>`;
    							list.prepend(message);
    						}
    					},
    					maxResults: 50,
    					noResults: true
    				},
    				resultItem: { highlight: true },
    				events: {
    					input: {
    						selection: event => {
    							let input = event.detail.selection.value;
    							autoCompleteJS.input.value = input;
    							delete invoiceQuery.invoice_nr;
    							delete invoiceQuery.name;
    							if ($invoiceNumberStrings.findIndex(number => number === input) > -1) $$invalidate(3, invoiceQuery.invoice_nr = input, invoiceQuery);
    							if ($invoiceNames.findIndex(name => name === input) > -1) $$invalidate(3, invoiceQuery.name = input, invoiceQuery);
    							fetchInvoices(true);
    						},
    						keyup: () => {
    							if (autoCompleteJS.input.value === '') fetchInvoices(false);
    						}
    					}
    				}
    			});
    	});

    	async function fetchData() {
    		const result = await getReconciliationInvoices(invoiceQuery);
    		$$invalidate(2, maxPage = result.meta.last_page);
    		$$invalidate(1, newBatch = result.data);
    	}

    	async function fetchInvoices(doQuery) {
    		$$invalidate(3, invoiceQuery.page = 1, invoiceQuery);
    		$$invalidate(1, newBatch = []);

    		if (doQuery) {
    			const result = await getReconciliationInvoices(invoiceQuery);
    			$$invalidate(2, maxPage = result.meta.last_page);
    			$$invalidate(0, data = [...result.data]);
    		} else {
    			delete invoiceQuery.invoice_nr;
    			delete invoiceQuery.name;
    			$$invalidate(0, data = []);
    			await fetchData();
    		}
    	}

    	function togglePaid() {
    		$$invalidate(3, invoiceQuery.filter.paid = !document.getElementById('paid').checked, invoiceQuery);
    		$$invalidate(3, invoiceQuery.page = 1, invoiceQuery);

    		$$invalidate(
    			3,
    			invoiceQuery.orderBy = {
    				key: invoiceQuery.filter.paid ? 'invoice_nr' : 'invoice_nr',
    				order: invoiceQuery.filter.paid ? 'DESC' : 'ASC'
    			},
    			invoiceQuery
    		);

    		$$invalidate(4, paidDates = {});
    		$$invalidate(0, data = []);
    		$$invalidate(1, newBatch = []);
    		fetchData();
    	}

    	function attachDatePicker(id) {
    		datePicker = flatpickr('#date-' + id, { monthSelectorType: 'static' });
    		if (document.getElementById('date-' + id).value?.length > 0) $$invalidate(4, paidDates['date-' + id] = true, paidDates);
    	}

    	function removePaidDate(id) {
    		if (document.getElementById('date-' + id).value?.length > 0) document.getElementById('date-' + id).value = '';
    		$$invalidate(4, paidDates['date-' + id] = false, paidDates);
    	}

    	async function updatePaidDate(id) {
    		let invoice = data.find(i => i.id === id);

    		if (invoice) {
    			const date_paid = document.getElementById('date-' + id).value;
    			invoice.date_paid = date_paid;
    			let success = await updateInvoice(invoice, false);
    			if (invoice.stay_start) success = await updateBookingPaid(invoice.id, date_paid) && success;

    			if (success) {
    				uikit.notification('<span uk-icon="icon: check"></span> Invoice updated!', { status: 'success', pos: 'bottom-center' });
    				$$invalidate(4, paidDates = {});
    				$$invalidate(0, data = []);
    				$$invalidate(1, newBatch = []);
    				await fetchData();
    			} else uikit.notification('<span uk-icon="icon: warning"></span> Failed updating invoice!', { status: 'danger', pos: 'bottom-center' });
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Reconciliation> was created with unknown prop '${key}'`);
    	});

    	const click_handler = invoice => updatePaidDate(invoice.id);
    	const click_handler_1 = invoice => removePaidDate(invoice.id);

    	const loadMore_handler = () => {
    		if (invoiceQuery.page < maxPage) {
    			$$invalidate(3, invoiceQuery.page++, invoiceQuery);
    			fetchData();
    		}
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		InfiniteScroll,
    		SimpleSwitch,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		autoComplete,
    		DateTime: DateTime_1,
    		getReconciliationInvoices,
    		invoiceNames,
    		invoiceNumberStrings,
    		invoiceReconciliationNumbers,
    		updateInvoice,
    		flatpickr,
    		UIkit: uikit,
    		updateBookingPaid,
    		maxPage,
    		data,
    		newBatch,
    		autocompleteData,
    		invoiceQuery,
    		datePicker,
    		paidDates,
    		recreateForm,
    		dispatch,
    		fetchData,
    		fetchInvoices,
    		togglePaid,
    		attachDatePicker,
    		removePaidDate,
    		updatePaidDate,
    		$invoiceNames,
    		$invoiceNumberStrings,
    		$invoiceReconciliationNumbers,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL
    	});

    	$$self.$inject_state = $$props => {
    		if ('maxPage' in $$props) $$invalidate(2, maxPage = $$props.maxPage);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('newBatch' in $$props) $$invalidate(1, newBatch = $$props.newBatch);
    		if ('autocompleteData' in $$props) autocompleteData = $$props.autocompleteData;
    		if ('invoiceQuery' in $$props) $$invalidate(3, invoiceQuery = $$props.invoiceQuery);
    		if ('datePicker' in $$props) datePicker = $$props.datePicker;
    		if ('paidDates' in $$props) $$invalidate(4, paidDates = $$props.paidDates);
    		if ('recreateForm' in $$props) recreateForm = $$props.recreateForm;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, newBatch*/ 3) {
    			$$invalidate(0, data = [...data, ...newBatch]);
    		}
    	};

    	return [
    		data,
    		newBatch,
    		maxPage,
    		invoiceQuery,
    		paidDates,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		fetchData,
    		togglePaid,
    		attachDatePicker,
    		removePaidDate,
    		updatePaidDate,
    		click_handler,
    		click_handler_1,
    		loadMore_handler
    	];
    }

    class Reconciliation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Reconciliation",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    async function createBankrun(bankrun) {
        try {
            const result = await api.post('/bankrun/', bankrun);
            return result.data
        } catch (error) {}
    }

    async function updateBankrun(bankrun) {
        try {
            const result = await api.put('/bankrun/'+bankrun.id, bankrun);
            return result.data
        } catch (error) {}
    }

    async function getBankruns(page) {
        try {
            const result = await api.post('/bankruns/', {page: page, limit: 50});
            return result.data
        } catch (error) {}
    }

    /* src/components/BankRunSheet.svelte generated by Svelte v3.45.0 */
    const file$7 = "src/components/BankRunSheet.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    // (123:4) {:else }
    function create_else_block$6(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t0;
    	let th1;
    	let t2;
    	let th2;
    	let t4;
    	let th3;
    	let t6;
    	let th4;
    	let t8;
    	let th5;
    	let t10;
    	let tbody;
    	let each_value_1 = /*data*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			t0 = space();
    			th1 = element("th");
    			th1.textContent = "Invoice";
    			t2 = space();
    			th2 = element("th");
    			th2.textContent = "Date";
    			t4 = space();
    			th3 = element("th");
    			th3.textContent = "Name";
    			t6 = space();
    			th4 = element("th");
    			th4.textContent = "Type";
    			t8 = space();
    			th5 = element("th");
    			th5.textContent = "Amount";
    			t10 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$7, 126, 16, 5255);
    			add_location(th1, file$7, 127, 16, 5281);
    			attr_dev(th2, "class", "uk-visible@m");
    			add_location(th2, file$7, 128, 16, 5314);
    			add_location(th3, file$7, 129, 16, 5365);
    			add_location(th4, file$7, 130, 16, 5395);
    			attr_dev(th5, "class", "uk-visible@s");
    			add_location(th5, file$7, 131, 16, 5425);
    			add_location(tr, file$7, 125, 12, 5234);
    			add_location(thead, file$7, 124, 12, 5214);
    			add_location(tbody, file$7, 134, 12, 5513);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$7, 123, 8, 5116);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t0);
    			append_dev(tr, th1);
    			append_dev(tr, t2);
    			append_dev(tr, th2);
    			append_dev(tr, t4);
    			append_dev(tr, th3);
    			append_dev(tr, t6);
    			append_dev(tr, th4);
    			append_dev(tr, t8);
    			append_dev(tr, th5);
    			append_dev(table, t10);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data, DateTime, select*/ 33) {
    				each_value_1 = /*data*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(123:4) {:else }",
    		ctx
    	});

    	return block;
    }

    // (121:4) {#if data.length === 0}
    function create_if_block$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading invoices...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(121:4) {#if data.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (136:12) {#each data as invoice}
    function create_each_block_1(ctx) {
    	let tr;
    	let td0;
    	let input;
    	let input_id_value;
    	let t0;
    	let td1;
    	let t1_value = /*invoice*/ ctx[14].invoice_nr + "";
    	let t1;
    	let t2;
    	let td2;
    	let t3_value = DateTime_1.fromSQL(/*invoice*/ ctx[14].date).toFormat('dd LLL yyyy') + "";
    	let t3;
    	let t4;
    	let td3;
    	let t5_value = /*invoice*/ ctx[14].name + "";
    	let t5;
    	let t6;
    	let td4;
    	let span;
    	let t7_value = /*invoice*/ ctx[14].payment_type + "";
    	let t7;
    	let t8;
    	let td5;
    	let t9_value = /*invoice*/ ctx[14].total_amount + "";
    	let t9;
    	let t10;
    	let tr_id_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[9](/*invoice*/ ctx[14]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			input = element("input");
    			t0 = space();
    			td1 = element("td");
    			t1 = text$1(t1_value);
    			t2 = space();
    			td2 = element("td");
    			t3 = text$1(t3_value);
    			t4 = space();
    			td3 = element("td");
    			t5 = text$1(t5_value);
    			t6 = space();
    			td4 = element("td");
    			span = element("span");
    			t7 = text$1(t7_value);
    			t8 = space();
    			td5 = element("td");
    			t9 = text$1(t9_value);
    			t10 = space();
    			attr_dev(input, "class", "uk-checkbox");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "id", input_id_value = /*invoice*/ ctx[14].invoice_nr);
    			add_location(input, file$7, 137, 48, 5677);
    			attr_dev(td0, "class", "uk-table-shrink");
    			add_location(td0, file$7, 137, 20, 5649);
    			attr_dev(td1, "class", "uk-table-shrink");
    			add_location(td1, file$7, 138, 20, 5816);
    			attr_dev(td2, "class", "uk-table-shrink uk-text-nowrap uk-visible@m");
    			add_location(td2, file$7, 139, 20, 5890);
    			add_location(td3, file$7, 140, 20, 6028);
    			attr_dev(span, "class", "uk-label uk-margin-remove uk-background-secondary");
    			add_location(span, file$7, 141, 48, 6100);
    			attr_dev(td4, "class", "uk-table-shrink");
    			add_location(td4, file$7, 141, 20, 6072);
    			attr_dev(td5, "class", "uk-table-shrink uk-visible@s");
    			add_location(td5, file$7, 142, 20, 6219);
    			attr_dev(tr, "id", tr_id_value = "tr-" + /*invoice*/ ctx[14].invoice_nr);
    			attr_dev(tr, "class", "uk-text-muted");
    			add_location(tr, file$7, 136, 16, 5573);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, input);
    			append_dev(tr, t0);
    			append_dev(tr, td1);
    			append_dev(td1, t1);
    			append_dev(tr, t2);
    			append_dev(tr, td2);
    			append_dev(td2, t3);
    			append_dev(tr, t4);
    			append_dev(tr, td3);
    			append_dev(td3, t5);
    			append_dev(tr, t6);
    			append_dev(tr, td4);
    			append_dev(td4, span);
    			append_dev(span, t7);
    			append_dev(tr, t8);
    			append_dev(tr, td5);
    			append_dev(td5, t9);
    			append_dev(tr, t10);

    			if (!mounted) {
    				dispose = listen_dev(input, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*data*/ 1 && input_id_value !== (input_id_value = /*invoice*/ ctx[14].invoice_nr)) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (dirty & /*data*/ 1 && t1_value !== (t1_value = /*invoice*/ ctx[14].invoice_nr + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*data*/ 1 && t3_value !== (t3_value = DateTime_1.fromSQL(/*invoice*/ ctx[14].date).toFormat('dd LLL yyyy') + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*data*/ 1 && t5_value !== (t5_value = /*invoice*/ ctx[14].name + "")) set_data_dev(t5, t5_value);
    			if (dirty & /*data*/ 1 && t7_value !== (t7_value = /*invoice*/ ctx[14].payment_type + "")) set_data_dev(t7, t7_value);
    			if (dirty & /*data*/ 1 && t9_value !== (t9_value = /*invoice*/ ctx[14].total_amount + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*data*/ 1 && tr_id_value !== (tr_id_value = "tr-" + /*invoice*/ ctx[14].invoice_nr)) {
    				attr_dev(tr, "id", tr_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(136:12) {#each data as invoice}",
    		ctx
    	});

    	return block;
    }

    // (168:8) {#each printData as invoice}
    function create_each_block$3(ctx) {
    	let tr;
    	let td0;
    	let t0_value = /*invoice*/ ctx[14].invoice_nr + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = DateTime_1.fromSQL(/*invoice*/ ctx[14].date).toFormat('dd LLL yyyy') + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*invoice*/ ctx[14].name + "";
    	let t4;
    	let t5;
    	let td3;

    	let t6_value = (/*invoice*/ ctx[14].stay_start !== null && /*invoice*/ ctx[14].stay_end !== null
    	? DateTime_1.fromSQL(/*invoice*/ ctx[14].stay_start).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*invoice*/ ctx[14].stay_end).toFormat('dd LLL yyyy')
    	: '  ') + "";

    	let t6;
    	let t7;
    	let td4;

    	let t8_value = (/*invoice*/ ctx[14].payment_type === 'cash'
    	? /*invoice*/ ctx[14].total_amount
    	: '') + "";

    	let t8;
    	let t9;
    	let td5;

    	let t10_value = (/*invoice*/ ctx[14].payment_type === 'cheque'
    	? /*invoice*/ ctx[14].total_amount
    	: '') + "";

    	let t10;

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element("td");
    			t10 = text$1(t10_value);
    			attr_dev(td0, "class", "uk-table-shrink");
    			add_location(td0, file$7, 169, 16, 6903);
    			attr_dev(td1, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td1, file$7, 170, 16, 6973);
    			add_location(td2, file$7, 171, 16, 7094);
    			attr_dev(td3, "class", "uk-text-nowrap");
    			add_location(td3, file$7, 172, 16, 7134);
    			attr_dev(td4, "class", "uk-table-shrink");
    			add_location(td4, file$7, 173, 16, 7383);
    			attr_dev(td5, "class", "uk-table-shrink");
    			add_location(td5, file$7, 174, 16, 7494);
    			add_location(tr, file$7, 168, 12, 6882);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			append_dev(td5, t10);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*printData*/ 2 && t0_value !== (t0_value = /*invoice*/ ctx[14].invoice_nr + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*printData*/ 2 && t2_value !== (t2_value = DateTime_1.fromSQL(/*invoice*/ ctx[14].date).toFormat('dd LLL yyyy') + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*printData*/ 2 && t4_value !== (t4_value = /*invoice*/ ctx[14].name + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*printData*/ 2 && t6_value !== (t6_value = (/*invoice*/ ctx[14].stay_start !== null && /*invoice*/ ctx[14].stay_end !== null
    			? DateTime_1.fromSQL(/*invoice*/ ctx[14].stay_start).toFormat('dd LLL yyyy') + ' - ' + DateTime_1.fromSQL(/*invoice*/ ctx[14].stay_end).toFormat('dd LLL yyyy')
    			: '  ') + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*printData*/ 2 && t8_value !== (t8_value = (/*invoice*/ ctx[14].payment_type === 'cash'
    			? /*invoice*/ ctx[14].total_amount
    			: '') + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*printData*/ 2 && t10_value !== (t10_value = (/*invoice*/ ctx[14].payment_type === 'cheque'
    			? /*invoice*/ ctx[14].total_amount
    			: '') + "")) set_data_dev(t10, t10_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(168:8) {#each printData as invoice}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let h4;
    	let t1;
    	let form;
    	let div0;
    	let input;
    	let t2;
    	let button0;
    	let t3_value = (/*canPrint*/ ctx[4] ? 'Close' : 'Cancel') + "";
    	let t3;
    	let t4;
    	let button1;
    	let t5;
    	let button1_disabled_value;
    	let t6;
    	let t7;
    	let div1;
    	let table;
    	let thead;
    	let tr0;
    	let th0;
    	let t9;
    	let th1;
    	let t11;
    	let th2;
    	let t13;
    	let th3;
    	let t15;
    	let th4;
    	let t17;
    	let th5;
    	let t19;
    	let tbody;
    	let t20;
    	let tr1;
    	let td0;
    	let t22;
    	let td1;
    	let t23;
    	let td2;
    	let t24;
    	let td3;
    	let t25;
    	let td4;
    	let t26;
    	let t27;
    	let td5;
    	let t28;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0) return create_if_block$6;
    		return create_else_block$6;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);
    	let each_value = /*printData*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			h4.textContent = "Bank deposit sheet";
    			t1 = space();
    			form = element("form");
    			div0 = element("div");
    			input = element("input");
    			t2 = space();
    			button0 = element("button");
    			t3 = text$1(t3_value);
    			t4 = space();
    			button1 = element("button");
    			t5 = text$1("Print");
    			t6 = space();
    			if_block.c();
    			t7 = space();
    			div1 = element("div");
    			table = element("table");
    			thead = element("thead");
    			tr0 = element("tr");
    			th0 = element("th");
    			th0.textContent = "Invoice Nr";
    			t9 = space();
    			th1 = element("th");
    			th1.textContent = "Date";
    			t11 = space();
    			th2 = element("th");
    			th2.textContent = "Name";
    			t13 = space();
    			th3 = element("th");
    			th3.textContent = "Stay";
    			t15 = space();
    			th4 = element("th");
    			th4.textContent = "Cash";
    			t17 = space();
    			th5 = element("th");
    			th5.textContent = "Cheque";
    			t19 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t20 = space();
    			tr1 = element("tr");
    			td0 = element("td");
    			td0.textContent = "TOTAL";
    			t22 = space();
    			td1 = element("td");
    			t23 = space();
    			td2 = element("td");
    			t24 = space();
    			td3 = element("td");
    			t25 = space();
    			td4 = element("td");
    			t26 = text$1(/*printTotalCash*/ ctx[2]);
    			t27 = space();
    			td5 = element("td");
    			t28 = text$1(/*printTotalCheque*/ ctx[3]);
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-width-1-1");
    			add_location(h4, file$7, 109, 0, 4401);
    			attr_dev(input, "class", "uk-input uk-form-width-medium");
    			attr_dev(input, "id", "form-date");
    			attr_dev(input, "type", "text");
    			set_style(input, "color", "black");
    			add_location(input, file$7, 115, 8, 4631);
    			attr_dev(button0, "class", "uk-button uk-button-default uk-margin-large-left");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$7, 116, 8, 4733);
    			attr_dev(button1, "class", "uk-button uk-margin-large-left");
    			attr_dev(button1, "type", "submit");
    			button1.disabled = button1_disabled_value = !/*canPrint*/ ctx[4];
    			toggle_class(button1, "uk-button-primary", /*canPrint*/ ctx[4]);
    			add_location(button1, file$7, 117, 8, 4878);
    			attr_dev(div0, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-medium-bottom");
    			add_location(div0, file$7, 114, 4, 4542);
    			add_location(form, file$7, 113, 0, 4531);
    			attr_dev(th0, "class", "uk-text-nowrap");
    			add_location(th0, file$7, 158, 12, 6565);
    			add_location(th1, file$7, 159, 12, 6620);
    			add_location(th2, file$7, 160, 12, 6646);
    			add_location(th3, file$7, 161, 12, 6672);
    			attr_dev(th4, "class", "uk-text-nowrap");
    			add_location(th4, file$7, 162, 12, 6698);
    			attr_dev(th5, "class", "uk-text-nowrap");
    			add_location(th5, file$7, 163, 12, 6747);
    			add_location(tr0, file$7, 157, 8, 6548);
    			add_location(thead, file$7, 156, 8, 6532);
    			attr_dev(td0, "class", "uk-text-bold");
    			add_location(td0, file$7, 178, 12, 7727);
    			add_location(td1, file$7, 179, 12, 7775);
    			add_location(td2, file$7, 180, 12, 7797);
    			add_location(td3, file$7, 181, 12, 7819);
    			attr_dev(td4, "class", "uk-text-bold");
    			add_location(td4, file$7, 182, 12, 7841);
    			attr_dev(td5, "class", "uk-text-bold");
    			add_location(td5, file$7, 183, 12, 7900);
    			set_style(tr1, "border-top", "2px solid rgb(204, 204, 204)");
    			set_style(tr1, "border-bottom", "4px double");
    			add_location(tr1, file$7, 177, 8, 7633);
    			add_location(tbody, file$7, 166, 8, 6825);
    			attr_dev(table, "class", "uk-table uk-table-small uk-table-divider uk-text-small");
    			add_location(table, file$7, 155, 4, 6453);
    			attr_dev(div1, "id", "print");
    			div1.hidden = "hidden";
    			add_location(div1, file$7, 154, 0, 6416);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, form, anchor);
    			append_dev(form, div0);
    			append_dev(div0, input);
    			append_dev(div0, t2);
    			append_dev(div0, button0);
    			append_dev(button0, t3);
    			append_dev(div0, t4);
    			append_dev(div0, button1);
    			append_dev(button1, t5);
    			append_dev(form, t6);
    			if_block.m(form, null);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, table);
    			append_dev(table, thead);
    			append_dev(thead, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t9);
    			append_dev(tr0, th1);
    			append_dev(tr0, t11);
    			append_dev(tr0, th2);
    			append_dev(tr0, t13);
    			append_dev(tr0, th3);
    			append_dev(tr0, t15);
    			append_dev(tr0, th4);
    			append_dev(tr0, t17);
    			append_dev(tr0, th5);
    			append_dev(table, t19);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}

    			append_dev(tbody, t20);
    			append_dev(tbody, tr1);
    			append_dev(tr1, td0);
    			append_dev(tr1, t22);
    			append_dev(tr1, td1);
    			append_dev(tr1, t23);
    			append_dev(tr1, td2);
    			append_dev(tr1, t24);
    			append_dev(tr1, td3);
    			append_dev(tr1, t25);
    			append_dev(tr1, td4);
    			append_dev(td4, t26);
    			append_dev(tr1, t27);
    			append_dev(tr1, td5);
    			append_dev(td5, t28);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*close*/ ctx[7], false, false, false),
    					listen_dev(button1, "click", /*print*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*canPrint*/ 16 && t3_value !== (t3_value = (/*canPrint*/ ctx[4] ? 'Close' : 'Cancel') + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*canPrint*/ 16 && button1_disabled_value !== (button1_disabled_value = !/*canPrint*/ ctx[4])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*canPrint*/ 16) {
    				toggle_class(button1, "uk-button-primary", /*canPrint*/ ctx[4]);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(form, null);
    				}
    			}

    			if (dirty & /*printData, DateTime*/ 2) {
    				each_value = /*printData*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, t20);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*printTotalCash*/ 4) set_data_dev(t26, /*printTotalCash*/ ctx[2]);
    			if (dirty & /*printTotalCheque*/ 8) set_data_dev(t28, /*printTotalCheque*/ ctx[3]);
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(form);
    			if_block.d();
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BankRunSheet', slots, []);
    	let { bankRun = null } = $$props;
    	let data = [];
    	let selected = new Set();
    	let printData = [];
    	let printTotalCash = 0;
    	let printTotalCheque = 0;
    	let canPrint = false;
    	let didPrint = false;
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		$$invalidate(0, data = []);
    		if (bankRun) $$invalidate(0, data = await getBankRunInvoices(bankRun.invoices));
    		const invoices = await getAllBankRunInvoices();
    		if (invoices) $$invalidate(0, data = [...data, ...invoices]);

    		flatpickr('#form-date', {
    			monthSelectorType: 'static',
    			defaultDate: DateTime_1.now().toSQLDate()
    		});
    	});

    	afterUpdate(() => setTimeout(
    		() => {
    			if (bankRun) {
    				bankRun.invoices.forEach(i => {
    					selected.add(i);
    					document.getElementById(i).checked = true;
    					document.getElementById('tr-' + i).classList.add('uk-text-emphasis');
    					document.getElementById('tr-' + i).classList.remove('uk-text-muted');
    				});
    			}

    			$$invalidate(4, canPrint = selected.size > 0);
    		},
    		100
    	));

    	function select(invoiceNr) {
    		if (document.getElementById(invoiceNr).checked) {
    			selected.add(invoiceNr);
    			document.getElementById('tr-' + invoiceNr).classList.add('uk-text-emphasis');
    			document.getElementById('tr-' + invoiceNr).classList.remove('uk-text-muted');
    		} else {
    			selected.delete(invoiceNr);
    			document.getElementById('tr-' + invoiceNr).classList.add('uk-text-muted');
    			document.getElementById('tr-' + invoiceNr).classList.remove('uk-text-emphasis');
    		}

    		$$invalidate(4, canPrint = selected.size > 0);
    	}

    	function updatePrintData() {
    		$$invalidate(1, printData = data.filter(i => selected.has(i.invoice_nr)));
    		$$invalidate(2, printTotalCash = printData.filter(i => i.payment_type === 'cash').reduce((prev, i) => prev + i.total_amount, 0));
    		$$invalidate(3, printTotalCheque = printData.filter(i => i.payment_type === 'cheque').reduce((prev, i) => prev + i.total_amount, 0));
    	}

    	async function print() {
    		updatePrintData();

    		window.setTimeout(
    			() => {
    				let printWindow = window.open('', '', 'left=' + (window.innerWidth / 2 - 300) + ', top=200, height=800, width=600');
    				printWindow.document.write('<html>');
    				printWindow.document.write('<link rel="stylesheet" href="/build/bundle.css">');
    				printWindow.document.write('<body onload="window.print()" onafterprint="window.close()">');
    				printWindow.document.write(document.getElementById('print').innerHTML);
    				printWindow.document.write('</body></html>');
    				printWindow.document.close();
    				didPrint = true;
    			},
    			0
    		);
    	}

    	async function close() {
    		if ((didPrint || bankRun) && confirm('Save this bank-run?')) {
    			updatePrintData();

    			const bankrun = {
    				date: document.getElementById('form-date').value,
    				invoices: [...selected],
    				total_amount_cash: printTotalCash,
    				total_amount_cheque: printTotalCheque
    			};

    			if (bankRun) {
    				bankrun.id = bankRun.id;
    				if (await updateBankrun(bankrun)) uikit.notification('<span uk-icon="icon: check"></span> Bankrun saved!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    			} else {
    				if (bankRun && await updateBankrun(bankrun) || bankRun === null && await createBankrun(bankrun)) uikit.notification('<span uk-icon="icon: check"></span> Bankrun created!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    			}

    			$$invalidate(8, bankRun = null);
    		}

    		dispatch('message', { goto: 'cancel' });
    	}

    	const writable_props = ['bankRun'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BankRunSheet> was created with unknown prop '${key}'`);
    	});

    	const click_handler = invoice => select(invoice.invoice_nr);

    	$$self.$$set = $$props => {
    		if ('bankRun' in $$props) $$invalidate(8, bankRun = $$props.bankRun);
    	};

    	$$self.$capture_state = () => ({
    		DateTime: DateTime_1,
    		afterUpdate,
    		createEventDispatcher,
    		onMount,
    		getAllBankRunInvoices,
    		getBankRunInvoices,
    		createBankrun,
    		updateBankrun,
    		UIkit: uikit,
    		flatpickr,
    		bankRun,
    		data,
    		selected,
    		printData,
    		printTotalCash,
    		printTotalCheque,
    		canPrint,
    		didPrint,
    		dispatch,
    		select,
    		updatePrintData,
    		print,
    		close
    	});

    	$$self.$inject_state = $$props => {
    		if ('bankRun' in $$props) $$invalidate(8, bankRun = $$props.bankRun);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('selected' in $$props) selected = $$props.selected;
    		if ('printData' in $$props) $$invalidate(1, printData = $$props.printData);
    		if ('printTotalCash' in $$props) $$invalidate(2, printTotalCash = $$props.printTotalCash);
    		if ('printTotalCheque' in $$props) $$invalidate(3, printTotalCheque = $$props.printTotalCheque);
    		if ('canPrint' in $$props) $$invalidate(4, canPrint = $$props.canPrint);
    		if ('didPrint' in $$props) didPrint = $$props.didPrint;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		data,
    		printData,
    		printTotalCash,
    		printTotalCheque,
    		canPrint,
    		select,
    		print,
    		close,
    		bankRun,
    		click_handler
    	];
    }

    class BankRunSheet extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$7, create_fragment$7, safe_not_equal, { bankRun: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BankRunSheet",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get bankRun() {
    		throw new Error("<BankRunSheet>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bankRun(value) {
    		throw new Error("<BankRunSheet>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/BankRuns.svelte generated by Svelte v3.45.0 */
    const file$6 = "src/components/BankRuns.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    // (72:12) {:else }
    function create_else_block$5(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let tbody;
    	let each_value = /*data*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Date";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Invoices";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Total cash";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Total cheque";
    			t7 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$6, 75, 24, 2683);
    			add_location(th1, file$6, 76, 24, 2721);
    			attr_dev(th2, "class", "uk-text-nowrap");
    			add_location(th2, file$6, 77, 24, 2763);
    			attr_dev(th3, "class", "uk-text-nowrap");
    			add_location(th3, file$6, 78, 24, 2830);
    			add_location(tr, file$6, 74, 20, 2654);
    			add_location(thead, file$6, 73, 20, 2626);
    			add_location(tbody, file$6, 81, 20, 2950);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$6, 72, 16, 2520);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(table, t7);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*openForm, data, DateTime*/ 513) {
    				each_value = /*data*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(72:12) {:else }",
    		ctx
    	});

    	return block;
    }

    // (70:12) {#if data.length === 0 }
    function create_if_block$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading bank deposits...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(70:12) {#if data.length === 0 }",
    		ctx
    	});

    	return block;
    }

    // (83:20) {#each data as bankrun}
    function create_each_block$2(ctx) {
    	let tr;
    	let td0;
    	let t0_value = DateTime_1.fromSQL(/*bankrun*/ ctx[19].date).toFormat('dd LLL yyyy') + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*bankrun*/ ctx[19].invoices.join(', ') + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*bankrun*/ ctx[19].total_amount_cash + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*bankrun*/ ctx[19].total_amount_cheque + "";
    	let t6;
    	let t7;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[11](/*bankrun*/ ctx[19]);
    	}

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[12](/*bankrun*/ ctx[19]);
    	}

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[13](/*bankrun*/ ctx[19]);
    	}

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[14](/*bankrun*/ ctx[19]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			attr_dev(td0, "class", "uk-text-nowrap");
    			add_location(td0, file$6, 84, 28, 3081);
    			add_location(td1, file$6, 85, 28, 3233);
    			attr_dev(td2, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td2, file$6, 86, 28, 3335);
    			attr_dev(td3, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td3, file$6, 87, 28, 3474);
    			attr_dev(tr, "class", "uk-table-link");
    			add_location(tr, file$6, 83, 24, 3026);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);

    			if (!mounted) {
    				dispose = [
    					listen_dev(td0, "click", click_handler, false, false, false),
    					listen_dev(td1, "click", click_handler_1, false, false, false),
    					listen_dev(td2, "click", click_handler_2, false, false, false),
    					listen_dev(td3, "click", click_handler_3, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*data*/ 1 && t0_value !== (t0_value = DateTime_1.fromSQL(/*bankrun*/ ctx[19].date).toFormat('dd LLL yyyy') + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*data*/ 1 && t2_value !== (t2_value = /*bankrun*/ ctx[19].invoices.join(', ') + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*data*/ 1 && t4_value !== (t4_value = /*bankrun*/ ctx[19].total_amount_cash + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*data*/ 1 && t6_value !== (t6_value = /*bankrun*/ ctx[19].total_amount_cheque + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(83:20) {#each data as bankrun}",
    		ctx
    	});

    	return block;
    }

    // (115:16) {#key recreateForm}
    function create_key_block$2(ctx) {
    	let bankrunsheet;
    	let updating_bankRun;
    	let current;

    	function bankrunsheet_bankRun_binding(value) {
    		/*bankrunsheet_bankRun_binding*/ ctx[16](value);
    	}

    	let bankrunsheet_props = {};

    	if (/*selectedBankRun*/ ctx[4] !== void 0) {
    		bankrunsheet_props.bankRun = /*selectedBankRun*/ ctx[4];
    	}

    	bankrunsheet = new BankRunSheet({
    			props: bankrunsheet_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$1(bankrunsheet, 'bankRun', bankrunsheet_bankRun_binding));
    	bankrunsheet.$on("message", /*closeForm*/ ctx[10]);

    	const block = {
    		c: function create() {
    			create_component(bankrunsheet.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(bankrunsheet, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const bankrunsheet_changes = {};

    			if (!updating_bankRun && dirty & /*selectedBankRun*/ 16) {
    				updating_bankRun = true;
    				bankrunsheet_changes.bankRun = /*selectedBankRun*/ ctx[4];
    				add_flush_callback(() => updating_bankRun = false);
    			}

    			bankrunsheet.$set(bankrunsheet_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bankrunsheet.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bankrunsheet.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(bankrunsheet, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$2.name,
    		type: "key",
    		source: "(115:16) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let div2;
    	let div1;
    	let h4;

    	let t0_value = (/*$screenWidthS*/ ctx[6] || /*$screenWidthM*/ ctx[7]
    	? 'Deposits'
    	: 'Bank deposits') + "";

    	let t0;
    	let t1;
    	let span1;
    	let button0;
    	let span0;
    	let t2;
    	let t3;
    	let div0;
    	let t4;
    	let infinitescroll;
    	let t5;
    	let div6;
    	let div5;
    	let button1;
    	let t6;
    	let div4;
    	let div3;
    	let previous_key = /*recreateForm*/ ctx[5];
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0) return create_if_block$5;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	infinitescroll = new InfiniteScroll({
    			props: {
    				hasMore: /*newBatch*/ ctx[1].length,
    				threshold: 80
    			},
    			$$inline: true
    		});

    	infinitescroll.$on("loadMore", /*loadMore_handler*/ ctx[15]);
    	let key_block = create_key_block$2(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span1 = element("span");
    			button0 = element("button");
    			span0 = element("span");
    			t2 = text$1(" Deposit sheet");
    			t3 = space();
    			div0 = element("div");
    			if_block.c();
    			t4 = space();
    			create_component(infinitescroll.$$.fragment);
    			t5 = space();
    			div6 = element("div");
    			div5 = element("div");
    			button1 = element("button");
    			t6 = space();
    			div4 = element("div");
    			div3 = element("div");
    			key_block.c();
    			attr_dev(span0, "uk-icon", "icon: plus; ratio: 0.6");
    			add_location(span0, file$6, 66, 102, 2271);
    			attr_dev(button0, "class", "uk-button uk-button-primary uk-margin-medium-left");
    			add_location(button0, file$6, 66, 16, 2185);
    			attr_dev(span1, "class", "uk-position-right");
    			add_location(span1, file$6, 65, 12, 2136);
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-inline uk-width-1-1");
    			add_location(h4, file$6, 64, 8, 1950);
    			attr_dev(div0, "class", "uk-margin-medium");
    			add_location(div0, file$6, 68, 8, 2374);
    			attr_dev(div1, "class", "uk-section uk-section-xsmall uk-margin-medium-top uk-margin-bottom uk-width-2-3@m uk-width-5-6");
    			add_location(div1, file$6, 63, 4, 1833);
    			attr_dev(div2, "class", "uk-flex uk-flex-center");
    			set_style(div2, "max-height", "90%");
    			set_style(div2, "overflow-x", "scroll");
    			add_location(div2, file$6, 62, 0, 1747);
    			attr_dev(button1, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "uk-close", "");
    			add_location(button1, file$6, 111, 8, 4185);
    			attr_dev(div3, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div3, "uk-height-viewport", "");
    			add_location(div3, file$6, 113, 12, 4326);
    			attr_dev(div4, "class", "uk-flex uk-flex-center");
    			add_location(div4, file$6, 112, 8, 4277);
    			attr_dev(div5, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div5, file$6, 110, 4, 4115);
    			attr_dev(div6, "id", "modal-bank-run");
    			attr_dev(div6, "class", "uk-modal-full");
    			attr_dev(div6, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div6, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[7]);
    			add_location(div6, file$6, 106, 0, 3960);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t0);
    			append_dev(h4, t1);
    			append_dev(h4, span1);
    			append_dev(span1, button0);
    			append_dev(button0, span0);
    			append_dev(button0, t2);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			if_block.m(div0, null);
    			append_dev(div1, t4);
    			mount_component(infinitescroll, div1, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div5);
    			append_dev(div5, button1);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			key_block.m(div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button0, "click", /*openForm*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$screenWidthS, $screenWidthM*/ 192) && t0_value !== (t0_value = (/*$screenWidthS*/ ctx[6] || /*$screenWidthM*/ ctx[7]
    			? 'Deposits'
    			: 'Bank deposits') + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}

    			const infinitescroll_changes = {};
    			if (dirty & /*newBatch*/ 2) infinitescroll_changes.hasMore = /*newBatch*/ ctx[1].length;
    			infinitescroll.$set(infinitescroll_changes);

    			if (dirty & /*recreateForm*/ 32 && safe_not_equal(previous_key, previous_key = /*recreateForm*/ ctx[5])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block$2(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div3, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (dirty & /*$screenWidthM*/ 128) {
    				toggle_class(div6, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[7]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(infinitescroll.$$.fragment, local);
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(infinitescroll.$$.fragment, local);
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block.d();
    			destroy_component(infinitescroll);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div6);
    			key_block.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $screenWidthS;
    	let $screenWidthM;
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(6, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(7, $screenWidthM = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BankRuns', slots, []);
    	let page = 1;
    	let maxPage = 2;
    	let data = [];
    	let newBatch = [];
    	let selectedBankRun = null;
    	let recreateForm = true;
    	const dispatch = createEventDispatcher();
    	onMount(async () => await fetchData());

    	async function fetchData() {
    		const response = await getBankruns(page);
    		$$invalidate(3, maxPage = response.meta.last_page);
    		$$invalidate(1, newBatch = await response.data);
    	}

    	function openForm(bankRun) {
    		$$invalidate(4, selectedBankRun = bankRun instanceof MouseEvent
    		? null
    		: JSON.parse(JSON.stringify(bankRun)));

    		$$invalidate(5, recreateForm = !recreateForm);
    		uikit.modal("#modal-bank-run").show();
    	}

    	function closeForm(event) {
    		if (event.detail.goto !== undefined) {
    			switch (event.detail.goto) {
    				case 'cancel':
    					uikit.modal("#modal-bank-run").hide();
    					dispatchReload();
    			}
    		}
    	}

    	function dispatchReload() {
    		dispatch('message', { reload: 'bankrun' });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BankRuns> was created with unknown prop '${key}'`);
    	});

    	const click_handler = bankrun => openForm(bankrun);
    	const click_handler_1 = bankrun => openForm(bankrun);
    	const click_handler_2 = bankrun => openForm(bankrun);
    	const click_handler_3 = bankrun => openForm(bankrun);

    	const loadMore_handler = () => {
    		if (page < maxPage) {
    			$$invalidate(2, page++, page);
    			fetchData();
    		}
    	};

    	function bankrunsheet_bankRun_binding(value) {
    		selectedBankRun = value;
    		$$invalidate(4, selectedBankRun);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		InfiniteScroll,
    		SimpleSwitch,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		autoComplete,
    		DateTime: DateTime_1,
    		getInvoices,
    		getReconciliationInvoices,
    		invoiceNames,
    		updateInvoice,
    		flatpickr,
    		UIkit: uikit,
    		BankRunSheet,
    		getBankruns,
    		page,
    		maxPage,
    		data,
    		newBatch,
    		selectedBankRun,
    		recreateForm,
    		dispatch,
    		fetchData,
    		openForm,
    		closeForm,
    		dispatchReload,
    		$screenWidthS,
    		$screenWidthM
    	});

    	$$self.$inject_state = $$props => {
    		if ('page' in $$props) $$invalidate(2, page = $$props.page);
    		if ('maxPage' in $$props) $$invalidate(3, maxPage = $$props.maxPage);
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('newBatch' in $$props) $$invalidate(1, newBatch = $$props.newBatch);
    		if ('selectedBankRun' in $$props) $$invalidate(4, selectedBankRun = $$props.selectedBankRun);
    		if ('recreateForm' in $$props) $$invalidate(5, recreateForm = $$props.recreateForm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, newBatch*/ 3) {
    			$$invalidate(0, data = [...data, ...newBatch]);
    		}
    	};

    	return [
    		data,
    		newBatch,
    		page,
    		maxPage,
    		selectedBankRun,
    		recreateForm,
    		$screenWidthS,
    		$screenWidthM,
    		fetchData,
    		openForm,
    		closeForm,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		loadMore_handler,
    		bankrunsheet_bankRun_binding
    	];
    }

    class BankRuns extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BankRuns",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* src/components/Newsletter.svelte generated by Svelte v3.45.0 */
    const file$5 = "src/components/Newsletter.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (53:12) {:else}
    function create_else_block$4(ctx) {
    	let a;
    	let span;
    	let t;
    	let each_1_anchor;
    	let mounted;
    	let dispose;
    	let each_value = /*list*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			span = element("span");
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$3();
    			attr_dev(span, "class", "uk-position-top-right");
    			attr_dev(span, "uk-icon", "icon: copy");
    			attr_dev(span, "uk-tooltip", "Copy emails");
    			add_location(span, file$5, 53, 52, 2265);
    			attr_dev(a, "href", '#');
    			add_location(a, file$5, 53, 16, 2229);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, span);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*copyList*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*list*/ 2) {
    				each_value = /*list*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(53:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (51:12) {#if list.length === 0}
    function create_if_block$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Please select a start date");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(51:12) {#if list.length === 0}",
    		ctx
    	});

    	return block;
    }

    // (55:16) {#each list as email}
    function create_each_block$1(ctx) {
    	let t_value = /*email*/ ctx[10] + "";
    	let t;
    	let br;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    			br = element("br");
    			add_location(br, file$5, 55, 27, 2424);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, br, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*list*/ 2 && t_value !== (t_value = /*email*/ ctx[10] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(br);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(55:16) {#each list as email}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div2;
    	let div1;
    	let h4;

    	let t0_value = (/*$screenWidthS*/ ctx[2] || /*$screenWidthM*/ ctx[3] || /*$screenWidthL*/ ctx[4]
    	? 'Emails'
    	: 'Newsletter emails') + "";

    	let t0;
    	let t1;
    	let span;
    	let input;
    	let t2;
    	let button;
    	let t4;
    	let div0;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*list*/ ctx[1].length === 0) return create_if_block$4;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			h4 = element("h4");
    			t0 = text$1(t0_value);
    			t1 = space();
    			span = element("span");
    			input = element("input");
    			t2 = space();
    			button = element("button");
    			button.textContent = "Get list";
    			t4 = space();
    			div0 = element("div");
    			if_block.c();
    			attr_dev(input, "class", "uk-input uk-form-width-medium");
    			attr_dev(input, "id", "form-date");
    			attr_dev(input, "name", "date");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "Start Date");
    			input.readOnly = true;
    			set_style(input, "color", "black");
    			add_location(input, file$5, 45, 16, 1714);
    			attr_dev(button, "class", "uk-button uk-button-primary uk-margin-left");
    			attr_dev(button, "id", "submit");
    			add_location(button, file$5, 47, 12, 1916);
    			attr_dev(span, "class", "uk-position-center-right uk-text-default");
    			add_location(span, file$5, 44, 12, 1642);
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-inline uk-width-1-1");
    			add_location(h4, file$5, 43, 8, 1438);
    			attr_dev(div0, "class", "uk-margin-medium uk-inline uk-width-expand");
    			add_location(div0, file$5, 49, 8, 2057);
    			attr_dev(div1, "class", "uk-section uk-section-xsmall uk-margin-medium-top uk-margin-bottom uk-width-2-3@m uk-width-5-6");
    			add_location(div1, file$5, 42, 4, 1321);
    			attr_dev(div2, "class", "uk-flex uk-flex-center");
    			add_location(div2, file$5, 41, 0, 1280);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, h4);
    			append_dev(h4, t0);
    			append_dev(h4, t1);
    			append_dev(h4, span);
    			append_dev(span, input);
    			set_input_value(input, /*lastRetrieval*/ ctx[0]);
    			append_dev(span, t2);
    			append_dev(span, button);
    			append_dev(div1, t4);
    			append_dev(div1, div0);
    			if_block.m(div0, null);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[7]),
    					listen_dev(button, "click", /*getList*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$screenWidthS, $screenWidthM, $screenWidthL*/ 28 && t0_value !== (t0_value = (/*$screenWidthS*/ ctx[2] || /*$screenWidthM*/ ctx[3] || /*$screenWidthL*/ ctx[4]
    			? 'Emails'
    			: 'Newsletter emails') + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*lastRetrieval*/ 1 && input.value !== /*lastRetrieval*/ ctx[0]) {
    				set_input_value(input, /*lastRetrieval*/ ctx[0]);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $settings;
    	let $screenWidthS;
    	let $screenWidthM;
    	let $screenWidthL;
    	validate_store(settings, 'settings');
    	component_subscribe($$self, settings, $$value => $$invalidate(8, $settings = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(2, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(3, $screenWidthM = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(4, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Newsletter', slots, []);
    	const dispatch = createEventDispatcher();
    	let lastRetrieval = DateTime_1.now().toSQLDate();
    	let list = [];

    	onMount(() => {
    		$$invalidate(0, lastRetrieval = $settings.last_newsletter_retrieval);

    		flatpickr('#form-date', {
    			monthSelectorType: 'static',
    			defaultDate: lastRetrieval
    		});
    	});

    	async function getList() {
    		$$invalidate(0, lastRetrieval = document.getElementById('form-date').value);
    		$$invalidate(1, list = await getNewsletterEmails(lastRetrieval));
    		set_store_value(settings, $settings.last_newsletter_retrieval = lastRetrieval, $settings);
    		await updateSettings($settings);
    		dispatch('message', { reload: 'newsletter' });
    	}

    	async function copyList() {
    		await navigator.clipboard.writeText(list.join('\n'));
    		uikit.notification('<span uk-icon="icon: check"></span> Emails copied!', { status: 'success', pos: 'bottom-center' });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Newsletter> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		lastRetrieval = this.value;
    		$$invalidate(0, lastRetrieval);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		DateTime: DateTime_1,
    		getNewsletterEmails,
    		flatpickr,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		UIkit: uikit,
    		settings,
    		updateSettings,
    		dispatch,
    		lastRetrieval,
    		list,
    		getList,
    		copyList,
    		$settings,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL
    	});

    	$$self.$inject_state = $$props => {
    		if ('lastRetrieval' in $$props) $$invalidate(0, lastRetrieval = $$props.lastRetrieval);
    		if ('list' in $$props) $$invalidate(1, list = $$props.list);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		lastRetrieval,
    		list,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		getList,
    		copyList,
    		input_input_handler
    	];
    }

    class Newsletter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Newsletter",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* src/components/DataExport.svelte generated by Svelte v3.45.0 */
    const file$4 = "src/components/DataExport.svelte";

    function create_fragment$4(ctx) {
    	let div13;
    	let div12;
    	let h4;
    	let t1;
    	let form;
    	let div11;
    	let div10;
    	let div0;
    	let label0;
    	let t3;
    	let div3;
    	let div1;
    	let input0;
    	let t4;
    	let div2;
    	let input1;
    	let t5;
    	let div4;
    	let label1;
    	let t7;
    	let div5;
    	let t9;
    	let div6;
    	let button0;
    	let t10;
    	let button0_disabled_value;
    	let t11;
    	let div7;
    	let label2;
    	let t13;
    	let div8;
    	let t15;
    	let div9;
    	let button1;
    	let t16;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div13 = element("div");
    			div12 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Data export";
    			t1 = space();
    			form = element("form");
    			div11 = element("div");
    			div10 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Dates";
    			t3 = space();
    			div3 = element("div");
    			div1 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div2 = element("div");
    			input1 = element("input");
    			t5 = space();
    			div4 = element("div");
    			label1 = element("label");
    			label1.textContent = "Bookings";
    			t7 = space();
    			div5 = element("div");
    			div5.textContent = "Booking data for selected date range (arrival date)";
    			t9 = space();
    			div6 = element("div");
    			button0 = element("button");
    			t10 = text$1("Bookings");
    			t11 = space();
    			div7 = element("div");
    			label2 = element("label");
    			label2.textContent = "Invoices";
    			t13 = space();
    			div8 = element("div");
    			div8.textContent = "Invoice data (non-booking) for selected date range (paid date)";
    			t15 = space();
    			div9 = element("div");
    			button1 = element("button");
    			t16 = text$1("Invoices");
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-width-1-1");
    			add_location(h4, file$4, 40, 8, 1308);
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-start_date");
    			add_location(label0, file$4, 45, 24, 1687);
    			attr_dev(div0, "class", "uk-width-1-5@s");
    			add_location(div0, file$4, 44, 20, 1634);
    			attr_dev(input0, "class", "uk-input");
    			attr_dev(input0, "id", "form-start_date");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Start date");
    			input0.readOnly = true;
    			set_style(input0, "color", "black");
    			add_location(input0, file$4, 49, 28, 2004);
    			attr_dev(div1, "class", "uk-width-1-3@s");
    			add_location(div1, file$4, 48, 24, 1947);
    			attr_dev(input1, "class", "uk-input");
    			attr_dev(input1, "id", "form-end_date");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "End date");
    			input1.readOnly = true;
    			set_style(input1, "color", "black");
    			add_location(input1, file$4, 53, 28, 2287);
    			attr_dev(div2, "class", "uk-width-1-3@s");
    			add_location(div2, file$4, 52, 24, 2230);
    			attr_dev(div3, "class", "uk-width-4-5@s uk-form-controls uk-grid-small uk-margin-remove-left uk-padding-remove");
    			attr_dev(div3, "id", "form-dates");
    			attr_dev(div3, "uk-grid", "");
    			add_location(div3, file$4, 47, 20, 1799);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "form-bookings");
    			add_location(label1, file$4, 58, 24, 2583);
    			attr_dev(div4, "class", "uk-width-1-5@s");
    			add_location(div4, file$4, 57, 20, 2530);
    			attr_dev(div5, "class", "uk-width-2-5@s uk-text-small");
    			add_location(div5, file$4, 60, 20, 2696);
    			attr_dev(button0, "class", "uk-button");
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "id", "form-bookings");
    			button0.disabled = button0_disabled_value = !/*inputValid*/ ctx[2];
    			toggle_class(button0, "uk-button-primary", /*inputValid*/ ctx[2]);
    			add_location(button0, file$4, 64, 24, 2915);
    			attr_dev(div6, "class", "uk-width-2-5@s");
    			add_location(div6, file$4, 63, 20, 2862);
    			attr_dev(label2, "class", "uk-form-label");
    			attr_dev(label2, "for", "form-invoices");
    			add_location(label2, file$4, 68, 24, 3207);
    			attr_dev(div7, "class", "uk-width-1-5@s");
    			add_location(div7, file$4, 67, 20, 3154);
    			attr_dev(div8, "class", "uk-width-2-5@s uk-text-small");
    			add_location(div8, file$4, 70, 20, 3320);
    			attr_dev(button1, "class", "uk-button");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "id", "form-invoices");
    			button1.disabled = button1_disabled_value = !/*inputValid*/ ctx[2];
    			toggle_class(button1, "uk-button-primary", /*inputValid*/ ctx[2]);
    			add_location(button1, file$4, 74, 24, 3550);
    			attr_dev(div9, "class", "uk-width-2-5@s");
    			add_location(div9, file$4, 73, 20, 3497);
    			attr_dev(div10, "class", "uk-grid-small uk-margin-remove-left");
    			attr_dev(div10, "uk-grid", "");
    			add_location(div10, file$4, 43, 16, 1556);
    			attr_dev(div11, "class", "uk-margin-medium");
    			add_location(div11, file$4, 42, 12, 1509);
    			attr_dev(form, "class", "uk-form");
    			toggle_class(form, "uk-form-horizontal", !/*$screenWidthL*/ ctx[3]);
    			add_location(form, file$4, 41, 8, 1432);
    			attr_dev(div12, "class", "uk-section uk-section-xsmall uk-margin-medium-top uk-margin-bottom uk-width-2-3@m uk-width-5-6");
    			add_location(div12, file$4, 39, 4, 1191);
    			attr_dev(div13, "class", "uk-flex uk-flex-center");
    			add_location(div13, file$4, 38, 0, 1150);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div12);
    			append_dev(div12, h4);
    			append_dev(div12, t1);
    			append_dev(div12, form);
    			append_dev(form, div11);
    			append_dev(div11, div10);
    			append_dev(div10, div0);
    			append_dev(div0, label0);
    			append_dev(div10, t3);
    			append_dev(div10, div3);
    			append_dev(div3, div1);
    			append_dev(div1, input0);
    			set_input_value(input0, /*startDate*/ ctx[0]);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, input1);
    			set_input_value(input1, /*endDate*/ ctx[1]);
    			append_dev(div10, t5);
    			append_dev(div10, div4);
    			append_dev(div4, label1);
    			append_dev(div10, t7);
    			append_dev(div10, div5);
    			append_dev(div10, t9);
    			append_dev(div10, div6);
    			append_dev(div6, button0);
    			append_dev(button0, t10);
    			append_dev(div10, t11);
    			append_dev(div10, div7);
    			append_dev(div7, label2);
    			append_dev(div10, t13);
    			append_dev(div10, div8);
    			append_dev(div10, t15);
    			append_dev(div10, div9);
    			append_dev(div9, button1);
    			append_dev(button1, t16);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[6]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[7]),
    					listen_dev(button0, "click", /*getBookings*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*getInvoices*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*startDate*/ 1 && input0.value !== /*startDate*/ ctx[0]) {
    				set_input_value(input0, /*startDate*/ ctx[0]);
    			}

    			if (dirty & /*endDate*/ 2 && input1.value !== /*endDate*/ ctx[1]) {
    				set_input_value(input1, /*endDate*/ ctx[1]);
    			}

    			if (dirty & /*inputValid*/ 4 && button0_disabled_value !== (button0_disabled_value = !/*inputValid*/ ctx[2])) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (dirty & /*inputValid*/ 4) {
    				toggle_class(button0, "uk-button-primary", /*inputValid*/ ctx[2]);
    			}

    			if (dirty & /*inputValid*/ 4 && button1_disabled_value !== (button1_disabled_value = !/*inputValid*/ ctx[2])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*inputValid*/ 4) {
    				toggle_class(button1, "uk-button-primary", /*inputValid*/ ctx[2]);
    			}

    			if (dirty & /*$screenWidthL*/ 8) {
    				toggle_class(form, "uk-form-horizontal", !/*$screenWidthL*/ ctx[3]);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div13);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $screenWidthL;
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(3, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DataExport', slots, []);
    	let startDate = '';
    	let endDate = '';
    	let inputValid = false;

    	onMount(() => {
    		flatpickr('#form-dates', {
    			monthSelectorType: 'static',
    			mode: 'range',
    			onChange(selectedDates, dateStr) {
    				$$invalidate(0, startDate = dateStr.substring(0, 10));
    				$$invalidate(1, endDate = dateStr.substring(14));
    				if (startDate !== '') document.getElementById('form-start_date').focus();

    				if (endDate !== '') {
    					document.getElementById('form-end_date').focus();
    					setTimeout(() => document.getElementById('form-start_date').blur(), 0);
    				}

    				$$invalidate(2, inputValid = startDate !== '' && endDate !== '');
    			}
    		});
    	});

    	async function getBookings() {
    		await bookingsCSV(startDate, endDate);
    	}

    	async function getInvoices() {
    		await invoicesCSV(startDate, endDate);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DataExport> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		startDate = this.value;
    		$$invalidate(0, startDate);
    	}

    	function input1_input_handler() {
    		endDate = this.value;
    		$$invalidate(1, endDate);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		screenWidthL,
    		flatpickr,
    		bookingsCSV,
    		invoicesCSV,
    		startDate,
    		endDate,
    		inputValid,
    		getBookings,
    		getInvoices,
    		$screenWidthL
    	});

    	$$self.$inject_state = $$props => {
    		if ('startDate' in $$props) $$invalidate(0, startDate = $$props.startDate);
    		if ('endDate' in $$props) $$invalidate(1, endDate = $$props.endDate);
    		if ('inputValid' in $$props) $$invalidate(2, inputValid = $$props.inputValid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		startDate,
    		endDate,
    		inputValid,
    		$screenWidthL,
    		getBookings,
    		getInvoices,
    		input0_input_handler,
    		input1_input_handler
    	];
    }

    class DataExport extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DataExport",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    async function importEmporiaCSV(data) {
        try {
            return await api.post('/data/emporia-import/', data, {headers: {"Content-Type": "multipart/form-data"}})
        } catch (error) {
            console.error(error);
        }
    }

    async function importBookings(start, end) {
        try {
            return await api.post('/data/bookings-import/', {"start_date": start, "end_date": end})
        } catch (error) {
            console.error(error);
        }
    }

    /* src/components/DataImport.svelte generated by Svelte v3.45.0 */
    const file$3 = "src/components/DataImport.svelte";

    // (60:0) {:else}
    function create_else_block$3(ctx) {
    	let div11;
    	let div10;
    	let h4;
    	let t1;
    	let form;
    	let div9;
    	let div8;
    	let div0;
    	let label0;
    	let t3;
    	let div1;
    	let input0;
    	let t4;
    	let div2;
    	let button0;
    	let t5;
    	let button0_disabled_value;
    	let t6;
    	let div3;
    	let label1;
    	let t8;
    	let div6;
    	let div4;
    	let input1;
    	let t9;
    	let div5;
    	let input2;
    	let t10;
    	let div7;
    	let button1;
    	let t11;
    	let button1_disabled_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div11 = element("div");
    			div10 = element("div");
    			h4 = element("h4");
    			h4.textContent = "Elasticsearch import";
    			t1 = space();
    			form = element("form");
    			div9 = element("div");
    			div8 = element("div");
    			div0 = element("div");
    			label0 = element("label");
    			label0.textContent = "Emporia CSV";
    			t3 = space();
    			div1 = element("div");
    			input0 = element("input");
    			t4 = space();
    			div2 = element("div");
    			button0 = element("button");
    			t5 = text$1("Upload");
    			t6 = space();
    			div3 = element("div");
    			label1 = element("label");
    			label1.textContent = "Bookings";
    			t8 = space();
    			div6 = element("div");
    			div4 = element("div");
    			input1 = element("input");
    			t9 = space();
    			div5 = element("div");
    			input2 = element("input");
    			t10 = space();
    			div7 = element("div");
    			button1 = element("button");
    			t11 = text$1("Import");
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-width-1-1");
    			add_location(h4, file$3, 62, 12, 2593);
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-start_date");
    			add_location(label0, file$3, 67, 28, 3001);
    			attr_dev(div0, "class", "uk-width-1-5@s");
    			add_location(div0, file$3, 66, 24, 2944);
    			attr_dev(input0, "type", "file");
    			attr_dev(input0, "name", "emporia-csv");
    			attr_dev(input0, "id", "emporia-csv");
    			add_location(input0, file$3, 70, 28, 3198);
    			attr_dev(div1, "class", "uk-width-3-5@s uk-text-small");
    			add_location(div1, file$3, 69, 24, 3127);
    			attr_dev(button0, "class", "uk-button uk-button-primary uk-width-1-1");
    			button0.disabled = button0_disabled_value = !/*fileInputValid*/ ctx[4];
    			add_location(button0, file$3, 73, 28, 3368);
    			attr_dev(div2, "class", "uk-width-1-5@s");
    			add_location(div2, file$3, 72, 24, 3311);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "form-start_date");
    			add_location(label1, file$3, 77, 28, 3609);
    			attr_dev(div3, "class", "uk-width-1-5@s");
    			add_location(div3, file$3, 76, 24, 3552);
    			attr_dev(input1, "class", "uk-input");
    			attr_dev(input1, "id", "form-start_date");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "Start date");
    			input1.readOnly = true;
    			set_style(input1, "color", "black");
    			add_location(input1, file$3, 81, 32, 3945);
    			attr_dev(div4, "class", "uk-width-1-3@s");
    			add_location(div4, file$3, 80, 28, 3884);
    			attr_dev(input2, "class", "uk-input");
    			attr_dev(input2, "id", "form-end_date");
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", "End date");
    			input2.readOnly = true;
    			set_style(input2, "color", "black");
    			add_location(input2, file$3, 85, 32, 4244);
    			attr_dev(div5, "class", "uk-width-1-3@s");
    			add_location(div5, file$3, 84, 28, 4183);
    			attr_dev(div6, "class", "uk-width-3-5@s uk-form-controls uk-grid-small uk-margin-remove-left uk-padding-remove");
    			attr_dev(div6, "id", "form-dates");
    			attr_dev(div6, "uk-grid", "");
    			add_location(div6, file$3, 79, 24, 3732);
    			attr_dev(button1, "class", "uk-button uk-button-primary uk-width-1-1");
    			button1.disabled = button1_disabled_value = !/*dateInputValid*/ ctx[3];
    			add_location(button1, file$3, 90, 28, 4560);
    			attr_dev(div7, "class", "uk-width-1-5@s");
    			add_location(div7, file$3, 89, 24, 4503);
    			attr_dev(div8, "class", "uk-grid-small uk-margin-remove-left");
    			attr_dev(div8, "uk-grid", "");
    			add_location(div8, file$3, 65, 20, 2862);
    			attr_dev(div9, "class", "uk-margin-medium");
    			add_location(div9, file$3, 64, 16, 2811);
    			attr_dev(form, "class", "uk-form");
    			toggle_class(form, "uk-form-horizontal", !/*$screenWidthL*/ ctx[5]);
    			add_location(form, file$3, 63, 12, 2730);
    			attr_dev(div10, "class", "uk-section uk-section-xsmall uk-margin-medium-top uk-margin-bottom uk-width-2-3@m uk-width-5-6");
    			add_location(div10, file$3, 61, 8, 2472);
    			attr_dev(div11, "class", "uk-flex uk-flex-center");
    			add_location(div11, file$3, 60, 4, 2427);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div10);
    			append_dev(div10, h4);
    			append_dev(div10, t1);
    			append_dev(div10, form);
    			append_dev(form, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div0);
    			append_dev(div0, label0);
    			append_dev(div8, t3);
    			append_dev(div8, div1);
    			append_dev(div1, input0);
    			append_dev(div8, t4);
    			append_dev(div8, div2);
    			append_dev(div2, button0);
    			append_dev(button0, t5);
    			append_dev(div8, t6);
    			append_dev(div8, div3);
    			append_dev(div3, label1);
    			append_dev(div8, t8);
    			append_dev(div8, div6);
    			append_dev(div6, div4);
    			append_dev(div4, input1);
    			set_input_value(input1, /*startDate*/ ctx[1]);
    			append_dev(div6, t9);
    			append_dev(div6, div5);
    			append_dev(div5, input2);
    			set_input_value(input2, /*endDate*/ ctx[2]);
    			append_dev(div8, t10);
    			append_dev(div8, div7);
    			append_dev(div7, button1);
    			append_dev(button1, t11);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*handleEmporiaCSV*/ ctx[7], false, false, false),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[8]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[9]),
    					listen_dev(button1, "click", /*handleBookingsImport*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fileInputValid*/ 16 && button0_disabled_value !== (button0_disabled_value = !/*fileInputValid*/ ctx[4])) {
    				prop_dev(button0, "disabled", button0_disabled_value);
    			}

    			if (dirty & /*startDate*/ 2 && input1.value !== /*startDate*/ ctx[1]) {
    				set_input_value(input1, /*startDate*/ ctx[1]);
    			}

    			if (dirty & /*endDate*/ 4 && input2.value !== /*endDate*/ ctx[2]) {
    				set_input_value(input2, /*endDate*/ ctx[2]);
    			}

    			if (dirty & /*dateInputValid*/ 8 && button1_disabled_value !== (button1_disabled_value = !/*dateInputValid*/ ctx[3])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty & /*$screenWidthL*/ 32) {
    				toggle_class(form, "uk-form-horizontal", !/*$screenWidthL*/ ctx[5]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div11);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(60:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (56:0) {#if processing}
    function create_if_block$3(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$3, 57, 8, 2370);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-xlarge-top");
    			add_location(div1, file$3, 56, 4, 2304);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(56:0) {#if processing}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*processing*/ ctx[0]) return create_if_block$3;
    		return create_else_block$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$3();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $screenWidthL;
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(5, $screenWidthL = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DataImport', slots, []);
    	let processing = false;
    	let startDate = '';
    	let endDate = '';
    	let dateInputValid = false;
    	let fileInputValid = false;

    	onMount(() => {
    		flatpickr('#form-dates', {
    			monthSelectorType: 'static',
    			mode: 'range',
    			onChange(selectedDates, dateStr) {
    				$$invalidate(1, startDate = dateStr.substring(0, 10));
    				$$invalidate(2, endDate = dateStr.substring(14));
    				if (startDate !== '') document.getElementById('form-start_date').focus();

    				if (endDate !== '') {
    					document.getElementById('form-end_date').focus();
    					setTimeout(() => document.getElementById('form-start_date').blur(), 0);
    				}

    				$$invalidate(3, dateInputValid = startDate !== '' && endDate !== '');
    			}
    		});

    		let fileInput = document.getElementById('emporia-csv');
    		fileInput.addEventListener('change', () => $$invalidate(4, fileInputValid = fileInput.files.length > 0));
    	});

    	async function handleBookingsImport() {
    		$$invalidate(0, processing = true);
    		const result = await importBookings(startDate, endDate);
    		$$invalidate(0, processing = false);
    		if (result.status && result.status === 200) uikit.notification('<span uk-icon="icon: check"></span> Successfully ingested!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed! ' + result.data, { status: 'danger', pos: 'bottom-center' });
    	}

    	async function handleEmporiaCSV() {
    		$$invalidate(0, processing = true);
    		const result = await importEmporiaCSV(new FormData(document.querySelector('form')));
    		$$invalidate(0, processing = false);
    		if (result.status && result.status === 200) uikit.notification('<span uk-icon="icon: check"></span> Successfully ingested!', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Failed! ' + result.data, { status: 'danger', pos: 'bottom-center' });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DataImport> was created with unknown prop '${key}'`);
    	});

    	function input1_input_handler() {
    		startDate = this.value;
    		$$invalidate(1, startDate);
    	}

    	function input2_input_handler() {
    		endDate = this.value;
    		$$invalidate(2, endDate);
    	}

    	$$self.$capture_state = () => ({
    		screenWidthL,
    		importEmporiaCSV,
    		importBookings,
    		UIkit: uikit,
    		onMount,
    		flatpickr,
    		processing,
    		startDate,
    		endDate,
    		dateInputValid,
    		fileInputValid,
    		handleBookingsImport,
    		handleEmporiaCSV,
    		$screenWidthL
    	});

    	$$self.$inject_state = $$props => {
    		if ('processing' in $$props) $$invalidate(0, processing = $$props.processing);
    		if ('startDate' in $$props) $$invalidate(1, startDate = $$props.startDate);
    		if ('endDate' in $$props) $$invalidate(2, endDate = $$props.endDate);
    		if ('dateInputValid' in $$props) $$invalidate(3, dateInputValid = $$props.dateInputValid);
    		if ('fileInputValid' in $$props) $$invalidate(4, fileInputValid = $$props.fileInputValid);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		processing,
    		startDate,
    		endDate,
    		dateInputValid,
    		fileInputValid,
    		$screenWidthL,
    		handleBookingsImport,
    		handleEmporiaCSV,
    		input1_input_handler,
    		input2_input_handler
    	];
    }

    class DataImport extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$3, create_fragment$3, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DataImport",
    			options,
    			id: create_fragment$3.name
    		});
    	}
    }

    /* src/components/MattressForm.svelte generated by Svelte v3.45.0 */

    const { Object: Object_1 } = globals;
    const file$2 = "src/components/MattressForm.svelte";

    // (139:4) {:else}
    function create_else_block_4$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Creating transaction");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4$1.name,
    		type: "else",
    		source: "(139:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (137:19) 
    function create_if_block_11$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Updating transaction");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11$1.name,
    		type: "if",
    		source: "(137:19) ",
    		ctx
    	});

    	return block;
    }

    // (134:26) 
    function create_if_block_10$1(ctx) {
    	let t0;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text$1("Edit transaction\n        ");
    			button = element("button");
    			button.textContent = "Delete";
    			attr_dev(button, "class", "uk-button uk-text-normal uk-margin uk-button-secondary uk-position-bottom-right uk-button-danger");
    			attr_dev(button, "type", "button");
    			add_location(button, file$2, 135, 8, 5275);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*deleteMe*/ ctx[21], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10$1.name,
    		type: "if",
    		source: "(134:26) ",
    		ctx
    	});

    	return block;
    }

    // (132:4) {#if !edit && !dispatched}
    function create_if_block_9$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("New transaction");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9$1.name,
    		type: "if",
    		source: "(132:4) {#if !edit && !dispatched}",
    		ctx
    	});

    	return block;
    }

    // (147:0) {:else}
    function create_else_block$2(ctx) {
    	let form_1;
    	let div2;
    	let label;
    	let t1;
    	let div1;
    	let div0;
    	let select;
    	let option;
    	let if_block0_anchor;
    	let t3;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = (!/*edit*/ ctx[4] || /*edit*/ ctx[4] && /*transaction*/ ctx[0]?.transaction !== 'credit') && create_if_block_7$2(ctx);
    	let if_block1 = (!/*edit*/ ctx[4] || /*edit*/ ctx[4] && /*transaction*/ ctx[0]?.transaction !== 'debit' && /*transaction*/ ctx[0]?.transaction !== 'reserve') && create_if_block_6$2(ctx);
    	let if_block2 = /*hasTransactionType*/ ctx[5] && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			form_1 = element("form");
    			div2 = element("div");
    			label = element("label");
    			label.textContent = "Transaction";
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			select = element("select");
    			option = element("option");
    			option.textContent = "Select transaction type:";
    			if (if_block0) if_block0.c();
    			if_block0_anchor = empty$3();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(label, "class", "uk-form-label");
    			attr_dev(label, "for", "form-transaction");
    			add_location(label, file$2, 150, 12, 5853);
    			option.__value = "";
    			option.value = option.__value;
    			option.selected = true;
    			option.disabled = true;
    			add_location(option, file$2, 154, 24, 6294);
    			attr_dev(select, "class", "uk-select");
    			attr_dev(select, "id", "form-transaction");
    			attr_dev(select, "name", "transaction");
    			attr_dev(select, "type", "text");
    			if (/*$form*/ ctx[8].transaction === void 0) add_render_callback(() => /*select_change_handler*/ ctx[23].call(select));
    			add_location(select, file$2, 153, 20, 6124);
    			attr_dev(div0, "class", "uk-width-1-1@s");
    			add_location(div0, file$2, 152, 16, 6075);
    			attr_dev(div1, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l uk-margin-small-bottom");
    			attr_dev(div1, "id", "form-transaction");
    			attr_dev(div1, "uk-grid", "");
    			add_location(div1, file$2, 151, 12, 5937);
    			attr_dev(div2, "class", "uk-margin-medium uk-margin-small-bottom");
    			add_location(div2, file$2, 149, 8, 5787);
    			attr_dev(form_1, "class", "uk-form");
    			toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[11]);
    			add_location(form_1, file$2, 147, 4, 5688);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form_1, anchor);
    			append_dev(form_1, div2);
    			append_dev(div2, label);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, select);
    			append_dev(select, option);
    			if (if_block0) if_block0.m(select, null);
    			append_dev(select, if_block0_anchor);
    			if (if_block1) if_block1.m(select, null);
    			select_option(select, /*$form*/ ctx[8].transaction);
    			append_dev(form_1, t3);
    			if (if_block2) if_block2.m(form_1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*selectTransactionType*/ ctx[19], false, false, false),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[23]),
    					listen_dev(form_1, "submit", /*handleSubmit*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!/*edit*/ ctx[4] || /*edit*/ ctx[4] && /*transaction*/ ctx[0]?.transaction !== 'credit') {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_7$2(ctx);
    					if_block0.c();
    					if_block0.m(select, if_block0_anchor);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*edit*/ ctx[4] || /*edit*/ ctx[4] && /*transaction*/ ctx[0]?.transaction !== 'debit' && /*transaction*/ ctx[0]?.transaction !== 'reserve') {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_6$2(ctx);
    					if_block1.c();
    					if_block1.m(select, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*$form*/ 256) {
    				select_option(select, /*$form*/ ctx[8].transaction);
    			}

    			if (/*hasTransactionType*/ ctx[5]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*hasTransactionType*/ 32) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$2(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(form_1, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*$screenWidthL*/ 2048) {
    				toggle_class(form_1, "uk-form-horizontal", !/*$screenWidthL*/ ctx[11]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form_1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(147:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (143:0) {#if dispatched}
    function create_if_block$2(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "uk-spinner", "ratio: 3");
    			add_location(div0, file$2, 144, 8, 5631);
    			attr_dev(div1, "class", "uk-flex uk-flex-center uk-margin-xlarge-top");
    			add_location(div1, file$2, 143, 4, 5565);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: noop$4,
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(143:0) {#if dispatched}",
    		ctx
    	});

    	return block;
    }

    // (156:24) {#if !edit || (edit && transaction?.transaction !== 'credit')}
    function create_if_block_7$2(ctx) {
    	let option;

    	function select_block_type_2(ctx, dirty) {
    		if (/*balance*/ ctx[2] > 0) return create_if_block_8$1;
    		return create_else_block_3$1;
    	}

    	let current_block_type = select_block_type_2(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			option = element("option");
    			option.textContent = "Planned";
    			option.__value = "reserve";
    			option.value = option.__value;
    			add_location(option, file$2, 161, 28, 6764);
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, option, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_2(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(option.parentNode, option);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(156:24) {#if !edit || (edit && transaction?.transaction !== 'credit')}",
    		ctx
    	});

    	return block;
    }

    // (159:28) {:else}
    function create_else_block_3$1(ctx) {
    	let option;

    	const block = {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Allocation (no funding)";
    			option.__value = "debit";
    			option.value = option.__value;
    			option.disabled = true;
    			add_location(option, file$2, 159, 32, 6638);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$1.name,
    		type: "else",
    		source: "(159:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (157:28) {#if balance > 0}
    function create_if_block_8$1(ctx) {
    	let option;

    	const block = {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Allocation";
    			option.__value = "debit";
    			option.value = option.__value;
    			add_location(option, file$2, 157, 32, 6528);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(157:28) {#if balance > 0}",
    		ctx
    	});

    	return block;
    }

    // (164:24) {#if !edit || (edit && transaction?.transaction !== 'debit' && transaction?.transaction !== 'reserve')}
    function create_if_block_6$2(ctx) {
    	let option;

    	const block = {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Income";
    			option.__value = "credit";
    			option.value = option.__value;
    			add_location(option, file$2, 164, 28, 6991);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(164:24) {#if !edit || (edit && transaction?.transaction !== 'debit' && transaction?.transaction !== 'reserve')}",
    		ctx
    	});

    	return block;
    }

    // (171:8) {#if hasTransactionType}
    function create_if_block_1$2(ctx) {
    	let div2;
    	let label0;

    	let t0_value = (/*$form*/ ctx[8].transaction === 'credit'
    	? 'Income from'
    	: 'Expense for') + "";

    	let t0;
    	let t1;
    	let div1;
    	let div0;
    	let t2;
    	let span;

    	let t3_value = (/*$form*/ ctx[8].transaction === 'credit'
    	? 'Income'
    	: /*$form*/ ctx[8].transaction === 'debit'
    		? 'Allocation'
    		: 'Reservation') + "";

    	let t3;
    	let t4;
    	let div5;
    	let label1;
    	let t6;
    	let div4;
    	let div3;
    	let input;
    	let t7;
    	let t8;
    	let div8;
    	let label2;
    	let t10;
    	let div7;
    	let div6;
    	let textarea;
    	let textarea_placeholder_value;
    	let t11;
    	let current_block_type_index;
    	let if_block2;
    	let t12;
    	let div9;
    	let button0;
    	let t14;
    	let button1;
    	let t15_value = (/*edit*/ ctx[4] ? 'Update' : 'Create') + "";
    	let t15;
    	let button1_disabled_value;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type_3(ctx, dirty) {
    		if (/*$form*/ ctx[8].transaction === 'credit') return create_if_block_4$2;
    		return create_else_block_2$1;
    	}

    	let current_block_type = select_block_type_3(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*$form*/ ctx[8].type !== 'paf' && create_if_block_3$2(ctx);
    	const if_block_creators = [create_if_block_2$2, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type_4(ctx, dirty) {
    		if (/*$form*/ ctx[8].transaction !== 'credit' && /*$form*/ ctx[8].type === 'paf') return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_4(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			label0 = element("label");
    			t0 = text$1(t0_value);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			if_block0.c();
    			t2 = space();
    			span = element("span");
    			t3 = text$1(t3_value);
    			t4 = space();
    			div5 = element("div");
    			label1 = element("label");
    			label1.textContent = "Allocator";
    			t6 = space();
    			div4 = element("div");
    			div3 = element("div");
    			input = element("input");
    			t7 = space();
    			if (if_block1) if_block1.c();
    			t8 = space();
    			div8 = element("div");
    			label2 = element("label");
    			label2.textContent = "Description";
    			t10 = space();
    			div7 = element("div");
    			div6 = element("div");
    			textarea = element("textarea");
    			t11 = space();
    			if_block2.c();
    			t12 = space();
    			div9 = element("div");
    			button0 = element("button");
    			button0.textContent = "Cancel";
    			t14 = space();
    			button1 = element("button");
    			t15 = text$1(t15_value);
    			attr_dev(label0, "class", "uk-form-label");
    			attr_dev(label0, "for", "form-type");
    			add_location(label0, file$2, 172, 16, 7283);
    			attr_dev(span, "class", "uk-label uk-label-success uk-position-center-right uk-margin-right");
    			add_location(span, file$2, 194, 24, 9006);
    			attr_dev(div0, "class", "uk-width-1-1@s uk-inline");
    			add_location(div0, file$2, 174, 20, 7529);
    			attr_dev(div1, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div1, "id", "form-type");
    			attr_dev(div1, "uk-grid", "");
    			add_location(div1, file$2, 173, 16, 7417);
    			attr_dev(div2, "class", "uk-margin-medium uk-margin-remove-top uk-margin-small-bottom");
    			add_location(div2, file$2, 171, 12, 7192);
    			attr_dev(label1, "class", "uk-form-label");
    			attr_dev(label1, "for", "form-alllocator");
    			add_location(label1, file$2, 199, 16, 9350);
    			attr_dev(input, "class", "uk-input uk-form-width-large");
    			attr_dev(input, "id", "form-allocator-no1pw-search");
    			attr_dev(input, "name", "allocator");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "Allocator's name");
    			set_style(input, "color", "black");
    			toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].allocator && /*$touched*/ ctx[10].allocator);
    			add_location(input, file$2, 202, 24, 9605);
    			attr_dev(div3, "class", "uk-width-1-2@s");
    			add_location(div3, file$2, 201, 20, 9552);
    			attr_dev(div4, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div4, "id", "form-allocator");
    			attr_dev(div4, "uk-grid", "");
    			add_location(div4, file$2, 200, 16, 9435);
    			attr_dev(div5, "class", "uk-margin-medium uk-margin-remove-top");
    			add_location(div5, file$2, 198, 12, 9282);
    			attr_dev(label2, "class", "uk-form-label");
    			attr_dev(label2, "for", "form-description");
    			add_location(label2, file$2, 221, 16, 11020);
    			attr_dev(textarea, "class", "uk-textarea");
    			attr_dev(textarea, "name", "description");

    			attr_dev(textarea, "placeholder", textarea_placeholder_value = /*$form*/ ctx[8].type === 'donation_baguette'
    			? 'Invoice number'
    			: /*$form*/ ctx[8].type === 'donation_squid'
    				? 'Squid payment date'
    				: 'Description');

    			set_style(textarea, "color", "black");
    			toggle_class(textarea, "uk-form-danger", /*$errors*/ ctx[9].description && /*$touched*/ ctx[10].description);
    			add_location(textarea, file$2, 224, 28, 11282);
    			attr_dev(div6, "class", "uk-width-1-1");
    			add_location(div6, file$2, 223, 20, 11227);
    			attr_dev(div7, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div7, "id", "form-Description");
    			attr_dev(div7, "uk-grid", "");
    			add_location(div7, file$2, 222, 16, 11108);
    			attr_dev(div8, "class", "uk-margin-small");
    			add_location(div8, file$2, 220, 12, 10974);
    			attr_dev(button0, "class", "uk-button uk-button-default");
    			attr_dev(button0, "type", "button");
    			add_location(button0, file$2, 249, 16, 13048);
    			attr_dev(button1, "class", "uk-button uk-margin-large-left");
    			attr_dev(button1, "id", "submit");
    			attr_dev(button1, "type", "submit");
    			button1.disabled = button1_disabled_value = !/*formValid*/ ctx[6];
    			toggle_class(button1, "uk-button-primary", /*formValid*/ ctx[6]);
    			add_location(button1, file$2, 250, 16, 13156);
    			attr_dev(div9, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div9, file$2, 248, 12, 12958);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, label0);
    			append_dev(label0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			if_block0.m(div0, null);
    			append_dev(div0, t2);
    			append_dev(div0, span);
    			append_dev(span, t3);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div5, anchor);
    			append_dev(div5, label1);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, div3);
    			append_dev(div3, input);
    			set_input_value(input, /*$form*/ ctx[8].allocator);
    			insert_dev(target, t7, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, label2);
    			append_dev(div8, t10);
    			append_dev(div8, div7);
    			append_dev(div7, div6);
    			append_dev(div6, textarea);
    			set_input_value(textarea, /*$form*/ ctx[8].description);
    			insert_dev(target, t11, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, button0);
    			append_dev(div9, t14);
    			append_dev(div9, button1);
    			append_dev(button1, t15);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "keyup", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(input, "blur", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[26]),
    					listen_dev(textarea, "keyup", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(textarea, "blur", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[28]),
    					listen_dev(button0, "click", /*cancel*/ ctx[22], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*$form*/ 256) && t0_value !== (t0_value = (/*$form*/ ctx[8].transaction === 'credit'
    			? 'Income from'
    			: 'Expense for') + "")) set_data_dev(t0, t0_value);

    			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div0, t2);
    				}
    			}

    			if ((!current || dirty[0] & /*$form*/ 256) && t3_value !== (t3_value = (/*$form*/ ctx[8].transaction === 'credit'
    			? 'Income'
    			: /*$form*/ ctx[8].transaction === 'debit'
    				? 'Allocation'
    				: 'Reservation') + "")) set_data_dev(t3, t3_value);

    			if (dirty[0] & /*$form*/ 256 && input.value !== /*$form*/ ctx[8].allocator) {
    				set_input_value(input, /*$form*/ ctx[8].allocator);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 1536) {
    				toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].allocator && /*$touched*/ ctx[10].allocator);
    			}

    			if (/*$form*/ ctx[8].type !== 'paf') {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$2(ctx);
    					if_block1.c();
    					if_block1.m(t8.parentNode, t8);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty[0] & /*$form*/ 256 && textarea_placeholder_value !== (textarea_placeholder_value = /*$form*/ ctx[8].type === 'donation_baguette'
    			? 'Invoice number'
    			: /*$form*/ ctx[8].type === 'donation_squid'
    				? 'Squid payment date'
    				: 'Description')) {
    				attr_dev(textarea, "placeholder", textarea_placeholder_value);
    			}

    			if (dirty[0] & /*$form*/ 256) {
    				set_input_value(textarea, /*$form*/ ctx[8].description);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 1536) {
    				toggle_class(textarea, "uk-form-danger", /*$errors*/ ctx[9].description && /*$touched*/ ctx[10].description);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_4(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				} else {
    					if_block2.p(ctx, dirty);
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(t12.parentNode, t12);
    			}

    			if ((!current || dirty[0] & /*edit*/ 16) && t15_value !== (t15_value = (/*edit*/ ctx[4] ? 'Update' : 'Create') + "")) set_data_dev(t15, t15_value);

    			if (!current || dirty[0] & /*formValid*/ 64 && button1_disabled_value !== (button1_disabled_value = !/*formValid*/ ctx[6])) {
    				prop_dev(button1, "disabled", button1_disabled_value);
    			}

    			if (dirty[0] & /*formValid*/ 64) {
    				toggle_class(button1, "uk-button-primary", /*formValid*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_block0.d();
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div5);
    			if (detaching) detach_dev(t7);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (detaching) detach_dev(div8);
    			if (detaching) detach_dev(t11);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div9);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(171:8) {#if hasTransactionType}",
    		ctx
    	});

    	return block;
    }

    // (186:24) {:else}
    function create_else_block_2$1(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Select Expense type:";
    			option1 = element("option");
    			option1.textContent = "PAF booking";
    			option2 = element("option");
    			option2.textContent = "Travel";
    			option3 = element("option");
    			option3.textContent = "Per diem";
    			option4 = element("option");
    			option4.textContent = "Other";
    			option0.__value = "";
    			option0.value = option0.__value;
    			option0.selected = true;
    			option0.disabled = true;
    			add_location(option0, file$2, 187, 32, 8562);
    			option1.__value = "paf";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 188, 32, 8659);
    			option2.__value = "travel";
    			option2.value = option2.__value;
    			add_location(option2, file$2, 189, 32, 8732);
    			option3.__value = "perdiem";
    			option3.value = option3.__value;
    			add_location(option3, file$2, 190, 32, 8803);
    			option4.__value = "other";
    			option4.value = option4.__value;
    			add_location(option4, file$2, 191, 32, 8877);
    			attr_dev(select, "class", "uk-select");
    			attr_dev(select, "id", "form-type");
    			attr_dev(select, "name", "type");
    			attr_dev(select, "type", "text");
    			if (/*$form*/ ctx[8].type === void 0) add_render_callback(() => /*select_change_handler_2*/ ctx[25].call(select));
    			add_location(select, file$2, 186, 28, 8414);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			append_dev(select, option3);
    			append_dev(select, option4);
    			select_option(select, /*$form*/ ctx[8].type);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(select, "change", /*select_change_handler_2*/ ctx[25])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 256) {
    				select_option(select, /*$form*/ ctx[8].type);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(186:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (176:24) {#if $form.transaction === 'credit'}
    function create_if_block_4$2(ctx) {
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let mounted;
    	let dispose;
    	let if_block = /*$role*/ ctx[12] === 'admin' | /*$role*/ ctx[12] === 'root' && create_if_block_5$2(ctx);

    	const block = {
    		c: function create() {
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Select Income type:";
    			option1 = element("option");
    			option1.textContent = "Donation cash";
    			option2 = element("option");
    			option2.textContent = "Donation cheque/transfer";
    			if (if_block) if_block.c();
    			option0.__value = "";
    			option0.value = option0.__value;
    			option0.selected = true;
    			option0.disabled = true;
    			add_location(option0, file$2, 177, 32, 7805);
    			option1.__value = "donation_squid";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 178, 32, 7901);
    			option2.__value = "donation_baguette";
    			option2.value = option2.__value;
    			add_location(option2, file$2, 179, 32, 7987);
    			attr_dev(select, "class", "uk-select");
    			attr_dev(select, "id", "form-type");
    			attr_dev(select, "name", "type");
    			attr_dev(select, "type", "text");
    			if (/*$form*/ ctx[8].type === void 0) add_render_callback(() => /*select_change_handler_1*/ ctx[24].call(select));
    			add_location(select, file$2, 176, 28, 7657);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, select, anchor);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			if (if_block) if_block.m(select, null);
    			select_option(select, /*$form*/ ctx[8].type);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(select, "change", /*select_change_handler_1*/ ctx[24])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*$role*/ ctx[12] === 'admin' | /*$role*/ ctx[12] === 'root') {
    				if (if_block) ; else {
    					if_block = create_if_block_5$2(ctx);
    					if_block.c();
    					if_block.m(select, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty[0] & /*$form*/ 256) {
    				select_option(select, /*$form*/ ctx[8].type);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(select);
    			if (if_block) if_block.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(176:24) {#if $form.transaction === 'credit'}",
    		ctx
    	});

    	return block;
    }

    // (181:32) {#if $role === 'admin' | $role === 'root'}
    function create_if_block_5$2(ctx) {
    	let option0;
    	let option1;

    	const block = {
    		c: function create() {
    			option0 = element("option");
    			option0.textContent = "PERFmts";
    			option1 = element("option");
    			option1.textContent = "Wine";
    			option0.__value = "perfmts";
    			option0.value = option0.__value;
    			add_location(option0, file$2, 181, 36, 8166);
    			option1.__value = "wine";
    			option1.value = option1.__value;
    			add_location(option1, file$2, 182, 36, 8243);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option0, anchor);
    			insert_dev(target, option1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option0);
    			if (detaching) detach_dev(option1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(181:32) {#if $role === 'admin' | $role === 'root'}",
    		ctx
    	});

    	return block;
    }

    // (209:12) {#if $form.type !== 'paf'}
    function create_if_block_3$2(ctx) {
    	let div2;
    	let label;

    	let t0_value = (/*$form*/ ctx[8].transaction === 'credit'
    	? 'Source'
    	: 'Name') + "";

    	let t0;
    	let t1;
    	let div1;
    	let div0;
    	let input;
    	let input_placeholder_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			label = element("label");
    			t0 = text$1(t0_value);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			attr_dev(label, "class", "uk-form-label");
    			attr_dev(label, "for", "form-name");
    			add_location(label, file$2, 210, 20, 10163);
    			attr_dev(input, "class", "uk-input uk-form-width-large");
    			attr_dev(input, "id", "form-name-no1pw-search");
    			attr_dev(input, "name", "name");
    			attr_dev(input, "type", "text");

    			attr_dev(input, "placeholder", input_placeholder_value = /*$form*/ ctx[8].transaction === 'credit'
    			? 'Name, institution, '
    			: 'Person\'s name');

    			set_style(input, "color", "black");
    			toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].name && /*$touched*/ ctx[10].name);
    			add_location(input, file$2, 213, 28, 10462);
    			attr_dev(div0, "class", "uk-width-1-2@s");
    			add_location(div0, file$2, 212, 24, 10405);
    			attr_dev(div1, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div1, "id", "form-name");
    			attr_dev(div1, "uk-grid", "");
    			add_location(div1, file$2, 211, 20, 10289);
    			attr_dev(div2, "class", "uk-margin-medium uk-margin-small-bottom");
    			add_location(div2, file$2, 209, 16, 10089);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, label);
    			append_dev(label, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*$form*/ ctx[8].name);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "keyup", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(input, "blur", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_1*/ ctx[27])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 256 && t0_value !== (t0_value = (/*$form*/ ctx[8].transaction === 'credit'
    			? 'Source'
    			: 'Name') + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*$form*/ 256 && input_placeholder_value !== (input_placeholder_value = /*$form*/ ctx[8].transaction === 'credit'
    			? 'Name, institution, '
    			: 'Person\'s name')) {
    				attr_dev(input, "placeholder", input_placeholder_value);
    			}

    			if (dirty[0] & /*$form*/ 256 && input.value !== /*$form*/ ctx[8].name) {
    				set_input_value(input, /*$form*/ ctx[8].name);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 1536) {
    				toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].name && /*$touched*/ ctx[10].name);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(209:12) {#if $form.type !== 'paf'}",
    		ctx
    	});

    	return block;
    }

    // (237:12) {:else}
    function create_else_block_1$1(ctx) {
    	let div2;
    	let label;
    	let t1;
    	let div1;
    	let div0;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			label = element("label");
    			label.textContent = "Amount";
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			attr_dev(label, "class", "uk-form-label");
    			attr_dev(label, "for", "form-amount");
    			add_location(label, file$2, 238, 20, 12288);
    			attr_dev(input, "class", "uk-input");
    			attr_dev(input, "id", "form-amount-no1pw-search");
    			attr_dev(input, "name", "amount");
    			attr_dev(input, "type", "text");
    			set_style(input, "color", "black");
    			toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].amount && /*$touched*/ ctx[10].amount);
    			add_location(input, file$2, 241, 28, 12545);
    			attr_dev(div0, "class", "uk-width-1-6@s");
    			add_location(div0, file$2, 240, 24, 12488);
    			attr_dev(div1, "class", "uk-form-controls uk-grid-small uk-margin-remove-left@l");
    			attr_dev(div1, "id", "form-amount");
    			attr_dev(div1, "uk-grid", "");
    			add_location(div1, file$2, 239, 20, 12370);
    			attr_dev(div2, "class", "uk-margin-small");
    			add_location(div2, file$2, 237, 16, 12238);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, label);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			set_input_value(input, /*$form*/ ctx[8].amount);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "keyup", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(input, "blur", /*handleUpdate*/ ctx[20], false, false, false),
    					listen_dev(input, "input", /*input_input_handler_2*/ ctx[31])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$form*/ 256 && input.value !== /*$form*/ ctx[8].amount) {
    				set_input_value(input, /*$form*/ ctx[8].amount);
    			}

    			if (dirty[0] & /*$errors, $touched*/ 1536) {
    				toggle_class(input, "uk-form-danger", /*$errors*/ ctx[9].amount && /*$touched*/ ctx[10].amount);
    			}
    		},
    		i: noop$4,
    		o: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(237:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (232:12) {#if $form.transaction !== 'credit' && $form.type === 'paf'}
    function create_if_block_2$2(ctx) {
    	let div;
    	let t;
    	let bookingformcomponent;
    	let updating_booking;
    	let updating_formValid;
    	let current;

    	function bookingformcomponent_booking_binding(value) {
    		/*bookingformcomponent_booking_binding*/ ctx[29](value);
    	}

    	function bookingformcomponent_formValid_binding(value) {
    		/*bookingformcomponent_formValid_binding*/ ctx[30](value);
    	}

    	let bookingformcomponent_props = { isMattressBooking: true };

    	if (/*booking*/ ctx[1] !== void 0) {
    		bookingformcomponent_props.booking = /*booking*/ ctx[1];
    	}

    	if (/*bookingFormValid*/ ctx[3] !== void 0) {
    		bookingformcomponent_props.formValid = /*bookingFormValid*/ ctx[3];
    	}

    	bookingformcomponent = new BookingFormComponent({
    			props: bookingformcomponent_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$1(bookingformcomponent, 'booking', bookingformcomponent_booking_binding));
    	binding_callbacks.push(() => bind$1(bookingformcomponent, 'formValid', bookingformcomponent_formValid_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			create_component(bookingformcomponent.$$.fragment);
    			attr_dev(div, "class", "uk-heading-small uk-heading-divider uk-margin-medium-bottom uk-width-1-1");
    			add_location(div, file$2, 232, 16, 11922);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(bookingformcomponent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const bookingformcomponent_changes = {};

    			if (!updating_booking && dirty[0] & /*booking*/ 2) {
    				updating_booking = true;
    				bookingformcomponent_changes.booking = /*booking*/ ctx[1];
    				add_flush_callback(() => updating_booking = false);
    			}

    			if (!updating_formValid && dirty[0] & /*bookingFormValid*/ 8) {
    				updating_formValid = true;
    				bookingformcomponent_changes.formValid = /*bookingFormValid*/ ctx[3];
    				add_flush_callback(() => updating_formValid = false);
    			}

    			bookingformcomponent.$set(bookingformcomponent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bookingformcomponent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bookingformcomponent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t);
    			destroy_component(bookingformcomponent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(232:12) {#if $form.transaction !== 'credit' && $form.type === 'paf'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let h4;
    	let t;
    	let current_block_type_index;
    	let if_block1;
    	let if_block1_anchor;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (!/*edit*/ ctx[4] && !/*dispatched*/ ctx[7]) return create_if_block_9$1;
    		if (!/*dispatched*/ ctx[7]) return create_if_block_10$1;
    		if (/*edit*/ ctx[4]) return create_if_block_11$1;
    		return create_else_block_4$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	const if_block_creators = [create_if_block$2, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*dispatched*/ ctx[7]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			h4 = element("h4");
    			if_block0.c();
    			t = space();
    			if_block1.c();
    			if_block1_anchor = empty$3();
    			attr_dev(h4, "class", "uk-heading-small uk-heading-divider uk-text-light uk-margin-medium-bottom uk-inline uk-width-1-1");
    			add_location(h4, file$2, 130, 0, 5050);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h4, anchor);
    			if_block0.m(h4, null);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h4, null);
    				}
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h4);
    			if_block0.d();
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $form;
    	let $isValid;
    	let $errors;
    	let $touched;
    	let $screenWidthL;
    	let $role;
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(11, $screenWidthL = $$value));
    	validate_store(role, 'role');
    	component_subscribe($$self, role, $$value => $$invalidate(12, $role = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MattressForm', slots, []);
    	let { balance = 0 } = $$props;
    	let { transaction = undefined } = $$props;
    	let { booking = undefined } = $$props;
    	let bookingLoaded = false;
    	let edit = false;
    	let hasTransactionType = false;
    	let bookingFormValid = false;
    	let formValid = false;
    	let dispatched = false;
    	const dispatch = createEventDispatcher();

    	const { form, errors, touched, state, isValid, handleChange, handleSubmit } = createForm({
    		initialValues: {
    			allocator: '',
    			transaction: '',
    			type: '',
    			name: '',
    			description: '',
    			amount: 0
    		},
    		onSubmit: values => {
    			if (!dispatched && ($form.transaction !== 'credit' || confirm('Please ensure the source of income is clearly described'))) {
    				$$invalidate(7, dispatched = true);
    				if (transaction === null) $$invalidate(0, transaction = {});
    				handleUpdate();
    				Object.entries(values).forEach(e => $$invalidate(0, transaction[e[0]] = e[1], transaction));

    				if (booking) {
    					$$invalidate(1, booking.mattress_booking = true, booking);

    					if (!booking.paid && $form.transaction === 'debit') {
    						$$invalidate(1, booking.paid = true, booking);
    						$$invalidate(1, booking.date_paid = DateTime_1.now().toSQLDate(), booking);
    					}

    					if (booking.paid && $form.transaction === 'reserve') {
    						$$invalidate(1, booking.paid = false, booking);
    						$$invalidate(1, booking.date_paid = null, booking);
    					}
    				}

    				dispatch('message', {
    					goto: 'save',
    					booking: $form.transaction !== 'credit' && $form.type === 'paf' && bookingFormValid
    					? booking
    					: null
    				});
    			}
    		},
    		validationSchema: create$4().shape({
    			allocator: create$7().min(3).max(128).required(),
    			transaction: create$7().required(),
    			type: create$7().required(),
    			name: create$7().min(3).max(128).required(),
    			description: create$7().min(3).max(512),
    			amount: create$6().transform((number, string) => string === '' ? 0 : Number(string)).min(1)
    		})
    	});

    	validate_store(form, 'form');
    	component_subscribe($$self, form, value => $$invalidate(8, $form = value));
    	validate_store(errors, 'errors');
    	component_subscribe($$self, errors, value => $$invalidate(9, $errors = value));
    	validate_store(touched, 'touched');
    	component_subscribe($$self, touched, value => $$invalidate(10, $touched = value));
    	validate_store(isValid, 'isValid');
    	component_subscribe($$self, isValid, value => $$invalidate(32, $isValid = value));

    	onMount(async () => {
    		if (transaction !== undefined && booking !== undefined) {
    			$$invalidate(4, edit = transaction != null);

    			set_store_value(
    				form,
    				$form.allocator = transaction !== null && transaction.allocator !== null
    				? transaction.allocator
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.transaction = transaction !== null && transaction.transaction !== null
    				? transaction.transaction
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.type = transaction !== null && transaction.type !== null
    				? transaction.type
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.name = transaction !== null && transaction.name !== null
    				? transaction.name
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.description = transaction !== null && transaction.description !== null
    				? transaction.description
    				: '',
    				$form
    			);

    			set_store_value(
    				form,
    				$form.amount = transaction !== null && transaction.amount !== null
    				? transaction.amount
    				: '',
    				$form
    			);

    			// ugly hack to get force evaluate isValid
    			if (transaction === null) handleSubmit(null);

    			setTimeout(() => $$invalidate(6, formValid = $isValid && ($form.transaction !== 'credit' && $form.type === 'paf' && bookingFormValid || !($form.transaction !== 'credit' && $form.type === 'paf'))), 100);
    			$$invalidate(5, hasTransactionType = $form.transaction !== '');
    		}
    	});

    	function selectTransactionType(event) {
    		handleUpdate(event);
    		$$invalidate(5, hasTransactionType = $form.transaction !== '');
    		if (!edit) set_store_value(form, $form.type = '', $form);
    	}

    	function handleUpdate(event) {
    		if ($form.transaction !== 'credit' && $form.type === 'paf' && bookingFormValid) {
    			set_store_value(form, $form.name = booking?.name, $form);
    			set_store_value(form, $form.amount = calculateAmount(), $form);
    			set_store_value(touched, $touched.name = set_store_value(touched, $touched.amount = true, $touched), $touched);
    			set_store_value(errors, $errors.name = set_store_value(errors, $errors.amount = '', $errors), $errors);
    		}

    		if (event) handleChange(event);
    		setTimeout(() => $$invalidate(6, formValid = $isValid && ($form.transaction !== 'credit' && $form.type === 'paf' && bookingFormValid || !($form.transaction !== 'credit' && $form.type === 'paf'))), 0);
    	}

    	function calculateAmount() {
    		$$invalidate(1, booking = calculateBookingAmounts(booking));
    		return booking !== null ? booking.total_amount : 0;
    	}

    	async function deleteMe() {
    		if (transaction !== null && confirm("Are you sure to delete this transaction?")) {
    			dispatch('message', { goto: 'delete' });
    		}
    	}

    	function cancel() {
    		dispatch('message', { goto: 'cancel' });
    	}

    	const writable_props = ['balance', 'transaction', 'booking'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MattressForm> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		$form.transaction = select_value(this);
    		form.set($form);
    	}

    	function select_change_handler_1() {
    		$form.type = select_value(this);
    		form.set($form);
    	}

    	function select_change_handler_2() {
    		$form.type = select_value(this);
    		form.set($form);
    	}

    	function input_input_handler() {
    		$form.allocator = this.value;
    		form.set($form);
    	}

    	function input_input_handler_1() {
    		$form.name = this.value;
    		form.set($form);
    	}

    	function textarea_input_handler() {
    		$form.description = this.value;
    		form.set($form);
    	}

    	function bookingformcomponent_booking_binding(value) {
    		booking = value;
    		$$invalidate(1, booking);
    	}

    	function bookingformcomponent_formValid_binding(value) {
    		bookingFormValid = value;
    		$$invalidate(3, bookingFormValid);
    	}

    	function input_input_handler_2() {
    		$form.amount = this.value;
    		form.set($form);
    	}

    	$$self.$$set = $$props => {
    		if ('balance' in $$props) $$invalidate(2, balance = $$props.balance);
    		if ('transaction' in $$props) $$invalidate(0, transaction = $$props.transaction);
    		if ('booking' in $$props) $$invalidate(1, booking = $$props.booking);
    	};

    	$$self.$capture_state = () => ({
    		role,
    		createEventDispatcher,
    		onMount,
    		createForm,
    		yup,
    		screenWidthL,
    		BookingFormComponent,
    		DateTime: DateTime_1,
    		calculateBookingAmounts,
    		balance,
    		transaction,
    		booking,
    		bookingLoaded,
    		edit,
    		hasTransactionType,
    		bookingFormValid,
    		formValid,
    		dispatched,
    		dispatch,
    		form,
    		errors,
    		touched,
    		state,
    		isValid,
    		handleChange,
    		handleSubmit,
    		selectTransactionType,
    		handleUpdate,
    		calculateAmount,
    		deleteMe,
    		cancel,
    		$form,
    		$isValid,
    		$errors,
    		$touched,
    		$screenWidthL,
    		$role
    	});

    	$$self.$inject_state = $$props => {
    		if ('balance' in $$props) $$invalidate(2, balance = $$props.balance);
    		if ('transaction' in $$props) $$invalidate(0, transaction = $$props.transaction);
    		if ('booking' in $$props) $$invalidate(1, booking = $$props.booking);
    		if ('bookingLoaded' in $$props) $$invalidate(13, bookingLoaded = $$props.bookingLoaded);
    		if ('edit' in $$props) $$invalidate(4, edit = $$props.edit);
    		if ('hasTransactionType' in $$props) $$invalidate(5, hasTransactionType = $$props.hasTransactionType);
    		if ('bookingFormValid' in $$props) $$invalidate(3, bookingFormValid = $$props.bookingFormValid);
    		if ('formValid' in $$props) $$invalidate(6, formValid = $$props.formValid);
    		if ('dispatched' in $$props) $$invalidate(7, dispatched = $$props.dispatched);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*bookingFormValid*/ 8) {
    			bookingFormValid && handleUpdate();
    		}
    	};

    	return [
    		transaction,
    		booking,
    		balance,
    		bookingFormValid,
    		edit,
    		hasTransactionType,
    		formValid,
    		dispatched,
    		$form,
    		$errors,
    		$touched,
    		$screenWidthL,
    		$role,
    		bookingLoaded,
    		form,
    		errors,
    		touched,
    		isValid,
    		handleSubmit,
    		selectTransactionType,
    		handleUpdate,
    		deleteMe,
    		cancel,
    		select_change_handler,
    		select_change_handler_1,
    		select_change_handler_2,
    		input_input_handler,
    		input_input_handler_1,
    		textarea_input_handler,
    		bookingformcomponent_booking_binding,
    		bookingformcomponent_formValid_binding,
    		input_input_handler_2
    	];
    }

    class MattressForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$2, create_fragment$2, safe_not_equal, { balance: 2, transaction: 0, booking: 1 }, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MattressForm",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get balance() {
    		throw new Error("<MattressForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set balance(value) {
    		throw new Error("<MattressForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get transaction() {
    		throw new Error("<MattressForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set transaction(value) {
    		throw new Error("<MattressForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get booking() {
    		throw new Error("<MattressForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set booking(value) {
    		throw new Error("<MattressForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/Mattress.svelte generated by Svelte v3.45.0 */
    const file$1 = "src/components/Mattress.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    // (266:20) {:else}
    function create_else_block_5(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.debit + "";
    	let t1;
    	let span_style_value;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");

    			attr_dev(span, "style", span_style_value = /*transactionCounts*/ ctx[3]?.debit > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc');

    			add_location(span, file$1, 266, 31, 12060);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.debit + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*transactionCounts*/ 8 && span_style_value !== (span_style_value = /*transactionCounts*/ ctx[3]?.debit > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc')) {
    				attr_dev(span, "style", span_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_5.name,
    		type: "else",
    		source: "(266:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (264:20) {#if tab === 'debit'}
    function create_if_block_7$1(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.debit + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");
    			add_location(span, file$1, 264, 31, 11944);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.debit + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(264:20) {#if tab === 'debit'}",
    		ctx
    	});

    	return block;
    }

    // (273:20) {:else}
    function create_else_block_4(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.reserve + "";
    	let t1;
    	let span_style_value;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");

    			attr_dev(span, "style", span_style_value = /*transactionCounts*/ ctx[3]?.reserve > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc');

    			add_location(span, file$1, 273, 31, 12539);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.reserve + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*transactionCounts*/ 8 && span_style_value !== (span_style_value = /*transactionCounts*/ ctx[3]?.reserve > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc')) {
    				attr_dev(span, "style", span_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(273:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (271:20) {#if tab === 'reserve'}
    function create_if_block_6$1(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.reserve + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");
    			add_location(span, file$1, 271, 31, 12421);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.reserve + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(271:20) {#if tab === 'reserve'}",
    		ctx
    	});

    	return block;
    }

    // (281:24) {:else}
    function create_else_block_3(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.credit_mat + "";
    	let t1;
    	let span_style_value;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");

    			attr_dev(span, "style", span_style_value = /*transactionCounts*/ ctx[3]?.credit_all > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc');

    			add_location(span, file$1, 281, 35, 13016);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.credit_mat + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*transactionCounts*/ 8 && span_style_value !== (span_style_value = /*transactionCounts*/ ctx[3]?.credit_all > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc')) {
    				attr_dev(span, "style", span_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(281:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (279:24) {#if tab === 'credit'}
    function create_if_block_5$1(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.credit_mat + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");
    			add_location(span, file$1, 279, 35, 12887);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.credit_mat + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(279:24) {#if tab === 'credit'}",
    		ctx
    	});

    	return block;
    }

    // (291:32) {:else}
    function create_else_block_2(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.credit_mat + "";
    	let t1;
    	let span_style_value;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");

    			attr_dev(span, "style", span_style_value = /*transactionCounts*/ ctx[3]?.credit_mat > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc');

    			add_location(span, file$1, 291, 43, 13802);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.credit_mat + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*transactionCounts*/ 8 && span_style_value !== (span_style_value = /*transactionCounts*/ ctx[3]?.credit_mat > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc')) {
    				attr_dev(span, "style", span_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(291:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (289:32) {#if tab === 'credit' && creditShowOnlyMattress}
    function create_if_block_4$1(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.credit_mat + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");
    			add_location(span, file$1, 289, 43, 13657);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.credit_mat + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(289:32) {#if tab === 'credit' && creditShowOnlyMattress}",
    		ctx
    	});

    	return block;
    }

    // (298:32) {:else}
    function create_else_block_1(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.credit_all + "";
    	let t1;
    	let span_style_value;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");

    			attr_dev(span, "style", span_style_value = /*transactionCounts*/ ctx[3]?.credit_all > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc');

    			add_location(span, file$1, 298, 43, 14413);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.credit_all + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*transactionCounts*/ 8 && span_style_value !== (span_style_value = /*transactionCounts*/ ctx[3]?.credit_all > 0
    			? 'background-color: #999999'
    			: 'background-color: #cccccc')) {
    				attr_dev(span, "style", span_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(298:32) {:else}",
    		ctx
    	});

    	return block;
    }

    // (296:32) {#if tab === 'credit' && !creditShowOnlyMattress}
    function create_if_block_3$1(ctx) {
    	let t0;
    	let span;
    	let t1_value = /*transactionCounts*/ ctx[3]?.credit_all + "";
    	let t1;

    	const block = {
    		c: function create() {
    			t0 = text$1(" ");
    			span = element("span");
    			t1 = text$1(t1_value);
    			attr_dev(span, "class", "uk-badge");
    			add_location(span, file$1, 296, 43, 14268);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*transactionCounts*/ 8 && t1_value !== (t1_value = /*transactionCounts*/ ctx[3]?.credit_all + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(296:32) {#if tab === 'credit' && !creditShowOnlyMattress}",
    		ctx
    	});

    	return block;
    }

    // (313:12) {:else }
    function create_else_block$1(ctx) {
    	let table;
    	let thead;
    	let tr;
    	let th0;
    	let t1;
    	let th1;
    	let t3;
    	let th2;
    	let t5;
    	let th3;
    	let t7;
    	let th4;
    	let t9;
    	let th5;
    	let t11;
    	let th6;
    	let t13;
    	let tbody;
    	let each_value = /*data*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			table = element("table");
    			thead = element("thead");
    			tr = element("tr");
    			th0 = element("th");
    			th0.textContent = "Date";
    			t1 = space();
    			th1 = element("th");
    			th1.textContent = "Allocator";
    			t3 = space();
    			th2 = element("th");
    			th2.textContent = "Name";
    			t5 = space();
    			th3 = element("th");
    			th3.textContent = "Type";
    			t7 = space();
    			th4 = element("th");
    			th4.textContent = "Description";
    			t9 = space();
    			th5 = element("th");
    			th5.textContent = "Nights";
    			t11 = space();
    			th6 = element("th");
    			th6.textContent = "Amount";
    			t13 = space();
    			tbody = element("tbody");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(th0, file$1, 316, 24, 15179);
    			attr_dev(th1, "class", "uk-width-small");
    			add_location(th1, file$1, 317, 24, 15217);
    			attr_dev(th2, "class", "uk-width-small");
    			add_location(th2, file$1, 318, 24, 15283);
    			attr_dev(th3, "class", "uk-width-small uk-table-shrink");
    			add_location(th3, file$1, 319, 24, 15344);
    			attr_dev(th4, "class", "uk-visible@m");
    			add_location(th4, file$1, 320, 24, 15421);
    			attr_dev(th5, "class", "uk-table-shrink");
    			add_location(th5, file$1, 321, 24, 15487);
    			attr_dev(th6, "class", "uk-table-shrink");
    			add_location(th6, file$1, 322, 24, 15551);
    			add_location(tr, file$1, 315, 20, 15150);
    			add_location(thead, file$1, 314, 20, 15122);
    			add_location(tbody, file$1, 325, 20, 15666);
    			attr_dev(table, "class", "uk-table uk-table-striped uk-table-hover uk-table-small uk-text-small");
    			add_location(table, file$1, 313, 16, 15016);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, thead);
    			append_dev(thead, tr);
    			append_dev(tr, th0);
    			append_dev(tr, t1);
    			append_dev(tr, th1);
    			append_dev(tr, t3);
    			append_dev(tr, th2);
    			append_dev(tr, t5);
    			append_dev(tr, th3);
    			append_dev(tr, t7);
    			append_dev(tr, th4);
    			append_dev(tr, t9);
    			append_dev(tr, th5);
    			append_dev(tr, t11);
    			append_dev(tr, th6);
    			append_dev(table, t13);
    			append_dev(table, tbody);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(tbody, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*data, openForm, creditShowOnlyMattress*/ 262209) {
    				each_value = /*data*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(tbody, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(313:12) {:else }",
    		ctx
    	});

    	return block;
    }

    // (311:40) 
    function create_if_block_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("Loading allocations...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(311:40) ",
    		ctx
    	});

    	return block;
    }

    // (309:12) {#if data.length === 0 && transactionQuery.name}
    function create_if_block$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("No filter results...");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop$4,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(309:12) {#if data.length === 0 && transactionQuery.name}",
    		ctx
    	});

    	return block;
    }

    // (328:24) {#if !creditShowOnlyMattress || (creditShowOnlyMattress && transaction.type !== 'stay' && transaction.type !== 'membership')}
    function create_if_block_2$1(ctx) {
    	let tr;
    	let td0;
    	let t0_value = DateTime_1.fromSQL(/*transaction*/ ctx[42].date).toFormat('dd LLL yyyy') + "";
    	let t0;
    	let t1;
    	let td1;
    	let t2_value = /*transaction*/ ctx[42].allocator + "";
    	let t2;
    	let t3;
    	let td2;
    	let t4_value = /*transaction*/ ctx[42].name + "";
    	let t4;
    	let t5;
    	let td3;
    	let t6_value = /*transaction*/ ctx[42].type + "";
    	let t6;
    	let t7;
    	let td4;

    	let t8_value = (/*transaction*/ ctx[42].type === 'stay' || /*transaction*/ ctx[42].type === 'membership'
    	? 'automated (system)'
    	: /*transaction*/ ctx[42].description) + "";

    	let t8;
    	let t9;
    	let td5;

    	let t10_value = (/*transaction*/ ctx[42].booking_nights
    	? /*transaction*/ ctx[42].booking_nights
    	: '') + "";

    	let t10;
    	let t11;
    	let td6;
    	let t12_value = /*transaction*/ ctx[42].amount + "";
    	let t12;
    	let t13;
    	let mounted;
    	let dispose;

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[24](/*transaction*/ ctx[42]);
    	}

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[25](/*transaction*/ ctx[42]);
    	}

    	function click_handler_6() {
    		return /*click_handler_6*/ ctx[26](/*transaction*/ ctx[42]);
    	}

    	function click_handler_7() {
    		return /*click_handler_7*/ ctx[27](/*transaction*/ ctx[42]);
    	}

    	function click_handler_8() {
    		return /*click_handler_8*/ ctx[28](/*transaction*/ ctx[42]);
    	}

    	function click_handler_9() {
    		return /*click_handler_9*/ ctx[29](/*transaction*/ ctx[42]);
    	}

    	function click_handler_10() {
    		return /*click_handler_10*/ ctx[30](/*transaction*/ ctx[42]);
    	}

    	const block = {
    		c: function create() {
    			tr = element("tr");
    			td0 = element("td");
    			t0 = text$1(t0_value);
    			t1 = space();
    			td1 = element("td");
    			t2 = text$1(t2_value);
    			t3 = space();
    			td2 = element("td");
    			t4 = text$1(t4_value);
    			t5 = space();
    			td3 = element("td");
    			t6 = text$1(t6_value);
    			t7 = space();
    			td4 = element("td");
    			t8 = text$1(t8_value);
    			t9 = space();
    			td5 = element("td");
    			t10 = text$1(t10_value);
    			t11 = space();
    			td6 = element("td");
    			t12 = text$1(t12_value);
    			t13 = space();
    			attr_dev(td0, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td0, file$1, 329, 32, 16046);
    			attr_dev(td1, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td1, file$1, 330, 32, 16226);
    			attr_dev(td2, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td2, file$1, 331, 32, 16369);
    			attr_dev(td3, "class", "uk-table-shrink uk-text-nowrap");
    			add_location(td3, file$1, 332, 32, 16507);
    			attr_dev(td4, "class", "uk-visible@m uk-text-truncate");
    			add_location(td4, file$1, 333, 32, 16645);
    			add_location(td5, file$1, 334, 32, 16880);
    			add_location(td6, file$1, 335, 32, 17023);
    			attr_dev(tr, "class", "uk-table-link");
    			toggle_class(tr, "uk-text-muted", /*transaction*/ ctx[42].type === 'stay' || /*transaction*/ ctx[42].type === 'membership');
    			add_location(tr, file$1, 328, 28, 15900);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, tr, anchor);
    			append_dev(tr, td0);
    			append_dev(td0, t0);
    			append_dev(tr, t1);
    			append_dev(tr, td1);
    			append_dev(td1, t2);
    			append_dev(tr, t3);
    			append_dev(tr, td2);
    			append_dev(td2, t4);
    			append_dev(tr, t5);
    			append_dev(tr, td3);
    			append_dev(td3, t6);
    			append_dev(tr, t7);
    			append_dev(tr, td4);
    			append_dev(td4, t8);
    			append_dev(tr, t9);
    			append_dev(tr, td5);
    			append_dev(td5, t10);
    			append_dev(tr, t11);
    			append_dev(tr, td6);
    			append_dev(td6, t12);
    			append_dev(tr, t13);

    			if (!mounted) {
    				dispose = [
    					listen_dev(td0, "click", click_handler_4, false, false, false),
    					listen_dev(td1, "click", click_handler_5, false, false, false),
    					listen_dev(td2, "click", click_handler_6, false, false, false),
    					listen_dev(td3, "click", click_handler_7, false, false, false),
    					listen_dev(td4, "click", click_handler_8, false, false, false),
    					listen_dev(td5, "click", click_handler_9, false, false, false),
    					listen_dev(td6, "click", click_handler_10, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*data*/ 1 && t0_value !== (t0_value = DateTime_1.fromSQL(/*transaction*/ ctx[42].date).toFormat('dd LLL yyyy') + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*data*/ 1 && t2_value !== (t2_value = /*transaction*/ ctx[42].allocator + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*data*/ 1 && t4_value !== (t4_value = /*transaction*/ ctx[42].name + "")) set_data_dev(t4, t4_value);
    			if (dirty[0] & /*data*/ 1 && t6_value !== (t6_value = /*transaction*/ ctx[42].type + "")) set_data_dev(t6, t6_value);

    			if (dirty[0] & /*data*/ 1 && t8_value !== (t8_value = (/*transaction*/ ctx[42].type === 'stay' || /*transaction*/ ctx[42].type === 'membership'
    			? 'automated (system)'
    			: /*transaction*/ ctx[42].description) + "")) set_data_dev(t8, t8_value);

    			if (dirty[0] & /*data*/ 1 && t10_value !== (t10_value = (/*transaction*/ ctx[42].booking_nights
    			? /*transaction*/ ctx[42].booking_nights
    			: '') + "")) set_data_dev(t10, t10_value);

    			if (dirty[0] & /*data*/ 1 && t12_value !== (t12_value = /*transaction*/ ctx[42].amount + "")) set_data_dev(t12, t12_value);

    			if (dirty[0] & /*data*/ 1) {
    				toggle_class(tr, "uk-text-muted", /*transaction*/ ctx[42].type === 'stay' || /*transaction*/ ctx[42].type === 'membership');
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(tr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(328:24) {#if !creditShowOnlyMattress || (creditShowOnlyMattress && transaction.type !== 'stay' && transaction.type !== 'membership')}",
    		ctx
    	});

    	return block;
    }

    // (327:20) {#each data as transaction}
    function create_each_block(ctx) {
    	let if_block_anchor;
    	let if_block = (!/*creditShowOnlyMattress*/ ctx[6] || /*creditShowOnlyMattress*/ ctx[6] && /*transaction*/ ctx[42].type !== 'stay' && /*transaction*/ ctx[42].type !== 'membership') && create_if_block_2$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*creditShowOnlyMattress*/ ctx[6] || /*creditShowOnlyMattress*/ ctx[6] && /*transaction*/ ctx[42].type !== 'stay' && /*transaction*/ ctx[42].type !== 'membership') {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(327:20) {#each data as transaction}",
    		ctx
    	});

    	return block;
    }

    // (363:16) {#key recreateForm}
    function create_key_block$1(ctx) {
    	let mattressform;
    	let updating_balance;
    	let updating_transaction;
    	let updating_booking;
    	let current;

    	function mattressform_balance_binding(value) {
    		/*mattressform_balance_binding*/ ctx[32](value);
    	}

    	function mattressform_transaction_binding(value) {
    		/*mattressform_transaction_binding*/ ctx[33](value);
    	}

    	function mattressform_booking_binding(value) {
    		/*mattressform_booking_binding*/ ctx[34](value);
    	}

    	let mattressform_props = {};

    	if (/*$accounts*/ ctx[13].mattress_balance !== void 0) {
    		mattressform_props.balance = /*$accounts*/ ctx[13].mattress_balance;
    	}

    	if (/*selectedTransaction*/ ctx[7] !== void 0) {
    		mattressform_props.transaction = /*selectedTransaction*/ ctx[7];
    	}

    	if (/*selectedBooking*/ ctx[8] !== void 0) {
    		mattressform_props.booking = /*selectedBooking*/ ctx[8];
    	}

    	mattressform = new MattressForm({
    			props: mattressform_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$1(mattressform, 'balance', mattressform_balance_binding));
    	binding_callbacks.push(() => bind$1(mattressform, 'transaction', mattressform_transaction_binding));
    	binding_callbacks.push(() => bind$1(mattressform, 'booking', mattressform_booking_binding));
    	mattressform.$on("message", /*processTransaction*/ ctx[19]);

    	const block = {
    		c: function create() {
    			create_component(mattressform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mattressform, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mattressform_changes = {};

    			if (!updating_balance && dirty[0] & /*$accounts*/ 8192) {
    				updating_balance = true;
    				mattressform_changes.balance = /*$accounts*/ ctx[13].mattress_balance;
    				add_flush_callback(() => updating_balance = false);
    			}

    			if (!updating_transaction && dirty[0] & /*selectedTransaction*/ 128) {
    				updating_transaction = true;
    				mattressform_changes.transaction = /*selectedTransaction*/ ctx[7];
    				add_flush_callback(() => updating_transaction = false);
    			}

    			if (!updating_booking && dirty[0] & /*selectedBooking*/ 256) {
    				updating_booking = true;
    				mattressform_changes.booking = /*selectedBooking*/ ctx[8];
    				add_flush_callback(() => updating_booking = false);
    			}

    			mattressform.$set(mattressform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mattressform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mattressform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mattressform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$1.name,
    		type: "key",
    		source: "(363:16) {#key recreateForm}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let input;
    	let input_class_value;
    	let t0;
    	let button0;
    	let span0;

    	let t1_value = (/*$screenWidthS*/ ctx[10]
    	? ''
    	: /*$screenWidthM*/ ctx[11]
    		? '\xa0transaction'
    		: '\xa0New transaction') + "";

    	let t1;
    	let t2;
    	let div16;
    	let div15;
    	let div11;
    	let div4;
    	let div3;
    	let span1;
    	let t3_value = /*$accounts*/ ctx[13].mattress_balance + "";
    	let t3;
    	let t4;
    	let br0;
    	let t5;
    	let t6;
    	let div6;
    	let div5;
    	let span2;
    	let t7_value = /*$accounts*/ ctx[13].mattress_reserved + "";
    	let t7;
    	let t8;
    	let br1;
    	let t9;
    	let t10;
    	let div8;
    	let div7;
    	let span3;
    	let t11_value = /*$allocatedNights*/ ctx[14].nights + "";
    	let t11;
    	let br2;
    	let t12;
    	let t13;
    	let div10;
    	let div9;
    	let span4;
    	let t14_value = /*$income*/ ctx[15].income + "";
    	let t14;
    	let t15;
    	let br3;
    	let t16;
    	let t17_value = DateTime_1.now().year + "";
    	let t17;
    	let t18;
    	let div13;
    	let ul1;
    	let li0;
    	let a0;
    	let t19;
    	let t20;
    	let li1;
    	let a1;
    	let t21;
    	let t22;
    	let li4;
    	let a2;
    	let t23;
    	let t24;
    	let span5;
    	let t25;
    	let div12;
    	let ul0;
    	let li2;
    	let a3;
    	let t26;
    	let t27;
    	let li3;
    	let a4;
    	let t28;
    	let t29;
    	let div14;
    	let t30;
    	let infinitescroll;
    	let t31;
    	let div20;
    	let div19;
    	let button1;
    	let t32;
    	let div18;
    	let div17;
    	let previous_key = /*recreateForm*/ ctx[9];
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type(ctx, dirty) {
    		if (/*tab*/ ctx[4] === 'debit') return create_if_block_7$1;
    		return create_else_block_5;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (/*tab*/ ctx[4] === 'reserve') return create_if_block_6$1;
    		return create_else_block_4;
    	}

    	let current_block_type_1 = select_block_type_1(ctx);
    	let if_block1 = current_block_type_1(ctx);

    	function select_block_type_2(ctx, dirty) {
    		if (/*tab*/ ctx[4] === 'credit') return create_if_block_5$1;
    		return create_else_block_3;
    	}

    	let current_block_type_2 = select_block_type_2(ctx);
    	let if_block2 = current_block_type_2(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (/*tab*/ ctx[4] === 'credit' && /*creditShowOnlyMattress*/ ctx[6]) return create_if_block_4$1;
    		return create_else_block_2;
    	}

    	let current_block_type_3 = select_block_type_3(ctx);
    	let if_block3 = current_block_type_3(ctx);

    	function select_block_type_4(ctx, dirty) {
    		if (/*tab*/ ctx[4] === 'credit' && !/*creditShowOnlyMattress*/ ctx[6]) return create_if_block_3$1;
    		return create_else_block_1;
    	}

    	let current_block_type_4 = select_block_type_4(ctx);
    	let if_block4 = current_block_type_4(ctx);

    	function select_block_type_5(ctx, dirty) {
    		if (/*data*/ ctx[0].length === 0 && /*transactionQuery*/ ctx[5].name) return create_if_block$1;
    		if (/*data*/ ctx[0].length === 0) return create_if_block_1$1;
    		return create_else_block$1;
    	}

    	let current_block_type_5 = select_block_type_5(ctx);
    	let if_block5 = current_block_type_5(ctx);

    	infinitescroll = new InfiniteScroll({
    			props: {
    				hasMore: /*newBatch*/ ctx[1].length,
    				threshold: 80
    			},
    			$$inline: true
    		});

    	infinitescroll.$on("loadMore", /*loadMore_handler*/ ctx[31]);
    	let key_block = create_key_block$1(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			button0 = element("button");
    			span0 = element("span");
    			t1 = text$1(t1_value);
    			t2 = space();
    			div16 = element("div");
    			div15 = element("div");
    			div11 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			span1 = element("span");
    			t3 = text$1(t3_value);
    			t4 = text$1(" ");
    			br0 = element("br");
    			t5 = text$1("\n                    Balance");
    			t6 = space();
    			div6 = element("div");
    			div5 = element("div");
    			span2 = element("span");
    			t7 = text$1(t7_value);
    			t8 = text$1(" ");
    			br1 = element("br");
    			t9 = text$1("\n                    Planned");
    			t10 = space();
    			div8 = element("div");
    			div7 = element("div");
    			span3 = element("span");
    			t11 = text$1(t11_value);
    			br2 = element("br");
    			t12 = text$1("\n                    Nights allocated");
    			t13 = space();
    			div10 = element("div");
    			div9 = element("div");
    			span4 = element("span");
    			t14 = text$1(t14_value);
    			t15 = text$1(" ");
    			br3 = element("br");
    			t16 = text$1("\n                    Income ");
    			t17 = text$1(t17_value);
    			t18 = space();
    			div13 = element("div");
    			ul1 = element("ul");
    			li0 = element("li");
    			a0 = element("a");
    			t19 = text$1("Allocated\n                    ");
    			if_block0.c();
    			t20 = space();
    			li1 = element("li");
    			a1 = element("a");
    			t21 = text$1("Planned\n                    ");
    			if_block1.c();
    			t22 = space();
    			li4 = element("li");
    			a2 = element("a");
    			t23 = text$1("Income\n                        ");
    			if_block2.c();
    			t24 = space();
    			span5 = element("span");
    			t25 = space();
    			div12 = element("div");
    			ul0 = element("ul");
    			li2 = element("li");
    			a3 = element("a");
    			t26 = text$1("Mattress administrated\n                                ");
    			if_block3.c();
    			t27 = space();
    			li3 = element("li");
    			a4 = element("a");
    			t28 = text$1("All income\n                                ");
    			if_block4.c();
    			t29 = space();
    			div14 = element("div");
    			if_block5.c();
    			t30 = space();
    			create_component(infinitescroll.$$.fragment);
    			t31 = space();
    			div20 = element("div");
    			div19 = element("div");
    			button1 = element("button");
    			t32 = space();
    			div18 = element("div");
    			div17 = element("div");
    			key_block.c();

    			attr_dev(input, "class", input_class_value = "uk-input " + (/*$screenWidthS*/ ctx[10]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[11] || /*$screenWidthL*/ ctx[12]
    				? 'uk-width-medium'
    				: 'uk-width-large'));

    			attr_dev(input, "id", "autocomplete");
    			attr_dev(input, "type", "search");
    			attr_dev(input, "spellcheck", "false");
    			attr_dev(input, "autocorrect", "off");
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "autocapitalize", "off");
    			attr_dev(input, "maxlength", "256");
    			add_location(input, file$1, 224, 12, 9231);
    			attr_dev(span0, "uk-icon", "icon: plus; ratio: 0.6");
    			add_location(span0, file$1, 225, 113, 9601);
    			attr_dev(button0, "class", "uk-button uk-button-small uk-button-primary uk-margin-large-left");
    			add_location(button0, file$1, 225, 12, 9500);
    			attr_dev(div0, "class", "uk-flex uk-flex-center");
    			add_location(div0, file$1, 223, 8, 9182);
    			attr_dev(div1, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6 paf-top-section-bg");
    			add_location(div1, file$1, 222, 4, 9084);
    			attr_dev(div2, "class", "uk-flex uk-flex-center uk-margin-large-top uk-margin-bottom");
    			add_location(div2, file$1, 221, 0, 9006);
    			attr_dev(span1, "class", "uk-text-large");
    			set_style(span1, "color", "white");
    			add_location(span1, file$1, 236, 20, 10302);
    			add_location(br0, file$1, 236, 106, 10388);
    			attr_dev(div3, "class", "uk-margin-medium uk-padding-small uk-text-center uk-text-bold uk-label-success uk-light");
    			toggle_class(div3, "uk-label-warning", /*$accounts*/ ctx[13].mattress_balance < 100);
    			toggle_class(div3, "uk-label-danger", /*$accounts*/ ctx[13].mattress_balance <= 0);
    			toggle_class(div3, "uk-text-small", /*$screenWidthS*/ ctx[10]);
    			add_location(div3, file$1, 235, 16, 10030);
    			attr_dev(div4, "class", "uk-width-small");
    			add_location(div4, file$1, 234, 12, 9985);
    			attr_dev(span2, "class", "uk-text-large");
    			set_style(span2, "color", "white");
    			add_location(span2, file$1, 242, 20, 10716);
    			add_location(br1, file$1, 242, 107, 10803);
    			attr_dev(div5, "class", "uk-margin-medium uk-padding-small uk-text-center uk-text-bold uk-light");
    			set_style(div5, "background-color", "#999999");
    			toggle_class(div5, "uk-text-small", /*$screenWidthS*/ ctx[10]);
    			add_location(div5, file$1, 241, 16, 10541);
    			attr_dev(div6, "class", "uk-width-small uk-margin-large-left");
    			add_location(div6, file$1, 240, 12, 10475);
    			attr_dev(span3, "class", "uk-text-large");
    			set_style(span3, "color", "white");
    			add_location(span3, file$1, 248, 20, 11118);
    			add_location(br2, file$1, 248, 101, 11199);
    			attr_dev(div7, "class", "uk-margin-medium uk-padding-small uk-background-primary uk-text-center uk-text-bold uk-light");
    			toggle_class(div7, "uk-text-small", /*$screenWidthS*/ ctx[10]);
    			add_location(div7, file$1, 247, 16, 10955);
    			attr_dev(div8, "class", "uk-width-auto uk-margin-large-left");
    			add_location(div8, file$1, 246, 12, 10890);
    			attr_dev(span4, "class", "uk-text-large");
    			set_style(span4, "color", "white");
    			add_location(span4, file$1, 254, 20, 11518);
    			add_location(br3, file$1, 254, 94, 11592);
    			attr_dev(div9, "class", "uk-margin-medium uk-padding-small uk-label-success uk-text-center uk-text-bold uk-light");
    			toggle_class(div9, "uk-text-small", /*$screenWidthS*/ ctx[10]);
    			add_location(div9, file$1, 253, 16, 11360);
    			attr_dev(div10, "class", "uk-width-auto uk-margin-large-left");
    			add_location(div10, file$1, 252, 12, 11295);
    			attr_dev(div11, "class", "uk-flex uk-flex-center");
    			add_location(div11, file$1, 233, 8, 9936);
    			attr_dev(a0, "href", "#");
    			add_location(a0, file$1, 262, 38, 11811);
    			attr_dev(li0, "class", "uk-active");
    			add_location(li0, file$1, 262, 16, 11789);
    			attr_dev(a1, "href", "#");
    			add_location(a1, file$1, 269, 20, 12286);
    			add_location(li1, file$1, 269, 16, 12282);
    			attr_dev(span5, "uk-icon", "icon: triangle-down");
    			add_location(span5, file$1, 283, 24, 13234);
    			attr_dev(a2, "href", "");
    			add_location(a2, file$1, 277, 20, 12790);
    			attr_dev(a3, "href", "#");
    			add_location(a3, file$1, 287, 32, 13447);
    			add_location(li2, file$1, 287, 28, 13443);
    			attr_dev(a4, "href", "#");
    			add_location(a4, file$1, 294, 32, 14074);
    			add_location(li3, file$1, 294, 28, 14070);
    			attr_dev(ul0, "class", "uk-nav uk-dropdown-nav");
    			add_location(ul0, file$1, 286, 24, 13379);
    			attr_dev(div12, "uk-dropdown", "mode: click");
    			add_location(div12, file$1, 285, 20, 13323);
    			add_location(li4, file$1, 276, 16, 12765);
    			attr_dev(ul1, "uk-tab", "");
    			add_location(ul1, file$1, 261, 12, 11761);
    			attr_dev(div13, "class", "uk-flex uk-flex-center");
    			add_location(div13, file$1, 260, 8, 11712);
    			attr_dev(div14, "class", "uk-width-1-1");
    			add_location(div14, file$1, 307, 8, 14774);
    			attr_dev(div15, "class", "uk-section uk-section-xsmall uk-width-4-5@m uk-width-5-6");
    			add_location(div15, file$1, 231, 4, 9856);
    			attr_dev(div16, "class", "uk-flex uk-flex-center");
    			set_style(div16, "max-height", "75%");
    			set_style(div16, "overflow-x", "scroll");
    			add_location(div16, file$1, 230, 0, 9770);
    			attr_dev(button1, "class", "uk-modal-close-full uk-close-large");
    			attr_dev(button1, "type", "button");
    			attr_dev(button1, "uk-close", "");
    			add_location(button1, file$1, 359, 8, 17760);
    			attr_dev(div17, "class", "uk-padding-large uk-width-3-5@xl uk-width-2-3@l uk-width-5-6");
    			attr_dev(div17, "uk-height-viewport", "");
    			add_location(div17, file$1, 361, 12, 17901);
    			attr_dev(div18, "class", "uk-flex uk-flex-center");
    			add_location(div18, file$1, 360, 8, 17852);
    			attr_dev(div19, "class", "uk-modal-dialog uk-overflow-auto uk-width-3-4@m");
    			add_location(div19, file$1, 358, 4, 17690);
    			attr_dev(div20, "id", "modal-transaction");
    			attr_dev(div20, "class", "uk-modal-full");
    			attr_dev(div20, "uk-modal", "esc-close: false; bg-close: false");
    			toggle_class(div20, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[11]);
    			add_location(div20, file$1, 354, 0, 17532);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, input);
    			append_dev(div0, t0);
    			append_dev(div0, button0);
    			append_dev(button0, span0);
    			append_dev(button0, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div16, anchor);
    			append_dev(div16, div15);
    			append_dev(div15, div11);
    			append_dev(div11, div4);
    			append_dev(div4, div3);
    			append_dev(div3, span1);
    			append_dev(span1, t3);
    			append_dev(span1, t4);
    			append_dev(div3, br0);
    			append_dev(div3, t5);
    			append_dev(div11, t6);
    			append_dev(div11, div6);
    			append_dev(div6, div5);
    			append_dev(div5, span2);
    			append_dev(span2, t7);
    			append_dev(span2, t8);
    			append_dev(div5, br1);
    			append_dev(div5, t9);
    			append_dev(div11, t10);
    			append_dev(div11, div8);
    			append_dev(div8, div7);
    			append_dev(div7, span3);
    			append_dev(span3, t11);
    			append_dev(div7, br2);
    			append_dev(div7, t12);
    			append_dev(div11, t13);
    			append_dev(div11, div10);
    			append_dev(div10, div9);
    			append_dev(div9, span4);
    			append_dev(span4, t14);
    			append_dev(span4, t15);
    			append_dev(div9, br3);
    			append_dev(div9, t16);
    			append_dev(div9, t17);
    			append_dev(div15, t18);
    			append_dev(div15, div13);
    			append_dev(div13, ul1);
    			append_dev(ul1, li0);
    			append_dev(li0, a0);
    			append_dev(a0, t19);
    			if_block0.m(a0, null);
    			append_dev(ul1, t20);
    			append_dev(ul1, li1);
    			append_dev(li1, a1);
    			append_dev(a1, t21);
    			if_block1.m(a1, null);
    			append_dev(ul1, t22);
    			append_dev(ul1, li4);
    			append_dev(li4, a2);
    			append_dev(a2, t23);
    			if_block2.m(a2, null);
    			append_dev(a2, t24);
    			append_dev(a2, span5);
    			append_dev(li4, t25);
    			append_dev(li4, div12);
    			append_dev(div12, ul0);
    			append_dev(ul0, li2);
    			append_dev(li2, a3);
    			append_dev(a3, t26);
    			if_block3.m(a3, null);
    			append_dev(ul0, t27);
    			append_dev(ul0, li3);
    			append_dev(li3, a4);
    			append_dev(a4, t28);
    			if_block4.m(a4, null);
    			append_dev(div15, t29);
    			append_dev(div15, div14);
    			if_block5.m(div14, null);
    			append_dev(div16, t30);
    			mount_component(infinitescroll, div16, null);
    			insert_dev(target, t31, anchor);
    			insert_dev(target, div20, anchor);
    			append_dev(div20, div19);
    			append_dev(div19, button1);
    			append_dev(div19, t32);
    			append_dev(div19, div18);
    			append_dev(div18, div17);
    			key_block.m(div17, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*openForm*/ ctx[18], false, false, false),
    					listen_dev(a0, "click", /*click_handler*/ ctx[20], false, false, false),
    					listen_dev(a1, "click", /*click_handler_1*/ ctx[21], false, false, false),
    					listen_dev(a3, "click", /*click_handler_2*/ ctx[22], false, false, false),
    					listen_dev(a4, "click", /*click_handler_3*/ ctx[23], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*$screenWidthS, $screenWidthM, $screenWidthL*/ 7168 && input_class_value !== (input_class_value = "uk-input " + (/*$screenWidthS*/ ctx[10]
    			? 'uk-width-small'
    			: /*$screenWidthM*/ ctx[11] || /*$screenWidthL*/ ctx[12]
    				? 'uk-width-medium'
    				: 'uk-width-large'))) {
    				attr_dev(input, "class", input_class_value);
    			}

    			if ((!current || dirty[0] & /*$screenWidthS, $screenWidthM*/ 3072) && t1_value !== (t1_value = (/*$screenWidthS*/ ctx[10]
    			? ''
    			: /*$screenWidthM*/ ctx[11]
    				? '\xa0transaction'
    				: '\xa0New transaction') + "")) set_data_dev(t1, t1_value);

    			if ((!current || dirty[0] & /*$accounts*/ 8192) && t3_value !== (t3_value = /*$accounts*/ ctx[13].mattress_balance + "")) set_data_dev(t3, t3_value);

    			if (dirty[0] & /*$accounts*/ 8192) {
    				toggle_class(div3, "uk-label-warning", /*$accounts*/ ctx[13].mattress_balance < 100);
    			}

    			if (dirty[0] & /*$accounts*/ 8192) {
    				toggle_class(div3, "uk-label-danger", /*$accounts*/ ctx[13].mattress_balance <= 0);
    			}

    			if (dirty[0] & /*$screenWidthS*/ 1024) {
    				toggle_class(div3, "uk-text-small", /*$screenWidthS*/ ctx[10]);
    			}

    			if ((!current || dirty[0] & /*$accounts*/ 8192) && t7_value !== (t7_value = /*$accounts*/ ctx[13].mattress_reserved + "")) set_data_dev(t7, t7_value);

    			if (dirty[0] & /*$screenWidthS*/ 1024) {
    				toggle_class(div5, "uk-text-small", /*$screenWidthS*/ ctx[10]);
    			}

    			if ((!current || dirty[0] & /*$allocatedNights*/ 16384) && t11_value !== (t11_value = /*$allocatedNights*/ ctx[14].nights + "")) set_data_dev(t11, t11_value);

    			if (dirty[0] & /*$screenWidthS*/ 1024) {
    				toggle_class(div7, "uk-text-small", /*$screenWidthS*/ ctx[10]);
    			}

    			if ((!current || dirty[0] & /*$income*/ 32768) && t14_value !== (t14_value = /*$income*/ ctx[15].income + "")) set_data_dev(t14, t14_value);

    			if (dirty[0] & /*$screenWidthS*/ 1024) {
    				toggle_class(div9, "uk-text-small", /*$screenWidthS*/ ctx[10]);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(a0, null);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(a1, null);
    				}
    			}

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_2(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_2(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(a2, t24);
    				}
    			}

    			if (current_block_type_3 === (current_block_type_3 = select_block_type_3(ctx)) && if_block3) {
    				if_block3.p(ctx, dirty);
    			} else {
    				if_block3.d(1);
    				if_block3 = current_block_type_3(ctx);

    				if (if_block3) {
    					if_block3.c();
    					if_block3.m(a3, null);
    				}
    			}

    			if (current_block_type_4 === (current_block_type_4 = select_block_type_4(ctx)) && if_block4) {
    				if_block4.p(ctx, dirty);
    			} else {
    				if_block4.d(1);
    				if_block4 = current_block_type_4(ctx);

    				if (if_block4) {
    					if_block4.c();
    					if_block4.m(a4, null);
    				}
    			}

    			if (current_block_type_5 === (current_block_type_5 = select_block_type_5(ctx)) && if_block5) {
    				if_block5.p(ctx, dirty);
    			} else {
    				if_block5.d(1);
    				if_block5 = current_block_type_5(ctx);

    				if (if_block5) {
    					if_block5.c();
    					if_block5.m(div14, null);
    				}
    			}

    			const infinitescroll_changes = {};
    			if (dirty[0] & /*newBatch*/ 2) infinitescroll_changes.hasMore = /*newBatch*/ ctx[1].length;
    			infinitescroll.$set(infinitescroll_changes);

    			if (dirty[0] & /*recreateForm*/ 512 && safe_not_equal(previous_key, previous_key = /*recreateForm*/ ctx[9])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block$1(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(div17, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (dirty[0] & /*$screenWidthM*/ 2048) {
    				toggle_class(div20, "uk-margin-auto-vertical", !/*$screenWidthM*/ ctx[11]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(infinitescroll.$$.fragment, local);
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(infinitescroll.$$.fragment, local);
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div16);
    			if_block0.d();
    			if_block1.d();
    			if_block2.d();
    			if_block3.d();
    			if_block4.d();
    			if_block5.d();
    			destroy_component(infinitescroll);
    			if (detaching) detach_dev(t31);
    			if (detaching) detach_dev(div20);
    			key_block.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $mattressNames;
    	let $screenWidthS;
    	let $screenWidthM;
    	let $screenWidthL;
    	let $accounts;
    	let $allocatedNights;
    	let $income;
    	validate_store(mattressNames, 'mattressNames');
    	component_subscribe($$self, mattressNames, $$value => $$invalidate(37, $mattressNames = $$value));
    	validate_store(screenWidthS, 'screenWidthS');
    	component_subscribe($$self, screenWidthS, $$value => $$invalidate(10, $screenWidthS = $$value));
    	validate_store(screenWidthM, 'screenWidthM');
    	component_subscribe($$self, screenWidthM, $$value => $$invalidate(11, $screenWidthM = $$value));
    	validate_store(screenWidthL, 'screenWidthL');
    	component_subscribe($$self, screenWidthL, $$value => $$invalidate(12, $screenWidthL = $$value));
    	validate_store(accounts, 'accounts');
    	component_subscribe($$self, accounts, $$value => $$invalidate(13, $accounts = $$value));
    	validate_store(allocatedNights, 'allocatedNights');
    	component_subscribe($$self, allocatedNights, $$value => $$invalidate(14, $allocatedNights = $$value));
    	validate_store(income, 'income');
    	component_subscribe($$self, income, $$value => $$invalidate(15, $income = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Mattress', slots, []);
    	let data = [];
    	let newBatch = [];
    	let maxPage = 2;
    	let transactionCounts = {};
    	let tab = 'debit';
    	let transactionQuery = { page: 1, limit: 50, transaction: tab };
    	let transactionName = null;
    	let creditShowOnlyMattress = true;
    	let selectedTransaction = null;
    	let editTransaction = false;
    	let selectedBooking = null;
    	let recreateForm = false;
    	const dispatch = createEventDispatcher();

    	onMount(async () => {
    		await getAccounts();
    		await getAllocatedNights();
    		await getIncome();
    		await fetchData();

    		const autoCompleteJS = new autoComplete({
    				selector: "#autocomplete",
    				placeHolder: "Search allocations...",
    				diacritics: true,
    				searchEngine: 'strict',
    				data: { src: $mattressNames, cache: true },
    				resultsList: {
    					element: (list, data) => {
    						if (!data.results.length) {
    							const message = document.createElement("div");
    							message.setAttribute("class", "no_result");
    							message.innerHTML = `<span>No Allocation for "${data.query}"</span>`;
    							list.prepend(message);
    						}
    					},
    					maxResults: 50,
    					noResults: true
    				},
    				resultItem: { highlight: true },
    				events: {
    					input: {
    						selection: event => {
    							autoCompleteJS.input.value = event.detail.selection.value;
    							transactionName = event.detail.selection.value;
    							fetchTransaction();
    						},
    						keyup: () => {
    							if (autoCompleteJS.input.value === '') {
    								transactionName = null;
    								fetchTransaction();
    							}
    						}
    					}
    				}
    			});
    	});

    	async function fetchData() {
    		const result = await getTransactions(transactionQuery);
    		$$invalidate(2, maxPage = result.meta.last_page);
    		$$invalidate(1, newBatch = result.data);
    		processCounts(result.counts);
    	}

    	async function fetchTransaction() {
    		$$invalidate(5, transactionQuery.page = 1, transactionQuery);
    		$$invalidate(1, newBatch = []);

    		if (transactionName !== null) {
    			$$invalidate(5, transactionQuery.name = transactionName, transactionQuery);
    			const result = await getTransactions(transactionQuery);
    			$$invalidate(2, maxPage = result.meta.last_page);
    			$$invalidate(0, data = result.data);
    			processCounts(result.counts);
    		} else {
    			delete transactionQuery.name;
    			$$invalidate(0, data = []);
    			await fetchData();
    		}
    	}

    	function processCounts(counts) {
    		$$invalidate(3, transactionCounts = {
    			credit_all: counts.filter(c => c.transaction === 'credit').reduce((acc, c) => acc + c['COUNT(*)'], 0),
    			credit_mat: counts.filter(c => c.transaction === 'credit' && c.type !== 'stay' && c.type !== 'membership').reduce((acc, c) => acc + c['COUNT(*)'], 0),
    			debit: counts.filter(c => c.transaction === 'debit').reduce((acc, c) => acc + c['COUNT(*)'], 0),
    			reserve: counts.filter(c => c.transaction === 'reserve').reduce((acc, c) => acc + c['COUNT(*)'], 0)
    		});
    	}

    	function switchTab(selection, qualifier) {
    		$$invalidate(4, tab = selection);
    		$$invalidate(6, creditShowOnlyMattress = qualifier === 'mattress');
    		$$invalidate(5, transactionQuery.creditShowOnlyMattress = creditShowOnlyMattress, transactionQuery);
    		$$invalidate(5, transactionQuery.transaction = tab, transactionQuery);
    		$$invalidate(5, transactionQuery.page = 1, transactionQuery);
    		fetchTransaction();
    	}

    	async function openForm(transaction) {
    		if (transaction.type === 'stay' || transaction.type === 'membership') return;

    		$$invalidate(7, selectedTransaction = transaction instanceof MouseEvent
    		? null
    		: JSON.parse(JSON.stringify(transaction)));

    		$$invalidate(8, selectedBooking = null);

    		if (selectedTransaction?.booking_id) {
    			$$invalidate(8, selectedBooking = await getBookingsByIds([selectedTransaction.booking_id]));
    			$$invalidate(8, selectedBooking = selectedBooking[0]);

    			$$invalidate(
    				8,
    				selectedBooking.paf_events = selectedBooking.paf_events !== null
    				? JSON.parse(selectedBooking.paf_events)
    				: selectedBooking.paf_events,
    				selectedBooking
    			);
    		}

    		editTransaction = selectedTransaction != null;
    		$$invalidate(9, recreateForm = !recreateForm);
    		uikit.modal("#modal-transaction").show();
    	}

    	async function processTransaction(event) {
    		if (event.detail.goto !== undefined) {
    			let success = false;

    			switch (event.detail.goto) {
    				case 'cancel':
    					uikit.modal("#modal-transaction").hide();
    					break;
    				case 'save':
    					if (event.detail.booking !== null) {
    						let bookingId = 0;
    						if (!editTransaction) bookingId = await createBooking(event.detail.booking); else bookingId = await updateBooking(event.detail.booking);

    						if (bookingId > 0) {
    							if (!editTransaction) $$invalidate(7, selectedTransaction.booking_id = bookingId, selectedTransaction);
    							if (event.detail.booking.stay_days) $$invalidate(7, selectedTransaction.booking_nights = event.detail.booking.stay_days, selectedTransaction);
    							uikit.notification('<span uk-icon="icon: check"></span> Booking successfully ' + (editTransaction ? 'updated!' : 'created!'), { status: 'success', pos: 'bottom-center' });
    						} else uikit.notification('<span uk-icon="icon: warning"></span> Booking failed!', { status: 'danger', pos: 'bottom-center' });
    					}
    					if (!editTransaction) success = await createTransaction(selectedTransaction); else if (selectedTransaction.id !== undefined && selectedTransaction.id !== null) success = await updateTransaction(selectedTransaction);
    					if (success) {
    						uikit.modal("#modal-transaction").hide();
    						uikit.notification('<span uk-icon="icon: check"></span> Successfully ' + (editTransaction ? 'updated!' : 'created!'), { status: 'success', pos: 'bottom-center' });
    					} else {
    						uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    					}
    					if (selectedTransaction) dispatchReload();
    					break;
    				case 'delete':
    					if (selectedTransaction.booking_id !== null && selectedTransaction.booking_id > 0) {
    						success = await deleteBooking(selectedTransaction.booking_id);
    						if (success) uikit.notification('<span uk-icon="icon: check"></span> Booking uccessfully deleted', { status: 'success', pos: 'bottom-center' }); else uikit.notification('<span uk-icon="icon: warning"></span> Booking failed to delete!', { status: 'danger', pos: 'bottom-center' });
    						success = false;
    					}
    					success = await deleteTransaction(selectedTransaction.id);
    					if (success) {
    						uikit.modal("#modal-transaction").hide();
    						uikit.notification('<span uk-icon="icon: check"></span> Successfully deleted', { status: 'success', pos: 'bottom-center' });
    					} else {
    						uikit.notification('<span uk-icon="icon: warning"></span> Failed!', { status: 'danger', pos: 'bottom-center' });
    					}
    					dispatchReload();
    					break;
    			}
    		}
    	}

    	function dispatchReload() {
    		dispatch('message', { reload: 'mattress' });
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Mattress> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => switchTab('debit');
    	const click_handler_1 = () => switchTab('reserve');
    	const click_handler_2 = () => switchTab('credit', 'mattress');
    	const click_handler_3 = () => switchTab('credit', 'all');
    	const click_handler_4 = transaction => openForm(transaction);
    	const click_handler_5 = transaction => openForm(transaction);
    	const click_handler_6 = transaction => openForm(transaction);
    	const click_handler_7 = transaction => openForm(transaction);
    	const click_handler_8 = transaction => openForm(transaction);
    	const click_handler_9 = transaction => openForm(transaction);
    	const click_handler_10 = transaction => openForm(transaction);

    	const loadMore_handler = () => {
    		if (transactionQuery.page < maxPage) {
    			$$invalidate(5, transactionQuery.page++, transactionQuery);
    			fetchData();
    		}
    	};

    	function mattressform_balance_binding(value) {
    		if ($$self.$$.not_equal($accounts.mattress_balance, value)) {
    			$accounts.mattress_balance = value;
    			accounts.set($accounts);
    		}
    	}

    	function mattressform_transaction_binding(value) {
    		selectedTransaction = value;
    		$$invalidate(7, selectedTransaction);
    	}

    	function mattressform_booking_binding(value) {
    		selectedBooking = value;
    		$$invalidate(8, selectedBooking);
    	}

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		onMount,
    		DateTime: DateTime_1,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		screenWidthXL,
    		autoComplete,
    		createBooking,
    		updateBooking,
    		deleteBooking,
    		getBookingsByIds,
    		mattressNames,
    		getAccounts,
    		getAllocatedNights,
    		getIncome,
    		getTransactions,
    		accounts,
    		createTransaction,
    		updateTransaction,
    		deleteTransaction,
    		allocatedNights,
    		income,
    		InfiniteScroll,
    		UIkit: uikit,
    		MattressForm,
    		data,
    		newBatch,
    		maxPage,
    		transactionCounts,
    		tab,
    		transactionQuery,
    		transactionName,
    		creditShowOnlyMattress,
    		selectedTransaction,
    		editTransaction,
    		selectedBooking,
    		recreateForm,
    		dispatch,
    		fetchData,
    		fetchTransaction,
    		processCounts,
    		switchTab,
    		openForm,
    		processTransaction,
    		dispatchReload,
    		$mattressNames,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		$accounts,
    		$allocatedNights,
    		$income
    	});

    	$$self.$inject_state = $$props => {
    		if ('data' in $$props) $$invalidate(0, data = $$props.data);
    		if ('newBatch' in $$props) $$invalidate(1, newBatch = $$props.newBatch);
    		if ('maxPage' in $$props) $$invalidate(2, maxPage = $$props.maxPage);
    		if ('transactionCounts' in $$props) $$invalidate(3, transactionCounts = $$props.transactionCounts);
    		if ('tab' in $$props) $$invalidate(4, tab = $$props.tab);
    		if ('transactionQuery' in $$props) $$invalidate(5, transactionQuery = $$props.transactionQuery);
    		if ('transactionName' in $$props) transactionName = $$props.transactionName;
    		if ('creditShowOnlyMattress' in $$props) $$invalidate(6, creditShowOnlyMattress = $$props.creditShowOnlyMattress);
    		if ('selectedTransaction' in $$props) $$invalidate(7, selectedTransaction = $$props.selectedTransaction);
    		if ('editTransaction' in $$props) editTransaction = $$props.editTransaction;
    		if ('selectedBooking' in $$props) $$invalidate(8, selectedBooking = $$props.selectedBooking);
    		if ('recreateForm' in $$props) $$invalidate(9, recreateForm = $$props.recreateForm);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*data, newBatch*/ 3) {
    			$$invalidate(0, data = [...data, ...newBatch]);
    		}
    	};

    	return [
    		data,
    		newBatch,
    		maxPage,
    		transactionCounts,
    		tab,
    		transactionQuery,
    		creditShowOnlyMattress,
    		selectedTransaction,
    		selectedBooking,
    		recreateForm,
    		$screenWidthS,
    		$screenWidthM,
    		$screenWidthL,
    		$accounts,
    		$allocatedNights,
    		$income,
    		fetchData,
    		switchTab,
    		openForm,
    		processTransaction,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8,
    		click_handler_9,
    		click_handler_10,
    		loadMore_handler,
    		mattressform_balance_binding,
    		mattressform_transaction_binding,
    		mattressform_booking_binding
    	];
    }

    class Mattress extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance$1, create_fragment$1, safe_not_equal, {}, null, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Mattress",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.45.0 */

    const file = "src/App.svelte";

    // (161:0) {:else}
    function create_else_block(ctx) {
    	let navbar;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let t10;
    	let t11;
    	let t12;
    	let t13;
    	let t14;
    	let t15;
    	let t16;
    	let if_block16_anchor;
    	let current;
    	navbar = new NavBar({ $$inline: true });
    	let if_block0 = /*$navigation*/ ctx[13].dashboard && create_if_block_17(ctx);
    	let if_block1 = /*$navigation*/ ctx[13].booking && create_if_block_16(ctx);
    	let if_block2 = /*$navigation*/ ctx[13].member && create_if_block_15(ctx);
    	let if_block3 = /*$navigation*/ ctx[13].payment && create_if_block_14(ctx);
    	let if_block4 = /*$navigation*/ ctx[13].mattress && create_if_block_13(ctx);
    	let if_block5 = /*$navigation*/ ctx[13].invoice && create_if_block_12(ctx);
    	let if_block6 = /*$navigation*/ ctx[13].event && create_if_block_11(ctx);
    	let if_block7 = /*$navigation*/ ctx[13].reservations && create_if_block_10(ctx);
    	let if_block8 = /*$navigation*/ ctx[13].newsletter && create_if_block_9(ctx);
    	let if_block9 = /*$navigation*/ ctx[13].accounting && create_if_block_8(ctx);
    	let if_block10 = /*$navigation*/ ctx[13].reconciliation && create_if_block_7(ctx);
    	let if_block11 = /*$navigation*/ ctx[13].bankrun && create_if_block_6(ctx);
    	let if_block12 = /*$navigation*/ ctx[13].sci && create_if_block_5(ctx);
    	let if_block13 = /*$navigation*/ ctx[13].data && create_if_block_4(ctx);
    	let if_block14 = /*$navigation*/ ctx[13].datain && create_if_block_3(ctx);
    	let if_block15 = /*$navigation*/ ctx[13].settings && create_if_block_2(ctx);
    	let if_block16 = /*$navigation*/ ctx[13].users && create_if_block_1(ctx);

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			if (if_block5) if_block5.c();
    			t6 = space();
    			if (if_block6) if_block6.c();
    			t7 = space();
    			if (if_block7) if_block7.c();
    			t8 = space();
    			if (if_block8) if_block8.c();
    			t9 = space();
    			if (if_block9) if_block9.c();
    			t10 = space();
    			if (if_block10) if_block10.c();
    			t11 = space();
    			if (if_block11) if_block11.c();
    			t12 = space();
    			if (if_block12) if_block12.c();
    			t13 = space();
    			if (if_block13) if_block13.c();
    			t14 = space();
    			if (if_block14) if_block14.c();
    			t15 = space();
    			if (if_block15) if_block15.c();
    			t16 = space();
    			if (if_block16) if_block16.c();
    			if_block16_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block3) if_block3.m(target, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block4) if_block4.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t6, anchor);
    			if (if_block6) if_block6.m(target, anchor);
    			insert_dev(target, t7, anchor);
    			if (if_block7) if_block7.m(target, anchor);
    			insert_dev(target, t8, anchor);
    			if (if_block8) if_block8.m(target, anchor);
    			insert_dev(target, t9, anchor);
    			if (if_block9) if_block9.m(target, anchor);
    			insert_dev(target, t10, anchor);
    			if (if_block10) if_block10.m(target, anchor);
    			insert_dev(target, t11, anchor);
    			if (if_block11) if_block11.m(target, anchor);
    			insert_dev(target, t12, anchor);
    			if (if_block12) if_block12.m(target, anchor);
    			insert_dev(target, t13, anchor);
    			if (if_block13) if_block13.m(target, anchor);
    			insert_dev(target, t14, anchor);
    			if (if_block14) if_block14.m(target, anchor);
    			insert_dev(target, t15, anchor);
    			if (if_block15) if_block15.m(target, anchor);
    			insert_dev(target, t16, anchor);
    			if (if_block16) if_block16.m(target, anchor);
    			insert_dev(target, if_block16_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$navigation*/ ctx[13].dashboard) {
    				if (if_block0) {
    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_17(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].booking) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_16(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t2.parentNode, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].member) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_15(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(t3.parentNode, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].payment) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_14(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(t4.parentNode, t4);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].mattress) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_13(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(t5.parentNode, t5);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].invoice) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_12(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t6.parentNode, t6);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].event) {
    				if (if_block6) {
    					if_block6.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_11(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(t7.parentNode, t7);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].reservations) {
    				if (if_block7) {
    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block7, 1);
    					}
    				} else {
    					if_block7 = create_if_block_10(ctx);
    					if_block7.c();
    					transition_in(if_block7, 1);
    					if_block7.m(t8.parentNode, t8);
    				}
    			} else if (if_block7) {
    				group_outros();

    				transition_out(if_block7, 1, 1, () => {
    					if_block7 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].newsletter) {
    				if (if_block8) {
    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block8, 1);
    					}
    				} else {
    					if_block8 = create_if_block_9(ctx);
    					if_block8.c();
    					transition_in(if_block8, 1);
    					if_block8.m(t9.parentNode, t9);
    				}
    			} else if (if_block8) {
    				group_outros();

    				transition_out(if_block8, 1, 1, () => {
    					if_block8 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].accounting) {
    				if (if_block9) {
    					if_block9.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block9, 1);
    					}
    				} else {
    					if_block9 = create_if_block_8(ctx);
    					if_block9.c();
    					transition_in(if_block9, 1);
    					if_block9.m(t10.parentNode, t10);
    				}
    			} else if (if_block9) {
    				group_outros();

    				transition_out(if_block9, 1, 1, () => {
    					if_block9 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].reconciliation) {
    				if (if_block10) {
    					if_block10.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block10, 1);
    					}
    				} else {
    					if_block10 = create_if_block_7(ctx);
    					if_block10.c();
    					transition_in(if_block10, 1);
    					if_block10.m(t11.parentNode, t11);
    				}
    			} else if (if_block10) {
    				group_outros();

    				transition_out(if_block10, 1, 1, () => {
    					if_block10 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].bankrun) {
    				if (if_block11) {
    					if_block11.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block11, 1);
    					}
    				} else {
    					if_block11 = create_if_block_6(ctx);
    					if_block11.c();
    					transition_in(if_block11, 1);
    					if_block11.m(t12.parentNode, t12);
    				}
    			} else if (if_block11) {
    				group_outros();

    				transition_out(if_block11, 1, 1, () => {
    					if_block11 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].sci) {
    				if (if_block12) {
    					if_block12.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block12, 1);
    					}
    				} else {
    					if_block12 = create_if_block_5(ctx);
    					if_block12.c();
    					transition_in(if_block12, 1);
    					if_block12.m(t13.parentNode, t13);
    				}
    			} else if (if_block12) {
    				group_outros();

    				transition_out(if_block12, 1, 1, () => {
    					if_block12 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].data) {
    				if (if_block13) {
    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block13, 1);
    					}
    				} else {
    					if_block13 = create_if_block_4(ctx);
    					if_block13.c();
    					transition_in(if_block13, 1);
    					if_block13.m(t14.parentNode, t14);
    				}
    			} else if (if_block13) {
    				group_outros();

    				transition_out(if_block13, 1, 1, () => {
    					if_block13 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].datain) {
    				if (if_block14) {
    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block14, 1);
    					}
    				} else {
    					if_block14 = create_if_block_3(ctx);
    					if_block14.c();
    					transition_in(if_block14, 1);
    					if_block14.m(t15.parentNode, t15);
    				}
    			} else if (if_block14) {
    				group_outros();

    				transition_out(if_block14, 1, 1, () => {
    					if_block14 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].settings) {
    				if (if_block15) {
    					if_block15.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block15, 1);
    					}
    				} else {
    					if_block15 = create_if_block_2(ctx);
    					if_block15.c();
    					transition_in(if_block15, 1);
    					if_block15.m(t16.parentNode, t16);
    				}
    			} else if (if_block15) {
    				group_outros();

    				transition_out(if_block15, 1, 1, () => {
    					if_block15 = null;
    				});

    				check_outros();
    			}

    			if (/*$navigation*/ ctx[13].users) {
    				if (if_block16) {
    					if_block16.p(ctx, dirty);

    					if (dirty & /*$navigation*/ 8192) {
    						transition_in(if_block16, 1);
    					}
    				} else {
    					if_block16 = create_if_block_1(ctx);
    					if_block16.c();
    					transition_in(if_block16, 1);
    					if_block16.m(if_block16_anchor.parentNode, if_block16_anchor);
    				}
    			} else if (if_block16) {
    				group_outros();

    				transition_out(if_block16, 1, 1, () => {
    					if_block16 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(if_block7);
    			transition_in(if_block8);
    			transition_in(if_block9);
    			transition_in(if_block10);
    			transition_in(if_block11);
    			transition_in(if_block12);
    			transition_in(if_block13);
    			transition_in(if_block14);
    			transition_in(if_block15);
    			transition_in(if_block16);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			transition_out(if_block7);
    			transition_out(if_block8);
    			transition_out(if_block9);
    			transition_out(if_block10);
    			transition_out(if_block11);
    			transition_out(if_block12);
    			transition_out(if_block13);
    			transition_out(if_block14);
    			transition_out(if_block15);
    			transition_out(if_block16);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block3) if_block3.d(detaching);
    			if (detaching) detach_dev(t4);
    			if (if_block4) if_block4.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t6);
    			if (if_block6) if_block6.d(detaching);
    			if (detaching) detach_dev(t7);
    			if (if_block7) if_block7.d(detaching);
    			if (detaching) detach_dev(t8);
    			if (if_block8) if_block8.d(detaching);
    			if (detaching) detach_dev(t9);
    			if (if_block9) if_block9.d(detaching);
    			if (detaching) detach_dev(t10);
    			if (if_block10) if_block10.d(detaching);
    			if (detaching) detach_dev(t11);
    			if (if_block11) if_block11.d(detaching);
    			if (detaching) detach_dev(t12);
    			if (if_block12) if_block12.d(detaching);
    			if (detaching) detach_dev(t13);
    			if (if_block13) if_block13.d(detaching);
    			if (detaching) detach_dev(t14);
    			if (if_block14) if_block14.d(detaching);
    			if (detaching) detach_dev(t15);
    			if (if_block15) if_block15.d(detaching);
    			if (detaching) detach_dev(t16);
    			if (if_block16) if_block16.d(detaching);
    			if (detaching) detach_dev(if_block16_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(161:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (159:0) {#if !$loggedIn.loggedIn}
    function create_if_block(ctx) {
    	let login;
    	let current;
    	login = new Login({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(login.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(login, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(login.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(login.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(login, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(159:0) {#if !$loggedIn.loggedIn}",
    		ctx
    	});

    	return block;
    }

    // (165:1) {#if $navigation.dashboard}
    function create_if_block_17(ctx) {
    	let dashboard;
    	let current;
    	dashboard = new Dashboard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dashboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dashboard, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dashboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dashboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dashboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_17.name,
    		type: "if",
    		source: "(165:1) {#if $navigation.dashboard}",
    		ctx
    	});

    	return block;
    }

    // (168:1) {#if $navigation.booking}
    function create_if_block_16(ctx) {
    	let previous_key = /*reloadBookingToggle*/ ctx[2];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_10(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadBookingToggle*/ 4 && safe_not_equal(previous_key, previous_key = /*reloadBookingToggle*/ ctx[2])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_10(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_16.name,
    		type: "if",
    		source: "(168:1) {#if $navigation.booking}",
    		ctx
    	});

    	return block;
    }

    // (169:2) {#key reloadBookingToggle}
    function create_key_block_10(ctx) {
    	let booking;
    	let current;
    	booking = new Booking({ $$inline: true });
    	booking.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(booking.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(booking, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(booking.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(booking.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(booking, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_10.name,
    		type: "key",
    		source: "(169:2) {#key reloadBookingToggle}",
    		ctx
    	});

    	return block;
    }

    // (173:1) {#if $navigation.member}
    function create_if_block_15(ctx) {
    	let previous_key = /*reloadMemberToggle*/ ctx[4];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_9(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadMemberToggle*/ 16 && safe_not_equal(previous_key, previous_key = /*reloadMemberToggle*/ ctx[4])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_9(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_15.name,
    		type: "if",
    		source: "(173:1) {#if $navigation.member}",
    		ctx
    	});

    	return block;
    }

    // (174:2) {#key reloadMemberToggle}
    function create_key_block_9(ctx) {
    	let members;
    	let current;
    	members = new Member({ $$inline: true });
    	members.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(members.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(members, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(members.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(members.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(members, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_9.name,
    		type: "key",
    		source: "(174:2) {#key reloadMemberToggle}",
    		ctx
    	});

    	return block;
    }

    // (178:1) {#if $navigation.payment}
    function create_if_block_14(ctx) {
    	let previous_key = /*reloadPaymentToggle*/ ctx[5];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_8(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadPaymentToggle*/ 32 && safe_not_equal(previous_key, previous_key = /*reloadPaymentToggle*/ ctx[5])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_8(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(178:1) {#if $navigation.payment}",
    		ctx
    	});

    	return block;
    }

    // (179:2) {#key reloadPaymentToggle}
    function create_key_block_8(ctx) {
    	let payment;
    	let current;
    	payment = new Payment({ $$inline: true });
    	payment.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(payment.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(payment, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(payment.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(payment.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(payment, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_8.name,
    		type: "key",
    		source: "(179:2) {#key reloadPaymentToggle}",
    		ctx
    	});

    	return block;
    }

    // (183:1) {#if $navigation.mattress}
    function create_if_block_13(ctx) {
    	let previous_key = /*reloadMattressToggle*/ ctx[7];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_7(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadMattressToggle*/ 128 && safe_not_equal(previous_key, previous_key = /*reloadMattressToggle*/ ctx[7])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_7(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(183:1) {#if $navigation.mattress}",
    		ctx
    	});

    	return block;
    }

    // (184:2) {#key reloadMattressToggle}
    function create_key_block_7(ctx) {
    	let mattress;
    	let current;
    	mattress = new Mattress({ $$inline: true });
    	mattress.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(mattress.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mattress, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mattress.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mattress.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mattress, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_7.name,
    		type: "key",
    		source: "(184:2) {#key reloadMattressToggle}",
    		ctx
    	});

    	return block;
    }

    // (188:1) {#if $navigation.invoice}
    function create_if_block_12(ctx) {
    	let previous_key = /*reloadInvoiceToggle*/ ctx[6];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_6(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadInvoiceToggle*/ 64 && safe_not_equal(previous_key, previous_key = /*reloadInvoiceToggle*/ ctx[6])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_6(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(188:1) {#if $navigation.invoice}",
    		ctx
    	});

    	return block;
    }

    // (189:2) {#key reloadInvoiceToggle}
    function create_key_block_6(ctx) {
    	let invoice;
    	let current;
    	invoice = new Invoice({ $$inline: true });
    	invoice.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(invoice.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(invoice, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(invoice.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(invoice.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(invoice, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_6.name,
    		type: "key",
    		source: "(189:2) {#key reloadInvoiceToggle}",
    		ctx
    	});

    	return block;
    }

    // (193:1) {#if $navigation.event}
    function create_if_block_11(ctx) {
    	let previous_key = /*reloadEventToggle*/ ctx[3];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_5(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadEventToggle*/ 8 && safe_not_equal(previous_key, previous_key = /*reloadEventToggle*/ ctx[3])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_5(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(193:1) {#if $navigation.event}",
    		ctx
    	});

    	return block;
    }

    // (194:2) {#key reloadEventToggle}
    function create_key_block_5(ctx) {
    	let event;
    	let current;
    	event = new Event$1({ $$inline: true });
    	event.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(event.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(event, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(event.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(event.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(event, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_5.name,
    		type: "key",
    		source: "(194:2) {#key reloadEventToggle}",
    		ctx
    	});

    	return block;
    }

    // (198:1) {#if $navigation.reservations}
    function create_if_block_10(ctx) {
    	let reservations;
    	let current;
    	reservations = new Reservations({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(reservations.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(reservations, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(reservations.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(reservations.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(reservations, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(198:1) {#if $navigation.reservations}",
    		ctx
    	});

    	return block;
    }

    // (201:1) {#if $navigation.newsletter}
    function create_if_block_9(ctx) {
    	/*reloadNewsletterToggle*/ ctx[9];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_4(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(201:1) {#if $navigation.newsletter}",
    		ctx
    	});

    	return block;
    }

    // (202:2) {#key reloadNewsletterToggle}
    function create_key_block_4(ctx) {
    	let newsletter;
    	let current;
    	newsletter = new Newsletter({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(newsletter.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(newsletter, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(newsletter.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(newsletter.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(newsletter, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_4.name,
    		type: "key",
    		source: "(202:2) {#key reloadNewsletterToggle}",
    		ctx
    	});

    	return block;
    }

    // (206:1) {#if $navigation.accounting}
    function create_if_block_8(ctx) {
    	let accounting;
    	let current;
    	accounting = new Accounting({ $$inline: true });
    	accounting.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(accounting.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(accounting, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(accounting.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(accounting.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(accounting, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(206:1) {#if $navigation.accounting}",
    		ctx
    	});

    	return block;
    }

    // (211:1) {#if $navigation.reconciliation}
    function create_if_block_7(ctx) {
    	let reconciliation;
    	let current;
    	reconciliation = new Reconciliation({ $$inline: true });
    	reconciliation.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(reconciliation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(reconciliation, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(reconciliation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(reconciliation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(reconciliation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(211:1) {#if $navigation.reconciliation}",
    		ctx
    	});

    	return block;
    }

    // (216:1) {#if $navigation.bankrun}
    function create_if_block_6(ctx) {
    	let previous_key = /*reloadBankrunToggle*/ ctx[8];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_3(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadBankrunToggle*/ 256 && safe_not_equal(previous_key, previous_key = /*reloadBankrunToggle*/ ctx[8])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_3(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(216:1) {#if $navigation.bankrun}",
    		ctx
    	});

    	return block;
    }

    // (217:2) {#key reloadBankrunToggle}
    function create_key_block_3(ctx) {
    	let bankruns;
    	let current;
    	bankruns = new BankRuns({ $$inline: true });
    	bankruns.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(bankruns.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(bankruns, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(bankruns.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(bankruns.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(bankruns, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_3.name,
    		type: "key",
    		source: "(217:2) {#key reloadBankrunToggle}",
    		ctx
    	});

    	return block;
    }

    // (221:1) {#if $navigation.sci}
    function create_if_block_5(ctx) {
    	let previous_key = /*reloadSciToggle*/ ctx[10];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_2(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadSciToggle*/ 1024 && safe_not_equal(previous_key, previous_key = /*reloadSciToggle*/ ctx[10])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_2(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(221:1) {#if $navigation.sci}",
    		ctx
    	});

    	return block;
    }

    // (222:2) {#key reloadSciToggle}
    function create_key_block_2(ctx) {
    	let sci;
    	let current;
    	sci = new Sci({ $$inline: true });
    	sci.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(sci.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(sci, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sci.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sci.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(sci, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_2.name,
    		type: "key",
    		source: "(222:2) {#key reloadSciToggle}",
    		ctx
    	});

    	return block;
    }

    // (226:1) {#if $navigation.data}
    function create_if_block_4(ctx) {
    	let dataexport;
    	let current;
    	dataexport = new DataExport({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dataexport.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dataexport, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dataexport.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dataexport.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dataexport, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(226:1) {#if $navigation.data}",
    		ctx
    	});

    	return block;
    }

    // (229:1) {#if $navigation.datain}
    function create_if_block_3(ctx) {
    	let dataimport;
    	let current;
    	dataimport = new DataImport({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dataimport.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dataimport, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dataimport.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dataimport.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dataimport, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(229:1) {#if $navigation.datain}",
    		ctx
    	});

    	return block;
    }

    // (232:1) {#if $navigation.settings}
    function create_if_block_2(ctx) {
    	let previous_key = /*reloadSettingsToggle*/ ctx[11];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block_1(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadSettingsToggle*/ 2048 && safe_not_equal(previous_key, previous_key = /*reloadSettingsToggle*/ ctx[11])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block_1(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(232:1) {#if $navigation.settings}",
    		ctx
    	});

    	return block;
    }

    // (233:2) {#key reloadSettingsToggle}
    function create_key_block_1(ctx) {
    	let settings;
    	let current;
    	settings = new Settings({ $$inline: true });
    	settings.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(settings.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(settings, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(settings.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(settings.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(settings, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block_1.name,
    		type: "key",
    		source: "(233:2) {#key reloadSettingsToggle}",
    		ctx
    	});

    	return block;
    }

    // (237:1) {#if $navigation.users}
    function create_if_block_1(ctx) {
    	let previous_key = /*reloadUsersToggle*/ ctx[12];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty$3();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*reloadUsersToggle*/ 4096 && safe_not_equal(previous_key, previous_key = /*reloadUsersToggle*/ ctx[12])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop$4);
    				check_outros();
    				key_block = create_key_block(ctx);
    				key_block.c();
    				transition_in(key_block);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(237:1) {#if $navigation.users}",
    		ctx
    	});

    	return block;
    }

    // (238:2) {#key reloadUsersToggle}
    function create_key_block(ctx) {
    	let users;
    	let current;
    	users = new Users({ $$inline: true });
    	users.$on("message", /*reload*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(users.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(users, target, anchor);
    			current = true;
    		},
    		p: noop$4,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(users.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(users.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(users, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(238:2) {#key reloadUsersToggle}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let t;
    	let body;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[17]);
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*$loggedIn*/ ctx[1].loggedIn) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			t = space();
    			body = element("body");
    			if_block.c();
    			document.title = "PAF Admin Central";
    			attr_dev(body, "class", "svelte-keo21b");
    			add_location(body, file, 157, 0, 4624);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, body, anchor);
    			if_blocks[current_block_type_index].m(body, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "resize", /*onwindowresize*/ ctx[17]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(body, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(body);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $loggedIn;
    	let $navigation;
    	validate_store(loggedIn, 'loggedIn');
    	component_subscribe($$self, loggedIn, $$value => $$invalidate(1, $loggedIn = $$value));
    	validate_store(navigation, 'navigation');
    	component_subscribe($$self, navigation, $$value => $$invalidate(13, $navigation = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let didValidateAuth = false;
    	let reloadAccountingToggle = false;
    	let reloadBookingToggle = false;
    	let reloadEventToggle = false;
    	let reloadMemberToggle = false;
    	let reloadPaymentToggle = false;
    	let reloadInvoiceToggle = false;
    	let reloadMattressToggle = false;
    	let reloadReconciliationToggle = false;
    	let reloadBankrunToggle = false;
    	let reloadNewsletterToggle = false;
    	let reloadSciToggle = false;
    	let reloadSettingsToggle = false;
    	let reloadUsersToggle = false;
    	let innerWidth = 0;
    	uikit.use(uikitIcons);

    	beforeUpdate(() => {
    		if (!didValidateAuth) {
    			validateAuth();
    			didValidateAuth = true;
    		}
    	});

    	function loadAppData() {
    		if ($loggedIn.loggedIn) {
    			fetchSettings();
    			getBookingNames();
    			getMattressNames();
    			getMemberEmails();
    			getMemberNames();
    			getInvoiceNames();
    			getInvoiceNumbers();
    			fetchEvents();
    			getSciMembers();
    		}
    	}

    	async function reload(event) {
    		if (event.detail.reload !== undefined) {
    			switch (event.detail.reload) {
    				case 'bankrun':
    					await getBankruns();
    					$$invalidate(8, reloadBankrunToggle = !reloadBankrunToggle);
    					break;
    				case 'booking':
    					await getBookingNames();
    					await fetchEvents();
    					await getSciMembers();
    					$$invalidate(2, reloadBookingToggle = !reloadBookingToggle);
    					break;
    				case 'event':
    					await fetchEvents();
    					$$invalidate(3, reloadEventToggle = !reloadEventToggle);
    					break;
    				case 'invoice':
    					await getInvoiceNames();
    					await getInvoiceNumbers();
    					await fetchSettings();
    					$$invalidate(6, reloadInvoiceToggle = !reloadInvoiceToggle);
    					break;
    				case 'mattress':
    					await getMattressNames();
    					await getAccounts();
    					await getAllocatedNights();
    					await getIncome();
    					$$invalidate(7, reloadMattressToggle = !reloadMattressToggle);
    					break;
    				case 'member':
    					await getMemberEmails();
    					await getMemberNames();
    					$$invalidate(4, reloadMemberToggle = !reloadMemberToggle);
    					break;
    				case 'newsletter':
    					await fetchSettings();
    					$$invalidate(9, reloadNewsletterToggle = !reloadNewsletterToggle);
    					break;
    				case 'payment':
    					await getInvoiceNames();
    					await getInvoiceNumbers();
    					await fetchSettings();
    					await getSciMembers();
    					$$invalidate(5, reloadPaymentToggle = !reloadPaymentToggle);
    					break;
    				case 'sci':
    					await getSciMembers();
    					$$invalidate(10, reloadSciToggle = !reloadSciToggle);
    					break;
    				case 'settings':
    					await fetchSettings();
    					$$invalidate(11, reloadSettingsToggle = !reloadSettingsToggle);
    					break;
    				case 'users':
    					$$invalidate(12, reloadUsersToggle = !reloadUsersToggle);
    					break;
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function onwindowresize() {
    		$$invalidate(0, innerWidth = window.innerWidth);
    	}

    	$$self.$capture_state = () => ({
    		UIkit: uikit,
    		Icons: uikitIcons,
    		Login,
    		NavBar,
    		Members: Member,
    		beforeUpdate,
    		validateAuth,
    		loggedIn,
    		fetchSettings,
    		getBookingNames,
    		getMemberEmails,
    		getMemberNames,
    		getSciMembers,
    		navigation,
    		screenWidthL,
    		screenWidthM,
    		screenWidthS,
    		screenWidthXL,
    		Booking,
    		Invoice,
    		getInvoiceNames,
    		getInvoiceNumbers,
    		Payment,
    		Event: Event$1,
    		fetchEvents,
    		Settings,
    		Users,
    		Sci,
    		Accounting,
    		Reservations,
    		Dashboard,
    		Reconciliation,
    		BankRuns,
    		getBankruns,
    		Newsletter,
    		DataExport,
    		DataImport,
    		Mattress,
    		getAccounts,
    		getMattressNames,
    		getAllocatedNights,
    		getIncome,
    		didValidateAuth,
    		reloadAccountingToggle,
    		reloadBookingToggle,
    		reloadEventToggle,
    		reloadMemberToggle,
    		reloadPaymentToggle,
    		reloadInvoiceToggle,
    		reloadMattressToggle,
    		reloadReconciliationToggle,
    		reloadBankrunToggle,
    		reloadNewsletterToggle,
    		reloadSciToggle,
    		reloadSettingsToggle,
    		reloadUsersToggle,
    		innerWidth,
    		loadAppData,
    		reload,
    		$loggedIn,
    		$navigation
    	});

    	$$self.$inject_state = $$props => {
    		if ('didValidateAuth' in $$props) didValidateAuth = $$props.didValidateAuth;
    		if ('reloadAccountingToggle' in $$props) $$invalidate(14, reloadAccountingToggle = $$props.reloadAccountingToggle);
    		if ('reloadBookingToggle' in $$props) $$invalidate(2, reloadBookingToggle = $$props.reloadBookingToggle);
    		if ('reloadEventToggle' in $$props) $$invalidate(3, reloadEventToggle = $$props.reloadEventToggle);
    		if ('reloadMemberToggle' in $$props) $$invalidate(4, reloadMemberToggle = $$props.reloadMemberToggle);
    		if ('reloadPaymentToggle' in $$props) $$invalidate(5, reloadPaymentToggle = $$props.reloadPaymentToggle);
    		if ('reloadInvoiceToggle' in $$props) $$invalidate(6, reloadInvoiceToggle = $$props.reloadInvoiceToggle);
    		if ('reloadMattressToggle' in $$props) $$invalidate(7, reloadMattressToggle = $$props.reloadMattressToggle);
    		if ('reloadReconciliationToggle' in $$props) $$invalidate(15, reloadReconciliationToggle = $$props.reloadReconciliationToggle);
    		if ('reloadBankrunToggle' in $$props) $$invalidate(8, reloadBankrunToggle = $$props.reloadBankrunToggle);
    		if ('reloadNewsletterToggle' in $$props) $$invalidate(9, reloadNewsletterToggle = $$props.reloadNewsletterToggle);
    		if ('reloadSciToggle' in $$props) $$invalidate(10, reloadSciToggle = $$props.reloadSciToggle);
    		if ('reloadSettingsToggle' in $$props) $$invalidate(11, reloadSettingsToggle = $$props.reloadSettingsToggle);
    		if ('reloadUsersToggle' in $$props) $$invalidate(12, reloadUsersToggle = $$props.reloadUsersToggle);
    		if ('innerWidth' in $$props) $$invalidate(0, innerWidth = $$props.innerWidth);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$loggedIn*/ 2) {
    			$loggedIn && loadAppData();
    		}

    		if ($$self.$$.dirty & /*innerWidth*/ 1) {
    			screenWidthS.set(innerWidth <= 640);
    		}

    		if ($$self.$$.dirty & /*innerWidth*/ 1) {
    			screenWidthM.set(innerWidth > 640 && innerWidth <= 960);
    		}

    		if ($$self.$$.dirty & /*innerWidth*/ 1) {
    			screenWidthL.set(innerWidth > 960 && innerWidth <= 1200);
    		}

    		if ($$self.$$.dirty & /*innerWidth*/ 1) {
    			screenWidthXL.set(innerWidth > 1200);
    		}
    	};

    	return [
    		innerWidth,
    		$loggedIn,
    		reloadBookingToggle,
    		reloadEventToggle,
    		reloadMemberToggle,
    		reloadPaymentToggle,
    		reloadInvoiceToggle,
    		reloadMattressToggle,
    		reloadBankrunToggle,
    		reloadNewsletterToggle,
    		reloadSciToggle,
    		reloadSettingsToggle,
    		reloadUsersToggle,
    		$navigation,
    		reloadAccountingToggle,
    		reloadReconciliationToggle,
    		reload,
    		onwindowresize
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init$2(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
